




















#include "tool_setup.h"

#include "slist_wc.h"

#if !defined(CURL_DISABLE_LIBCURL_OPTION)

#define ENABLE_CURLX_PRINTF

#include "curlx.h"

#include "tool_cfgable.h"
#include "tool_easysrc.h"
#include "tool_msgs.h"

#include "memdebug.h" 



struct slist_wc *easysrc_decl = NULL; 
struct slist_wc *easysrc_data = NULL; 
struct slist_wc *easysrc_code = NULL; 
struct slist_wc *easysrc_toohard = NULL; 
struct slist_wc *easysrc_clean = NULL; 
int easysrc_mime_count = 0;
int easysrc_slist_count = 0;

static const char *const srchead[]={
"/********* Sample code generated by the curl command line tool **********",
" * All curl_easy_setopt() options are documented at:",
" * https://curl.haxx.se/libcurl/c/curl_easy_setopt.html",
" ************************************************************************/",
"#include <curl/curl.h>",
"",
"int main(int argc, char *argv[])",
"{",
" CURLcode ret;",
" CURL *hnd;",
NULL
};



static const char *const srchard[]={
"/* Here is a list of options the curl code used that cannot get generated",
" as source easily. You may select to either not use them or implement",
" them yourself.",
"",
NULL
};
static const char *const srcend[]={
"",
" return (int)ret;",
"}",
"/**** End of sample code ****/",
NULL
};


static void easysrc_free(void)
{
slist_wc_free_all(easysrc_decl);
easysrc_decl = NULL;
slist_wc_free_all(easysrc_data);
easysrc_data = NULL;
slist_wc_free_all(easysrc_code);
easysrc_code = NULL;
slist_wc_free_all(easysrc_toohard);
easysrc_toohard = NULL;
slist_wc_free_all(easysrc_clean);
easysrc_clean = NULL;
}


CURLcode easysrc_add(struct slist_wc **plist, const char *line)
{
CURLcode ret = CURLE_OK;
struct slist_wc *list = slist_wc_append(*plist, line);
if(!list) {
easysrc_free();
ret = CURLE_OUT_OF_MEMORY;
}
else
*plist = list;
return ret;
}

CURLcode easysrc_addf(struct slist_wc **plist, const char *fmt, ...)
{
CURLcode ret;
char *bufp;
va_list ap;
va_start(ap, fmt);
bufp = curlx_mvaprintf(fmt, ap);
va_end(ap);
if(! bufp) {
ret = CURLE_OUT_OF_MEMORY;
}
else {
ret = easysrc_add(plist, bufp);
curl_free(bufp);
}
return ret;
}

#define CHKRET(v) do {CURLcode ret = (v); if(ret) return ret;} while(0)

CURLcode easysrc_init(void)
{
CHKRET(easysrc_add(&easysrc_code,
"hnd = curl_easy_init();"));
return CURLE_OK;
}

CURLcode easysrc_perform(void)
{

if(easysrc_toohard) {
int i;
struct curl_slist *ptr;
const char *c;
CHKRET(easysrc_add(&easysrc_code, ""));

for(i = 0; ((c = srchard[i]) != NULL); i++)
CHKRET(easysrc_add(&easysrc_code, c));

if(easysrc_toohard) {
for(ptr = easysrc_toohard->first; ptr; ptr = ptr->next)
CHKRET(easysrc_add(&easysrc_code, ptr->data));
}
CHKRET(easysrc_add(&easysrc_code, ""));
CHKRET(easysrc_add(&easysrc_code, "*/"));

slist_wc_free_all(easysrc_toohard);
easysrc_toohard = NULL;
}

CHKRET(easysrc_add(&easysrc_code, ""));
CHKRET(easysrc_add(&easysrc_code, "ret = curl_easy_perform(hnd);"));
CHKRET(easysrc_add(&easysrc_code, ""));

return CURLE_OK;
}

CURLcode easysrc_cleanup(void)
{
CHKRET(easysrc_add(&easysrc_code, "curl_easy_cleanup(hnd);"));
CHKRET(easysrc_add(&easysrc_code, "hnd = NULL;"));

return CURLE_OK;
}

void dumpeasysrc(struct GlobalConfig *config)
{
struct curl_slist *ptr;
char *o = config->libcurl;

FILE *out;
bool fopened = FALSE;
if(strcmp(o, "-")) {
out = fopen(o, FOPEN_WRITETEXT);
fopened = TRUE;
}
else
out = stdout;
if(!out)
warnf(config, "Failed to open %s to write libcurl code!\n", o);
else {
int i;
const char *c;

for(i = 0; ((c = srchead[i]) != NULL); i++)
fprintf(out, "%s\n", c);


if(easysrc_decl) {
for(ptr = easysrc_decl->first; ptr; ptr = ptr->next)
fprintf(out, " %s\n", ptr->data);
}


if(easysrc_data) {
fprintf(out, "\n");

for(ptr = easysrc_data->first; ptr; ptr = ptr->next)
fprintf(out, " %s\n", ptr->data);
}

fprintf(out, "\n");
if(easysrc_code) {
for(ptr = easysrc_code->first; ptr; ptr = ptr->next) {
if(ptr->data[0]) {
fprintf(out, " %s\n", ptr->data);
}
else {
fprintf(out, "\n");
}
}
}

if(easysrc_clean) {
for(ptr = easysrc_clean->first; ptr; ptr = ptr->next)
fprintf(out, " %s\n", ptr->data);
}

for(i = 0; ((c = srcend[i]) != NULL); i++)
fprintf(out, "%s\n", c);

if(fopened)
fclose(out);
}

easysrc_free();
}

#endif 
