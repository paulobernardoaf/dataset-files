<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\curl-analysis\_cppstats\curl\lib\mime.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_setup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;curl/curl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mime.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"non-ascii.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"warnless.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"urldata.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sendf.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_MIME</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_SMTP</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_IMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBGEN_H</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BASENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;libgen.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rand.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"slist.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strcase.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_printf.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memdebug.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>R_OK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_OK</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_ERROR</name></cpp:macro> <cpp:value>((size_t) -1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STOP_FILLING</name></cpp:macro> <cpp:value>((size_t) -2)</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>mime_subparts_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasread</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_nop_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_nop_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_7bit_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_base64_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_base64_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_qp_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_qp_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>mime_encoder</name></type> <name><name>encoders</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="string">"binary"</literal></expr>, <expr><name>encoder_nop_read</name></expr>, <expr><name>encoder_nop_size</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"8bit"</literal></expr>, <expr><name>encoder_nop_read</name></expr>, <expr><name>encoder_nop_size</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"7bit"</literal></expr>, <expr><name>encoder_7bit_read</name></expr>, <expr><name>encoder_nop_size</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"base64"</literal></expr>, <expr><name>encoder_base64_read</name></expr>, <expr><name>encoder_base64_size</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"quoted-printable"</literal></expr>, <expr><name>encoder_qp_read</name></expr>, <expr><name>encoder_qp_size</name></expr>}</block></expr>,

<expr><block>{<expr><name>ZERO_NULL</name></expr>, <expr><name>ZERO_NULL</name></expr>, <expr><name>ZERO_NULL</name></expr>}</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>base64</name><index>[]</index></name> <init>=

<expr><literal type="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QP_OK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QP_SP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QP_CR</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QP_LF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>qp_class</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><name>QP_SP</name></expr>, <expr><name>QP_LF</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>QP_CR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><name>QP_SP</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><literal type="number">0</literal></expr> , <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, 

<expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><name>QP_OK</name></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, 

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> 

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>aschex</name><index>[]</index></name> <init>=

<expr><literal type="string">"\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x41\x42\x43\x44\x45\x46"</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>filesize</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>stat_data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(stat_data.st_size)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fopen_read</name></cpp:macro> <cpp:value>fopen</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fabdef.h&gt;</cpp:file></cpp:include>

<function><type><name>curl_off_t</name></type> <name>VmsRealFileSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>struct_stat</name> <modifier>*</modifier></type><name>stat_buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">8192</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>curl_off_t</name></type> <name>count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret_stat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>file</name></decl>;</decl_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>FOPEN_READTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_stat</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while<condition>(<expr><name>ret_stat</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret_stat</name> <operator>=</operator> <call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ret_stat</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>count</name> <operator>+=</operator> <name>ret_stat</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>count</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>VmsSpecialSize</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>struct_stat</name> <modifier>*</modifier></type><name>stat_buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch<condition>(<expr><name><name>stat_buf</name><operator>-&gt;</operator><name>st_fab_rfm</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>FAB$C_VAR</name></expr>:</case>

<case>case <expr><name>FAB$C_VFC</name></expr>:</case>

<return>return <expr><call><name>VmsRealFileSize</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>stat_buf</name></expr></argument>)</argument_list></call></expr>;</return>

<break>break;</break>

<default>default:</default>

<return>return <expr><name><name>stat_buf</name><operator>-&gt;</operator><name>st_size</name></name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>filesize</name><parameter_list>(<parameter><type><name>name</name></type></parameter>, <parameter><type><name>stat_data</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>VmsSpecialSize(name, &amp;stat_data)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type> <name>vmsfopenread</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>struct_stat</name></type> <name>statbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stat</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name><name>statbuf</name><operator>.</operator><name>st_fab_rfm</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>FAB$C_VAR</name></expr>:</case>

<case>case <expr><name>FAB$C_VFC</name></expr>:</case>

<case>case <expr><name>FAB$C_STMCR</name></expr>:</case>

<return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>FOPEN_READTEXT</name></expr></argument>)</argument_list></call></expr>;</return> 

<break>break;</break>

<default>default:</default>

<return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>FOPEN_READTEXT</name></expr></argument>, <argument><expr><literal type="string">"rfm=stmlf"</literal></expr></argument>, <argument><expr><literal type="string">"ctx=stm"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fopen_read</name></cpp:macro> <cpp:value>vmsfopenread</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BASENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>Curl_basename</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>s1</name> <operator>&amp;&amp;</operator> <name>s2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>s1</name> <operator>&gt;</operator> <name>s2</name></expr>?</condition><then> <expr><name>s1</name></expr> </then><else>: <expr><name>s2</name></expr></else></ternary><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if<condition>(<expr><name>s1</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>s1</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name>s2</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <name>s2</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>path</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>basename</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>Curl_basename((x))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mimesetstate</name><parameter_list>(<parameter><decl><type><name>mime_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name><name>enum</name> <name>mimestate</name></name></type> <name>tok</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>tok</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>escape_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>bytecount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <name><name>src</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bytecount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>bytecount</name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>bytecount</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>dst</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>src</name></expr>;</condition> <incr><expr><name>src</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>*</operator><name>src</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <operator>*</operator><name>src</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>src</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<return>return <expr><name>dst</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>match_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>lbl</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><call><name>strncasecompare</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>lbl</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<for>for<control>(<init><expr><name>value</name> <operator>=</operator> <name><name>hdr</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>value</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>value</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for></block_content></block></if></if_stmt>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>search_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>hdrlist</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for<control>(<init>;</init> <condition><expr><operator>!</operator><name>value</name> <operator>&amp;&amp;</operator> <name>hdrlist</name></expr>;</condition> <incr><expr><name>hdrlist</name> <operator>=</operator> <name><name>hdrlist</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>match_header</name><argument_list>(<argument><expr><name>hdrlist</name></expr></argument>, <argument><expr><name>hdr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>strippath</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fullfile</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>fullfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><call><name>basename</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>base</name></expr>;</return> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_encoder_state</name><parameter_list>(<parameter><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>bufend</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_nop_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>insize</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>ateof</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;</operator> <name>insize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>insize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_nop_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_7bit_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>ateof</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>size</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;</operator> <name>cursize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>cursize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for<control>(<init><expr><name>cursize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cursize</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><name>cursize</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>&amp;</operator> <literal type="number">0x80</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>READ_ERROR</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>cursize</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_base64_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>

<while>while<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;</operator> <name>MAX_ENCODED_LINE_LENGTH</name> <operator>-</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cursize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\r'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cursize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name><operator>++</operator></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name><operator>++</operator></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>i</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name><operator>++</operator></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <name><name>base64</name><index>[<expr><name>i</name> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if<condition>(<expr><name>ateof</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cursize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>ptr</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'='</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>i</name> <operator>|=</operator> <operator>(</operator><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">18</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">12</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>++</operator><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>!=</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>base64</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">6</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0x3F</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name>cursize</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><call><name>Curl_convert_to_network</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>cursize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cursize</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_base64_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_off_t</name></type> <name>size</name> <init>= <expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>size</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">4</literal> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>size</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><operator>(</operator><name>size</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>MAX_ENCODED_LINE_LENGTH</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>qp_lookahead_eol</name><parameter_list>(<parameter><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ateof</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>n</name> <operator>&gt;=</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>&amp;&amp;</operator> <name>ateof</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>n</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name>ateof</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>qp_class</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>]</index></name> <operator>==</operator> <name>QP_CR</name> <operator>&amp;&amp;</operator>

<name><name>qp_class</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>]</index></name> <operator>==</operator> <name>QP_LF</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>encoder_qp_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ateof</name></decl></parameter>,

<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>softlinebreak</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<while>while<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>consumed</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>aschex</name><index>[<expr><operator>(</operator><name>i</name> <operator>&gt;&gt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>aschex</name><index>[<expr><name>i</name> <operator>&amp;</operator> <literal type="number">0xF</literal></expr>]</index></name></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name><name>qp_class</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>buf</name><index>[<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xFF</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>QP_OK</name></expr>:</case> 

<break>break;</break>

<case>case <expr><name>QP_SP</name></expr>:</case> 

<switch>switch<condition>(<expr><call><name>qp_lookahead_eol</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>ateof</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 

<return>return <expr><name>cursize</name></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\x3D'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>QP_CR</name></expr>:</case> 

<switch>switch<condition>(<expr><call><name>qp_lookahead_eol</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>ateof</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 

<return>return <expr><name>cursize</name></expr>;</return>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\x0A'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>consumed</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\x3D'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\x3D'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if<condition>(<expr><name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\x0A'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>softlinebreak</name> <operator>=</operator> <name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>MAX_ENCODED_LINE_LENGTH</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>softlinebreak</name> <operator>&amp;&amp;</operator> <name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>+</operator> <name>len</name> <operator>==</operator> <name>MAX_ENCODED_LINE_LENGTH</name></expr>)</condition> <block>{<block_content>

<switch>switch<condition>(<expr><call><name>qp_lookahead_eol</name><argument_list>(<argument><expr><name>st</name></expr></argument>, <argument><expr><name>ateof</name></expr></argument>, <argument><expr><name>consumed</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 

<return>return <expr><name>cursize</name></expr>;</return>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><name>softlinebreak</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>softlinebreak</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x3D\x0D\x0A"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>consumed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>cursize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>buf</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\x0A'</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>+=</operator> <name>consumed</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>cursize</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>encoder_qp_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>mime_mem_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>curlx_sotouz</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>-</operator> <name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>size</name></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>nitems</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>nitems</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <name>nitems</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>sz</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>curlx_sotouz</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>sz</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_mem_seek</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>, <parameter><decl><type><name>curl_off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name>whence</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SEEK_CUR</name></expr>:</case>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SEEK_END</name></expr>:</case>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if<condition>(<expr><name><name>offset</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>offset</name></expr></argument> &gt;</argument_list></name> <name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURL_SEEKFUNC_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<return>return <expr><name>CURL_SEEKFUNC_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mime_mem_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>ptr</name><operator>)</operator><operator>-&gt;</operator><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_open_file</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type> <name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <call><name>fopen_read</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"rb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>mime_file_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>nitems</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>mime_open_file</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>fread</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_file_seek</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>, <parameter><decl><type><name>curl_off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>whence</name> <operator>==</operator> <name>SEEK_SET</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>offset</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURL_SEEKFUNC_OK</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if<condition>(<expr><call><name>mime_open_file</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURL_SEEKFUNC_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><ternary><condition><expr><call><name>fseek</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>?</condition><then>

<expr><name>CURL_SEEKFUNC_CANTSEEK</name></expr></then><else>: <expr><name>CURL_SEEKFUNC_OK</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mime_file_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>readback_bytes</name><parameter_list>(<parameter><decl><type><name>mime_state</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bytes</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>numbytes</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>trail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>offset</name> <init>= <expr><call><name>curlx_sotouz</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>numbytes</name> <operator>&gt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <name>numbytes</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bytes</name> <operator>+=</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>tsz</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>trail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <name>offset</name> <operator>-</operator> <name>numbytes</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>sz</name> <operator>&gt;=</operator> <name>tsz</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <name>trail</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <name>tsz</name> <operator>-</operator> <name>sz</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>sz</name> <operator>&gt;</operator> <name>bufsize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <name>bufsize</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<return>return <expr><name>sz</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>read_part_content</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasread</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><name>CURL_READFUNC_ABORT</name></expr>:</case>

<case>case <expr><name>CURL_READFUNC_PAUSE</name></expr>:</case>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<return>return <expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name></expr>;</return>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>!=</operator> <operator>(</operator><name>curl_off_t</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator>

<name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name> <operator>&gt;=</operator> <name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if>

<else>else <block>{<block_content>

<switch>switch<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIMEKIND_MULTIPART</name></expr>:</case>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>mime_subparts_read</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMEKIND_FILE</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name> <operator>&amp;&amp;</operator> <call><name>feof</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<default>default:</default>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_FAST_READ</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>*</operator><name>hasread</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>STOP_FILLING</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>hasread</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<switch>switch<condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>STOP_FILLING</name></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><name>CURL_READFUNC_ABORT</name></expr>:</case>

<case>case <expr><name>CURL_READFUNC_PAUSE</name></expr>:</case>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>sz</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>read_encoded_part_content</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasread</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>mime_encoder_state</name> <modifier>*</modifier></type><name>st</name> <init>= <expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ateof</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<for>for<control>(<init>;</init><condition>;</condition><incr/>)</control> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>&lt;</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>||</operator> <name>ateof</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name><name>part</name><operator>-&gt;</operator><name>encoder</name><operator>-&gt;</operator><name>encodefunc</name></name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>ateof</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if<condition>(<expr><name>ateof</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cursize</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<case>case <expr><name>STOP_FILLING</name></expr>:</case>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</return>

<default>default:</default>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bufsize</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufbeg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>READ_ERROR</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>read_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name> <operator>+</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>st</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name><name>st</name><operator>-&gt;</operator><name>bufend</name></name></expr></argument>, <argument><expr><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>ateof</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CURL_READFUNC_ABORT</name></expr>:</case>

<case>case <expr><name>CURL_READFUNC_PAUSE</name></expr>:</case>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<case>case <expr><name>STOP_FILLING</name></expr>:</case>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</return>

<default>default:</default>

<expr_stmt><expr><name><name>st</name><operator>-&gt;</operator><name>bufend</name></name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>readback_part</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>bufsize</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasread</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>convbuf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while<condition>(<expr><name>bufsize</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><operator>(</operator>struct <name>curl_slist</name> <operator>*</operator><operator>)</operator> <name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIMESTATE_BEGIN</name></expr>:</case>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_BODY_ONLY</name><operator>)</operator></expr>?</condition><then>

<expr><name>MIMESTATE_BODY</name></expr></then><else>: <expr><name>MIMESTATE_CURLHEADERS</name></expr></else></ternary></expr></argument>,

<argument><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_USERHEADERS</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>hdr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_EOH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>match_header</name><argument_list>(<argument><expr><name>hdr</name></expr></argument>, <argument><expr><literal type="string">"Content-Type"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_USERHEADERS</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>MIMESTATE_CURLHEADERS</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>hdr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_USERHEADERS</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>readback_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,

<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_EOH</name></expr>:</case>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>readback_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><literal type="string">"\r\n"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BODY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_BODY</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name>convbuf</name> <operator>&lt;</operator> <name>buffer</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><call><name>Curl_convert_to_network</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><name>convbuf</name></expr></argument>,

<argument><expr><name>buffer</name> <operator>-</operator> <name>convbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>convbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>cleanup_encoder_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_CONTENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_CONTENT</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>encoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>read_encoded_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>read_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<switch>switch<condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_FILE</name> <operator>&amp;&amp;</operator> <name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><name>CURL_READFUNC_ABORT</name></expr>:</case>

<case>case <expr><name>CURL_READFUNC_PAUSE</name></expr>:</case>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<case>case <expr><name>STOP_FILLING</name></expr>:</case>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</return>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>MIMESTATE_END</name></expr>:</case>

<return>return <expr><name>cursize</name></expr>;</return>

<default>default:</default>

<break>break;</break> 

</block_content>}</block></switch>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bufsize</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>

</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name>convbuf</name> <operator>&lt;</operator> <name>buffer</name> <operator>&amp;&amp;</operator>

<name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>&lt;</operator> <name>MIMESTATE_BODY</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><call><name>Curl_convert_to_network</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><name>convbuf</name></expr></argument>,

<argument><expr><name>buffer</name> <operator>-</operator> <name>convbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cursize</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>mime_subparts_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasread</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>cursize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>convbuf</name> <init>= <expr><name>buffer</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>size</name></expr>;</expr_stmt> 

<while>while<condition>(<expr><name>nitems</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><name><name>mime</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

<switch>switch<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIMESTATE_BEGIN</name></expr>:</case>

<case>case <expr><name>MIMESTATE_BODY</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>convbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BOUNDARY1</name></expr></argument>, <argument><expr><name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>offset</name></name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_BOUNDARY1</name></expr>:</case>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>readback_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><literal type="string">"\r\n--"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BOUNDARY2</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_BOUNDARY2</name></expr>:</case>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>readback_bytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name><name>mime</name><operator>-&gt;</operator><name>boundary</name></name></expr></argument>,

<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>boundary</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><ternary><condition><expr><name>part</name></expr>?</condition><then> <expr><literal type="string">"\r\n"</literal></expr></then><else>: <expr><literal type="string">"--\r\n"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>sz</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name>convbuf</name> <operator>&lt;</operator> <name>buffer</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><call><name>Curl_convert_to_network</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><name>convbuf</name></expr></argument>,

<argument><expr><name>buffer</name> <operator>-</operator> <name>convbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>convbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_CONTENT</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>MIMESTATE_CONTENT</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>readback_part</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>sz</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>CURL_READFUNC_ABORT</name></expr>:</case>

<case>case <expr><name>CURL_READFUNC_PAUSE</name></expr>:</case>

<case>case <expr><name>READ_ERROR</name></expr>:</case>

<case>case <expr><name>STOP_FILLING</name></expr>:</case>

<return>return <expr><ternary><condition><expr><name>cursize</name></expr>?</condition><then> <expr><name>cursize</name></expr></then><else>: <expr><name>sz</name></expr></else></ternary></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>convbuf</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BOUNDARY1</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>nextpart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>MIMESTATE_END</name></expr>:</case>

<return>return <expr><name>cursize</name></expr>;</return>

<default>default:</default>

<break>break;</break> 

</block_content>}</block></switch>

<expr_stmt><expr><name>cursize</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nitems</name> <operator>-=</operator> <name>sz</name></expr>;</expr_stmt>

</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DOES_CONVERSIONS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name>convbuf</name> <operator>&lt;</operator> <name>buffer</name> <operator>&amp;&amp;</operator>

<name><name>mime</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>&lt;=</operator> <name>MIMESTATE_CONTENT</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><call><name>Curl_convert_to_network</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><name>convbuf</name></expr></argument>,

<argument><expr><name>buffer</name> <operator>-</operator> <name>convbuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>READ_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>cursize</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_part_rewind</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>CURL_SEEKFUNC_OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>enum</name> <name>mimestate</name></name></type> <name>targetstate</name> <init>= <expr><name>MIMESTATE_BEGIN</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_BODY_ONLY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>targetstate</name> <operator>=</operator> <name>MIMESTATE_BODY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_encoder_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>&gt;</operator> <name>targetstate</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURL_SEEKFUNC_CANTSEEK</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>curl_off_t</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>CURL_SEEKFUNC_OK</name></expr>:</case>

<case>case <expr><name>CURL_SEEKFUNC_FAIL</name></expr>:</case>

<case>case <expr><name>CURL_SEEKFUNC_CANTSEEK</name></expr>:</case>

<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURL_SEEKFUNC_CANTSEEK</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURL_SEEKFUNC_FAIL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>CURL_SEEKFUNC_OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>targetstate</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mime_subparts_seek</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>, <parameter><decl><type><name>curl_off_t</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>whence</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>CURL_SEEKFUNC_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>whence</name> <operator>!=</operator> <name>SEEK_SET</name> <operator>||</operator> <name>offset</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURL_SEEKFUNC_CANTSEEK</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>MIMESTATE_BEGIN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURL_SEEKFUNC_OK</name></expr>;</return></block_content></block></if></if_stmt> 

<for>for<control>(<init><expr><name>part</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>;</init> <condition><expr><name>part</name></expr>;</condition> <incr><expr><name>part</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>nextpart</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>mime_part_rewind</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name> <operator>!=</operator> <name>CURL_SEEKFUNC_OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><name>result</name> <operator>==</operator> <name>CURL_SEEKFUNC_OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BEGIN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cleanup_part_content</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>part</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>fp</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <operator>(</operator><name>curl_off_t</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>cleanup_encoder_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>encstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MIMEKIND_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MIME_FAST_READ</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mime_subparts_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name> <operator>&amp;&amp;</operator> <name><name>mime</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>curl_mime_free</name><argument_list>(<argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mime_subparts_unbind</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name>ptr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name> <operator>&amp;&amp;</operator> <name><name>mime</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_mime_cleanpart</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>curl_slist_free_all</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_USERHEADERS_OWNER</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>curl_slist_free_all</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_mime_initpart</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>curl_mime_free</name><parameter_list>(<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mime_subparts_unbind</name><argument_list>(<argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<while>while<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>part</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>nextpart</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_mime_cleanpart</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_duppart</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>curl_mimepart</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>curl_mimepart</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>res</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIMEKIND_NONE</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>MIMEKIND_DATA</name></expr>:</case>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_data</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name><name>src</name><operator>-&gt;</operator><name>datasize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMEKIND_FILE</name></expr>:</case>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_filedata</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name> <operator>==</operator> <name>CURLE_READ_ERROR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>MIMEKIND_CALLBACK</name></expr>:</case>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_data_cb</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>datasize</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>readfunc</name></name></expr></argument>,

<argument><expr><name><name>src</name><operator>-&gt;</operator><name>seekfunc</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>freefunc</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMEKIND_MULTIPART</name></expr>:</case>

<expr_stmt><expr><name>mime</name> <operator>=</operator> <call><name>curl_mime_init</name><argument_list>(<argument><expr><name><name>dst</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name>mime</name></expr>?</condition><then> <expr><call><name>curl_mime_subparts</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>CURLE_OUT_OF_MEMORY</name></expr></else></ternary></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>s</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name><name>src</name><operator>-&gt;</operator><name>arg</name></name><operator>)</operator><operator>-&gt;</operator><name>firstpart</name></expr>;</init> <condition><expr><operator>!</operator><name>res</name> <operator>&amp;&amp;</operator> <name>s</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>nextpart</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>curl_mime_addpart</name><argument_list>(<argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name>d</name></expr>?</condition><then> <expr><call><name>Curl_mime_duppart</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>CURLE_OUT_OF_MEMORY</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>userheaders</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>hdrs</name> <init>= <expr><call><name>Curl_slist_duplicate</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>hdrs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURLE_OUT_OF_MEMORY</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_headers</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>hdrs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>curl_slist_free_all</name><argument_list>(<argument><expr><name>hdrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>dst</name><operator>-&gt;</operator><name>encoder</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>encoder</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_type</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>mimetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_name</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>curl_mime_filename</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Curl_mime_cleanpart</name><argument_list>(<argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>curl_mime</name> <modifier>*</modifier></type><name>curl_mime_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>easy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl>;</decl_stmt>

<expr_stmt><expr><name>mime</name> <operator>=</operator> <operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>mime</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name> <operator>=</operator> <name>easy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>lastpart</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>boundary</name></name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>Curl_rand_hex</name><argument_list>(<argument><expr><name>easy</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>boundary</name><index>[<expr><literal type="number">24</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>MIME_RAND_BOUNDARY_CHARS</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>mime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>mime</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BEGIN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>mime</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_mime_initpart</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>easy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>part</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>part</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>=</operator> <name>easy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_BEGIN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>curl_mime_addpart</name><parameter_list>(<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>mime</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>part</name> <operator>=</operator> <operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>part</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>part</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Curl_mime_initpart</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name><name>mime</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>mime</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>mime</name><operator>-&gt;</operator><name>lastpart</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>lastpart</name><operator>-&gt;</operator><name>nextpart</name></name> <operator>=</operator> <name>part</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name> <operator>=</operator> <name>part</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>mime</name><operator>-&gt;</operator><name>lastpart</name></name> <operator>=</operator> <name>part</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>part</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_name</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_filename</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_data</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datasize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>datasize</name> <operator>==</operator> <name>CURL_ZERO_TERMINATED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>datasize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>datasize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <name>datasize</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>datasize</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>datasize</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name> <operator>=</operator> <name>mime_mem_read</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name> <operator>=</operator> <name>mime_mem_seek</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>mime_mem_free</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MIME_FAST_READ</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MIMEKIND_DATA</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_filedata</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>struct_stat</name></type> <name>sbuf</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sbuf</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>access</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>R_OK</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_READ_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OUT_OF_MEMORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>sbuf</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <call><name>filesize</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name> <operator>=</operator> <name>mime_file_seek</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name> <operator>=</operator> <name>mime_file_read</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>mime_file_free</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MIMEKIND_FILE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>strippath</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>base</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OUT_OF_MEMORY</name></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>res</name> <init>= <expr><call><name>curl_mime_filename</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_type</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mimetype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>mimetype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>mimetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_encoder</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>mime_encoder</name> <modifier>*</modifier></type><name>mep</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>encoder</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt> 

<for>for<control>(<init><expr><name>mep</name> <operator>=</operator> <name>encoders</name></expr>;</init> <condition><expr><name><name>mep</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>mep</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><call><name>strcasecompare</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name><name>mep</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>encoder</name></name> <operator>=</operator> <name>mep</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_headers</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>headers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>take_ownership</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_USERHEADERS_OWNER</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name> <operator>!=</operator> <name>headers</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>curl_slist_free_all</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>MIME_USERHEADERS_OWNER</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name> <operator>=</operator> <name>headers</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>headers</name> <operator>&amp;&amp;</operator> <name>take_ownership</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>MIME_USERHEADERS_OWNER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_data_cb</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name>curl_off_t</name></type> <name>datasize</name></decl></parameter>,

<parameter><decl><type><name>curl_read_callback</name></type> <name>readfunc</name></decl></parameter>,

<parameter><decl><type><name>curl_seek_callback</name></type> <name>seekfunc</name></decl></parameter>,

<parameter><decl><type><name>curl_free_callback</name></type> <name>freefunc</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>readfunc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>readfunc</name></name> <operator>=</operator> <name>readfunc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name> <operator>=</operator> <name>seekfunc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>freefunc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <name>datasize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MIMEKIND_CALLBACK</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_set_subparts</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>subparts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>take_ownership</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>part</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_MULTIPART</name> <operator>&amp;&amp;</operator> <name><name>part</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>subparts</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>cleanup_part_content</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>subparts</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name><name>subparts</name><operator>-&gt;</operator><name>easy</name></name> <operator>&amp;&amp;</operator> <name><name>part</name><operator>-&gt;</operator><name>easy</name></name> <operator>!=</operator> <name><name>subparts</name><operator>-&gt;</operator><name>easy</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>subparts</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>root</name></expr>)</condition> <block>{<block_content>

<while>while<condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>parent</name></name> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>root</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>parent</name><operator>-&gt;</operator><name>parent</name></name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if<condition>(<expr><name>subparts</name> <operator>==</operator> <name>root</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>easy</name></name></expr></argument>, <argument><expr><literal type="string">"Can't add itself as a subpart!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>CURLE_BAD_FUNCTION_ARGUMENT</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>subparts</name><operator>-&gt;</operator><name>parent</name></name> <operator>=</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>seekfunc</name></name> <operator>=</operator> <name>mime_subparts_seek</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <ternary><condition><expr><name>take_ownership</name></expr>?</condition><then> <expr><name>mime_subparts_free</name></expr></then><else>: <expr><name>mime_subparts_unbind</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <name>subparts</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>MIMEKIND_MULTIPART</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_subparts</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>subparts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>Curl_mime_set_subparts</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>subparts</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Curl_mime_read</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nitems</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>instream</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><operator>(</operator><name>curl_mimepart</name> <operator>*</operator><operator>)</operator> <name>instream</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>hasread</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>size</name></expr>;</expr_stmt> 

<do>do <block>{<block_content>

<expr_stmt><expr><name>hasread</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>readback_part</name><argument_list>(<argument><expr><name>part</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nitems</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while<condition>(<expr><name>ret</name> <operator>==</operator> <name>STOP_FILLING</name></expr>)</condition>;</do>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_rewind</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>mime_part_rewind</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>CURL_SEEKFUNC_OK</name></expr>?</condition><then>

<expr><name>CURLE_OK</name></expr></then><else>: <expr><name>CURLE_SEND_FAIL_REWIND</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>slist_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>s</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>overhead</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>skip</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>skiplen</name> <init>= <expr><ternary><condition><expr><name>skip</name></expr>?</condition><then> <expr><call><name>strlen</name><argument_list>(<argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for<control>(<init>;</init> <condition><expr><name>s</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>skip</name> <operator>||</operator> <operator>!</operator><call><name>match_header</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>, <argument><expr><name>skiplen</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>overhead</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>curl_off_t</name></type> <name>multipart_size</name><parameter_list>(<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_off_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>boundarysize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>mime</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>boundarysize</name> <operator>=</operator> <literal type="number">4</literal> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>mime</name><operator>-&gt;</operator><name>boundary</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>boundarysize</name></expr>;</expr_stmt> 

<for>for<control>(<init><expr><name>part</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>;</init> <condition><expr><name>part</name></expr>;</condition> <incr><expr><name>part</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>nextpart</name></name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>curl_off_t</name></type> <name>sz</name> <init>= <expr><call><name>Curl_mime_size</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name>boundarysize</name> <operator>+</operator> <name>sz</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>curl_off_t</name></type> <name>Curl_mime_size</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_off_t</name></type> <name>size</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_MULTIPART</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>datasize</name></name> <operator>=</operator> <call><name>multipart_size</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>datasize</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>encoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>part</name><operator>-&gt;</operator><name>encoder</name><operator>-&gt;</operator><name>sizefunc</name></name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>size</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>part</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>MIME_BODY_ONLY</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>slist_size</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>slist_size</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"Content-Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<return>return <expr><name>size</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_add_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>slp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>hdr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>curl_mvaprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hdr</name> <operator>=</operator> <call><name>Curl_slist_append_nodup</name><argument_list>(<argument><expr><operator>*</operator><name>slp</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>hdr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>slp</name> <operator>=</operator> <name>hdr</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>hdr</name></expr>?</condition><then> <expr><name>CURLE_OK</name></expr></then><else>: <expr><name>CURLE_OUT_OF_MEMORY</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>add_content_type</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>slp</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>boundary</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>Curl_mime_add_header</name><argument_list>(<argument><expr><name>slp</name></expr></argument>, <argument><expr><literal type="string">"Content-Type: %s%s%s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>boundary</name></expr>?</condition><then> <expr><literal type="string">"; boundary="</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>boundary</name></expr>?</condition><then> <expr><name>boundary</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>Curl_mime_contenttype</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<struct>struct <name>ContentType</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>extension</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>ContentType</name></name></type> <name><name>ctts</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="string">".gif"</literal></expr>, <expr><literal type="string">"image/gif"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".jpg"</literal></expr>, <expr><literal type="string">"image/jpeg"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".jpeg"</literal></expr>, <expr><literal type="string">"image/jpeg"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".png"</literal></expr>, <expr><literal type="string">"image/png"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".svg"</literal></expr>, <expr><literal type="string">"image/svg+xml"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".txt"</literal></expr>, <expr><literal type="string">"text/plain"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".htm"</literal></expr>, <expr><literal type="string">"text/html"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".html"</literal></expr>, <expr><literal type="string">"text/html"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".pdf"</literal></expr>, <expr><literal type="string">"application/pdf"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">".xml"</literal></expr>, <expr><literal type="string">"application/xml"</literal></expr>}</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>filename</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameend</name> <init>= <expr><name>filename</name> <operator>+</operator> <name>len1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ctts</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>ctts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len2</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>ctts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extension</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>len1</name> <operator>&gt;=</operator> <name>len2</name> <operator>&amp;&amp;</operator> <call><name>strcasecompare</name><argument_list>(<argument><expr><name>nameend</name> <operator>-</operator> <name>len2</name></expr></argument>, <argument><expr><name><name>ctts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>extension</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>ctts</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_prepare_headers</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>contenttype</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>disposition</name></decl></parameter>,

<parameter><decl><type><name><name>enum</name> <name>mimestrategy</name></name></type> <name>strategy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>boundary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>customct</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>ret</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>curl_slist_free_all</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>MIMESTATE_CURLHEADERS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_CURLHEADERS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>customct</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>mimetype</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>customct</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>customct</name> <operator>=</operator> <call><name>search_header</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>, <argument><expr><literal type="string">"Content-Type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>customct</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <name>customct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>contenttype</name></expr>)</condition> <block>{<block_content>

<switch>switch<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>MIMEKIND_MULTIPART</name></expr>:</case>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <name>MULTIPART_CONTENTTYPE_DEFAULT</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>MIMEKIND_FILE</name></expr>:</case>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <call><name>Curl_mime_contenttype</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>contenttype</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <call><name>Curl_mime_contenttype</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>contenttype</name> <operator>&amp;&amp;</operator> <name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <name>FILE_CONTENTTYPE_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <call><name>Curl_mime_contenttype</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_MULTIPART</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mime</name> <operator>=</operator> <operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>boundary</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>boundary</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if<condition>(<expr><name>contenttype</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>customct</name> <operator>&amp;&amp;</operator>

<call><name>strcasecompare</name><argument_list>(<argument><expr><name>contenttype</name></expr></argument>, <argument><expr><literal type="string">"text/plain"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><name>strategy</name> <operator>==</operator> <name>MIMESTRATEGY_MAIL</name> <operator>||</operator> <operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>contenttype</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>search_header</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>, <argument><expr><literal type="string">"Content-Disposition"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>disposition</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name> <operator>||</operator> <name><name>part</name><operator>-&gt;</operator><name>name</name></name> <operator>||</operator>

<operator>(</operator><name>contenttype</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncasecompare</name><argument_list>(<argument><expr><name>contenttype</name></expr></argument>, <argument><expr><literal type="string">"multipart/"</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disposition</name> <operator>=</operator> <name>DISPOSITION_DEFAULT</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>disposition</name> <operator>&amp;&amp;</operator> <call><name>curl_strequal</name><argument_list>(<argument><expr><name>disposition</name></expr></argument>, <argument><expr><literal type="string">"attachment"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disposition</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>disposition</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>escape_string</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>CURLE_OUT_OF_MEMORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ret</name> <operator>&amp;&amp;</operator> <name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>escape_string</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>filename</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>CURLE_OUT_OF_MEMORY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>Curl_mime_add_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>,

<argument><expr><literal type="string">"Content-Disposition: %s%s%s%s%s%s%s"</literal></expr></argument>,

<argument><expr><name>disposition</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>name</name></expr>?</condition><then> <expr><literal type="string">"; name=\""</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>name</name></expr>?</condition><then> <expr><name>name</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>name</name></expr>?</condition><then> <expr><literal type="string">"\""</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>filename</name></expr>?</condition><then> <expr><literal type="string">"; filename=\""</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>filename</name></expr>?</condition><then> <expr><name>filename</name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><ternary><condition><expr><name>filename</name></expr>?</condition><then> <expr><literal type="string">"\""</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>contenttype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>add_content_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>, <argument><expr><name>contenttype</name></expr></argument>, <argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>search_header</name><argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>userheaders</name></name></expr></argument>, <argument><expr><literal type="string">"Content-Transfer-Encoding"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>encoder</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cte</name> <operator>=</operator> <name><name>part</name><operator>-&gt;</operator><name>encoder</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if<condition>(<expr><name>contenttype</name> <operator>&amp;&amp;</operator> <name>strategy</name> <operator>==</operator> <name>MIMESTRATEGY_MAIL</name> <operator>&amp;&amp;</operator>

<name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>MIMEKIND_MULTIPART</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>cte</name> <operator>=</operator> <literal type="string">"8bit"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>cte</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>Curl_mime_add_header</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>,

<argument><expr><literal type="string">"Content-Transfer-Encoding: %s"</literal></expr></argument>, <argument><expr><name>cte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>state</name></name> <operator>==</operator> <name>MIMESTATE_CURLHEADERS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mimesetstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>part</name><operator>-&gt;</operator><name>state</name></name></expr></argument>, <argument><expr><name>MIMESTATE_CURLHEADERS</name></expr></argument>, <argument><expr><name><name>part</name><operator>-&gt;</operator><name>curlheaders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_MULTIPART</name> <operator>&amp;&amp;</operator> <name>mime</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>subpart</name></decl>;</decl_stmt>

<expr_stmt><expr><name>disposition</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>strcasecompare</name><argument_list>(<argument><expr><name>contenttype</name></expr></argument>, <argument><expr><literal type="string">"multipart/form-data"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disposition</name> <operator>=</operator> <literal type="string">"form-data"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for<control>(<init><expr><name>subpart</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>;</init> <condition><expr><name>subpart</name></expr>;</condition> <incr><expr><name>subpart</name> <operator>=</operator> <name><name>subpart</name><operator>-&gt;</operator><name>nextpart</name></name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>Curl_mime_prepare_headers</name><argument_list>(<argument><expr><name>subpart</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>disposition</name></expr></argument>, <argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ret</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_mime_unpause</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>part</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>==</operator> <name>CURL_READFUNC_PAUSE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>part</name><operator>-&gt;</operator><name>lastreadstatus</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>part</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>MIMEKIND_MULTIPART</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name> <init>= <expr><operator>(</operator><name>curl_mime</name> <operator>*</operator><operator>)</operator> <name><name>part</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>mime</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>subpart</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>subpart</name> <operator>=</operator> <name><name>mime</name><operator>-&gt;</operator><name>firstpart</name></name></expr>;</init> <condition><expr><name>subpart</name></expr>;</condition> <incr><expr><name>subpart</name> <operator>=</operator> <name><name>subpart</name><operator>-&gt;</operator><name>nextpart</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Curl_mime_unpause</name><argument_list>(<argument><expr><name>subpart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else> 

<function><type><name>curl_mime</name> <modifier>*</modifier></type><name>curl_mime_init</name><parameter_list>(<parameter><decl><type><name>CURL</name> <modifier>*</modifier></type><name>easy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>easy</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>curl_mime_free</name><parameter_list>(<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>mime</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>curl_mime_addpart</name><parameter_list>(<parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>mime</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>mime</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_name</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>name</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_filename</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>filename</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_type</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mimetype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>mimetype</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_encoder</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>encoding</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>encoding</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_data</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datasize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>data</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>datasize</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_filedata</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>filename</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_data_cb</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name>curl_off_t</name></type> <name>datasize</name></decl></parameter>,

<parameter><decl><type><name>curl_read_callback</name></type> <name>readfunc</name></decl></parameter>,

<parameter><decl><type><name>curl_seek_callback</name></type> <name>seekfunc</name></decl></parameter>,

<parameter><decl><type><name>curl_free_callback</name></type> <name>freefunc</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>datasize</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>readfunc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>seekfunc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>freefunc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_subparts</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>, <parameter><decl><type><name>curl_mime</name> <modifier>*</modifier></type><name>subparts</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>subparts</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>curl_mime_headers</name><parameter_list>(<parameter><decl><type><name>curl_mimepart</name> <modifier>*</modifier></type><name>part</name></decl></parameter>,

<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier></type><name>headers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>take_ownership</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>part</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>headers</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>take_ownership</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_mime_add_header</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_slist</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>slp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>slp</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>fmt</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
