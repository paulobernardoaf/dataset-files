<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\curl-analysis\_cppstats\curl\lib\content_encoding.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_setup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"urldata.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;curl/curl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__SYMBIAN32__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>WIN32</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROTLI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;brotli/decode.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sendf.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"content_encoding.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strdup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"strcase.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_memory.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memdebug.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTENT_ENCODING_DEFAULT</name></cpp:macro> <cpp:value>"identity"</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DSIZ</name></cpp:macro> <cpp:value>CURL_MAX_WRITE_SIZE</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OLD_ZLIB_SUPPORT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GZIP_MAGIC_0</name></cpp:macro> <cpp:value>0x1f</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GZIP_MAGIC_1</name></cpp:macro> <cpp:value>0x8b</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASCII_FLAG</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEAD_CRC</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_FIELD</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ORIG_NAME</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMMENT</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESERVED</name></cpp:macro> <cpp:value>0xE0</cpp:value></cpp:define> 

<typedef>typedef <type><enum>enum <block>{

<decl><name>ZLIB_UNINIT</name></decl>, 

<decl><name>ZLIB_INIT</name></decl>, 

<decl><name>ZLIB_INFLATING</name></decl>, 

<decl><name>ZLIB_EXTERNAL_TRAILER</name></decl>, 

<decl><name>ZLIB_GZIP_HEADER</name></decl>, 

<decl><name>ZLIB_GZIP_INFLATING</name></decl>, 

<decl><name>ZLIB_INIT_GZIP</name></decl> 

}</block></enum></type> <name>zlibInitState</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>zlibInitState</name></type> <name>zlib_init</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name></type> <name>trailerlen</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>z_stream</name></type> <name>z</name></decl>;</decl_stmt> 

}</block></struct></type> <name>zlib_params</name>;</typedef>

<function><type><specifier>static</specifier> <name>voidpf</name></type>

<name>zalloc_cb</name><parameter_list>(<parameter><decl><type><name>voidpf</name></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>items</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>opaque</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>voidpf</name><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>zfree_cb</name><parameter_list>(<parameter><decl><type><name>voidpf</name></type> <name>opaque</name></decl></parameter>, <parameter><decl><type><name>voidpf</name></type> <name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>opaque</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type>

<name>process_zlib_error</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>msg</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Error while processing content unencoding: %s"</literal></expr></argument>,

<argument><expr><name><name>z</name><operator>-&gt;</operator><name>msg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Error while processing content unencoding: "</literal>

<literal type="string">"Unknown failure within decompression software."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>CURLE_BAD_CONTENT_ENCODING</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type>

<name>exit_zlib</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name></decl></parameter>, <parameter><decl><type><name>zlibInitState</name> <modifier>*</modifier></type><name>zlib_init</name></decl></parameter>, <parameter><decl><type><name>CURLcode</name></type> <name>result</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>*</operator><name>zlib_init</name> <operator>==</operator> <name>ZLIB_GZIP_HEADER</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>*</operator><name>zlib_init</name> <operator>!=</operator> <name>ZLIB_UNINIT</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>inflateEnd</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>==</operator> <name>CURLE_OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>zlib_init</name> <operator>=</operator> <name>ZLIB_UNINIT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>process_trailer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uInt</name></type> <name>len</name> <init>= <expr><ternary><condition><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>&lt;</operator> <name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name></expr>?</condition><then> <expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></then><else>: <expr><name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_WRITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name> <operator>||</operator> <operator>!</operator><name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_EXTERNAL_TRAILER</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>inflate_stream</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>, <parameter><decl><type><name>zlibInitState</name></type> <name>started</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>uInt</name></type> <name>nread</name> <init>= <expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Bytef</name> <modifier>*</modifier></type><name>orig_in</name> <init>= <expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>decomp</name></decl>;</decl_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>!=</operator> <name>ZLIB_INIT</name> <operator>&amp;&amp;</operator>

<name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>!=</operator> <name>ZLIB_INFLATING</name> <operator>&amp;&amp;</operator>

<name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>!=</operator> <name>ZLIB_INIT_GZIP</name> <operator>&amp;&amp;</operator>

<name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>!=</operator> <name>ZLIB_GZIP_INFLATING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_WRITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>decomp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>DSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>decomp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<while>while<condition>(<expr><operator>!</operator><name>done</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt> 

<expr_stmt><expr><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_out</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>decomp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>=</operator> <name>DSIZ</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Z_BLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>Z_BLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>Z_SYNC_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>avail_out</name></name> <operator>!=</operator> <name>DSIZ</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>status</name> <operator>==</operator> <name>Z_OK</name> <operator>||</operator> <name>status</name> <operator>==</operator> <name>Z_STREAM_END</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>started</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_unencode_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr></argument>, <argument><expr><name>decomp</name></expr></argument>,

<argument><expr><name>DSIZ</name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>avail_out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>Z_OK</name></expr>:</case>

<expr_stmt><expr><name>done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>Z_BUF_ERROR</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>Z_STREAM_END</name></expr>:</case>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>process_trailer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>Z_DATA_ERROR</name></expr>:</case>

<if_stmt><if>if<condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>==</operator> <name>ZLIB_INIT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>inflateEnd</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><call><name>inflateInit2</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><name>MAX_WBITS</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <name>orig_in</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <name>nread</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_INFLATING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_UNINIT</name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<default>default:</default>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>decomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>nread</name> <operator>&amp;&amp;</operator> <name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>==</operator> <name>ZLIB_INIT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>started</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>deflate_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator> <name>zalloc_cb</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <operator>(</operator><name>free_func</name><operator>)</operator> <name>zfree_cb</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>inflateInit</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_INIT</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>deflate_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>==</operator> <name>ZLIB_EXTERNAL_TRAILER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>process_trailer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>inflate_stream</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>, <argument><expr><name>ZLIB_INFLATING</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>deflate_close_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name></type> <name>deflate_encoding</name> <init>= <expr><block>{

<expr><literal type="string">"deflate"</literal></expr>,

<expr><name>NULL</name></expr>,

<expr><name>deflate_init_writer</name></expr>,

<expr><name>deflate_unencode_write</name></expr>,

<expr><name>deflate_close_writer</name></expr>,

<expr>sizeof<operator>(</operator><name>zlib_params</name><operator>)</operator></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>gzip_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>zalloc</name></name> <operator>=</operator> <operator>(</operator><name>alloc_func</name><operator>)</operator> <name>zalloc_cb</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>zfree</name></name> <operator>=</operator> <operator>(</operator><name>free_func</name><operator>)</operator> <name>zfree_cb</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>zlibVersion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><literal type="string">"1.2.0.4"</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>inflateInit2</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>MAX_WBITS</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_INIT_GZIP</name></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>inflateInit2</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><operator>-</operator><name>MAX_WBITS</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>Z_OK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>trailerlen</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_INIT</name></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>OLD_ZLIB_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<enum><specifier>static</specifier> enum <block>{

<decl><name>GZIP_OK</name></decl>,

<decl><name>GZIP_BAD</name></decl>,

<decl><name>GZIP_UNDERFLOW</name></decl>

}</block> <decl><name>check_gzip_header</name><argument_list>(<argument><expr><name>unsigned</name> <name>char</name> <specifier>const</specifier> <operator>*</operator><name>data</name></expr></argument>, <argument><expr><name>ssize_t</name> <name>len</name></expr></argument>, <argument><expr><name>ssize_t</name> <operator>*</operator><name>headerlen</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>method</name></decl>, <decl><type ref="prev"/><name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ssize_t</name></type> <name>totallen</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>GZIP_MAGIC_0</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>GZIP_MAGIC_1</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_BAD</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>method</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>method</name> <operator>!=</operator> <name>Z_DEFLATED</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>RESERVED</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>GZIP_BAD</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>EXTRA_FIELD</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>extra_len</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>extra_len</name> <operator>=</operator> <operator>(</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>(</operator><name>extra_len</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <operator>(</operator><name>extra_len</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>data</name> <operator>+=</operator> <operator>(</operator><name>extra_len</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ORIG_NAME</name></expr>)</condition> <block>{<block_content>

<while>while<condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>data</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>len</name> <operator>||</operator> <operator>*</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>data</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>COMMENT</name></expr>)</condition> <block>{<block_content>

<while>while<condition>(<expr><name>len</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>data</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>len</name> <operator>||</operator> <operator>*</operator><name>data</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>HEAD_CRC</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>GZIP_UNDERFLOW</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>headerlen</name> <operator>=</operator> <name>totallen</name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><name>GZIP_OK</name></expr>;</return>

</block_content>}</block></decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl>static <name>CURLcode</name> <name>gzip_unencode_write</name><argument_list>(<argument><expr>struct <name>connectdata</name> <operator>*</operator><name>conn</name></expr></argument>,

<argument><expr><name>contenc_writer</name> <operator>*</operator><name>writer</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>buf</name></expr></argument>, <argument><expr><name>size_t</name> <name>nbytes</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>==</operator> <name>ZLIB_INIT_GZIP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<return>return <expr><call><name>inflate_stream</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>, <argument><expr><name>ZLIB_INIT_GZIP</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>OLD_ZLIB_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_WRITE_ERROR</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<switch>switch<condition>(<expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ZLIB_INIT</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>hlen</name></decl>;</decl_stmt>

<switch>switch<condition>(<expr><call><name>check_gzip_header</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GZIP_OK</name></expr>:</case>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name> <operator>+</operator> <name>hlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <operator>(</operator><name>nbytes</name> <operator>-</operator> <name>hlen</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_GZIP_INFLATING</name></expr>;</expr_stmt> 

<break>break;</break>

<case>case <expr><name>GZIP_UNDERFLOW</name></expr>:</case>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_GZIP_HEADER</name></expr>;</expr_stmt> 

<return>return <expr><name>CURLE_OK</name></expr>;</return>

<case>case <expr><name>GZIP_BAD</name></expr>:</case>

<default>default:</default>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>ZLIB_GZIP_HEADER</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>ssize_t</name></type> <name>hlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>+=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <call><name>Curl_saferealloc</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-</operator> <name>nbytes</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><call><name>check_gzip_header</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hlen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>GZIP_OK</name></expr>:</case>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name> <operator>+</operator> <name>hlen</name> <operator>+</operator> <name>nbytes</name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>-</operator> <name>hlen</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name> <operator>=</operator> <name>ZLIB_GZIP_INFLATING</name></expr>;</expr_stmt> 

<break>break;</break>

<case>case <expr><name>GZIP_UNDERFLOW</name></expr>:</case>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

<case>case <expr><name>GZIP_BAD</name></expr>:</case>

<default>default:</default>

<return>return <expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><call><name>process_zlib_error</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>ZLIB_EXTERNAL_TRAILER</name></expr>:</case>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<return>return <expr><call><name>process_trailer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>zp</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ZLIB_GZIP_INFLATING</name></expr>:</case>

<default>default:</default>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Bytef</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name>uInt</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if<condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>inflate_stream</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>, <argument><expr><name>ZLIB_GZIP_INFLATING</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></decl>

<decl>static <name>void</name> <name>gzip_close_writer</name><argument_list>(<argument><expr>struct <name>connectdata</name> <operator>*</operator><name>conn</name></expr></argument>,

<argument><expr><name>contenc_writer</name> <operator>*</operator><name>writer</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>zlib_params</name> <modifier>*</modifier></type><name>zp</name> <init>= <expr><operator>(</operator><name>zlib_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>z_stream</name> <modifier>*</modifier></type><name>z</name> <init>= <expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>z</name></name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>exit_zlib</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>z</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zp</name><operator>-&gt;</operator><name>zlib_init</name></name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl>

<decl>static const <name>content_encoding</name> <name>gzip_encoding</name> <init>= <expr><block>{

<expr><literal type="string">"gzip"</literal></expr>,

<expr><literal type="string">"x-gzip"</literal></expr>,

<expr><name>gzip_init_writer</name></expr>,

<expr><name>gzip_unencode_write</name></expr>,

<expr><name>gzip_close_writer</name></expr>,

<expr>sizeof<operator>(</operator><name>zlib_params</name><operator>)</operator></expr>

}</block></expr></init></decl>;</enum>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROTLI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>BrotliDecoderState</name> <modifier>*</modifier></type><name>br</name></decl>;</decl_stmt> 

}</block></struct></type> <name>brotli_params</name>;</typedef>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>brotli_map_error</name><parameter_list>(<parameter><decl><type><name>BrotliDecoderErrorCode</name></type> <name>be</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch<condition>(<expr><name>be</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_CL_SPACE</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_TRANSFORM</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_DICTIONARY</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_PADDING_1</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_FORMAT_PADDING_2</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_COMPOUND_DICTIONARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BROTLI_DECODER_ERROR_COMPOUND_DICTIONARY</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET</name></expr>:</case>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>BROTLI_DECODER_ERROR_INVALID_ARGUMENTS</name></expr>:</case>

<return>return <expr><name>CURLE_BAD_CONTENT_ENCODING</name></expr>;</return>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES</name></expr>:</case>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>CURLE_WRITE_ERROR</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>brotli_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>brotli_params</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>(</operator><name>brotli_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name> <operator>=</operator> <call><name>BrotliDecoderCreateInstance</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr>?</condition><then> <expr><name>CURLE_OK</name></expr></then><else>: <expr><name>CURLE_OUT_OF_MEMORY</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>brotli_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>brotli_params</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>(</operator><name>brotli_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>decomp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uint8_t</name> <modifier>*</modifier></type><name>dst</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>dstleft</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>BrotliDecoderResult</name></type> <name>r</name> <init>= <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_WRITE_ERROR</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>decomp</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>DSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>decomp</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<while>while<condition>(<expr><operator>(</operator><name>nbytes</name> <operator>||</operator> <name>r</name> <operator>==</operator> <name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name><operator>)</operator> <operator>&amp;&amp;</operator>

<name>result</name> <operator>==</operator> <name>CURLE_OK</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dst</name> <operator>=</operator> <operator>(</operator><name>uint8_t</name> <operator>*</operator><operator>)</operator> <name>decomp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dstleft</name> <operator>=</operator> <name>DSIZ</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>BrotliDecoderDecompressStream</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dstleft</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dst</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_unencode_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr></argument>,

<argument><expr><name>decomp</name></expr></argument>, <argument><expr><name>DSIZ</name> <operator>-</operator> <name>dstleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<switch>switch<condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT</name></expr>:</case>

<case>case <expr><name>BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>BROTLI_DECODER_RESULT_SUCCESS</name></expr>:</case>

<expr_stmt><expr><call><name>BrotliDecoderDestroyInstance</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_WRITE_ERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>brotli_map_error</name><argument_list>(<argument><expr><call><name>BrotliDecoderGetErrorCode</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>decomp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>brotli_close_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>brotli_params</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>(</operator><name>brotli_params</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>writer</name><operator>-&gt;</operator><name>params</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>BrotliDecoderDestroyInstance</name><argument_list>(<argument><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>br</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name></type> <name>brotli_encoding</name> <init>= <expr><block>{

<expr><literal type="string">"br"</literal></expr>,

<expr><name>NULL</name></expr>,

<expr><name>brotli_init_writer</name></expr>,

<expr><name>brotli_unencode_write</name></expr>,

<expr><name>brotli_close_writer</name></expr>,

<expr>sizeof<operator>(</operator><name>brotli_params</name><operator>)</operator></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>identity_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>?</condition><then> <expr><name>CURLE_OK</name></expr></then><else>: <expr><name>CURLE_WRITE_ERROR</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>identity_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>Curl_unencode_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>identity_close_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name></type> <name>identity_encoding</name> <init>= <expr><block>{

<expr><literal type="string">"identity"</literal></expr>,

<expr><literal type="string">"none"</literal></expr>,

<expr><name>identity_init_writer</name></expr>,

<expr><name>identity_unencode_write</name></expr>,

<expr><name>identity_close_writer</name></expr>,

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>encodings</name><index>[]</index></name> <init>= <expr><block>{

<expr><operator>&amp;</operator><name>identity_encoding</name></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LIBZ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><operator>&amp;</operator><name>deflate_encoding</name></expr>,

<expr><operator>&amp;</operator><name>gzip_encoding</name></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROTLI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><operator>&amp;</operator><name>brotli_encoding</name></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><name>char</name> <modifier>*</modifier></type><name>Curl_all_content_encodings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>cep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier></type><name>ce</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ace</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>cep</name> <operator>=</operator> <name>encodings</name></expr>;</init> <condition><expr><operator>*</operator><name>cep</name></expr>;</condition> <incr><expr><name>cep</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <operator>*</operator><name>cep</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcasecompare</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CONTENT_ENCODING_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>len</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>CONTENT_ENCODING_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ace</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>ace</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ace</name></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>cep</name> <operator>=</operator> <name>encodings</name></expr>;</init> <condition><expr><operator>*</operator><name>cep</name></expr>;</condition> <incr><expr><name>cep</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ce</name> <operator>=</operator> <operator>*</operator><name>cep</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>strcasecompare</name><argument_list>(<argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>CONTENT_ENCODING_DEFAULT</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ace</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>client_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>?</condition><then> <expr><name>CURLE_WRITE_ERROR</name></expr></then><else>: <expr><name>CURLE_OK</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>client_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>SingleRequest</name></name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>req</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>nbytes</name> <operator>||</operator> <name><name>k</name><operator>-&gt;</operator><name>ignorebody</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>Curl_client_write</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>CLIENTWRITE_BODY</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>client_close_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name></type> <name>client_encoding</name> <init>= <expr><block>{

<expr><name>NULL</name></expr>,

<expr><name>NULL</name></expr>,

<expr><name>client_init_writer</name></expr>,

<expr><name>client_unencode_write</name></expr>,

<expr><name>client_close_writer</name></expr>,

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>error_init_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>?</condition><then> <expr><name>CURLE_OK</name></expr></then><else>: <expr><name>CURLE_WRITE_ERROR</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>error_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>all</name> <init>= <expr><call><name>Curl_all_content_encodings</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>all</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="string">"Unrecognized content encoding type. "</literal>

<literal type="string">"libcurl understands %s content encodings."</literal></expr></argument>, <argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>CURLE_BAD_CONTENT_ENCODING</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>error_close_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name></type> <name>error_encoding</name> <init>= <expr><block>{

<expr><name>NULL</name></expr>,

<expr><name>NULL</name></expr>,

<expr><name>error_init_writer</name></expr>,

<expr><name>error_unencode_write</name></expr>,

<expr><name>error_close_writer</name></expr>,

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>contenc_writer</name> <modifier>*</modifier></type><name>new_unencoding_writer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier></type><name>handler</name></decl></parameter>,

<parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>downstream</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>sz</name> <init>= <expr><call><name>offsetof</name><argument_list>(<argument><expr><name>contenc_writer</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>handler</name><operator>-&gt;</operator><name>paramsize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name> <init>= <expr><operator>(</operator><name>contenc_writer</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>writer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>writer</name><operator>-&gt;</operator><name>handler</name></name> <operator>=</operator> <name>handler</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name> <operator>=</operator> <name>downstream</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name><name>handler</name><operator>-&gt;</operator><name>init_writer</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writer</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>writer</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>nbytes</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name><name>writer</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>unencode_write</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_unencode_cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>SingleRequest</name></name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>req</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name> <init>= <expr><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name></expr></init></decl>;</decl_stmt>

<while>while<condition>(<expr><name>writer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name> <operator>=</operator> <name><name>writer</name><operator>-&gt;</operator><name>downstream</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>writer</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>close_writer</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>writer</name> <operator>=</operator> <name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier></type><name>find_encoding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>cep</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>cep</name> <operator>=</operator> <name>encodings</name></expr>;</init> <condition><expr><operator>*</operator><name>cep</name></expr>;</condition> <incr><expr><name>cep</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier></type><name>ce</name> <init>= <expr><operator>*</operator><name>cep</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><call><name>strncasecompare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ce</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>ce</name><operator>-&gt;</operator><name>alias</name></name> <operator>&amp;&amp;</operator> <call><name>strncasecompare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>ce</name><operator>-&gt;</operator><name>alias</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ce</name><operator>-&gt;</operator><name>alias</name><index>[<expr><name>len</name></expr>]</index></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>ce</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_build_unencoding_stack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enclist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maybechunked</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>SingleRequest</name></name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>req</name></name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>namelen</name></decl>;</decl_stmt>

<while>while<condition>(<expr><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>enclist</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>enclist</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>enclist</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>enclist</name></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>namelen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>enclist</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enclist</name> <operator>!=</operator> <literal type="char">','</literal></expr>;</condition> <incr><expr><name>enclist</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>ISSPACE</name><argument_list>(<argument><expr><operator>*</operator><name>enclist</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>namelen</name> <operator>=</operator> <name>enclist</name> <operator>-</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if<condition>(<expr><name>maybechunked</name> <operator>&amp;&amp;</operator> <name>namelen</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>strncasecompare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"chunked"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>Curl_httpchunk_init</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if>

<if type="elseif">else if<condition>(<expr><name>namelen</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>content_encoding</name> <modifier>*</modifier></type><name>encoding</name> <init>= <expr><call><name>find_encoding</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name> <operator>=</operator> <call><name>new_unencoding_writer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>client_encoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>encoding</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>encoding</name> <operator>=</operator> <operator>&amp;</operator><name>error_encoding</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>writer</name> <operator>=</operator> <call><name>new_unencoding_writer</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>writer</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>writer_stack</name></name> <operator>=</operator> <name>writer</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> while<condition>(<expr><operator>*</operator><name>enclist</name></expr>)</condition>;</do>

<return>return <expr><name>CURLE_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><name>CURLcode</name></type> <name>Curl_build_unencoding_stack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>enclist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maybechunked</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>enclist</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>maybechunked</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>CURLcode</name></type> <name>Curl_unencode_write</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>contenc_writer</name> <modifier>*</modifier></type><name>writer</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>writer</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>nbytes</name></expr>;</expr_stmt>

<return>return <expr><name>CURLE_NOT_BUILT_IN</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_unencode_cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>conn</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type><name>Curl_all_content_encodings</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><name>CONTENT_ENCODING_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</return> 

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
