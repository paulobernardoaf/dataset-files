<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\curl-analysis\_cppstats_featurelocations\curl\lib\multi.c">





















<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_setup.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;curl/curl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"urldata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"transfer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"url.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"progress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"easyif.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"share.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"psl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"multiif.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sendf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"timeval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"select.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"warnless.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"speedcheck.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"conncache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"multihandle.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sigpipe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vtls/vtls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http_proxy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"http2.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"socketpair.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"socks.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_printf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"curl_memory.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"memdebug.h"</cpp:file></cpp:include>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_SOCKET_HASH_TABLE_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_SOCKET_HASH_TABLE_SIZE</name></cpp:macro> <cpp:value>911</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_CONNECTION_HASH_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_CONNECTION_HASH_SIZE</name></cpp:macro> <cpp:value>97</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURL_MULTI_HANDLE</name></cpp:macro> <cpp:value>0x000bab1e</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GOOD_MULTI_HANDLE</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &amp;&amp; (x)-&gt;type == CURL_MULTI_HANDLE)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>singlesocket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>add_next_timeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>multi_timeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>timeout_ms</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_pending_handles</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>detach_connnection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier> <specifier>const</specifier></type> <name><name>statename</name><index>[]</index></name><init>=<expr><block>{
<expr><literal type="string">"INIT"</literal></expr>,
<expr><literal type="string">"CONNECT_PEND"</literal></expr>,
<expr><literal type="string">"CONNECT"</literal></expr>,
<expr><literal type="string">"WAITRESOLVE"</literal></expr>,
<expr><literal type="string">"WAITCONNECT"</literal></expr>,
<expr><literal type="string">"WAITPROXYCONNECT"</literal></expr>,
<expr><literal type="string">"SENDPROTOCONNECT"</literal></expr>,
<expr><literal type="string">"PROTOCONNECT"</literal></expr>,
<expr><literal type="string">"DO"</literal></expr>,
<expr><literal type="string">"DOING"</literal></expr>,
<expr><literal type="string">"DO_MORE"</literal></expr>,
<expr><literal type="string">"DO_DONE"</literal></expr>,
<expr><literal type="string">"PERFORM"</literal></expr>,
<expr><literal type="string">"TOOFAST"</literal></expr>,
<expr><literal type="string">"DONE"</literal></expr>,
<expr><literal type="string">"COMPLETED"</literal></expr>,
<expr><literal type="string">"MSGSENT"</literal></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<typedef>typedef <function_decl><type><name>void</name></type> (<modifier>*</modifier><name>init_multistate_func</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>void</name></type> <name>Curl_init_completed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>




<expr_stmt><expr><call><name>detach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_expire_clear</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type> <name>mstate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>CURLMstate</name></type> <name>state</name></decl></parameter>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call></expr></cpp:if>
, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMstate</name></type> <name>oldstate</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>init_multistate_func</name></type> <name><name>finit</name><index>[<expr><name>CURLM_STATE_LAST</name></expr>]</index></name> <init>= <expr><block>{
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>Curl_init_CONNECT</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>Curl_connect_free</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>NULL</name></expr>, 
<expr><name>Curl_init_completed</name></expr>, 
<expr><name>NULL</name></expr> 
}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_VERBOSE_STRINGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>lineno</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name>oldstate</name> <operator>==</operator> <name>state</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>=</operator> <name>state</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_VERBOSE_STRINGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;=</operator> <name>CURLM_STATE_CONNECT_PEND</name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>connection_id</name> <init>= <expr><operator>-</operator><literal type="number">5000</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>connection_id</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>connection_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>,
<argument><expr><literal type="string">"STATE: %s =&gt; %s handle %p; line %d (connection #%ld)\n"</literal></expr></argument>,
<argument><expr><name><name>statename</name><index>[<expr><name>oldstate</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>statename</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr>]</index></name></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>, <argument><expr><name>lineno</name></expr></argument>, <argument><expr><name>connection_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name>state</name> <operator>==</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><name><name>finit</name><index>[<expr><name>state</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>finit</name><index>[<expr><name>state</name></expr>]</index></name><operator>(</operator><name>data</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>multistate</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mstate(x,y)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>multistate</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>mstate(x,y, __LINE__)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<struct>struct <name>Curl_sh_entry</name> <block>{
<decl_stmt><decl><type><name><name>struct</name> <name>curl_hash</name></name></type> <name>transfers</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>action</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>socketp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>users</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>readers</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>writers</name></decl>;</decl_stmt> 
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_READ</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SH_WRITE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>


<function><type><specifier>static</specifier> <name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>sh_getentry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_hash</name></name> <modifier>*</modifier></type><name>sh</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>Curl_hash_pick</name><argument_list>(<argument><expr><name>sh</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>curl_socket_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRHASH_SIZE</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>size_t</name></type> <name>trhash</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>key_length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>slots_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>size_t</name></type> <name>keyval</name> <init>= <expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>*</operator><operator>(</operator>struct <name>Curl_easy</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>key_length</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>keyval</name> <operator>%</operator> <name>slots_num</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>trhash_compare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>k1_len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>k2_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>k1_len</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>k2_len</name></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><operator>(</operator>struct <name>Curl_easy</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>k1</name> <operator>==</operator> <operator>*</operator><operator>(</operator>struct <name>Curl_easy</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>k2</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>trhash_dtor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>nada</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>nada</name></expr>;</expr_stmt>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>sh_addentry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_hash</name></name> <modifier>*</modifier></type><name>sh</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>there</name> <init>= <expr><call><name>sh_getentry</name><argument_list>(<argument><expr><name>sh</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>there</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>there</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Curl_sh_entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>check</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if<condition>(<expr><call><name>Curl_hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>check</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>, <argument><expr><name>TRHASH_SIZE</name></expr></argument>, <argument><expr><name>trhash</name></expr></argument>,
<argument><expr><name>trhash_compare</name></expr></argument>, <argument><expr><name>trhash_dtor</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>Curl_hash_add</name><argument_list>(<argument><expr><name>sh</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>curl_socket_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>check</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return> 
</block_content>}</block></if></if_stmt>

<return>return <expr><name>check</name></expr>;</return> 
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>sh_delentry</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curl_hash</name></name> <modifier>*</modifier></type><name>sh</name></decl></parameter>, <parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>Curl_hash_delete</name><argument_list>(<argument><expr><name>sh</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>curl_socket_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type> <name>sh_freeentry</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>freethis</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator>struct <name>Curl_sh_entry</name> <operator>*</operator><operator>)</operator> <name>freethis</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>fd_key_compare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>k1</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>k1_len</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>k2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>k2_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>k1_len</name></expr>;</expr_stmt> <expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>k2_len</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>curl_socket_t</name> <operator>*</operator><operator>)</operator> <name>k1</name><operator>)</operator><operator>)</operator> <operator>==</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>(</operator><name>curl_socket_t</name> <operator>*</operator><operator>)</operator> <name>k2</name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>hash_fd</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>key_length</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>slots_num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>fd</name> <init>= <expr><operator>*</operator><operator>(</operator><operator>(</operator><name>curl_socket_t</name> <operator>*</operator><operator>)</operator> <name>key</name><operator>)</operator></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>key_length</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>fd</name> <operator>%</operator> <name>slots_num</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>



















<function><type><specifier>static</specifier> <name>int</name></type> <name>sh_init</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curl_hash</name></name> <modifier>*</modifier></type><name>hash</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Curl_hash_init</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>hashsize</name></expr></argument>, <argument><expr><name>hash_fd</name></expr></argument>, <argument><expr><name>fd_key_compare</name></expr></argument>,
<argument><expr><name>sh_freeentry</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>multi_addmsg</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_message</name></name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>Curl_llist_insert_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>msglist</name><operator>.</operator><name>tail</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>msg</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>Curl_multi_handle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>hashsize</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>chashsize</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name> <init>= <expr><call><name>calloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Curl_multi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>multi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>CURL_MULTI_HANDLE</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>Curl_mk_dnscache</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>hostcache</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>sh_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>hashsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>Curl_conncache_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>conn_cache</name></name></expr></argument>, <argument><expr><name>chashsize</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>error</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_llist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>multiplexing</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>maxconnects</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>max_concurrent_streams</name></name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>ipv6_works</name></name> <operator>=</operator> <call><name>Curl_ipv6works</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><call><name>Curl_socketpair</name><argument_list>(<argument><expr><name>AF_UNIX</name></expr></argument>, <argument><expr><name>SOCK_STREAM</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CURL_SOCKET_BAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CURL_SOCKET_BAD</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><call><name>curlx_nonblock</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
<call><name>curlx_nonblock</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>sclose</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sclose</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>CURL_SOCKET_BAD</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>CURL_SOCKET_BAD</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>multi</name></expr>;</return>

<label><name>error</name>:</label>

<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>hostcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_conncache_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>conn_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>curl_multi_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Curl_multi_handle</name><argument_list>(<argument><expr><name>CURL_SOCKET_HASH_TABLE_SIZE</name></expr></argument>,
<argument><expr><name>CURL_CONNECTION_HASH_SIZE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_add_handle</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_EASY_HANDLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_EASY_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_ADDED_ALREADY</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>Curl_llist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>







<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>errorbuffer</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>errorbuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcache</name></name> <operator>||</operator>
<operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>==</operator> <name>HCACHE_NONE</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcache</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>hostcache</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>=</operator> <name>HCACHE_MULTI</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>share</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>share</name><operator>-&gt;</operator><name>specifier</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal><operator>&lt;&lt;</operator> <name>CURL_LOCK_DATA_CONNECT</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>share</name><operator>-&gt;</operator><name>conn_cache</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>conn_cache</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPSL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>share</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>share</name><operator>-&gt;</operator><name>specifier</name></name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CURL_LOCK_DATA_PSL</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>share</name><operator>-&gt;</operator><name>psl</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>psl</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>last</name> <init>= <expr><name><name>multi</name><operator>-&gt;</operator><name>easylp</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>last</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>easylp</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>easylp</name></name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name> <operator>=</operator> <name>multi</name></expr>;</expr_stmt>







<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPIRE_RUN_NOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>num_easy</name></name><operator>++</operator></expr>;</expr_stmt>


<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name><operator>++</operator></expr>;</expr_stmt>











<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name><operator>-&gt;</operator><name>closure_handle</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>timeout</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>timeout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name><operator>-&gt;</operator><name>closure_handle</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>server_response_timeout</name></name> <operator>=</operator>
<name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>server_response_timeout</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name><operator>-&gt;</operator><name>closure_handle</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>no_signal</name></name> <operator>=</operator>
<name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>no_signal</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>






static void debug_print_sock_hash(void *p)
{
struct Curl_sh_entry *sh = (struct Curl_sh_entry *)p;

fprintf(stderr, " [easy %p/magic %x/socket %d]",
(void *)sh-&gt;data, sh-&gt;data-&gt;magic, (int)sh-&gt;socket);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>multi_done</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>CURLcode</name></type> <name>status</name></decl></parameter>, 

<parameter><decl><type><name>bool</name></type> <name>premature</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGF</name><argument_list>(<argument><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"multi_done\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>Curl_resolver_kill</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>newurl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>location</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>status</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CURLE_ABORTED_BY_CALLBACK</name></expr>:</case>
<case>case <expr><name>CURLE_READ_ERROR</name></expr>:</case>
<case>case <expr><name>CURLE_WRITE_ERROR</name></expr>:</case>




<expr_stmt><expr><name>premature</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<default>default:</default>
<break>break;</break>
</block_content>}</block></switch>


<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>done</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>done</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>status</name></expr></argument>, <argument><expr><name>premature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>status</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><name>CURLE_ABORTED_BY_CALLBACK</name> <operator>!=</operator> <name>result</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name>CURLcode</name></type> <name>rc</name> <init>= <expr><call><name>Curl_pgrsDone</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <name>rc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_ABORTED_BY_CALLBACK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>CONN_LOCK</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>detach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>CONN_INUSE</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>easyq</name><operator>.</operator><name>head</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONN_UNLOCK</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGF</name><argument_list>(<argument><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Connection still in use %zu, "</literal>
<literal type="string">"no more multi_done now!\n"</literal></expr></argument>,
<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>easyq</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLE_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>done</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>dns_entry</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_resolv_unlock</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>dns_entry</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>dns_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>Curl_hostcache_prune</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_safefree</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>ulbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>tempcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>tempwrite</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>tempcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
















<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>reuse_forbid</name></name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_NTLM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>http_ntlm_state</name></name> <operator>==</operator> <name>NTLMSTATE_TYPE2</name> <operator>||</operator>
<name><name>conn</name><operator>-&gt;</operator><name>proxy_ntlm_state</name></name> <operator>==</operator> <name>NTLMSTATE_TYPE2</name><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SPNEGO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>http_negotiate_state</name></name> <operator>==</operator> <name>GSS_AUTHRECV</name> <operator>||</operator>
<name><name>conn</name><operator>-&gt;</operator><name>proxy_negotiate_state</name></name> <operator>==</operator> <name>GSS_AUTHRECV</name><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<operator>)</operator> <operator>||</operator> <name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>close</name></name>
<operator>||</operator> <operator>(</operator><name>premature</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTOPT_STREAM</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>res2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>connclose</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><literal type="string">"disconnecting"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>CONN_UNLOCK</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res2</name> <operator>=</operator> <call><name>Curl_disconnect</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>premature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <name>res2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>msnprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><literal type="string">"Connection #%ld to host %s left intact"</literal></expr></argument>,
<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>connection_id</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>socksproxy</name></name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>socks_proxy</name><operator>.</operator><name>host</name><operator>.</operator><name>dispname</name></name></expr> </then><else>:
<expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>httpproxy</name></name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>http_proxy</name><operator>.</operator><name>host</name><operator>.</operator><name>dispname</name></name></expr> </then><else>:
<expr><ternary><condition><expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>conn_to_host</name></name></expr> ?</condition><then> <expr><name><name>conn</name><operator>-&gt;</operator><name>conn_to_host</name><operator>.</operator><name>dispname</name></name></expr> </then><else>:
<expr><name><name>conn</name><operator>-&gt;</operator><name>host</name><operator>.</operator><name>dispname</name></name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CONN_UNLOCK</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><call><name>Curl_conncache_return_conn</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>lastconnect</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>lastconnect</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>Curl_free_request_state</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_remove_handle</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>easy</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>premature</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>easy_owns_conn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_EASY_HANDLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_EASY_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_OK</name></expr>;</return></block_content></block></if></if_stmt> 


<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name> <operator>!=</operator> <name>multi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_EASY_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>premature</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name><operator>)</operator></expr> ?</condition><then> <expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>easy_owns_conn</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>easy</name><operator>)</operator><operator>)</operator></expr> ?</condition><then>
<expr><name>TRUE</name></expr> </then><else>: <expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><name>premature</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;</operator> <name>CURLM_STATE_DO</name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>easy</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamclose</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"Removed with partial response"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>easy_owns_conn</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition> <block>{<block_content>



<if_stmt><if>if<condition>(<expr><name>easy_owns_conn</name></expr>)</condition> <block>{<block_content>






<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name></expr></argument>, <argument><expr><name>premature</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><call><name>Curl_expire_clear</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>connect_queue</name><operator>.</operator><name>ptr</name></name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>connect_queue</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>==</operator> <name>HCACHE_MULTI</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>=</operator> <name>HCACHE_NONE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_wildcard_dtor</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>wildcard</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>Curl_llist_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>=</operator> <name>CURLM_STATE_COMPLETED</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>singlesocket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>easy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 



<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>detach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPSL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>psl</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 




<for>for<control>(<init><expr><name>e</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>msglist</name><operator>.</operator><name>head</name></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_message</name></name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>msg</name><operator>-&gt;</operator><name>extmsg</name><operator>.</operator><name>easy_handle</name></name> <operator>==</operator> <name>easy</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>prev</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> 


<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>easylp</name></name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> 



<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>num_easy</name></name><operator>--</operator></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>bool</name></type> <name>Curl_multiplex_wanted</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>multi</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>multi</name><operator>-&gt;</operator><name>multiplexing</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>void</name></type> <name>detach_connnection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>conn</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>easyq</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>conn_queue</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>Curl_attach_connnection</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>conn</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_insert_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conn</name><operator>-&gt;</operator><name>easyq</name></name></expr></argument>, <argument><expr><name><name>conn</name><operator>-&gt;</operator><name>easyq</name><operator>.</operator><name>tail</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>conn_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>waitconnect_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>sock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_SSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><call><name>CONNECT_FIRSTSOCKET_PROXY_SSL</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Curl_ssl_getsock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><call><name>SOCKS_STATE</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>cnnct</name><operator>.</operator><name>state</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>Curl_SOCKS_getsock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>sock</name></expr></argument>, <argument><expr><name>FIRSTSOCKET</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><literal type="number">2</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>tempsock</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>sock</name><index>[<expr><name>s</name></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>tempsock</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_QUIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>transport</name></name> <operator>==</operator> <name>TRNSPRT_QUIC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>rc</name> <operator>|=</operator> <call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>waitproxyconnect_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>sock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>sock</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>sock</name><index>[<expr><name>FIRSTSOCKET</name></expr>]</index></name></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>connect_state</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>domore_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>socks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>domore_getsock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>domore_getsock</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>GETSOCK_BLANK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>doing_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>socks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>doing_getsock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>doing_getsock</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>GETSOCK_BLANK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>protocol_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>socks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>proto_getsock</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>proto_getsock</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name><name>socks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>sock</name><index>[<expr><name>FIRSTSOCKET</name></expr>]</index></name></expr>;</expr_stmt>
<return>return <expr><call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<function><type><specifier>static</specifier> <name>int</name></type> <name>multi_getsock</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name> <modifier>*</modifier></type><name>socks</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;</operator> <name>CURLM_STATE_CONNECT</name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr>)</condition> <block>{<block_content>
<default>default:</default>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

case CURLM_STATE_TOOFAST: 
case CURLM_STATE_COMPLETED:
case CURLM_STATE_MSGSENT:
case CURLM_STATE_INIT:
case CURLM_STATE_CONNECT:
case CURLM_STATE_WAITDO:
case CURLM_STATE_DONE:
case CURLM_STATE_LAST:


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><literal type="number">0</literal></expr>;</return>

<case>case <expr><name>CURLM_STATE_WAITRESOLVE</name></expr>:</case>
<return>return <expr><call><name>Curl_resolv_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_PROTOCONNECT</name></expr>:</case>
<case>case <expr><name>CURLM_STATE_SENDPROTOCONNECT</name></expr>:</case>
<return>return <expr><call><name>protocol_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_DO</name></expr>:</case>
<case>case <expr><name>CURLM_STATE_DOING</name></expr>:</case>
<return>return <expr><call><name>doing_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr>:</case>
<return>return <expr><call><name>waitproxyconnect_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_WAITCONNECT</name></expr>:</case>
<return>return <expr><call><name>waitconnect_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_DO_MORE</name></expr>:</case>
<return>return <expr><call><name>domore_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CURLM_STATE_DO_DONE</name></expr>:</case> 


<case>case <expr><name>CURLM_STATE_PERFORM</name></expr>:</case>
<return>return <expr><call><name>Curl_single_getsock</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_fdset</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>read_fd_set</name></decl></parameter>, <parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>write_fd_set</name></decl></parameter>,
<parameter><decl><type><name>fd_set</name> <modifier>*</modifier></type><name>exc_fd_set</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>max_fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>



<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>this_max_fd</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name><name>sockbunch</name><index>[<expr><name>MAX_SOCKSPEREASYHANDLE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><name>exc_fd_set</name></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>bitmap</name> <init>= <expr><call><name>multi_getsock</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sockbunch</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name>MAX_SOCKSPEREASYHANDLE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>s</name> <init>= <expr><name>CURL_SOCKET_BAD</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>(</operator><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>VALID_SOCK</name><argument_list>(<argument><expr><operator>(</operator><name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>read_fd_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>VALID_SOCK</name><argument_list>(<argument><expr><operator>(</operator><name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>write_fd_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>s</name> <operator>&gt;</operator> <name>this_max_fd</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>this_max_fd</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>max_fd</name> <operator>=</operator> <name>this_max_fd</name></expr>;</expr_stmt>

<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_POLLS_ON_STACK</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>Curl_multi_wait</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curl_waitfd</name></name></type> <name><name>extra_fds</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_nfds</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>timeout_ms</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>extrawait</name></decl></parameter>, 
<parameter><decl><type><name>bool</name></type> <name>use_wakeup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name><name>sockbunch</name><index>[<expr><name>MAX_SOCKSPEREASYHANDLE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bitmap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nfds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>curlfds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>ufds_malloc</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>timeout_internal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retcode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name></type> <name><name>a_few_on_stack</name><index>[<expr><name>NUM_POLLS_ON_STACK</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>pollfd</name></name> <modifier>*</modifier></type><name>ufds</name> <init>= <expr><operator>&amp;</operator><name><name>a_few_on_stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>timeout_ms</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_FUNCTION_ARGUMENT</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>multi_getsock</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sockbunch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name>MAX_SOCKSPEREASYHANDLE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>s</name> <init>= <expr><name>CURL_SOCKET_BAD</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 
</block_content>}</block></while>




<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multi_timeout</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name>timeout_internal</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>timeout_internal</name> <operator>&lt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>timeout_ms</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>timeout_internal</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>curlfds</name> <operator>=</operator> <name>nfds</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>nfds</name> <operator>+=</operator> <name>extra_nfds</name></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name>use_wakeup</name> <operator>&amp;&amp;</operator> <name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name>nfds</name> <operator>&gt;</operator> <name>NUM_POLLS_ON_STACK</name></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>ufds</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>nfds</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>pollfd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ufds</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>ufds_malloc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>nfds</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<if_stmt><if>if<condition>(<expr><name>curlfds</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>bitmap</name> <operator>=</operator> <call><name>multi_getsock</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>sockbunch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name>MAX_SOCKSPEREASYHANDLE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>s</name> <init>= <expr><name>CURL_SOCKET_BAD</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>bitmap</name> <operator>&amp;</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLOUT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>sockbunch</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>


<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>extra_nfds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>extra_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>fd</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>extra_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>&amp;</operator> <name>CURL_WAIT_POLLIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>extra_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>&amp;</operator> <name>CURL_WAIT_POLLPRI</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLPRI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>extra_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>&amp;</operator> <name>CURL_WAIT_POLLOUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>|=</operator> <name>POLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name>use_wakeup</name> <operator>&amp;&amp;</operator> <name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>fd</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ufds</name><index>[<expr><name>nfds</name></expr>]</index></name><operator>.</operator><name>events</name> <operator>=</operator> <name>POLLIN</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>nfds</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if<condition>(<expr><name>nfds</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>pollrc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>pollrc</name> <operator>=</operator> <call><name>Curl_poll</name><argument_list>(<argument><expr><name>ufds</name></expr></argument>, <argument><expr><name>nfds</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>pollrc</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>retcode</name> <operator>=</operator> <name>pollrc</name></expr>;</expr_stmt>



<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>extra_nfds</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>r</name> <init>= <expr><name><name>ufds</name><index>[<expr><name>curlfds</name> <operator>+</operator> <name>i</name></expr>]</index></name><operator>.</operator><name>revents</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>r</name> <operator>&amp;</operator> <name>POLLIN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>CURL_WAIT_POLLIN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>r</name> <operator>&amp;</operator> <name>POLLOUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>CURL_WAIT_POLLOUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>r</name> <operator>&amp;</operator> <name>POLLPRI</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>mask</name> <operator>|=</operator> <name>CURL_WAIT_POLLPRI</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>extra_fds</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>=</operator> <name>mask</name></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name>use_wakeup</name> <operator>&amp;&amp;</operator> <name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>ufds</name><index>[<expr><name>curlfds</name> <operator>+</operator> <name>extra_nfds</name></expr>]</index></name><operator>.</operator><name>revents</name> <operator>&amp;</operator> <name>POLLIN</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssize_t</name></type> <name>nread</name></decl>;</decl_stmt>
<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>




<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>sread</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>nread</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_WINSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name>nread</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>EINTR</name> <operator>==</operator> <name>SOCKERRNO</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><name>retcode</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>ufds_malloc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>ufds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <name>retcode</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>extrawait</name> <operator>||</operator> <name>nfds</name></expr>)</condition><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>sleep_ms</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>curl_multi_timeout</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sleep_ms</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>sleep_ms</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>sleep_ms</name> <operator>&gt;</operator> <name>timeout_ms</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sleep_ms</name> <operator>=</operator> <name>timeout_ms</name></expr>;</expr_stmt></block_content></block></if>


<if type="elseif">else if<condition>(<expr><operator>(</operator><name>sleep_ms</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>extrawait</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sleep_ms</name> <operator>=</operator> <name>timeout_ms</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>Curl_wait_ms</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>sleep_ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_wait</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curl_waitfd</name></name></type> <name><name>extra_fds</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_nfds</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>timeout_ms</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Curl_multi_wait</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>extra_fds</name></expr></argument>, <argument><expr><name>extra_nfds</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_poll</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curl_waitfd</name></name></type> <name><name>extra_fds</name><index>[]</index></name></decl></parameter>,
<parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>extra_nfds</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>timeout_ms</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>Curl_multi_wait</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>extra_fds</name></expr></argument>, <argument><expr><name>extra_nfds</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_wakeup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>





<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>



<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while<condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>









<if_stmt><if>if<condition>(<expr><call><name>swrite</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>SOCKERRNO</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>return_success</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_WINSOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>return_success</name> <operator>=</operator> <name>WSAEWOULDBLOCK</name> <operator>==</operator> <name>err</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if_stmt><if>if<condition>(<expr><name>EINTR</name> <operator>==</operator> <name>err</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>return_success</name> <operator>=</operator> <name>EWOULDBLOCK</name> <operator>==</operator> <name>err</name> <operator>||</operator> <name>EAGAIN</name> <operator>==</operator> <name>err</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>return_success</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_WAKEUP_FAILURE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>CURLM_WAKEUP_FAILURE</name></expr>;</return>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>bool</name></type> <name>multi_ischanged</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>clear</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name><name>multi</name><operator>-&gt;</operator><name>recheckstate</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>clear</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>recheckstate</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>Curl_multi_add_perform</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>rc</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>curl_multi_add_handle</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>rc</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>SingleRequest</name></name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>req</name></name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><call><name>Curl_init_do</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_PERFORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_attach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>k</name><operator>-&gt;</operator><name>keepon</name></name> <operator>|=</operator> <name>KEEP_RECV</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type> <name>do_complete</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>chunk</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_pgrsTime</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>TIMER_PRETRANSFER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>multi_do</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>do_it</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>do_it</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>done</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_complete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>multi_do_more</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>complete</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>complete</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>do_more</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>do_more</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>complete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>complete</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_complete</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>protocol_connecting</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>connecting</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>connecting</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>protocol_doing</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>conn</name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>doing</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>doing</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>CURLcode</name></type> <name>protocol_connect</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>protocol_done</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>protocol_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>protocol_done</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>tcpconnect</name><index>[<expr><name>FIRSTSOCKET</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>protoconnstart</name></name></expr>)</condition> <block>{<block_content>






<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>connecting</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>protocol_done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>CURLE_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>protoconnstart</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_proxy_connect</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>FIRSTSOCKET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>CONNECT_FIRSTSOCKET_PROXY_SSL</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>tunnel_proxy</name></name> <operator>&amp;&amp;</operator> <name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>httpproxy</name></name> <operator>&amp;&amp;</operator>
<call><name>Curl_connect_ongoing</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>


<return>return <expr><name>CURLE_OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>connect_it</name></name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>connect_it</name></name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>protocol_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>protocol_done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>protoconnstart</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>result</name></expr>;</return> 
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>multi_runsingle</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_message</name></name> <modifier>*</modifier></type><name>msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>connected</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>async</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>protocol_connected</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>dophase_done</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>result</name> <init>= <expr><name>CURLE_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timediff_t</name></type> <name>timeout_ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timediff_t</name></type> <name>recv_timeout_ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timediff_t</name></type> <name>send_timeout_ms</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>control</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_EASY_HANDLE</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_EASY_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<do>do <block>{<block_content>


<decl_stmt><decl><type><name>bool</name></type> <name>stream_error</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_OK</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;=</operator> <name>CURLM_STATE_CONNECT</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;=</operator> <name>CURLM_STATE_DONE</name><operator>)</operator> <operator>||</operator>
<name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;</operator> <name>CURLM_STATE_CONNECT</name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_DONE</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"In state %d with no conn, bail out!\n"</literal></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLM_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><call><name>multi_ischanged</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUGF</name><argument_list>(<argument><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"multi changed, check CONNECT_PEND queue!\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;</operator> <name>CURLM_STATE_CONNECT</name> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;=</operator> <name>CURLM_STATE_CONNECT</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name><operator>)</operator></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>timeout_ms</name> <operator>=</operator> <call><name>Curl_timeleft</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>now</name></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;=</operator> <name>CURLM_STATE_DO</name><operator>)</operator></expr>?</condition><then>
<expr><name>TRUE</name></expr></then><else>:<expr><name>FALSE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>timeout_ms</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>==</operator> <name>CURLM_STATE_WAITRESOLVE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Resolving timed out after %"</literal> <name>CURL_FORMAT_TIMEDIFF_T</name>
<literal type="string">" milliseconds"</literal></expr></argument>,
<argument><expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>t_startsingle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>==</operator> <name>CURLM_STATE_WAITCONNECT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Connection timed out after %"</literal> <name>CURL_FORMAT_TIMEDIFF_T</name>
<literal type="string">" milliseconds"</literal></expr></argument>,
<argument><expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>t_startsingle</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>SingleRequest</name></name> <modifier>*</modifier></type><name>k</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>req</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>k</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Operation timed out after %"</literal> <name>CURL_FORMAT_TIMEDIFF_T</name>
<literal type="string">" milliseconds with %"</literal> <name>CURL_FORMAT_CURL_OFF_T</name> <literal type="string">" out of %"</literal>
<name>CURL_FORMAT_CURL_OFF_T</name> <literal type="string">" bytes received"</literal></expr></argument>,
<argument><expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>t_startsingle</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>k</name><operator>-&gt;</operator><name>bytecount</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>
<expr_stmt><expr><call><name>failf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Operation timed out after %"</literal> <name>CURL_FORMAT_TIMEDIFF_T</name>
<literal type="string">" milliseconds with %"</literal> <name>CURL_FORMAT_CURL_OFF_T</name>
<literal type="string">" bytes received"</literal></expr></argument>,
<argument><expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>t_startsingle</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>k</name><operator>-&gt;</operator><name>bytecount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&gt;</operator> <name>CURLM_STATE_DO</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>streamclose</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"Disconnected with pending data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OPERATION_TIMEDOUT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>statemachine_end</name>;</goto>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<switch>switch<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CURLM_STATE_INIT</name></expr>:</case>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_pretransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_pgrsTime</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>TIMER_STARTOP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_CONNECT_PEND</name></expr>:</case>


<break>break;</break>

<case>case <expr><name>CURLM_STATE_CONNECT</name></expr>:</case>

<expr_stmt><expr><call><name>Curl_pgrsTime</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>TIMER_STARTSINGLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>timeout</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>timeout</name></name></expr></argument>, <argument><expr><name>EXPIRE_TIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>connecttimeout</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>connecttimeout</name></name></expr></argument>, <argument><expr><name>EXPIRE_CONNECTTIMEOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_connect</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>async</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>protocol_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>CURLE_NO_CONNECTION_AVAILABLE</name> <operator>==</operator> <name>result</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT_PEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_llist_insert_next</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>tail</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>connect_queue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>previouslypending</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Transfer was pending, now try another\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>async</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITRESOLVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>



<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>protocol_connected</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><call><name>Curl_connect_ongoing</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_WAITRESOLVE</name></expr>:</case>

<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_dns_entry</name></name> <modifier>*</modifier></type><name>dns</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hostname</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>httpproxy</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>http_proxy</name><operator>.</operator><name>host</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>conn_to_host</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>conn_to_host</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>hostname</name> <operator>=</operator> <name><name>conn</name><operator>-&gt;</operator><name>host</name><operator>.</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>dns</name> <operator>=</operator> <call><name>Curl_fetch_addr</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name><name>conn</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>dns</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURLRES_ASYNCH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>async</name><operator>.</operator><name>dns</name></name> <operator>=</operator> <name>dns</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>async</name><operator>.</operator><name>done</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Hostname '%s' was found in DNS cache\n"</literal></expr></argument>, <argument><expr><name>hostname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>dns</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_resolv_check</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>







<expr_stmt><expr><call><name>singlesocket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>dns</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_once_resolved</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>protocol_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if> 
<else>else <block>{<block_content>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>protocol_connected</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><call><name>Curl_connect_ongoing</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block>
<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr>:</case>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_http_connect</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>protocol_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>proxy_connect_closed</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>http_proxy</name><operator>.</operator><name>proxytype</name></name> <operator>!=</operator> <name>CURLPROXY_HTTPS</name> <operator>||</operator>
<name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>proxy_ssl_connected</name><index>[<expr><name>FIRSTSOCKET</name></expr>]</index></name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>Curl_connect_complete</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_SENDPROTOCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CURLM_STATE_WAITCONNECT</name></expr>:</case>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_is_connected</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>FIRSTSOCKET</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>connected</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_HTTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>http_proxy</name><operator>.</operator><name>proxytype</name></name> <operator>==</operator> <name>CURLPROXY_HTTPS</name> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>proxy_ssl_connected</name><index>[<expr><name>FIRSTSOCKET</name></expr>]</index></name><operator>)</operator> <operator>||</operator>
<call><name>Curl_connect_ongoing</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>tunnel_proxy</name></name></expr>?</condition><then>
<expr><name>CURLM_STATE_WAITPROXYCONNECT</name></expr></then><else>:
<expr><name>CURLM_STATE_SENDPROTOCONNECT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_SENDPROTOCONNECT</name></expr>:</case>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocol_connect</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>protocol_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>protocol_connected</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_PROTOCONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_PROTOCONNECT</name></expr>:</case>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocol_connecting</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>protocol_connected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name> <operator>&amp;&amp;</operator> <name>protocol_connected</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_DO</name></expr>:</case>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>connect_only</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>connkeep</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"CONNECT_ONLY"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_do</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dophase_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>dophase_done</name></expr>)</condition> <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_FTP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>wildcardmatch</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>WildcardData</name></name> <modifier>*</modifier></type><name>wc</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>wildcard</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CURLWC_DONE</name> <operator>||</operator> <name><name>wc</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>CURLWC_SKIP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DOING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_OK</name></expr>;</expr_stmt>
</block_content>}</block></if>


<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>do_more</name></name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO_MORE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_OK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DO_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>CURLE_SEND_ERROR</name> <operator>==</operator> <name>result</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>reuse</name></name></expr>)</condition> <block>{<block_content>





<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newurl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>followtype</name></type> <name>follow</name> <init>= <expr><name>FOLLOW_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>drc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>drc</name> <operator>=</operator> <call><name>Curl_retry_request</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>drc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>drc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>drc</name> <operator>=</operator> <call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><name>newurl</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>drc</name> <operator>||</operator> <operator>(</operator><name>drc</name> <operator>==</operator> <name>CURLE_SEND_ERROR</name><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>follow</name> <operator>=</operator> <name>FOLLOW_RETRY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>drc</name> <operator>=</operator> <call><name>Curl_follow</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>newurl</name></expr></argument>, <argument><expr><name>follow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>drc</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>drc</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>drc</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_DOING</name></expr>:</case>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>protocol_doing</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dophase_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>dophase_done</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>do_more</name></name></expr>?</condition><then>
<expr><name>CURLM_STATE_DO_MORE</name></expr></then><else>:
<expr><name>CURLM_STATE_DO_DONE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt> 
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_DO_MORE</name></expr>:</case>



<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_do_more</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>control</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>control</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><ternary><condition><expr><name>control</name> <operator>==</operator> <literal type="number">1</literal></expr>?</condition><then>
<expr><name>CURLM_STATE_DO_DONE</name></expr></then><else>:
<expr><name>CURLM_STATE_DOING</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_DO_DONE</name></expr>:</case>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>multiplex</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 



<if_stmt><if>if<condition>(<expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>sockfd</name></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>writesockfd</name></name> <operator>!=</operator> <name>CURL_SOCKET_BAD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_PERFORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else <block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_FTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>wildcardmatch</name></name> <operator>&amp;&amp;</operator>
<operator>(</operator><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTOPT_WILDCARD</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>wildcard</name><operator>.</operator><name>state</name></name> <operator>=</operator> <name>CURLWC_DONE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_TOOFAST</name></expr>:</case> 
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>Curl_pgrsUpdate</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_ABORTED_BY_CALLBACK</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_speedcheck</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>send_timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_send_speed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>send_timeout_ms</name> <operator>=</operator>
<call><name>Curl_pgrsLimitWaitTime</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>uploaded</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>ul_limit_size</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_send_speed</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>ul_limit_start</name></name></expr></argument>,
<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>recv_timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_recv_speed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>recv_timeout_ms</name> <operator>=</operator>
<call><name>Curl_pgrsLimitWaitTime</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>downloaded</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>dl_limit_size</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_recv_speed</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>dl_limit_start</name></name></expr></argument>,
<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>send_timeout_ms</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>recv_timeout_ms</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_PERFORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_ratelimit</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>send_timeout_ms</name> <operator>&gt;=</operator> <name>recv_timeout_ms</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>send_timeout_ms</name></expr></argument>, <argument><expr><name>EXPIRE_TOOFAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>recv_timeout_ms</name></expr></argument>, <argument><expr><name>EXPIRE_TOOFAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_PERFORM</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newurl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>retry</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>comeback</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name>send_timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_send_speed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>send_timeout_ms</name> <operator>=</operator> <call><name>Curl_pgrsLimitWaitTime</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>uploaded</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>ul_limit_size</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_send_speed</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>ul_limit_start</name></name></expr></argument>,
<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>recv_timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_recv_speed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>recv_timeout_ms</name> <operator>=</operator> <call><name>Curl_pgrsLimitWaitTime</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>downloaded</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>dl_limit_size</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>max_recv_speed</name></name></expr></argument>,
<argument><expr><name><name>data</name><operator>-&gt;</operator><name>progress</name><operator>.</operator><name>dl_limit_start</name></name></expr></argument>,
<argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>send_timeout_ms</name> <operator>||</operator> <name>recv_timeout_ms</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_ratelimit</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_TOOFAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>send_timeout_ms</name> <operator>&gt;=</operator> <name>recv_timeout_ms</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>send_timeout_ms</name></expr></argument>, <argument><expr><name>EXPIRE_TOOFAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>recv_timeout_ms</name></expr></argument>, <argument><expr><name>EXPIRE_TOOFAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_readwrite</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>done</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>comeback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>done</name> <operator>||</operator> <operator>(</operator><name>result</name> <operator>==</operator> <name>CURLE_RECV_ERROR</name><operator>)</operator></expr>)</condition> <block>{<block_content>




<decl_stmt><decl><type><name>CURLcode</name></type> <name>ret</name> <init>= <expr><call><name>Curl_retry_request</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newurl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retry</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newurl</name><operator>)</operator></expr>?</condition><then><expr><name>TRUE</name></expr></then><else>:<expr><name>FALSE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>retry</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>(</operator><name>CURLE_HTTP2_STREAM</name> <operator>==</operator> <name>result</name><operator>)</operator> <operator>&amp;&amp;</operator>
<call><name>Curl_h2_http_1_1_error</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>ret</name> <init>= <expr><call><name>Curl_retry_request</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newurl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Downgrades to HTTP/1.1!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>httpversion</name></name> <operator>=</operator> <name>CURL_HTTP_VERSION_1_1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>errorbuf</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>newurl</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newurl</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>change</name><operator>.</operator><name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>retry</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_OK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>








<if_stmt><if>if<condition>(<expr><operator>!</operator><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTOPT_DUAL</name><operator>)</operator> <operator>&amp;&amp;</operator>
<name>result</name> <operator>!=</operator> <name>CURLE_HTTP2_STREAM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>streamclose</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"Transfer returned error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>done</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>followtype</name></type> <name>follow</name> <init>= <expr><name>FOLLOW_NONE</name></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>newurl</name></name> <operator>||</operator> <name>retry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>retry</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newurl</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>newurl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>newurl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>follow</name> <operator>=</operator> <name>FOLLOW_REDIR</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>follow</name> <operator>=</operator> <name>FOLLOW_RETRY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_follow</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>newurl</name></expr></argument>, <argument><expr><name>follow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>




<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>location</name></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newurl</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>location</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>req</name><operator>.</operator><name>location</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Curl_follow</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>newurl</name></expr></argument>, <argument><expr><name>FOLLOW_FAKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newurl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>stream_error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name>comeback</name></expr>)</condition> <block>{<block_content>



<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPIRE_RUN_NOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_OK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block>

<case>case <expr><name>CURLM_STATE_DONE</name></expr>:</case>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CURLcode</name></type> <name>res</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>bits</name><operator>.</operator><name>multiplex</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 


<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <name>res</name></expr>;</expr_stmt></block_content></block></if></if_stmt>







<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>detach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CURL_DISABLE_FTP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>wildcardmatch</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>wildcard</name><operator>.</operator><name>state</name></name> <operator>!=</operator> <name>CURLWC_DONE</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_INIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_COMPLETED</name></expr>:</case>
<break>break;</break>

<case>case <expr><name>CURLM_STATE_MSGSENT</name></expr>:</case>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return> 

<default>default:</default>
<return>return <expr><name>CURLM_INTERNAL_ERROR</name></expr>;</return>
</block_content>}</block></switch>
<label><name>statemachine_end</name>:</label>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition> <block>{<block_content>









<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>stream_error</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>dead_connection</name> <init>= <expr><name>result</name> <operator>==</operator> <name>CURLE_OPERATION_TIMEDOUT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><call><name>detach_connnection</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_disconnect</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>dead_connection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>==</operator> <name>CURLM_STATE_CONNECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>Curl_posttransfer</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_COMPLETED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator> <call><name>Curl_pgrsUpdate</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>result</name> <operator>=</operator> <name>CURLE_ABORTED_BY_CALLBACK</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>streamclose</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>, <argument><expr><literal type="string">"Aborted by callback"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_DONE</name><operator>)</operator></expr>?</condition><then>
<expr><name>CURLM_STATE_DONE</name></expr></then><else>: <expr><name>CURLM_STATE_COMPLETED</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> <operator>=</operator> <name>CURLM_CALL_MULTI_PERFORM</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name>CURLM_STATE_COMPLETED</name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>fmultidone</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>data</name><operator>-&gt;</operator><name>set</name><operator>.</operator><name>fmultidone</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>msg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>msg</name><operator>-&gt;</operator><name>extmsg</name><operator>.</operator><name>msg</name></name> <operator>=</operator> <name>CURLMSG_DONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>msg</name><operator>-&gt;</operator><name>extmsg</name><operator>.</operator><name>easy_handle</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>msg</name><operator>-&gt;</operator><name>extmsg</name><operator>.</operator><name>data</name><operator>.</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>multi_addmsg</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_MSGSENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block> while<condition>(<expr><operator>(</operator><name>rc</name> <operator>==</operator> <name>CURLM_CALL_MULTI_PERFORM</name><operator>)</operator> <operator>||</operator> <call><name>multi_ischanged</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>result</name></name> <operator>=</operator> <name>result</name></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>CURLMcode</name></type> <name>curl_multi_perform</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>running_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>returncode</name> <init>= <expr><name>CURLM_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name> <init>= <expr><call><name>Curl_now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SIGPIPE_VARIABLE</name><argument_list>(<argument><expr><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigpipe_ignore</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_runsingle</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigpipe_restore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>returncode</name> <operator>=</operator> <name>result</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt> 
</block_content>}</block></while>











<do>do <block>{<block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name> <operator>=</operator> <call><name>Curl_splaygetbest</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>t</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_next_timeout</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block> while<condition>(<expr><name>t</name></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>running_handles</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>CURLM_OK</name> <operator>&gt;=</operator> <name>returncode</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>returncode</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_cleanup</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>nextdata</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 


<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>nextdata</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>done</name></name> <operator>&amp;&amp;</operator> <name><name>data</name><operator>-&gt;</operator><name>conn</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>multi_done</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLE_OK</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>==</operator> <name>HCACHE_MULTI</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>Curl_hostcache_clean</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>dns</name><operator>.</operator><name>hostcachetype</name></name> <operator>=</operator> <name>HCACHE_NONE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>conn_cache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_LIBPSL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>psl</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>psl</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>data</name> <operator>=</operator> <name>nextdata</name></expr>;</expr_stmt>
</block_content>}</block></while>


<expr_stmt><expr><call><name>Curl_conncache_close_all_connections</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>conn_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_conncache_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>conn_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_llist_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Curl_hash_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>hostcache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Curl_psl_destroy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>psl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENABLE_WAKEUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sclose</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sclose</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>wakeup_pair</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return>
</block_content>}</block></function>











<function><type><name>CURLMsg</name> <modifier>*</modifier></type><name>curl_multi_info_read</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>msgs_in_queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_message</name></name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>msgs_in_queue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<if_stmt><if>if<condition>(<expr><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
<operator>!</operator><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name> <operator>&amp;&amp;</operator>
<call><name>Curl_llist_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>


<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>msglist</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>msg</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>msgs_in_queue</name> <operator>=</operator> <call><name>curlx_uztosi</name><argument_list>(<argument><expr><call><name>Curl_llist_count</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>msglist</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name><name>msg</name><operator>-&gt;</operator><name>extmsg</name></name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>singlesocket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name><name>socks</name><index>[<expr><name>MAX_SOCKSPEREASYHANDLE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>curraction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>actions</name><index>[<expr><name>MAX_SOCKSPEREASYHANDLE</name></expr>]</index></name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name>MAX_SOCKSPEREASYHANDLE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>socks</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>CURL_SOCKET_BAD</name></expr>;</expr_stmt></block_content></block></for>



<expr_stmt><expr><name>curraction</name> <operator>=</operator> <call><name>multi_getsock</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>socks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>i</name><operator>&lt;</operator> <name>MAX_SOCKSPEREASYHANDLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
<operator>(</operator><name>curraction</name> <operator>&amp;</operator> <operator>(</operator><call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</condition>
<incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>action</name> <init>= <expr><name>CURL_POLL_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>prevaction</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>comboaction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>sincebefore</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>socks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>curraction</name> <operator>&amp;</operator> <call><name>GETSOCK_READSOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>action</name> <operator>|=</operator> <name>CURL_POLL_IN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>curraction</name> <operator>&amp;</operator> <call><name>GETSOCK_WRITESOCK</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>action</name> <operator>|=</operator> <name>CURL_POLL_OUT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>actions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>action</name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <name><name>data</name><operator>-&gt;</operator><name>sockets</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>prevaction</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>actions</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sincebefore</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>sh_addentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>CURLM_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if<condition>(<expr><name>sincebefore</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>prevaction</name> <operator>!=</operator> <name>action</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>prevaction</name> <operator>&amp;</operator> <name>CURL_POLL_IN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>readers</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>prevaction</name> <operator>&amp;</operator> <name>CURL_POLL_OUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>writers</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>action</name> <operator>&amp;</operator> <name>CURL_POLL_IN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>readers</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>action</name> <operator>&amp;</operator> <name>CURL_POLL_OUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>writers</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if<condition>(<expr><operator>!</operator><name>sincebefore</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>users</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>action</name> <operator>&amp;</operator> <name>CURL_POLL_IN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>readers</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>action</name> <operator>&amp;</operator> <name>CURL_POLL_OUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>writers</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>Curl_hash_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>, 
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Curl_easy</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_OUT_OF_MEMORY</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>comboaction</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>writers</name></name></expr>?</condition><then> <expr><name>CURL_POLL_OUT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
<operator>(</operator><ternary><condition><expr><name><name>entry</name><operator>-&gt;</operator><name>readers</name></name></expr> ?</condition><then> <expr><name>CURL_POLL_IN</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><name>sincebefore</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>comboaction</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>comboaction</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>socket_userp</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>socketp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>action</name></name> <operator>=</operator> <name>comboaction</name></expr>;</expr_stmt> 
</block_content>}</block></for>

<expr_stmt><expr><name>num</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt> 



<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>stillused</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <name><name>socks</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stillused</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name>stillused</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if<condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>oldactions</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>actions</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>users</name></name><operator>--</operator></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>oldactions</name> <operator>&amp;</operator> <name>CURL_POLL_OUT</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>writers</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>oldactions</name> <operator>&amp;</operator> <name>CURL_POLL_IN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>readers</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>users</name></name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>CURL_POLL_REMOVE</name></expr></argument>,
<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>socket_userp</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>socketp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>sh_delentry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<if_stmt><if>if<condition>(<expr><call><name>Curl_hash_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>data</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>Curl_easy</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for> 

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>sockets</name></name></expr></argument>, <argument><expr><name>socks</name></expr></argument>, <argument><expr><name>num</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>curl_socket_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>, <argument><expr><name>actions</name></expr></argument>, <argument><expr><name>num</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_updatesocket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>singlesocket</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>












<function><type><name>void</name></type> <name>Curl_multi_closed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>multi</name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>entry</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>CURL_POLL_REMOVE</name></expr></argument>,
<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>socket_userp</name></name></expr></argument>,
<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>socketp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>sh_delentry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>













<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>add_next_timeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>d</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name> <modifier>*</modifier></type><name>tv</name> <init>= <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>expiretime</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>time_node</name></name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>




<for>for<control>(<init><expr><name>e</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition><incr/>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timediff_t</name></type> <name>diff</name></decl>;</decl_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator>struct <name>time_node</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>Curl_timediff</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<break>break;</break></block_content></block></else></if_stmt>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name>e</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>head</name></name></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>tv</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name> <operator>=</operator> <call><name>Curl_splayinsert</name><argument_list>(<argument><expr><operator>*</operator><name>tv</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>d</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timenode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>multi_socket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>bool</name></type> <name>checkall</name></decl></parameter>,
<parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ev_bitmask</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>running_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>result</name> <init>= <expr><name>CURLM_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_tree</name></name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name> <init>= <expr><call><name>Curl_now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>checkall</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>curl_multi_perform</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>running_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if<condition>(<expr><name>result</name> <operator>!=</operator> <name>CURLM_BAD_HANDLE</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</expr_stmt>
<while>while<condition>(<expr><name>data</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>result</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>singlesocket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>


<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>s</name> <operator>!=</operator> <name>CURL_SOCKET_TIMEOUT</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition><block type="pseudo"><block_content>





<empty_stmt>;</empty_stmt></block_content></block></if>
<else>else <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_hash_iterator</name></name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_hash_element</name></name> <modifier>*</modifier></type><name>he</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>Curl_hash_start_iterate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>transfers</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>he</name> <operator>=</operator> <call><name>Curl_hash_next_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>he</name></expr>;</condition>
<incr><expr><name>he</name> <operator>=</operator> <call><name>Curl_hash_next_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name>iter</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <operator>(</operator>struct <name>Curl_easy</name> <operator>*</operator><operator>)</operator><name><name>he</name><operator>-&gt;</operator><name>ptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>CURLEASY_MAGIC_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>conn</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>handler</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>PROTOPT_DIRLOCK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>conn</name><operator>-&gt;</operator><name>cselect_bits</name></name> <operator>=</operator> <name>ev_bitmask</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPIRE_RUN_NOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>





<expr_stmt><expr><name>data</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>now</name> <operator>=</operator> <call><name>Curl_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else <block>{<block_content>





<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>






<do>do <block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>SIGPIPE_VARIABLE</name><argument_list>(<argument><expr><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sigpipe_ignore</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_runsingle</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>now</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sigpipe_restore</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pipe_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name>CURLM_OK</name> <operator>&gt;=</operator> <name>result</name></expr>)</condition> <block>{<block_content>


<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>singlesocket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name> <operator>=</operator> <call><name>Curl_splaygetbest</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>t</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>t</name><operator>-&gt;</operator><name>payload</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>add_next_timeout</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>multi</name></expr></argument>, <argument><expr><name><name>t</name><operator>-&gt;</operator><name>payload</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

</block_content>}</block> while<condition>(<expr><name>t</name></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>running_handles</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>curl_multi_setopt</name></cpp:undef>
<function><type><name>CURLMcode</name></type> <name>curl_multi_setopt</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>CURLMoption</name></type> <name>option</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>res</name> <init>= <expr><name>CURLM_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>param</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>option</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch<condition>(<expr><name>option</name></expr>)</condition> <block>{<block_content>
<case>case <expr><name>CURLMOPT_SOCKETFUNCTION</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>socket_cb</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>curl_socket_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_SOCKETDATA</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>socket_userp</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_PUSHFUNCTION</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>push_cb</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>curl_push_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_PUSHDATA</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>push_userp</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_PIPELINING</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>multiplexing</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>CURLPIPE_MULTIPLEX</name></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_TIMERFUNCTION</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_cb</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>curl_multi_timer_callback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_TIMERDATA</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_userp</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_MAXCONNECTS</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>maxconnects</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_MAX_HOST_CONNECTIONS</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>max_host_connections</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<case>case <expr><name>CURLMOPT_MAX_TOTAL_CONNECTIONS</name></expr>:</case>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>max_total_connections</name></name> <operator>=</operator> <call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>CURLMOPT_MAX_PIPELINE_LENGTH</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CURLMOPT_CONTENT_LENGTH_PENALTY_SIZE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CURLMOPT_CHUNK_LENGTH_PENALTY_SIZE</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CURLMOPT_PIPELINING_SITE_BL</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CURLMOPT_PIPELINING_SERVER_BL</name></expr>:</case>
<break>break;</break>
<case>case <expr><name>CURLMOPT_MAX_CONCURRENT_STREAMS</name></expr>:</case>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>streams</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>param</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>streams</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>streams</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>max_concurrent_streams</name></name> <operator>=</operator>
<ternary><condition><expr><operator>(</operator><name>streams</name> <operator>&gt;</operator> <operator>(</operator><name>long</name><operator>)</operator><name>INITIAL_MAX_CONCURRENT_STREAMS</name><operator>)</operator></expr>?</condition><then>
<expr><name>INITIAL_MAX_CONCURRENT_STREAMS</name></expr> </then><else>: <expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name>streams</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block>
<break>break;</break>
<default>default:</default>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>CURLM_UNKNOWN_OPTION</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></switch>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>


<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>curl_multi_socket</name></cpp:undef>

<function><type><name>CURLMcode</name></type> <name>curl_multi_socket</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>running_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_socket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>running_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>CURLM_OK</name> <operator>&gt;=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_socket_action</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ev_bitmask</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>running_handles</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_socket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>ev_bitmask</name></expr></argument>, <argument><expr><name>running_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>CURLM_OK</name> <operator>&gt;=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_socket_all</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>running_handles</name></decl></parameter>)</parameter_list>

<block>{<block_content>
<decl_stmt><decl><type><name>CURLMcode</name></type> <name>result</name></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>multi_socket</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>CURL_SOCKET_BAD</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>running_handles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>CURLM_OK</name> <operator>&gt;=</operator> <name>result</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>Curl_update_timer</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CURLMcode</name></type> <name>multi_timeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>timeout_ms</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>curltime</name></name></type> <name>tv_zero</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>now</name> <init>= <expr><call><name>Curl_now</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>


<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name> <operator>=</operator> <call><name>Curl_splay</name><argument_list>(<argument><expr><name>tv_zero</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>Curl_splaycomparekeys</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>timediff_t</name></type> <name>diff</name> <init>= <expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name>now</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>diff</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>







<expr_stmt><expr><operator>*</operator><name>timeout_ms</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>


<expr_stmt><expr><operator>*</operator><name>timeout_ms</name> <operator>=</operator> <operator>(</operator><name>long</name><operator>)</operator><name>diff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>timeout_ms</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>timeout_ms</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CURLMcode</name></type> <name>curl_multi_timeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>,
<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>timeout_ms</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if<condition>(<expr><operator>!</operator><call><name>GOOD_MULTI_HANDLE</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_HANDLE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>multi_timeout</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>Curl_update_timer</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>timeout_ms</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name><name>multi</name><operator>-&gt;</operator><name>timer_cb</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><call><name>multi_timeout</name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timeout_ms</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if<condition>(<expr><name>timeout_ms</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>curltime</name></name></type> <name>none</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><call><name>Curl_splaycomparekeys</name><argument_list>(<argument><expr><name>none</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name> <operator>=</operator> <name>none</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name><name>multi</name><operator>-&gt;</operator><name>timer_cb</name></name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_userp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if<condition>(<expr><call><name>Curl_splaycomparekeys</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name><operator>-&gt;</operator><name>key</name></name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_lastcall</name></name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>timetree</name><operator>-&gt;</operator><name>key</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name><name>multi</name><operator>-&gt;</operator><name>timer_cb</name></name><argument_list>(<argument><expr><name>multi</name></expr></argument>, <argument><expr><name>timeout_ms</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timer_userp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>multi_deltimeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>expire_id</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist</name></name> <modifier>*</modifier></type><name>timeoutlist</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></init></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>e</name> <operator>=</operator> <name><name>timeoutlist</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>time_node</name></name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator>struct <name>time_node</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>eid</name></name> <operator>==</operator> <name>eid</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><name>timeoutlist</name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>CURLMcode</name></type>
<name>multi_addtimeout</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>,
<parameter><decl><type><name><name>struct</name> <name>curltime</name></name> <modifier>*</modifier></type><name>stamp</name></decl></parameter>,
<parameter><decl><type><name>expire_id</name></type> <name>eid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>time_node</name></name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist</name></name> <modifier>*</modifier></type><name>timeoutlist</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>expires</name><index>[<expr><name>eid</name></expr>]</index></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name>stamp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>stamp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>eid</name></name> <operator>=</operator> <name>eid</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>Curl_llist_count</name><argument_list>(<argument><expr><name>timeoutlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<for>for<control>(<init><expr><name>e</name> <operator>=</operator> <name><name>timeoutlist</name><operator>-&gt;</operator><name>head</name></name></expr>;</init> <condition><expr><name>e</name></expr>;</condition> <incr><expr><name>e</name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>time_node</name></name> <modifier>*</modifier></type><name>check</name> <init>= <expr><operator>(</operator>struct <name>time_node</name> <operator>*</operator><operator>)</operator><name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timediff_t</name></type> <name>diff</name> <init>= <expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name><name>check</name><operator>-&gt;</operator><name>time</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>time</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>
</block_content>}</block></for>

</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>Curl_llist_insert_next</name><argument_list>(<argument><expr><name>timeoutlist</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>












<function><type><name>void</name></type> <name>Curl_expire</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>timediff_t</name></type> <name>milli</name></decl></parameter>, <parameter><decl><type><name>expire_id</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name> <modifier>*</modifier></type><name>nowp</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>expiretime</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name></type> <name>set</name></decl>;</decl_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name>multi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>id</name> <operator>&lt;</operator> <name>EXPIRE_LAST</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>set</name> <operator>=</operator> <call><name>Curl_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>set</name><operator>.</operator><name>tv_sec</name></name> <operator>+=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><operator>(</operator><name>milli</name><operator>/</operator><literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>set</name><operator>.</operator><name>tv_usec</name></name> <operator>+=</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>(</operator><name>milli</name><operator>%</operator><literal type="number">1000</literal><operator>)</operator><operator>*</operator><literal type="number">1000</literal></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>set</name><operator>.</operator><name>tv_usec</name></name> <operator>&gt;=</operator> <literal type="number">1000000</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><name><name>set</name><operator>.</operator><name>tv_sec</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>set</name><operator>.</operator><name>tv_usec</name></name> <operator>-=</operator> <literal type="number">1000000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>multi_deltimeout</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>multi_addtimeout</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>set</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><name><name>nowp</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>||</operator> <name><name>nowp</name><operator>-&gt;</operator><name>tv_usec</name></name></expr>)</condition> <block>{<block_content>



<decl_stmt><decl><type><name>timediff_t</name></type> <name>diff</name> <init>= <expr><call><name>Curl_timediff</name><argument_list>(<argument><expr><name>set</name></expr></argument>, <argument><expr><operator>*</operator><name>nowp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>


<return>return;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Curl_splayremovebyaddr</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timenode</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Internal error removing splay node = %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><operator>*</operator><name>nowp</name> <operator>=</operator> <name>set</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timenode</name><operator>.</operator><name>payload</name></name> <operator>=</operator> <name>data</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name> <operator>=</operator> <call><name>Curl_splayinsert</name><argument_list>(<argument><expr><operator>*</operator><name>nowp</name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timenode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type> <name>Curl_expire_done</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>expire_id</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>multi_deltimeout</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>






<function><type><name>void</name></type> <name>Curl_expire_clear</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>curltime</name></name> <modifier>*</modifier></type><name>nowp</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>expiretime</name></name></expr></init></decl>;</decl_stmt>



<if_stmt><if>if<condition>(<expr><operator>!</operator><name>multi</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if<condition>(<expr><name><name>nowp</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>||</operator> <name><name>nowp</name><operator>-&gt;</operator><name>tv_usec</name></name></expr>)</condition> <block>{<block_content>


<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist</name></name> <modifier>*</modifier></type><name>list</name> <init>= <expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timeoutlist</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>Curl_splayremovebyaddr</name><argument_list>(<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>timenode</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>timetree</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><name>rc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Internal error clearing splay node = %d\n"</literal></expr></argument>, <argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<while>while<condition>(<expr><name><name>list</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>list</name><operator>-&gt;</operator><name>tail</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>infof</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"Expire cleared (transfer %p)\n"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>nowp</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nowp</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><name>CURLMcode</name></type> <name>curl_multi_assign</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>, <parameter><decl><type><name>curl_socket_t</name></type> <name>s</name></decl></parameter>,
<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>hashp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>there</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if<condition>(<expr><name><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_RECURSIVE_API_CALL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>there</name> <operator>=</operator> <call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><operator>!</operator><name>there</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>CURLM_BAD_SOCKET</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>there</name><operator>-&gt;</operator><name>socketp</name></name> <operator>=</operator> <name>hashp</name></expr>;</expr_stmt>

<return>return <expr><name>CURLM_OK</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Curl_multi_max_host_connections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>multi</name></expr> ?</condition><then> <expr><name><name>multi</name><operator>-&gt;</operator><name>max_host_connections</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<function><type><name>size_t</name></type> <name>Curl_multi_max_total_connections</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><ternary><condition><expr><name>multi</name></expr> ?</condition><then> <expr><name><name>multi</name><operator>-&gt;</operator><name>max_total_connections</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>





<function><type><name>void</name></type> <name>Curl_multiuse_state</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>connectdata</name></name> <modifier>*</modifier></type><name>conn</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>bundlestate</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>conn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>bundle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>conn</name><operator>-&gt;</operator><name>bundle</name><operator>-&gt;</operator><name>multiuse</name></name> <operator>=</operator> <name>bundlestate</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>process_pending_handles</name><argument_list>(<argument><expr><name><name>conn</name><operator>-&gt;</operator><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>process_pending_handles</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>curl_llist_element</name></name> <modifier>*</modifier></type><name>e</name> <init>= <expr><name><name>multi</name><operator>-&gt;</operator><name>pending</name><operator>.</operator><name>head</name></name></expr></init></decl>;</decl_stmt>
<if_stmt><if>if<condition>(<expr><name>e</name></expr>)</condition> <block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>ptr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>==</operator> <name>CURLM_STATE_CONNECT_PEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>multistate</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>CURLM_STATE_CONNECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_llist_remove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>pending</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>Curl_expire</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>EXPIRE_RUN_NOW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>state</name><operator>.</operator><name>previouslypending</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>Curl_set_in_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name>data</name></expr>)</condition> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>multi_easy</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi_easy</name><operator>-&gt;</operator><name>in_callback</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>multi</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>data</name><operator>-&gt;</operator><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type> <name>Curl_is_in_callback</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>easy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><operator>(</operator><name><name>easy</name><operator>-&gt;</operator><name>multi</name></name> <operator>&amp;&amp;</operator> <name><name>easy</name><operator>-&gt;</operator><name>multi</name><operator>-&gt;</operator><name>in_callback</name></name><operator>)</operator> <operator>||</operator>
<operator>(</operator><name><name>easy</name><operator>-&gt;</operator><name>multi_easy</name></name> <operator>&amp;&amp;</operator> <name><name>easy</name><operator>-&gt;</operator><name>multi_easy</name><operator>-&gt;</operator><name>in_callback</name></name><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUGBUILD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type> <name>Curl_multi_dump</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_easy</name></name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"* Multi status: %d handles, %d alive\n"</literal></expr></argument>,
<argument><expr><name><name>multi</name><operator>-&gt;</operator><name>num_easy</name></name></expr></argument>, <argument><expr><name><name>multi</name><operator>-&gt;</operator><name>num_alive</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>data</name> <operator>=</operator> <name><name>multi</name><operator>-&gt;</operator><name>easyp</name></name></expr>;</init> <condition><expr><name>data</name></expr>;</condition> <incr><expr><name>data</name> <operator>=</operator> <name><name>data</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control> <block>{<block_content>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name> <operator>&lt;</operator> <name>CURLM_STATE_COMPLETED</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"handle %p, state %s, %d sockets\n"</literal></expr></argument>,
<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>,
<argument><expr><name><name>statename</name><index>[<expr><name><name>data</name><operator>-&gt;</operator><name>mstate</name></name></expr>]</index></name></expr></argument>, <argument><expr><name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>
<decl_stmt><decl><type><name>curl_socket_t</name></type> <name>s</name> <init>= <expr><name><name>data</name><operator>-&gt;</operator><name>sockets</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>Curl_sh_entry</name></name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>sh_getentry</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>multi</name><operator>-&gt;</operator><name>sockhash</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%d "</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if<condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition> <block>{<block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"INTERNAL CONFUSION\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"[%s %s] "</literal></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>action</name></name><operator>&amp;</operator><name>CURL_POLL_IN</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"RECVING"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>action</name></name><operator>&amp;</operator><name>CURL_POLL_OUT</name><operator>)</operator></expr>?</condition><then><expr><literal type="string">"SENDING"</literal></expr></then><else>:<expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>
<if_stmt><if>if<condition>(<expr><name><name>data</name><operator>-&gt;</operator><name>numsocks</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>unsigned</name> <name>int</name></type> <name>Curl_multi_max_concurrent_streams</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>Curl_multi</name></name> <modifier>*</modifier></type><name>multi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>DEBUGASSERT</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>multi</name><operator>-&gt;</operator><name>max_concurrent_streams</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
