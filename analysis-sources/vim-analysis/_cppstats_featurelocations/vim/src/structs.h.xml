<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats_featurelocations\vim\src\structs.h">















<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SASC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>SASC</name> <operator>&lt;</operator> <literal type="number">658</literal></expr></cpp:if>
<typedef>typedef <type><name>long</name></type> <name>linenr_T</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>colnr_T</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>short_u</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>col</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>coladd</name></decl>;</decl_stmt> 
}</block></struct></type> <name>pos_T</name>;</typedef>





<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>col</name></decl>;</decl_stmt> 
}</block></struct></type> <name>lpos_T</name>;</typedef>






<typedef>typedef <type><struct>struct <name>growarray</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>ga_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ga_maxlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ga_itemsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ga_growsize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ga_data</name></decl>;</decl_stmt> 
}</block></struct></type> <name>garray_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GA_EMPTY</name></cpp:macro> <cpp:value>{0, 0, 0, 0, NULL}</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>window_S</name></name></type> <name>win_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>wininfo_S</name></name></type> <name>wininfo_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>frame_S</name></name></type> <name>frame_T</name>;</typedef>
<typedef>typedef <type><name>int</name></type> <name>scid_T</name>;</typedef> 
<typedef>typedef <type><name><name>struct</name> <name>file_buffer</name></name></type> <name>buf_T</name>;</typedef> 
<typedef>typedef <type><name><name>struct</name> <name>terminal_S</name></name></type> <name>term_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name><name>struct</name> <name>VimMenu</name></name></type> <name>vimmenu_T</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCRIPT_VERSION_VIM9</name></cpp:macro> <cpp:value>999999</cpp:value></cpp:define>











<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>scid_T</name></type> <name>sc_sid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sc_seq</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>sc_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sc_version</name></decl>;</decl_stmt> 
}</block></struct></type> <name>sctx_T</name>;</typedef>





<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>br_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>br_fnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>br_buf_free_count</name></decl>;</decl_stmt>
}</block></struct></type> <name>bufref_T</name>;</typedef>




<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"regexp.h"</cpp:file></cpp:include>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gui.h"</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_XCLIPBOARD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;X11/Intrinsic.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>guicolor_T</name></cpp:macro> <cpp:value>long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALCOLOR</name></cpp:macro> <cpp:value>((guicolor_T)0x1ffffff)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CTERMCOLOR</name></cpp:macro> <cpp:value>((guicolor_T)0x1fffffe)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COLOR_INVALID</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) == INVALCOLOR || (x) == CTERMCOLOR)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NMARKS</name></cpp:macro> <cpp:value>('z' - 'a' + 1)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRA_MARKS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JUMPLISTSIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAGSTACKSIZE</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define> 

<typedef>typedef <type><struct>struct <name>filemark</name>
<block>{
<decl_stmt><decl><type><name>pos_T</name></type> <name>mark</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>fnum</name></decl>;</decl_stmt> 
}</block></struct></type> <name>fmark_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>xfilemark</name>
<block>{
<decl_stmt><decl><type><name>fmark_T</name></type> <name>fmark</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VIMINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>time_T</name></type> <name>time_set</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>xfmark_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>taggy</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tagname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>fmark_T</name></type> <name>fmark</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cur_match</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cur_fnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>user_data</name></decl>;</decl_stmt> 
}</block></struct></type> <name>taggy_T</name>;</typedef>






<typedef>typedef <type><struct>struct
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_ARABIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_arab</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_arab</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_arab</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_bri</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_bri</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_bri</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_briopt</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_briopt</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_briopt</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_wcr</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_wcr</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_wcr</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_diff</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_diff</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_diff</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long</name></type> <name>wo_fdc</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdc</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdc</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_fdc_save</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdc_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdc_save</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_fen</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fen</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fen</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_fen_save</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fen_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fen_save</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fdi</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdi</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdi</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>long</name></type> <name>wo_fdl</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdl</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdl</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_fdl_save</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdl_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdl_save</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fdm</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdm</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdm</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fdm_save</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdm_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdm_save</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>long</name></type> <name>wo_fml</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fml</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fml</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>long</name></type> <name>wo_fdn</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdn</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdn</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fde</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fde</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fde</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fdt</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fdt</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fdt</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_fmr</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_fmr</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_fmr</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_lbr</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_lbr</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_lbr</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>wo_list</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_list</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_list</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_nu</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_nu</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_nu</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_rnu</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_rnu</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_rnu</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long</name></type> <name>wo_nuw</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_nuw</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_nuw</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>wo_wfh</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_wfh</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_wfh</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_wfw</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_wfw</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_wfw</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_pvw</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_pvw</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_pvw</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_rl</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_rl</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_rl</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_rlc</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_rlc</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_rlc</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>long</name></type> <name>wo_scr</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_scr</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_scr</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_spell</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_spell</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_spell</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_cuc</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_cuc</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_cuc</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_cul</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_cul</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_cul</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_culopt</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_culopt</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_culopt</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_cc</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_cc</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_cc</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_sbr</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_sbr</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_sbr</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_STL_OPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_stl</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_stl</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_stl</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>wo_scb</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_scb</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_scb</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_diff_saved</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_diff_saved</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_diff_saved</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>wo_scb_save</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_scb_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_scb_save</cpp:value></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>wo_wrap</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_wrap</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_wrap</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wo_wrap_save</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_wrap_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_wrap_save</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CONCEAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_cocu</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_cocu</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_cocu</cpp:value></cpp:define>
<decl_stmt><decl><type><name>long</name></type> <name>wo_cole</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_cole</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_cole</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>wo_crb</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_crb</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_crb</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>wo_crb_save</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_crb_save</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_crb_save</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_scl</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_scl</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_scl</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMINAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_twk</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_twk</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_twk</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wo_tws</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_tws</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_tws</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>sctx_T</name></type> <name><name>wo_script_ctx</name><index>[<expr><name>WV_COUNT</name></expr>]</index></name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>w_p_script_ctx</name></cpp:macro> <cpp:value>w_onebuf_opt.wo_script_ctx</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>winopt_T</name>;</typedef>











<struct>struct <name>wininfo_S</name>
<block>{
<decl_stmt><decl><type><name>wininfo_T</name> <modifier>*</modifier></type><name>wi_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>wininfo_T</name> <modifier>*</modifier></type><name>wi_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wi_win</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>wi_fpos</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>wi_optset</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>winopt_T</name></type> <name>wi_opt</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wi_fold_manual</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>wi_folds</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>





<typedef>typedef <type><struct>struct <name>foldinfo</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>fi_level</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>fi_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>fi_low_level</name></decl>;</decl_stmt> 

}</block></struct></type> <name>foldinfo_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>pos_T</name></type> <name>vi_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>vi_end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>vi_mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>vi_curswant</name></decl>;</decl_stmt> 
}</block></struct></type> <name>visualinfo_T</name>;</typedef>







<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ul_line</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>ul_len</name></decl>;</decl_stmt> 

}</block></struct></type> <name>undoline_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>u_entry</name></name></type> <name>u_entry_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>u_header</name></name></type> <name>u_header_T</name>;</typedef>
<struct>struct <name>u_entry</name>
<block>{
<decl_stmt><decl><type><name>u_entry_T</name> <modifier>*</modifier></type><name>ue_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ue_top</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ue_bot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ue_lcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>undoline_T</name> <modifier>*</modifier></type><name>ue_array</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>ue_size</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>U_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ue_magic</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<struct>struct <name>u_header</name>
<block>{


<union>union <block>{
<decl_stmt><decl><type><name>u_header_T</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>seq</name></decl>;</decl_stmt>
}</block> <decl><name>uh_next</name></decl>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>u_header_T</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>seq</name></decl>;</decl_stmt>
}</block> <decl><name>uh_prev</name></decl>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>u_header_T</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>seq</name></decl>;</decl_stmt>
}</block> <decl><name>uh_alt_next</name></decl>;</union>
<union>union <block>{
<decl_stmt><decl><type><name>u_header_T</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>seq</name></decl>;</decl_stmt>
}</block> <decl><name>uh_alt_prev</name></decl>;</union>
<decl_stmt><decl><type><name>long</name></type> <name>uh_seq</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uh_walk</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>u_entry_T</name> <modifier>*</modifier></type><name>uh_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>u_entry_T</name> <modifier>*</modifier></type><name>uh_getbot_entry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>uh_cursor</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>uh_cursor_vcol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uh_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name><name>uh_namedm</name><index>[<expr><name>NMARKS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>visualinfo_T</name></type> <name>uh_visual</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>time_T</name></type> <name>uh_time</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>uh_save_nr</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>U_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>uh_magic</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UH_CHANGED</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UH_EMPTYBUF</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGN_LONG</name></cpp:macro></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGN_SIZE</name></cpp:macro> <cpp:value>(sizeof(long))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIGN_MASK</name></cpp:macro> <cpp:value>(ALIGN_SIZE - 1)</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>m_info</name></name></type> <name>minfo_T</name>;</typedef>




<struct>struct <name>m_info</name>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALIGN_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long_u</name></type> <name>m_size</name></decl>;</decl_stmt> 
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>short_u</name></type> <name>m_size</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>minfo_T</name> <modifier>*</modifier></type><name>m_next</name></decl>;</decl_stmt> 
}</block>;</struct>





<typedef>typedef <type><name><name>struct</name> <name>block_hdr</name></name></type> <name>bhdr_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>memfile</name></name></type> <name>memfile_T</name>;</typedef>
<typedef>typedef <type><name>long</name></type> <name>blocknr_T</name>;</typedef>








<typedef>typedef <type><name><name>struct</name> <name>mf_hashitem_S</name></name></type> <name>mf_hashitem_T</name>;</typedef>

<struct>struct <name>mf_hashitem_S</name>
<block>{
<decl_stmt><decl><type><name>mf_hashitem_T</name> <modifier>*</modifier></type><name>mhi_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mf_hashitem_T</name> <modifier>*</modifier></type><name>mhi_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>mhi_key</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MHT_INIT_SIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>mf_hashtab_S</name>
<block>{
<decl_stmt><decl><type><name>long_u</name></type> <name>mht_mask</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long_u</name></type> <name>mht_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>mf_hashitem_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>mht_buckets</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>mf_hashitem_T</name> <modifier>*</modifier></type><name><name>mht_small_buckets</name><index>[<expr><name>MHT_INIT_SIZE</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>mht_fixed</name></decl>;</decl_stmt> 
}</block></struct></type> <name>mf_hashtab_T</name>;</typedef>
















<struct>struct <name>block_hdr</name>
<block>{
<decl_stmt><decl><type><name>mf_hashitem_T</name></type> <name>bh_hashitem</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bh_bnum</name></cpp:macro> <cpp:value>bh_hashitem.mhi_key</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>bh_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>bh_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bh_data</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bh_page_count</name></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BH_DIRTY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BH_LOCKED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><name>char</name></type> <name>bh_flags</name></decl>;</decl_stmt> 
}</block>;</struct>







<typedef>typedef <type><name><name>struct</name> <name>nr_trans</name></name></type> <name>NR_TRANS</name>;</typedef>

<struct>struct <name>nr_trans</name>
<block>{
<decl_stmt><decl><type><name>mf_hashitem_T</name></type> <name>nt_hashitem</name></decl>;</decl_stmt> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nt_old_bnum</name></cpp:macro> <cpp:value>nt_hashitem.mhi_key</cpp:value></cpp:define> 

<decl_stmt><decl><type><name>blocknr_T</name></type> <name>nt_new_bnum</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><name><name>struct</name> <name>buffblock</name></name></type> <name>buffblock_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>buffheader</name></name></type> <name>buffheader_T</name>;</typedef>




<struct>struct <name>buffblock</name>
<block>{
<decl_stmt><decl><type><name>buffblock_T</name> <modifier>*</modifier></type><name>b_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>b_str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>




<struct>struct <name>buffheader</name>
<block>{
<decl_stmt><decl><type><name>buffblock_T</name></type> <name>bh_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>buffblock_T</name> <modifier>*</modifier></type><name>bh_curr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bh_index</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bh_space</name></decl>;</decl_stmt> 
}</block>;</struct>

<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>buffheader_T</name></type> <name>sr_redobuff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buffheader_T</name></type> <name>sr_old_redobuff</name></decl>;</decl_stmt>
}</block></struct></type> <name>save_redo_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>expand</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>xp_pattern</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>xp_context</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>xp_pattern_len</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>xp_arg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sctx_T</name></type> <name>xp_script_ctx</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>xp_backslash</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>xp_shell</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>xp_numfiles</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>xp_col</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>xp_files</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>xp_line</name></decl>;</decl_stmt> 
}</block></struct></type> <name>expand_T</name>;</typedef>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XP_BS_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XP_BS_ONE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XP_BS_THREE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 






<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmdbuff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdbufflen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdpos</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdspos</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdfirstc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdindent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmdprompt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdattr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>overstrike</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xpc</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>xp_context</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>xp_arg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>input_fn</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>cmdline_info_T</name>;</typedef>






<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>hide</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BROWSE_CMD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>browse</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>split</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tab</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_DIALOG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CON_DIALOG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>confirm</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>keepalt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>keepmarks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>keepjumps</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lockmarks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>keeppatterns</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>noswapfile</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_ei</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regmatch_T</name></type> <name>filter_regmatch</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>filter_force</name></decl>;</decl_stmt> 
}</block></struct></type> <name>cmdmod_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MF_SEED_LEN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<struct>struct <name>memfile</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mf_fname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mf_ffname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mf_fd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mf_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mf_reopen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>mf_free_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>mf_used_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>mf_used_last</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>mf_used_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>mf_used_count_max</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>mf_hashtab_T</name></type> <name>mf_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>mf_hashtab_T</name></type> <name>mf_trans</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>mf_blocknr_max</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>mf_blocknr_min</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>mf_neg_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>mf_infile_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>mf_page_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mf_dirty</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>mf_buffer</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>mf_seed</name><index>[<expr><name>MF_SEED_LEN</name></expr>]</index></name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mf_old_key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mf_old_cm</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>mf_old_seed</name><index>[<expr><name>MF_SEED_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>









<typedef>typedef <type><struct>struct <name>info_pointer</name>
<block>{
<decl_stmt><decl><type><name>blocknr_T</name></type> <name>ip_bnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ip_low</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ip_high</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ip_index</name></decl>;</decl_stmt> 
}</block></struct></type> <name>infoptr_T</name>;</typedef> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BYTEOFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <name>ml_chunksize</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>mlcs_numlines</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>mlcs_totalsize</name></decl>;</decl_stmt>
}</block></struct></type> <name>chunksize_T</name>;</typedef>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_CHNK_ADDLINE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_CHNK_DELLINE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_CHNK_UPDLINE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<typedef>typedef <type><struct>struct <name>memline</name>
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ml_line_count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>memfile_T</name> <modifier>*</modifier></type><name>ml_mfp</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>infoptr_T</name> <modifier>*</modifier></type><name>ml_stack</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ml_stack_top</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ml_stack_size</name></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_EMPTY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_LINE_DIRTY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_LOCKED_DIRTY</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ML_LOCKED_POS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 
<decl_stmt><decl><type><name>int</name></type> <name>ml_flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>ml_line_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ml_line_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ml_line_ptr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bhdr_T</name> <modifier>*</modifier></type><name>ml_locked</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ml_locked_low</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ml_locked_high</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ml_locked_lineadd</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BYTEOFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>chunksize_T</name> <modifier>*</modifier></type><name>ml_chunksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ml_numchunks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ml_usedchunks</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>memline_T</name>;</typedef>







<typedef>typedef <type><struct>struct <name>textprop_S</name>
<block>{
<decl_stmt><decl><type><name>colnr_T</name></type> <name>tp_col</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>tp_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tp_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tp_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tp_flags</name></decl>;</decl_stmt> 
}</block></struct></type> <name>textprop_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TP_FLAG_CONT_NEXT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TP_FLAG_CONT_PREV</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>proptype_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>pt_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pt_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pt_hl_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pt_priority</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pt_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>pt_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>proptype_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT_FLAG_INS_START_INCL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT_FLAG_INS_END_INCL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PT_FLAG_COMBINE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 


<typedef>typedef <type><struct>struct <name>signgroup_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>sg_next_sign_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short_u</name></type> <name>sg_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sg_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>signgroup_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>sign_entry</name></name></type> <name>sign_entry_T</name>;</typedef>
<struct>struct <name>sign_entry</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>se_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>se_typenr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>se_priority</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>se_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>signgroup_T</name> <modifier>*</modifier></type><name>se_group</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sign_entry_T</name> <modifier>*</modifier></type><name>se_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sign_entry_T</name> <modifier>*</modifier></type><name>se_prev</name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><struct>struct <name>sign_attrs_S</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sat_typenr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>sat_icon</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sat_text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sat_texthl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sat_linehl</name></decl>;</decl_stmt>
}</block></struct></type> <name>sign_attrs_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SGN_KEY_OFF</name></cpp:macro> <cpp:value>offsetof(signgroup_T, sg_name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2SG</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((signgroup_T *)((hi)-&gt;hi_key - SGN_KEY_OFF))</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGN_DEF_PRIO</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<typedef>typedef <type><struct>struct <name>arglist</name>
<block>{
<decl_stmt><decl><type><name>garray_T</name></type> <name>al_ga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>al_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt> 
}</block></struct></type> <name>alist_T</name>;</typedef>






<typedef>typedef <type><struct>struct <name>argentry</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ae_fname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ae_fnum</name></decl>;</decl_stmt> 
}</block></struct></type> <name>aentry_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALIST</name><parameter_list>(<parameter><type><name>win</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(win)-&gt;w_alist</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GARGLIST</name></cpp:macro> <cpp:value>((aentry_T *)global_alist.al_ga.ga_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGLIST</name></cpp:macro> <cpp:value>((aentry_T *)ALIST(curwin)-&gt;al_ga.ga_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WARGLIST</name><parameter_list>(<parameter><type><name>wp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((aentry_T *)ALIST(wp)-&gt;al_ga.ga_data)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AARGLIST</name><parameter_list>(<parameter><type><name>al</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((aentry_T *)((al)-&gt;al_ga.ga_data))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GARGCOUNT</name></cpp:macro> <cpp:value>(global_alist.al_ga.ga_len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARGCOUNT</name></cpp:macro> <cpp:value>(ALIST(curwin)-&gt;al_ga.ga_len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WARGCOUNT</name><parameter_list>(<parameter><type><name>wp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(ALIST(wp)-&gt;al_ga.ga_len)</cpp:value></cpp:define>







<typedef>typedef <type><name><name>struct</name> <name>eslist_elem</name></name></type> <name>eslist_T</name>;</typedef>
<struct>struct <name>eslist_elem</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>saved_emsg_silent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>eslist_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
}</block>;</struct>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTACK_LEN</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>short</name></type> <name><name>cs_flags</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name><name>cs_pending</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<union>union <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>csp_rv</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>csp_ex</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
}</block> <decl><name>cs_pend</name></decl>;</union>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name><name>cs_forinfo</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>cs_line</name><index>[<expr><name>CSTACK_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cs_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cs_looplevel</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cs_trylevel</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>eslist_T</name> <modifier>*</modifier></type><name>cs_emsg_silent_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>cs_lflags</name></decl>;</decl_stmt> 
}</block></struct></type> <name>cstack_T</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cs_rettv</name></cpp:macro> <cpp:value>cs_pend.csp_rv</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cs_exception</name></cpp:macro> <cpp:value>cs_pend.csp_ex</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_TRUE</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_ACTIVE</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_ELSE</name></cpp:macro> <cpp:value>0x0004</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_WHILE</name></cpp:macro> <cpp:value>0x0008</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_FOR</name></cpp:macro> <cpp:value>0x0010</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_TRY</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_FINALLY</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_THROWN</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_CAUGHT</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSF_SILENT</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 







<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_ERROR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_INTERRUPT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_THROW</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_BREAK</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_CONTINUE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_RETURN</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSTP_FINISH</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSL_HAD_LOOP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSL_HAD_ENDLOOP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSL_HAD_CONT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSL_HAD_FINA</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 







<struct>struct <name>msglist</name>
<block>{
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>msg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>throw_msg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>msglist</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><enum>enum
<block>{
<decl><name>ET_USER</name></decl>, 
<decl><name>ET_ERROR</name></decl>, 
<decl><name>ET_INTERRUPT</name></decl>, 
}</block></enum></type> <name>except_type_T</name>;</typedef>





<typedef>typedef <type><name><name>struct</name> <name>vim_exception</name></name></type> <name>except_T</name>;</typedef>
<struct>struct <name>vim_exception</name>
<block>{
<decl_stmt><decl><type><name>except_type_T</name></type> <name>type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>msglist</name></name> <modifier>*</modifier></type><name>messages</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>throw_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>throw_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>except_T</name> <modifier>*</modifier></type><name>caught</name></decl>;</decl_stmt> 
}</block>;</struct>






<typedef>typedef <type><name><name>struct</name> <name>cleanup_stuff</name></name></type> <name>cleanup_T</name>;</typedef>
<struct>struct <name>cleanup_stuff</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>pending</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>except_T</name> <modifier>*</modifier></type><name>exception</name></decl>;</decl_stmt> 
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<struct>struct <name>sp_syn</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>inc_tag</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>cont_in_list</name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><name><name>struct</name> <name>keyentry</name></name></type> <name>keyentry_T</name>;</typedef>

<struct>struct <name>keyentry</name>
<block>{
<decl_stmt><decl><type><name>keyentry_T</name> <modifier>*</modifier></type><name>ke_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name><name>struct</name> <name>sp_syn</name></name></type> <name>k_syn</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>next_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>k_char</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>keyword</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><struct>struct <name>buf_state</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>bs_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bs_flags</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CONCEAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>bs_seqnr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bs_cchar</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>reg_extmatch_T</name> <modifier>*</modifier></type><name>bs_extmatch</name></decl>;</decl_stmt> 
}</block></struct></type> <name>bufstate_T</name>;</typedef>





<typedef>typedef <type><name><name>struct</name> <name>syn_state</name></name></type> <name>synstate_T</name>;</typedef>

<struct>struct <name>syn_state</name>
<block>{
<decl_stmt><decl><type><name>synstate_T</name> <modifier>*</modifier></type><name>sst_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>sst_lnum</name></decl>;</decl_stmt> 
<union>union
<block>{
<decl_stmt><decl><type><name>bufstate_T</name></type> <name><name>sst_stack</name><index>[<expr><name>SST_FIX_STATES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sst_ga</name></decl>;</decl_stmt> 
}</block> <decl><name>sst_union</name></decl>;</union>
<decl_stmt><decl><type><name>int</name></type> <name>sst_next_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sst_stacksize</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name> <modifier>*</modifier></type><name>sst_next_list</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>disptick_T</name></type> <name>sst_tick</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>sst_change_lnum</name></decl>;</decl_stmt>

}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HL_ID</name></cpp:macro> <cpp:value>20000</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>attr_entry</name>
<block>{
<decl_stmt><decl><type><name>short</name></type> <name>ae_attr</name></decl>;</decl_stmt> 
<union>union
<block>{
<struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>stop</name></decl>;</decl_stmt> 
}</block> <decl><name>term</name></decl>;</struct>
<struct>struct
<block>{

<decl_stmt><decl><type><name>short_u</name></type> <name>fg_color</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short_u</name></type> <name>bg_color</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMGUICOLORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>guicolor_T</name></type> <name>fg_rgb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>guicolor_T</name></type> <name>bg_rgb</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>cterm</name></decl>;</struct>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct
<block>{
<decl_stmt><decl><type><name>guicolor_T</name></type> <name>fg_color</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>guicolor_T</name></type> <name>bg_color</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>guicolor_T</name></type> <name>sp_color</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>GuiFont</name></type> <name>font</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_XFONTSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>GuiFontset</name></type> <name>fontset</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>gui</name></decl>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block> <decl><name>ae_u</name></decl>;</union>
}</block></struct></type> <name>attrentry_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ICONV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ICONV_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;iconv.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_X</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/errno.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>EILSEQ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EILSEQ</name></cpp:macro> <cpp:value>ENOENT</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name><name>struct</name> <name>_iconv_t</name></name> <modifier>*</modifier></type><name>iconv_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><name>void</name> <modifier>*</modifier></type><name>iconv_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tb_buf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tb_noremap</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_buflen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_off</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_maplen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_silent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_no_abbr_cnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tb_change_cnt</name></decl>;</decl_stmt> 
}</block></struct></type> <name>typebuf_T</name>;</typedef>


<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>typebuf_T</name></type> <name>save_typebuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>typebuf_valid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>old_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>old_mod_mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buffheader_T</name></type> <name>save_readbuf1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buffheader_T</name></type> <name>save_readbuf2</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INPUT_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_inputbuf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>tasave_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>vc_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>vc_factor</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>vc_cpfrom</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>vc_cpto</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_ICONV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>iconv_t</name></type> <name>vc_fd</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>vc_fail</name></decl>;</decl_stmt> 
}</block></struct></type> <name>vimconv_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>hist_entry</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>hisnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>viminfo</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>hisstr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>time_t</name></type> <name>time_set</name></decl>;</decl_stmt> 
}</block></struct></type> <name>histentry_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_TO_UTF8</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_9_TO_UTF8</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_TO_LATIN1</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_TO_LATIN9</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_ICONV</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_CODEPAGE</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_X</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_MAC_LATIN1</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_LATIN1_MAC</name></cpp:macro> <cpp:value>21</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_MAC_UTF8</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_UTF8_MAC</name></cpp:macro> <cpp:value>23</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<typedef>typedef <type><name><name>struct</name> <name>mapblock</name></name></type> <name>mapblock_T</name>;</typedef>
<struct>struct <name>mapblock</name>
<block>{
<decl_stmt><decl><type><name>mapblock_T</name> <modifier>*</modifier></type><name>m_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>m_keys</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>m_str</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>m_orig_str</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>m_keylen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>m_mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>m_simplified</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>m_noremap</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>m_silent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>m_nowait</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name>m_expr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sctx_T</name></type> <name>m_script_ctx</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>




<struct>struct <name>stl_hlrec</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>userhl</name></decl>;</decl_stmt> 
}</block>;</struct>














<typedef>typedef <type><struct>struct <name>hashitem_S</name>
<block>{
<decl_stmt><decl><type><name>long_u</name></type> <name>hi_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>hi_key</name></decl>;</decl_stmt>
}</block></struct></type> <name>hashitem_T</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI_KEY_REMOVED</name></cpp:macro> <cpp:value>&amp;hash_removed</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HASHITEM_EMPTY</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((hi)-&gt;hi_key == NULL || (hi)-&gt;hi_key == &amp;hash_removed)</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HT_INIT_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>hashtable_S</name>
<block>{
<decl_stmt><decl><type><name>long_u</name></type> <name>ht_mask</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long_u</name></type> <name>ht_used</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long_u</name></type> <name>ht_filled</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ht_locked</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ht_error</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>ht_array</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>hashitem_T</name></type> <name><name>ht_smallarray</name><index>[<expr><name>HT_INIT_SIZE</name></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>hashtab_T</name>;</typedef>

<typedef>typedef <type><name>long_u</name></type> <name>hash_T</name>;</typedef> 



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<typedef>typedef <type><name>long</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>uvarnumber_T</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>LONG_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>LONG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>ULONG_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>__int64</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>__int64</name></type> <name>uvarnumber_T</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>_I64_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>_I64_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>_UI64_MAX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_NO_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDINT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>int64_t</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>uint64_t</name></type> <name>uvarnumber_T</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>INT64_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>INT64_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>UINT64_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>long</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name></type> <name>uvarnumber_T</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>LONG_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>LONG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>ULONG_MAX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<typedef>typedef <type><name>long</name> <name>long</name></type> <name>varnumber_T</name>;</typedef>
<typedef>typedef <type><name>unsigned</name> <name>long</name> <name>long</name></type> <name>uvarnumber_T</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>LLONG_MIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>LLONG_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>LLONG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>ULLONG_MAX</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MIN</name></cpp:macro> <cpp:value>LONG_LONG_MIN</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VARNUM_MAX</name></cpp:macro> <cpp:value>LONG_LONG_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UVARNUM_MAX</name></cpp:macro> <cpp:value>ULONG_LONG_MAX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name>double</name></type> <name>float_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>listvar_S</name></name></type> <name>list_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>dictvar_S</name></name></type> <name>dict_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>partial_S</name></name></type> <name>partial_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>blobvar_S</name></name></type> <name>blob_T</name>;</typedef>






<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cb_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>cb_partial</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cb_free_name</name></decl>;</decl_stmt> 
}</block></struct></type> <name>callback_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>isn_S</name></name></type> <name>isn_T</name>;</typedef> 
<typedef>typedef <type><name><name>struct</name> <name>dfunc_S</name></name></type> <name>dfunc_T</name>;</typedef> 

<typedef>typedef <type><name><name>struct</name> <name>jobvar_S</name></name></type> <name>job_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>readq_S</name></name></type> <name>readq_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>writeq_S</name></name></type> <name>writeq_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>jsonq_S</name></name></type> <name>jsonq_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>cbq_S</name></name></type> <name>cbq_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>channel_S</name></name></type> <name>channel_T</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>cctx_S</name></name></type> <name>cctx_T</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
<decl><name>VAR_UNKNOWN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 
<decl><name>VAR_VOID</name></decl>, 
<decl><name>VAR_BOOL</name></decl>, 
<decl><name>VAR_SPECIAL</name></decl>, 
<decl><name>VAR_NUMBER</name></decl>, 
<decl><name>VAR_FLOAT</name></decl>, 
<decl><name>VAR_STRING</name></decl>, 
<decl><name>VAR_BLOB</name></decl>, 
<decl><name>VAR_FUNC</name></decl>, 
<decl><name>VAR_PARTIAL</name></decl>, 
<decl><name>VAR_LIST</name></decl>, 
<decl><name>VAR_DICT</name></decl>, 
<decl><name>VAR_JOB</name></decl>, 
<decl><name>VAR_CHANNEL</name></decl>, 
}</block></enum></type> <name>vartype_T</name>;</typedef>


<typedef>typedef <type><name><name>struct</name> <name>type_S</name></name></type> <name>type_T</name>;</typedef>
<struct>struct <name>type_S</name> <block>{
<decl_stmt><decl><type><name>vartype_T</name></type> <name>tt_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>tt_argcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>tt_member</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>tt_args</name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>vartype_T</name></type> <name>v_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>v_lock</name></decl>;</decl_stmt> 
<union>union
<block>{
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>v_number</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>float_T</name></type> <name>v_float</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>v_string</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>v_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>v_dict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>v_partial</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>job_T</name> <modifier>*</modifier></type><name>v_job</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>v_channel</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>blob_T</name> <modifier>*</modifier></type><name>v_blob</name></decl>;</decl_stmt> 
}</block> <decl><name>vval</name></decl>;</union>
}</block></struct></type> <name>typval_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_SCOPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_DEF_SCOPE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_LOCKED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_FIXED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 




<typedef>typedef <type><name><name>struct</name> <name>listitem_S</name></name></type> <name>listitem_T</name>;</typedef>

<struct>struct <name>listitem_S</name>
<block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name></type> <name>li_tv</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><name><name>struct</name> <name>listwatch_S</name></name></type> <name>listwatch_T</name>;</typedef>

<struct>struct <name>listwatch_S</name>
<block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lw_item</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lw_next</name></decl>;</decl_stmt> 
}</block>;</struct>








<struct>struct <name>listvar_S</name>
<block>{
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_first</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listwatch_T</name> <modifier>*</modifier></type><name>lv_watch</name></decl>;</decl_stmt> 
<union>union <block>{
<struct>struct <block>{ 

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>lv_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>lv_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lv_stride</name></decl>;</decl_stmt>
}</block> <decl><name>nonmat</name></decl>;</struct>
<struct>struct <block>{ 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_last</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>lv_idx_item</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_idx</name></decl>;</decl_stmt> 
}</block> <decl><name>mat</name></decl>;</struct>
}</block> <decl><name>lv_u</name></decl>;</union>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_copylist</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_used_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>lv_used_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_len</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lv_with_items</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>lv_copyID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>lv_lock</name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>list_T</name></type> <name>sl_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name></type> <name><name>sl_items</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>staticList10_T</name>;</typedef>






<struct>struct <name>dictitem_S</name>
<block>{
<decl_stmt><decl><type><name>typval_T</name></type> <name>di_tv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>di_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>di_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>dictitem_S</name></name></type> <name>dictitem_T</name>;</typedef>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DICTITEM16_KEY_LEN</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<struct>struct <name>dictitem16_S</name>
<block>{
<decl_stmt><decl><type><name>typval_T</name></type> <name>di_tv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>di_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>di_key</name><index>[<expr><name>DICTITEM16_KEY_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>dictitem16_S</name></name></type> <name>dictitem16_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_RO</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_RO_SBX</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_FIX</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_LOCK</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_ALLOC</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DI_FLAGS_RELOAD</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 




<struct>struct <name>dictvar_S</name>
<block>{
<decl_stmt><decl><type><name>char</name></type> <name>dv_lock</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>dv_scope</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>dv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>dv_copyID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>dv_hashtab</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_copydict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_used_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dv_used_prev</name></decl>;</decl_stmt> 
}</block>;</struct>




<struct>struct <name>blobvar_S</name>
<block>{
<decl_stmt><decl><type><name>garray_T</name></type> <name>bv_ga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>bv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>bv_lock</name></decl>;</decl_stmt> 
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name><name>struct</name> <name>funccall_S</name></name></type> <name>funccall_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>uf_varargs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_calls</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_cleared</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_dfunc_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_args</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_def_args</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>uf_arg_types</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>uf_ret_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_type_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>uf_def_arg_idx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>uf_va_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>uf_va_type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>uf_lines</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>uf_profiling</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_prof_initialized</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>uf_tm_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_self</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tm_children</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>uf_tml_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name> <modifier>*</modifier></type><name>uf_tml_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name> <modifier>*</modifier></type><name>uf_tml_self</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_children</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>uf_tml_wait</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_tml_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>uf_tml_execed</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>sctx_T</name></type> <name>uf_script_ctx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>uf_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>funccall_T</name> <modifier>*</modifier></type><name>uf_scoped</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>uf_name_exp</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>uf_name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 


}</block></struct></type> <name>ufunc_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_FUNC_ARGS</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VAR_SHORT_LEN</name></cpp:macro> <cpp:value>20</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIXVAR_CNT</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define> 




<struct>struct <name>funccall_S</name>
<block>{
<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>func</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>linenr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>returned</name></decl>;</decl_stmt> 
<struct>struct 
<block>{
<decl_stmt><decl><type><name>dictitem_T</name></type> <name>var</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>room</name><index>[<expr><name>VAR_SHORT_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
}</block> <decl><name><name>fixvar</name><index>[<expr><name>FIXVAR_CNT</name></expr>]</index></name></decl>;</struct>
<decl_stmt><decl><type><name>dict_T</name></type> <name>l_vars</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dictitem_T</name></type> <name>l_vars_var</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name></type> <name>l_avars</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dictitem_T</name></type> <name>l_avars_var</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name></type> <name>l_varlist</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>listitem_T</name></type> <name><name>l_listitems</name><index>[<expr><name>MAX_FUNC_ARGS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>breakpoint</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>dbg_tick</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>level</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>prof_child</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>funccall_T</name> <modifier>*</modifier></type><name>caller</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>fc_refcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>fc_copyID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>fc_funcs</name></decl>;</decl_stmt> 

}</block>;</struct>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>fd_dict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fd_newkey</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>fd_di</name></decl>;</decl_stmt> 
}</block></struct></type> <name>funcdict_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>funccal_entry</name></name></type> <name>funccal_entry_T</name>;</typedef>
<struct>struct <name>funccal_entry</name> <block>{
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>top_funccal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>funccal_entry_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UF2HIKEY</name><parameter_list>(<parameter><type><name>fp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((fp)-&gt;uf_name)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIKEY2UF</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((ufunc_T *)((p) - offsetof(ufunc_T, uf_name)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2UF</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HIKEY2UF((hi)-&gt;hi_key)</cpp:value></cpp:define>





<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>dictitem_T</name></type> <name>sv_var</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name></type> <name>sv_dict</name></decl>;</decl_stmt>
}</block></struct></type> <name>scriptvar_T</name>;</typedef>




<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sv_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>sv_tv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>sv_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sv_const</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sv_export</name></decl>;</decl_stmt> 
}</block></struct></type> <name>svar_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>imp_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>imp_sid</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>imp_all</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>imp_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>imp_var_vals_idx</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>imp_funcname</name></decl>;</decl_stmt> 
}</block></struct></type> <name>imported_T</name>;</typedef>






<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sn_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scriptvar_T</name> <modifier>*</modifier></type><name>sn_vars</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sn_var_vals</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sn_imports</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sn_type_list</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sn_version</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sn_had_command</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sn_save_cpo</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>sn_prof_on</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sn_pr_force</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_pr_child</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sn_pr_nest</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sn_pr_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_pr_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_pr_self</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_pr_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_pr_children</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sn_prl_ga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_prl_start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_prl_children</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_prl_wait</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sn_prl_idx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sn_prl_execed</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>scriptitem_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>



<typedef>typedef <type><struct>struct <name>sn_prl_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>snp_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_prl_total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>sn_prl_self</name></decl>;</decl_stmt> 
}</block></struct></type> <name>sn_prl_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRL_ITEM</name><parameter_list>(<parameter><type><name>si</name></type></parameter>, <parameter><type><name>idx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sn_prl_T *)(si)-&gt;sn_prl_ga.ga_data)[(idx)])</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></struct></type> <name>ufunc_T</name>;</typedef>
<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></struct></type> <name>funccall_T</name>;</typedef>
<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></struct></type> <name>funcdict_T</name>;</typedef>
<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></struct></type> <name>funccal_entry_T</name>;</typedef>
<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block></struct></type> <name>scriptitem_T</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<typedef>typedef <type><struct>struct <block>{
<function_decl><type><name>int</name></type> (<modifier>*</modifier> <name>argv_func</name>)<parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>firstline</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lastline</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>doesrange</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>evaluate</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>partial</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>selfdict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>basetv</name></decl>;</decl_stmt> 
}</block></struct></type> <name>funcexe_T</name>;</typedef>

<struct>struct <name>partial_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>pt_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pt_name</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>pt_func</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>pt_auto</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>pt_argc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>pt_argv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>pt_dict</name></decl>;</decl_stmt> 
}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>AutoPatCmd_S</name></name></type> <name>AutoPatCmd</name>;</typedef>




<typedef>typedef <type><enum>enum <block>{
<decl><name>ETYPE_TOP</name></decl>, 
<decl><name>ETYPE_SCRIPT</name></decl>, 
<decl><name>ETYPE_UFUNC</name></decl>, 
<decl><name>ETYPE_AUCMD</name></decl>, 
<decl><name>ETYPE_MODELINE</name></decl>, 
<decl><name>ETYPE_EXCEPT</name></decl>, 
<decl><name>ETYPE_ARGS</name></decl>, 
<decl><name>ETYPE_ENV</name></decl>, 
<decl><name>ETYPE_INTERNAL</name></decl>, 
<decl><name>ETYPE_SPELL</name></decl>, 
}</block></enum></type> <name>etype_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>long</name></type> <name>es_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>es_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>etype_T</name></type> <name>es_type</name></decl>;</decl_stmt>
<union>union <block>{
<decl_stmt><decl><type><name>sctx_T</name> <modifier>*</modifier></type><name>sctx</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>AutoPatCmd</name> <modifier>*</modifier></type><name>aucmd</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>except_T</name> <modifier>*</modifier></type><name>except</name></decl>;</decl_stmt> 
}</block> <decl><name>es_info</name></decl>;</union>
}</block></struct></type> <name>estack_T</name>;</typedef>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>backspace</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>enter</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>interrupt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>nl_does_cr</name></decl>;</decl_stmt> 
}</block></struct></type> <name>ttyinfo_T</name>;</typedef>


<typedef>typedef <type><enum>enum
<block>{
<decl><name>JOB_FAILED</name></decl>,
<decl><name>JOB_STARTED</name></decl>,
<decl><name>JOB_ENDED</name></decl>, 
<decl><name>JOB_FINISHED</name></decl>, 
}</block></enum></type> <name>jobstatus_T</name>;</typedef>




<struct>struct <name>jobvar_S</name>
<block>{
<decl_stmt><decl><type><name>job_T</name> <modifier>*</modifier></type><name>jv_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>job_T</name> <modifier>*</modifier></type><name>jv_prev</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>pid_t</name></type> <name>jv_pid</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PROCESS_INFORMATION</name></type> <name>jv_proc_info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>jv_job_object</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jv_tty_in</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jv_tty_out</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>jobstatus_T</name></type> <name>jv_status</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jv_stoponexit</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jv_termsig</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jv_tty_type</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>jv_exitval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>jv_exit_cb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>jv_in_buf</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>jv_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>jv_copyID</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>jv_channel</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>jv_argv</name></decl>;</decl_stmt> 
}</block>;</struct>




<struct>struct <name>readq_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rq_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long_u</name></type> <name>rq_buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>readq_T</name> <modifier>*</modifier></type><name>rq_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>readq_T</name> <modifier>*</modifier></type><name>rq_prev</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>writeq_S</name>
<block>{
<decl_stmt><decl><type><name>garray_T</name></type> <name>wq_ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>writeq_T</name> <modifier>*</modifier></type><name>wq_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>writeq_T</name> <modifier>*</modifier></type><name>wq_prev</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>jsonq_S</name>
<block>{
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>jq_value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jsonq_T</name> <modifier>*</modifier></type><name>jq_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>jsonq_T</name> <modifier>*</modifier></type><name>jq_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jq_no_callback</name></decl>;</decl_stmt> 
}</block>;</struct>

<struct>struct <name>cbq_S</name>
<block>{
<decl_stmt><decl><type><name>callback_T</name></type> <name>cq_callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cq_seq_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cbq_T</name> <modifier>*</modifier></type><name>cq_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cbq_T</name> <modifier>*</modifier></type><name>cq_prev</name></decl>;</decl_stmt>
}</block>;</struct>


<typedef>typedef <type><enum>enum
<block>{
<decl><name>MODE_NL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>MODE_RAW</name></decl>,
<decl><name>MODE_JSON</name></decl>,
<decl><name>MODE_JS</name></decl>,
}</block></enum></type> <name>ch_mode_T</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
<decl><name>JIO_PIPE</name></decl>, 
<decl><name>JIO_NULL</name></decl>,
<decl><name>JIO_FILE</name></decl>,
<decl><name>JIO_BUFFER</name></decl>,
<decl><name>JIO_OUT</name></decl>
}</block></enum></type> <name>job_io_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CH_PART_FD</name><parameter_list>(<parameter><type><name>part</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>ch_part[part].ch_fd</cpp:value></cpp:define>



<typedef>typedef <type><enum>enum <block>{
<decl><name>PART_SOCK</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CH_SOCK_FD</name></cpp:macro> <cpp:value>CH_PART_FD(PART_SOCK)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl><name>PART_OUT</name></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CH_OUT_FD</name></cpp:macro> <cpp:value>CH_PART_FD(PART_OUT)</cpp:value></cpp:define>
<decl><name>PART_ERR</name></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CH_ERR_FD</name></cpp:macro> <cpp:value>CH_PART_FD(PART_ERR)</cpp:value></cpp:define>
<decl><name>PART_IN</name></decl>,
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CH_IN_FD</name></cpp:macro> <cpp:value>CH_PART_FD(PART_IN)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl><name>PART_COUNT</name></decl>,
}</block></enum></type> <name>ch_part_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FD</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>sock_T</name></type> <name>ch_fd</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SELECT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ch_poll_idx</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_X11</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XtInputId</name></type> <name>ch_inputHandler</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>gint</name></type> <name>ch_inputHandler</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ch_mode_T</name></type> <name>ch_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>job_io_T</name></type> <name>ch_io</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch_timeout</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>readq_T</name></type> <name>ch_head</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>jsonq_T</name></type> <name>ch_json_head</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>ch_block_ids</name></decl>;</decl_stmt> 





<decl_stmt><decl><type><name>size_t</name></type> <name>ch_wait_len</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>DWORD</name></type> <name>ch_deadline</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>ch_deadline</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>ch_block_write</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ch_nonblocking</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>writeq_T</name></type> <name>ch_writeque</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>cbq_T</name></type> <name>ch_cb_head</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>callback_T</name></type> <name>ch_callback</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bufref_T</name></type> <name>ch_bufref</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_nomodifiable</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_nomod_error</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_buf_append</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ch_buf_top</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>ch_buf_bot</name></decl>;</decl_stmt> 
}</block></struct></type> <name>chanpart_T</name>;</typedef>

<struct>struct <name>channel_S</name> <block>{
<decl_stmt><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>ch_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>ch_prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ch_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_last_msg_id</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>chanpart_T</name></type> <name><name>ch_part</name><index>[<expr><name>PART_COUNT</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_write_text_mode</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ch_hostname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_port</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ch_to_be_closed</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>ch_to_be_freed</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ch_error</name></decl>;</decl_stmt> 





<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>ch_nb_close_cb</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ch_named_pipe</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>callback_T</name></type> <name>ch_callback</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>callback_T</name></type> <name>ch_close_cb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_drop_never</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ch_keep_open</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_nonblock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>job_T</name> <modifier>*</modifier></type><name>ch_job</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>ch_job_killed</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ch_anonymous_pipe</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_killing</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ch_refcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ch_copyID</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_MODE</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_MODE</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_MODE</name></cpp:macro> <cpp:value>0x0004</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_MODE</name></cpp:macro> <cpp:value>0x0008</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_CALLBACK</name></cpp:macro> <cpp:value>0x0010</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_CALLBACK</name></cpp:macro> <cpp:value>0x0020</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_CALLBACK</name></cpp:macro> <cpp:value>0x0040</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_CLOSE_CALLBACK</name></cpp:macro> <cpp:value>0x0080</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_WAITTIME</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_TIMEOUT</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_TIMEOUT</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_TIMEOUT</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_PART</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ID</name></cpp:macro> <cpp:value>0x2000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_STOPONEXIT</name></cpp:macro> <cpp:value>0x4000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_EXIT_CB</name></cpp:macro> <cpp:value>0x8000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_IO</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_IO</name></cpp:macro> <cpp:value>0x20000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_IO</name></cpp:macro> <cpp:value>0x40000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_NAME</name></cpp:macro> <cpp:value>0x80000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_NAME</name></cpp:macro> <cpp:value>0x100000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_NAME</name></cpp:macro> <cpp:value>0x200000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_TOP</name></cpp:macro> <cpp:value>0x400000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_BOT</name></cpp:macro> <cpp:value>0x800000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_BUF</name></cpp:macro> <cpp:value>0x1000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_BUF</name></cpp:macro> <cpp:value>0x2000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_IN_BUF</name></cpp:macro> <cpp:value>0x4000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_CHANNEL</name></cpp:macro> <cpp:value>0x8000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_BLOCK_WRITE</name></cpp:macro> <cpp:value>0x10000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_OUT_MODIFIABLE</name></cpp:macro> <cpp:value>0x20000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ERR_MODIFIABLE</name></cpp:macro> <cpp:value>0x40000000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_ALL</name></cpp:macro> <cpp:value>0x7fffffff</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_OUT_MSG</name></cpp:macro> <cpp:value>0x0001</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_ERR_MSG</name></cpp:macro> <cpp:value>0x0002</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_NAME</name></cpp:macro> <cpp:value>0x0004</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_FINISH</name></cpp:macro> <cpp:value>0x0008</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_ENV</name></cpp:macro> <cpp:value>0x0010</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_CWD</name></cpp:macro> <cpp:value>0x0020</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_ROWS</name></cpp:macro> <cpp:value>0x0040</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_COLS</name></cpp:macro> <cpp:value>0x0080</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_VERTICAL</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_CURWIN</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_HIDDEN</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_OPENCMD</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_EOF_CHARS</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_NORESTORE</name></cpp:macro> <cpp:value>0x2000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_KILL</name></cpp:macro> <cpp:value>0x4000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_ANSI_COLORS</name></cpp:macro> <cpp:value>0x8000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TTY_TYPE</name></cpp:macro> <cpp:value>0x10000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_BUFNR</name></cpp:macro> <cpp:value>0x20000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_API</name></cpp:macro> <cpp:value>0x40000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO2_TERM_HIGHLIGHT</name></cpp:macro> <cpp:value>0x80000</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_MODE_ALL</name></cpp:macro> <cpp:value>(JO_MODE + JO_IN_MODE + JO_OUT_MODE + JO_ERR_MODE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_CB_ALL</name></cpp:macro> <cpp:value>(JO_CALLBACK + JO_OUT_CALLBACK + JO_ERR_CALLBACK + JO_CLOSE_CALLBACK)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JO_TIMEOUT_ALL</name></cpp:macro> <cpp:value>(JO_TIMEOUT + JO_OUT_TIMEOUT + JO_ERR_TIMEOUT)</cpp:value></cpp:define>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>jo_set</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>jo_set2</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>ch_mode_T</name></type> <name>jo_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ch_mode_T</name></type> <name>jo_in_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ch_mode_T</name></type> <name>jo_out_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ch_mode_T</name></type> <name>jo_err_mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_noblock</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>job_io_T</name></type> <name><name>jo_io</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_io_name_buf</name><index>[<expr><literal type="number">4</literal></expr>]</index><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name><name>jo_io_name</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>jo_io_buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_pty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>jo_modifiable</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>jo_message</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>jo_channel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>jo_in_top</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>jo_in_bot</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>callback_T</name></type> <name>jo_callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>jo_out_cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>jo_err_cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>jo_close_cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>jo_exit_cb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_drop_never</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_waittime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_out_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_err_timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_block_write</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>jo_part</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_stoponexit_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_stoponexit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>jo_env</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_cwd_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_cwd</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMINAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>jo_term_rows</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_term_cols</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_vertical</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_curwin</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>jo_bufnr_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_hidden</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_term_norestore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_term_name_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_term_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_term_opencmd_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_term_opencmd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_term_finish</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_eof_chars_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_eof_chars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_term_kill_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_term_kill</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMGUICOLORS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long_u</name></type> <name><name>jo_ansi_colors</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_term_highlight_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_term_highlight</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>jo_tty_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>jo_term_api_buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jo_term_api</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>jobopt_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>



<typedef>typedef <type><name><name>struct</name> <name>listener_S</name></name></type> <name>listener_T</name>;</typedef>
<struct>struct <name>listener_S</name>
<block>{
<decl_stmt><decl><type><name>listener_T</name> <modifier>*</modifier></type><name>lr_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lr_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>callback_T</name></type> <name>lr_callback</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<typedef>typedef <type><struct>struct <name>ht_stack_S</name>
<block>{
<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>ht_stack_S</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>ht_stack_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>list_stack_S</name>
<block>{
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name><name>struct</name> <name>list_stack_S</name></name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
}</block></struct></type> <name>list_stack_T</name>;</typedef>





<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>long_u</name></type> <name>dit_todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>dit_hi</name></decl>;</decl_stmt>
}</block></struct></type> <name>dict_iterator_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNSPL_DEFAULT</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNSPL_TOP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYNSPL_NOTOP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_SPELL</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((buf)-&gt;b_spell)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_SPELL</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>qf_info_S</name></name></type> <name>qf_info_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>proftime_T</name></type> <name>total</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>proftime_T</name></type> <name>slowest</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>match</name></decl>;</decl_stmt> 
}</block></struct></type> <name>syn_time_T</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><name><name>struct</name> <name>timer_S</name></name></type> <name>timer_T</name>;</typedef>
<struct>struct <name>timer_S</name>
<block>{
<decl_stmt><decl><type><name>long</name></type> <name>tr_id</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TIMERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>timer_T</name> <modifier>*</modifier></type><name>tr_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>timer_T</name> <modifier>*</modifier></type><name>tr_prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>tr_due</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>tr_firing</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>tr_paused</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tr_repeat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>tr_interval</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>callback_T</name></type> <name>tr_callback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tr_emsg_count</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>




<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>method_nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>method_state</name></decl>;</decl_stmt> 
}</block></struct></type> <name>cryptstate_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_M_ZIP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_M_BF</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_M_BF2</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CRYPT_M_COUNT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 




<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROP_POPUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><enum>enum <block>{
<decl><name>POPPOS_BOTLEFT</name></decl>,
<decl><name>POPPOS_TOPLEFT</name></decl>,
<decl><name>POPPOS_BOTRIGHT</name></decl>,
<decl><name>POPPOS_TOPRIGHT</name></decl>,
<decl><name>POPPOS_CENTER</name></decl>,
<decl><name>POPPOS_NONE</name></decl>
}</block></enum></type> <name>poppos_T</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{
<decl><name>POPCLOSE_NONE</name></decl>,
<decl><name>POPCLOSE_BUTTON</name></decl>,
<decl><name>POPCLOSE_CLICK</name></decl>
}</block></enum></type> <name>popclose_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPUPWIN_DEFAULT_ZINDEX</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPUPMENU_ZINDEX</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPUPWIN_DIALOG_ZINDEX</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>POPUPWIN_NOTIFICATION_ZINDEX</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<typedef>typedef <type><struct>struct <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>b_keywtab</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>b_keywtab_ic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_error</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RELTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_slow</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_ic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_spell</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>b_syn_patterns</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>b_syn_clusters</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_spell_cluster_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_nospell_cluster_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_containedin</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>b_syn_sync_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>b_syn_sync_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>b_syn_sync_minlines</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>b_syn_sync_maxlines</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>b_syn_sync_linebreaks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_syn_linecont_pat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>b_syn_linecont_prog</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>syn_time_T</name></type> <name>b_syn_linecont_time</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_linecont_ic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_topgrp</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CONCEAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_conceal</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>b_syn_folditems</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>














<decl_stmt><decl><type><name>synstate_T</name> <modifier>*</modifier></type><name>b_sst_array</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_sst_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>synstate_T</name> <modifier>*</modifier></type><name>b_sst_first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>synstate_T</name> <modifier>*</modifier></type><name>b_sst_firstfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_sst_freecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>b_sst_check_lnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short_u</name></type> <name>b_sst_lasttick</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>garray_T</name></type> <name>b_langp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>b_spell_ismw</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_spell_ismw_mb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_p_spc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>b_cap_prog</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_p_spf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_p_spl</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_cjk</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>b_syn_chartab</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_syn_isk</name></decl>;</decl_stmt> 
}</block></struct></type> <name>synblock_T</name>;</typedef>










<struct>struct <name>file_buffer</name>
<block>{
<decl_stmt><decl><type><name>memline_T</name></type> <name>b_ml</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>b_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>b_prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>b_nwindows</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>b_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_locked</name></decl>;</decl_stmt> 








<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_ffname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_sfname</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b_fname</name></decl>;</decl_stmt> 


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>b_dev_valid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dev_t</name></type> <name>b_dev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>ino_t</name></type> <name>b_ino</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CW_EDITOR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>FSSpec</name></type> <name>b_FSSpec</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name>b_fab_rfm</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>b_fab_rat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>b_fab_mrs</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>b_fnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>b_key</name><index>[<expr><name>VIM_SIZEOF_INT</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>int</name></type> <name>b_changed</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>dictitem16_T</name></type> <name>b_ct_di</name></decl>;</decl_stmt> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHANGEDTICK</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((buf)-&gt;b_ct_di.di_tv.vval.v_number)</cpp:value></cpp:define>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>b_last_changedtick</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>b_last_changedtick_pum</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>b_saving</name></decl>;</decl_stmt> 






<decl_stmt><decl><type><name>int</name></type> <name>b_mod_set</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>linenr_T</name></type> <name>b_mod_top</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>b_mod_bot</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>b_mod_xlines</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>wininfo_T</name> <modifier>*</modifier></type><name>b_wininfo</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>b_mtime</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>b_mtime_read</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>off_T</name></type> <name>b_orig_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_orig_mode</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VIMINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>time_T</name></type> <name>b_last_used</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>pos_T</name></type> <name><name>b_namedm</name><index>[<expr><name>NMARKS</name></expr>]</index></name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>visualinfo_T</name></type> <name>b_visual</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>b_visual_mode_eval</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>pos_T</name></type> <name>b_last_cursor</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>pos_T</name></type> <name>b_last_insert</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>b_last_change</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JUMPLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name>pos_T</name></type> <name><name>b_changelist</name><index>[<expr><name>JUMPLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b_changelistlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>b_new_change</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><name>char_u</name></type> <name><name>b_chartab</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>mapblock_T</name> <argument_list>*<argument><expr><operator>(</operator><name><name>b_maphash</name><index>[<expr><literal type="number">256</literal></expr>]</index></name><operator>)</operator></expr></argument>;


<argument><expr><name>mapblock_T</name> <operator>*</operator><name>b_first_abbr</name></expr></argument>;


<argument><expr><name>garray_T</name> <name>b_ucmds</name></expr></argument>;

<argument><expr><name>pos_T</name> <name>b_op_start</name></expr></argument>;
<argument><expr><name>pos_T</name> <name>b_op_start_orig</name></expr></argument>; 
<argument><expr><name>pos_T</name> <name>b_op_end</name></expr></argument>;

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VIMINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_marks_read</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<argument><expr><name>u_header_T</name> <operator>*</operator><name>b_u_oldhead</name></expr></argument>; 
<argument><expr><name>u_header_T</name> <operator>*</operator><name>b_u_newhead</name></expr></argument>; 

<argument><expr><name>u_header_T</name> <operator>*</operator><name>b_u_curhead</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_u_numhead</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_u_synced</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_u_seq_last</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_u_save_nr_last</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_u_seq_cur</name></expr></argument>; 
<argument><expr><name>time_T</name> <name>b_u_time_cur</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_u_save_nr_cur</name></expr></argument>; 




<argument><expr><name>undoline_T</name> <name>b_u_line_ptr</name></expr></argument>; 
<argument><expr><name>linenr_T</name> <name>b_u_line_lnum</name></expr></argument>; 
<argument><expr><name>colnr_T</name> <name>b_u_line_colnr</name></expr></argument>; 

<argument><expr><name>int</name> <name>b_scanned</name></expr></argument>; 


<argument><expr><name>long</name> <name>b_p_iminsert</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_imsearch</name></expr></argument>; 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_IMODE_USE_INSERT</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_IMODE_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_IMODE_LMAP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_IMODE_IM</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_IMODE_LAST</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_KEYMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>short</name> <name>b_kmap_state</name></expr></argument>; 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEYMAP_INIT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEYMAP_LOADED</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<argument><expr><name>garray_T</name> <name>b_kmap_ga</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<argument><expr><name>int</name> <name>b_p_initialized</name></expr></argument>; 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>sctx_T</name> <name><name>b_p_script_ctx</name><index>[<expr><name>BV_COUNT</name></expr>]</index></name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>int</name> <name>b_p_ai</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ai_nopaste</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_bkc</name></expr></argument>; 
<argument><expr><name>unsigned</name> <name>b_bkc_flags</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ci</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_bin</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_bomb</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_bh</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_bt</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_HAS_QF_ENTRY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF_HAS_LL_ENTRY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<argument><expr><name>int</name> <name>b_has_qf_entry</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>int</name> <name>b_p_bl</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CINDENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_p_cin</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cino</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cink</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CINDENT</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SMARTINDENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cinw</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_com</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cms</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cpt</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_csl</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_COMPL_FUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cfu</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_ofu</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_tfu</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>int</name> <name>b_p_eol</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_fixeol</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_et</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_et_nobin</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_et_nopaste</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_fenc</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_ff</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_ft</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_fo</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_flp</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_inf</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_isk</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FIND_ID</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_def</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_inc</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_inex</name></expr></argument>; 
<argument><expr><name>long_u</name> <name>b_p_inex_flags</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CINDENT</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_inde</name></expr></argument>; 
<argument><expr><name>long_u</name> <name>b_p_inde_flags</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_indk</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_fp</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_fex</name></expr></argument>; 
<argument><expr><name>long_u</name> <name>b_p_fex_flags</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_key</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_kp</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LISP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_p_lisp</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_menc</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_mps</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ml</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ml_nobin</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ma</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_nf</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_pi</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TEXTOBJ</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_qe</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>int</name> <name>b_p_ro</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_sw</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_sn</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SMARTINDENT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_p_si</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>long</name> <name>b_p_sts</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_sts_nopaste</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCHPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_sua</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>int</name> <name>b_p_swf</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>long</name> <name>b_p_smc</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_syn</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>long</name> <name>b_p_ts</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_tx</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_tw</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_tw_nobin</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_tw_nopaste</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_wm</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_wm_nobin</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_wm_nopaste</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VARTABS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_vsts</name></expr></argument>; 
<argument><expr><name>int</name> <operator>*</operator><name>b_p_vsts_array</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_vsts_nopaste</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_vts</name></expr></argument>; 
<argument><expr><name>int</name> <operator>*</operator><name>b_p_vts_array</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_KEYMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_keymap</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_gp</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_mp</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_efm</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_ep</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_path</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_p_ar</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_tags</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_tc</name></expr></argument>; 
<argument><expr><name>unsigned</name> <name>b_tc_flags</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_dict</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_tsr</name></expr></argument>; 
<argument><expr><name>long</name> <name>b_p_ul</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PERSISTENT_UNDO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_p_udf</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LISP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_lw</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMINAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>long</name> <name>b_p_twsl</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CINDENT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<argument><expr><name>int</name> <name>b_ind_level</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_open_imag</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_no_brace</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_first_open</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_open_extra</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_close_extra</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_open_left_imag</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_jump_label</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_case</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_case_code</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_case_break</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_param</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_func_type</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_comment</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_in_comment</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_in_comment2</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_cpp_baseclass</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_continuation</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_unclosed</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_unclosed2</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_unclosed_noignore</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_unclosed_wrapped</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_unclosed_whiteok</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_matching_paren</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_paren_prev</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_maxparen</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_maxcomment</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_scopedecl</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_scopedecl_code</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_java</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_js</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_keep_case_label</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_hash_comment</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_cpp_namespace</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_if_for_while</name></expr></argument>;
<argument><expr><name>int</name> <name>b_ind_cpp_extern_c</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>linenr_T</name> <name>b_no_eol_lnum</name></expr></argument>; 


<argument><expr><name>int</name> <name>b_start_eol</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_start_ffc</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>b_start_fenc</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_bad_char</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_start_bomb</name></expr></argument>; 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>dictitem_T</name> <name>b_bufvar</name></expr></argument>; 
<argument><expr><name>dict_T</name> <operator>*</operator><name>b_vars</name></expr></argument>; 

<argument><expr><name>listener_T</name> <operator>*</operator><name>b_listener</name></expr></argument>;
<argument><expr><name>list_T</name> <operator>*</operator><name>b_recorded_changes</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROP_POPUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_has_textprop</name></expr></argument>; 
<argument><expr><name>hashtab_T</name> <operator>*</operator><name>b_proptypes</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BEVAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_bexpr</name></expr></argument>; 
<argument><expr><name>long_u</name> <name>b_p_bexpr_flags</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_p_cm</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<argument><expr><name>int</name> <name>b_may_swap</name></expr></argument>;
<argument><expr><name>int</name> <name>b_did_warn</name></expr></argument>; 






<argument><expr><name>int</name> <name>b_help</name></expr></argument>; 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_spell</name></expr></argument>; 


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>int</name> <name>b_shortname</name></expr></argument>; 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>char_u</name> <operator>*</operator><name>b_prompt_text</name></expr></argument>; 
<argument><expr><name>callback_T</name> <name>b_prompt_callback</name></expr></argument>; 
<argument><expr><name>callback_T</name> <name>b_prompt_interrupt</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_prompt_insert</name></expr></argument>; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_mzscheme_ref</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PERL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_perl_private</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_python_ref</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_python3_ref</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TCL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_tcl_ref</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>b_ruby_ref</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>synblock_T</name> <name>b_s</name></expr></argument>; 


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>sign_entry_T</name> <operator>*</operator><name>b_signlist</name></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_NETBEANS_INTG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_has_sign_column</name></expr></argument>; 


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_NETBEANS_INTG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_netbeans_file</name></expr></argument>; 
<argument><expr><name>int</name> <name>b_was_netbeans_file</name></expr></argument>;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_write_to_channel</name></expr></argument>; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>cryptstate_T</name> <operator>*</operator><name>b_cryptstate</name></expr></argument>; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>int</name> <name>b_mapped_ctrl_c</name></expr></argument>; 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMINAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>term_T</name> <operator>*</operator><name>b_term</name></expr></argument>; 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>int</name> <name>b_diff_failed</name></expr></argument>;</argument_list></call></expr></expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct> 


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB_COUNT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 















<typedef>typedef <type><name><name>struct</name> <name>diffblock_S</name></name></type> <name>diff_T</name>;</typedef>
<struct>struct <name>diffblock_S</name>
<block>{
<decl_stmt><decl><type><name>diff_T</name> <modifier>*</modifier></type><name>df_next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name><name>df_lnum</name><index>[<expr><name>DB_COUNT</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name><name>df_count</name><index>[<expr><name>DB_COUNT</name></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAP_HELP_IDX</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAP_AUCMD_IDX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNAP_COUNT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>







<typedef>typedef <type><name><name>struct</name> <name>tabpage_S</name></name></type> <name>tabpage_T</name>;</typedef>
<struct>struct <name>tabpage_S</name>
<block>{
<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>tp_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>tp_topframe</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>tp_curwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>tp_prevwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>tp_firstwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>tp_lastwin</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROP_POPUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>tp_first_popupwin</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>long</name></type> <name>tp_old_Rows</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>tp_old_Columns</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>tp_ch_used</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name><name>tp_prev_which_scrollbars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tp_localdir</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>diff_T</name> <modifier>*</modifier></type><name>tp_first_diff</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>buf_T</name> <argument_list>*<argument><expr><operator>(</operator><name><name>tp_diffbuf</name><index>[<expr><name>DB_COUNT</name></expr>]</index></name><operator>)</operator></expr></argument>;
<argument><expr><name>int</name> <name>tp_diff_invalid</name></expr></argument>; 
<argument><expr><name>int</name> <name>tp_diff_update</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<argument><expr><name>frame_T</name> <operator>*</operator><operator>(</operator><name><name>tp_snapshot</name><index>[<expr><name>SNAP_COUNT</name></expr>]</index></name><operator>)</operator></expr></argument>; 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>dictitem_T</name> <name>tp_winvar</name></expr></argument>; 
<argument><expr><name>dict_T</name> <operator>*</operator><name>tp_vars</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>tp_python_ref</name></expr></argument>; 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><name>void</name> <operator>*</operator><name>tp_python3_ref</name></expr></argument>;</argument_list></call></expr></expr_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>













<typedef>typedef <type><struct>struct <name>w_line</name>
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>wl_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short_u</name></type> <name>wl_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>wl_valid</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name>wl_folded</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>wl_lastlnum</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>wline_T</name>;</typedef>





<struct>struct <name>frame_S</name>
<block>{
<decl_stmt><decl><type><name>char</name></type> <name>fr_layout</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>fr_width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fr_newwidth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>fr_height</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fr_newheight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>fr_parent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>fr_next</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>fr_prev</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>fr_child</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>fr_win</name></decl>;</decl_stmt> 
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FR_LEAF</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FR_ROW</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FR_COL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 







<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>regmmatch_T</name></type> <name>rm</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>attr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>attr_cur</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>first_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>startcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>endcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>is_addpos</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RELTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>tm</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>match_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXPOSMATCH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>col</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt> 
}</block></struct></type> <name>llpos_T</name>;</typedef>





<typedef>typedef <type><name><name>struct</name> <name>posmatch</name></name></type> <name>posmatch_T</name>;</typedef>
<struct>struct <name>posmatch</name>
<block>{
<decl_stmt><decl><type><name>llpos_T</name></type> <name><name>pos</name><index>[<expr><name>MAXPOSMATCH</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cur</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>toplnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>botlnum</name></decl>;</decl_stmt> 
}</block>;</struct>





<typedef>typedef <type><name><name>struct</name> <name>matchitem</name></name></type> <name>matchitem_T</name>;</typedef>
<struct>struct <name>matchitem</name>
<block>{
<decl_stmt><decl><type><name>matchitem_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>priority</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regmmatch_T</name></type> <name>match</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>posmatch_T</name></type> <name>pos</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>match_T</name></type> <name>hl</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>hlg_id</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CONCEAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>conceal_char</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>



<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>w_topline_save</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_topline_corr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>w_cursor_save</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>w_cursor_corr</name></decl>;</decl_stmt> 
}</block></struct></type> <name>pos_save_T</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>wb_startcol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wb_endcol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type><name>wb_menu</name></decl>;</decl_stmt>
}</block></struct></type> <name>winbar_item_T</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<struct>struct <name>window_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>w_id</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>w_buffer</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w_prev</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w_next</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>synblock_T</name> <modifier>*</modifier></type><name>w_s</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>w_closing</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>frame_T</name> <modifier>*</modifier></type><name>w_frame</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>pos_T</name></type> <name>w_cursor</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_curswant</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>int</name></type> <name>w_set_curswant</name></decl>;</decl_stmt> 



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_last_cursorline</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<decl_stmt><decl><type><name>char</name></type> <name>w_old_visual_mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_old_cursor_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_old_cursor_fcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_old_cursor_lcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_old_visual_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_old_visual_col</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_old_curswant</name></decl>;</decl_stmt> 





<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_topline</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name></type> <name>w_topline_was_set</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_topfill</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_old_topfill</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_botfill</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_old_botfill</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_leftcol</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_skipcol</name></decl>;</decl_stmt> 






<decl_stmt><decl><type><name>int</name></type> <name>w_winrow</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_height</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_status_height</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_wincol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_width</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_vsep_width</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_save_T</name></type> <name>w_save_cursor</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROP_POPUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_handled</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w_popup_title</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>poppos_T</name></type> <name>w_popup_pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_fixed</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_prop_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w_popup_prop_win</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_prop_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_zindex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w_minheight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_minwidth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_maxheight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_maxwidth</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_wantline</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_wantcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_firstline</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_want_scrollbar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_has_scrollbar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w_scrollbar_highlight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w_thumb_highlight</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>w_popup_padding</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>w_popup_border</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name><name>w_border_highlight</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>w_border_char</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_popup_leftoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_rightoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>w_popup_last_changedtick</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>w_popup_prop_changedtick</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>w_popup_prop_topline</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_popup_last_curline</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>callback_T</name></type> <name>w_close_cb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>callback_T</name></type> <name>w_filter_cb</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_filter_mode</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w_popup_curwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_popup_lnum</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_popup_mincol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_popup_maxcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_mouse_row</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_mouse_mincol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_mouse_maxcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>popclose_T</name></type> <name>w_popup_close</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>w_popup_mask</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w_popup_mask_cells</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_mask_height</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_popup_mask_width</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TIMERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>timer_T</name> <modifier>*</modifier></type><name>w_popup_timer</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<decl_stmt><decl><type><name>int</name></type> <name>w_valid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name></type> <name>w_valid_cursor</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_valid_leftcol</name></decl>;</decl_stmt> 





<decl_stmt><decl><type><name>int</name></type> <name>w_cline_height</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_cline_folded</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>w_cline_row</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_virtcol</name></decl>;</decl_stmt> 











<decl_stmt><decl><type><name>int</name></type> <name>w_wrow</name></decl>, <decl><type ref="prev"/><name>w_wcol</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_botline</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_empty_rows</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_filler_rows</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>











<decl_stmt><decl><type><name>int</name></type> <name>w_lines_valid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>wline_T</name> <modifier>*</modifier></type><name>w_lines</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>garray_T</name></type> <name>w_folds</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>w_fold_manual</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name></type> <name>w_foldinvalid</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_nrwidth</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>





<decl_stmt><decl><type><name>int</name></type> <name>w_redr_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_upd_rows</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_redraw_top</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_redraw_bot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_redr_status</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CMDL_INFO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>pos_T</name></type> <name>w_ru_cursor</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>w_ru_virtcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_ru_topline</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_ru_line_count</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_ru_topfill</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char</name></type> <name>w_ru_empty</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>w_alt_fnum</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>alist_T</name> <modifier>*</modifier></type><name>w_alist</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_arg_idx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_arg_idx_invalid</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w_localdir</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type><name>w_winbar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>winbar_item_T</name> <modifier>*</modifier></type><name>w_winbar_items</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_winbar_height</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>








<decl_stmt><decl><type><name>winopt_T</name></type> <name>w_onebuf_opt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>winopt_T</name></type> <name>w_allbuf_opt</name></decl>;</decl_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_STL_OPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long_u</name></type> <name>w_p_stl_flags</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>long_u</name></type> <name>w_p_fde_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long_u</name></type> <name>w_p_fdt_flags</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>w_p_cc_cols</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>w_p_culopt_flags</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>long</name></type> <name>w_p_siso</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>w_p_so</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>w_briopt_min</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_briopt_shift</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_briopt_sbr</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GLOBAL_WO</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((char *)p + sizeof(winopt_T))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>long</name></type> <name>w_scbind_pos</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>dictitem_T</name></type> <name>w_winvar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>w_vars</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>






<decl_stmt><decl><type><name>pos_T</name></type> <name>w_pcmark</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>w_prev_pcmark</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JUMPLIST</name></expr></argument>)</argument_list></call></expr></cpp:if>



<decl_stmt><decl><type><name>xfmark_T</name></type> <name><name>w_jumplist</name><index>[<expr><name>JUMPLISTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w_jumplistlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_jumplistidx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>w_changelistidx</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCH_EXTRA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>matchitem_T</name> <modifier>*</modifier></type><name>w_match_head</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_next_match_id</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>







<decl_stmt><decl><type><name>taggy_T</name></type> <name><name>w_tagstack</name><index>[<expr><name>TAGSTACKSIZE</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_tagstackidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_tagstacklen</name></decl>;</decl_stmt> 







<decl_stmt><decl><type><name>int</name></type> <name>w_fraction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>w_prev_fraction_row</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>scrollbar_T</name></type> <name><name>w_scrollbars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>w_nrwidth_line_count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>w_nuw_cached</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>w_nrwidth_width</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>w_llist</name></decl>;</decl_stmt> 




<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>w_llist_ref</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_mzscheme_ref</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PERL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_perl_private</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_python_ref</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PYTHON3</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_python3_ref</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TCL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_tcl_ref</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RUBY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>w_ruby_ref</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>




<typedef>typedef <type><struct>struct <name>oparg_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>op_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>regname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>motion_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>motion_force</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>use_reg_one</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>inclusive</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>end_adjusted</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>pos_T</name></type> <name>start</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>pos_T</name></type> <name>cursor_start</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>line_count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>empty</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>is_VIsual</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>block_mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>start_vcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>end_vcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>prev_opcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>prev_count0</name></decl>;</decl_stmt> 
}</block></struct></type> <name>oparg_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>cmdarg_S</name>
<block>{
<decl_stmt><decl><type><name>oparg_T</name> <modifier>*</modifier></type><name>oap</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>prechar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>cmdchar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>nchar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ncharC1</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ncharC2</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>extra_char</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>opcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>count0</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>count1</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>arg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>searchbuf</name></decl>;</decl_stmt> 
}</block></struct></type> <name>cmdarg_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CA_COMMAND_BUSY</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CA_NO_ADJ_OP_END</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURSOR_SHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_N</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_V</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_I</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_R</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_C</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_CI</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_CR</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_O</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_VE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_CLINE</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_STATUS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_SDRAG</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_VSEP</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_VDRAG</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_MORE</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_MOREL</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_SM</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_IDX_COUNT</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_BLOCK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_HOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_VER</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSHAPE_NUMBERED</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MSHAPE_HIDE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_MOUSE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHAPE_CURSOR</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<typedef>typedef <type><struct>struct <name>cursor_entry</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>shape</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>mshape</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>percentage</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>blinkwait</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>blinkon</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>blinkoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>id_lm</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>used_for</name></decl>;</decl_stmt> 
}</block></struct></type> <name>cursorentry_T</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_INVALID</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_NORMAL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_VISUAL</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_SELECT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_OP_PENDING</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_INSERT</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_CMDLINE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_TERMINAL</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INDEX_TIP</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_MODES</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_NORMAL_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_NORMAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_VISUAL_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_VISUAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_SELECT_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_SELECT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_OP_PENDING_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_OP_PENDING)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_INSERT_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_INSERT)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_CMDLINE_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_CMDLINE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_TERMINAL_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_TERMINAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_TIP_MODE</name></cpp:macro> <cpp:value>(1 &lt;&lt; MENU_INDEX_TIP)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MENU_ALL_MODES</name></cpp:macro> <cpp:value>((1 &lt;&lt; MENU_INDEX_TIP) - 1)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MNU_HIDDEN_CHAR</name></cpp:macro> <cpp:value>']'</cpp:value></cpp:define>

<struct>struct <name>VimMenu</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>modes</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>enabled</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dname</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>en_name</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>en_dname</name></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>mnemonic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>actext</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>priority</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>cb</name>)<parameter_list>(<parameter><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TOOLBAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>iconfile</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>iconidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>icon_builtin</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name><name>strings</name><index>[<expr><name>MENU_MODES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>noremap</name><index>[<expr><name>MENU_MODES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name><name>silent</name><index>[<expr><name>MENU_MODES</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type><name>children</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>vimmenu_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_X11</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Widget</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>Widget</name></type> <name>submenu_id</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>GtkWidget</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>GtkWidget</name> <modifier>*</modifier></type><name>submenu_id</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>GTK_CHECK_VERSION</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>GTK_CHECK_VERSION</name><argument_list>(<argument><expr><literal type="number">3</literal><operator>,</operator><literal type="number">4</literal><operator>,</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>GtkWidget</name> <modifier>*</modifier></type><name>tearoff_handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>GtkWidget</name> <modifier>*</modifier></type><name>label</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>sensitive</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>xpm</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xpm_fname</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Pixmap</name></type> <name>image</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BEVAL_TIP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>BalloonEval</name> <modifier>*</modifier></type><name>tip</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>UINT</name></type> <name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>HMENU</name></type> <name>submenu_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>HWND</name></type> <name>tearoff_handle</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FEAT_GUI_HAIKU</name></expr></cpp:if>
<decl_stmt><decl><type><name>BMenuItem</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>BMenu</name> <modifier>*</modifier></type><name>submenu_id</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TOOLBAR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>BPictureButton</name> <modifier>*</modifier></type><name>button</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call></expr></cpp:if>


<decl_stmt><decl><type><name>short</name></type> <name>menu_id</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>submenu_id</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>MenuHandle</name></type> <name>menu_handle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>MenuHandle</name></type> <name>submenu_handle</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_PHOTON</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PtWidget_t</name> <modifier>*</modifier></type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PtWidget_t</name> <modifier>*</modifier></type><name>submenu_id</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<typedef>typedef <type><name>int</name></type> <name>vimmenu_T</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 





<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>save_curbuf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>use_aucmd_win</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>save_curwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>new_curwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>save_prevwin</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>bufref_T</name></type> <name>new_curbuf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>globaldir</name></decl>;</decl_stmt> 
}</block></struct></type> <name>aco_save_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hasnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>number</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>strlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>present</name></decl>;</decl_stmt>
}</block></struct></type> <name>option_table_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>long_u</name></type> <name>fg_color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long_u</name></type> <name>bg_color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>italic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>underline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>undercurl</name></decl>;</decl_stmt>
}</block></struct></type> <name>prt_text_attr_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>n_collated_copies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n_uncollated_copies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>duplex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>chars_per_line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lines_per_page</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>has_color</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>prt_text_attr_T</name></type> <name>number</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>modec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>do_syntax</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>user_abort</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>jobname</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_POSTSCRIPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>outfile</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arguments</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>prt_settings_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINT_NUMBER_WIDTH</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pum_text</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pum_kind</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pum_extra</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pum_info</name></decl>;</decl_stmt> 
}</block></struct></type> <name>pumitem_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tn_tags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tn_np</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tn_did_filefind_init</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tn_hf_idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>tn_search_ctx</name></decl>;</decl_stmt>
}</block></struct></type> <name>tagname_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>UINT32_T</name></type> <name><name>total</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>UINT32_T</name></type> <name><name>state</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buffer</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>context_sha256_T</name>;</typedef>




<typedef>typedef <type><enum>enum
<block>{
<decl><name>EXPR_UNKNOWN</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
<decl><name>EXPR_EQUAL</name></decl>, 
<decl><name>EXPR_NEQUAL</name></decl>, 
<decl><name>EXPR_GREATER</name></decl>, 
<decl><name>EXPR_GEQUAL</name></decl>, 
<decl><name>EXPR_SMALLER</name></decl>, 
<decl><name>EXPR_SEQUAL</name></decl>, 
<decl><name>EXPR_MATCH</name></decl>, 
<decl><name>EXPR_NOMATCH</name></decl>, 
<decl><name>EXPR_IS</name></decl>, 
<decl><name>EXPR_ISNOT</name></decl>, 

<decl><name>EXPR_ADD</name></decl>, 
<decl><name>EXPR_SUB</name></decl>, 
<decl><name>EXPR_MULT</name></decl>, 
<decl><name>EXPR_DIV</name></decl>, 
<decl><name>EXPR_REM</name></decl>, 
}</block></enum></type> <name>exptype_T</name>;</typedef>




<struct>struct <name>js_reader</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>js_buf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>js_end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>js_used</name></decl>;</decl_stmt> 
<function_decl><type><name>int</name></type> (<modifier>*</modifier><name>js_fill</name>)<parameter_list>(<parameter><decl><type><name><name>struct</name> <name>js_reader</name></name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>js_cookie</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>js_cookie_arg</name></decl>;</decl_stmt> 
}</block>;</struct>
<typedef>typedef <type><name><name>struct</name> <name>js_reader</name></name></type> <name>js_read_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_ARG_CMDS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN_HOR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN_VER</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN_TABS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 


<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>argc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>evim_mode</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>use_vimrc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>clean</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>n_commands</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name><name>commands</name><index>[<expr><name>MAX_ARG_CMDS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cmds_tofree</name><index>[<expr><name>MAX_ARG_CMDS</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>n_pre_commands</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name><name>pre_commands</name><index>[<expr><name>MAX_ARG_CMDS</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>edit_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tagname</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>use_ef</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>want_full_screen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>not_a_term</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>tty_fail</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>term</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ask_for_key</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>no_swap_file</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>use_debug_break_level</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>window_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>window_layout</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CLIENTSERVER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>serverArg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>serverName_arg</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>serverStr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>serverStrEnc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>servername</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_FILENAMES</name></cpp:macro></cpp:define>
<decl_stmt><decl><type><name>int</name></type> <name>literal</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>full_path</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>diff_mode</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>mparm_T</name>;</typedef>




























<typedef>typedef <type><struct>struct <name>lval_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ll_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ll_name_end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>ll_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ll_exp_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>ll_tv</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>ll_li</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>ll_list</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ll_range</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ll_empty2</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>ll_n1</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>ll_n2</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>ll_dict</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>ll_di</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ll_newkey</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>blob_T</name> <modifier>*</modifier></type><name>ll_blob</name></decl>;</decl_stmt> 
}</block></struct></type> <name>lval_T</name>;</typedef>



<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_msg_scroll</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_restart_edit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_msg_didout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_State</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_insertmode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_finish_op</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_opcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>save_reg_executing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>tasave_T</name></type> <name>tabuf</name></decl>;</decl_stmt>
}</block></struct></type> <name>save_state_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>vv_prevcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>vv_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>varnumber_T</name></type> <name>vv_count1</name></decl>;</decl_stmt>
}</block></struct></type> <name>vimvars_save_T</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>CDSCOPE_GLOBAL</name></decl>, 
<decl><name>CDSCOPE_TABPAGE</name></decl>, 
<decl><name>CDSCOPE_WINDOW</name></decl> 
}</block></enum></type> <name>cdscope_T</name>;</typedef>


<typedef>typedef <type><enum>enum
<block>{
<decl><name>VAR_FLAVOUR_DEFAULT</name></decl>, 
<decl><name>VAR_FLAVOUR_SESSION</name></decl>, 
<decl><name>VAR_FLAVOUR_VIMINFO</name></decl> 
}</block></enum></type> <name>var_flavour_T</name>;</typedef>


<typedef>typedef <type><enum>enum <block>{
<decl><name>IGNORE_POPUP</name></decl>, 
<decl><name>FIND_POPUP</name></decl>, 
<decl><name>FAIL_POPUP</name></decl> 
}</block></enum></type> <name>mouse_find_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DELETION_REGISTER</name></cpp:macro> <cpp:value>36</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CLIPBOARD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STAR_REGISTER</name></cpp:macro> <cpp:value>37</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_X11</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLUS_REGISTER</name></cpp:macro> <cpp:value>38</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PLUS_REGISTER</name></cpp:macro> <cpp:value>STAR_REGISTER</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TILDE_REGISTER</name></cpp:macro> <cpp:value>(PLUS_REGISTER + 1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CLIPBOARD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_REGISTERS</name></cpp:macro> <cpp:value>(TILDE_REGISTER + 1)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_REGISTERS</name></cpp:macro> <cpp:value>(PLUS_REGISTER + 1)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_REGISTERS</name></cpp:macro> <cpp:value>37</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<struct>struct <name>block_def</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>startspaces</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>endspaces</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>textlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>textstart</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>textcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>start_vcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>end_vcol</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>is_short</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>is_MAX</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>is_oneChar</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pre_whitesp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>pre_whitesp_c</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>end_char_vcols</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>start_char_vcols</name></decl>;</decl_stmt> 
}</block>;</struct>


<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>y_array</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>linenr_T</name></type> <name>y_size</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>y_type</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>colnr_T</name></type> <name>y_width</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VIMINFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>time_t</name></type> <name>y_time_set</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></struct></type> <name>yankreg_T</name>;</typedef>



<typedef>typedef <type><struct>struct <name>soffset</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>line</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>off</name></decl>;</decl_stmt> 
}</block></struct></type> <name>soffset_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>spat</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>magic</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>no_scs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>soffset_T</name></type> <name>off</name></decl>;</decl_stmt>
}</block></struct></type> <name>spat_T</name>;</typedef>




<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>linenr_T</name></type> <name>sa_stop_lnum</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RELTIME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>proftime_T</name> <modifier>*</modifier></type><name>sa_tm</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sa_timed_out</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>sa_wrapped</name></decl>;</decl_stmt> 
}</block></struct></type> <name>searchit_arg_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITEBUFSIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_LATIN1</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_UTF8</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_UCS2</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_UCS4</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_UTF16</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_CODEPAGE</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_PUT_CP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x) &amp; 0xffff) &lt;&lt; 16)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_GET_CP</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((x)&gt;&gt;16) &amp; 0xffff)</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_CONVERT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_MACROMAN</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_ENDIAN_L</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_ENCRYPTED</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_NOCONVERT</name></cpp:macro> <cpp:value>0x2000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_UCSBOM</name></cpp:macro> <cpp:value>0x4000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIO_ALL</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONV_RESTLEN</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ICONV_MULT</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
</unit>
