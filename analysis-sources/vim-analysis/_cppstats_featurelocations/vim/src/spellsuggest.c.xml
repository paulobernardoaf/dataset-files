<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats_featurelocations\vim\src\spellsuggest.c">












<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESCORE</name><parameter_list>(<parameter><type><name>word_score</name></type></parameter>, <parameter><type><name>sound_score</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((3 * word_score + sound_score) / 4)</cpp:value></cpp:define>





<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXSCORE</name><parameter_list>(<parameter><type><name>word_score</name></type></parameter>, <parameter><type><name>sound_score</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((4 * word_score - sound_score) / 3)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_MIXCAP</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>suginfo_S</name>
<block>{
<decl_stmt><decl><type><name>garray_T</name></type> <name>su_ga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_maxcount</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_maxscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_sfmaxscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>su_sga</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>su_badptr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_badlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>su_badflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_fbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>su_sal_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>su_banned</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>su_sallang</name></decl>;</decl_stmt> 
}</block></struct></type> <name>suginfo_T</name>;</typedef>


<typedef>typedef <type><struct>struct <name>suggest_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>st_word</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_wordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_orglen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_altscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_salscore</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>st_had_bonus</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>st_slang</name></decl>;</decl_stmt> 
}</block></struct></type> <name>suggest_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG</name><parameter_list>(<parameter><type><name>ga</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((suggest_T *)(ga).ga_data)[i])</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WAS_BANNED</name><parameter_list>(<parameter><type><name>su</name></type></parameter>, <parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(!HASHITEM_EMPTY(hash_find(&amp;su-&gt;su_banned, word)))</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG_CLEAN_COUNT</name><parameter_list>(<parameter><type><name>su</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((su)-&gt;su_maxcount &lt; 130 ? 150 : (su)-&gt;su_maxcount + 20)</cpp:value></cpp:define>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUG_MAX_COUNT</name><parameter_list>(<parameter><type><name>su</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(SUG_CLEAN_COUNT(su) + 50)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SPLIT</name></cpp:macro> <cpp:value>149</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SPLIT_NO</name></cpp:macro> <cpp:value>249</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_ICASE</name></cpp:macro> <cpp:value>52</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_REGION</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_RARE</name></cpp:macro> <cpp:value>180</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SWAP</name></cpp:macro> <cpp:value>75</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SWAP3</name></cpp:macro> <cpp:value>110</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_REP</name></cpp:macro> <cpp:value>65</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SUBST</name></cpp:macro> <cpp:value>93</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SIMILAR</name></cpp:macro> <cpp:value>33</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SUBCOMP</name></cpp:macro> <cpp:value>33</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DEL</name></cpp:macro> <cpp:value>94</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DELDUP</name></cpp:macro> <cpp:value>66</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_DELCOMP</name></cpp:macro> <cpp:value>28</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INS</name></cpp:macro> <cpp:value>96</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INSDUP</name></cpp:macro> <cpp:value>67</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_INSCOMP</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_NONWORD</name></cpp:macro> <cpp:value>103</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_FILE</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_MAXINIT</name></cpp:macro> <cpp:value>350</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON1</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON2</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_COMMON3</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_THRES2</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_THRES3</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX1</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX2</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_SFMAX3</name></cpp:macro> <cpp:value>400</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_BIG</name></cpp:macro> <cpp:value>SCORE_INS * 3</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_MAXMAX</name></cpp:macro> <cpp:value>999999</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_LIMITMAX</name></cpp:macro> <cpp:value>350</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCORE_EDIT_MIN</name></cpp:macro> <cpp:value>SCORE_SIMILAR</cpp:value></cpp:define>




<typedef>typedef <type><enum>enum
<block>{
<decl><name>STATE_START</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, 


<decl><name>STATE_NOPREFIX</name></decl>, 
<decl><name>STATE_SPLITUNDO</name></decl>, 
<decl><name>STATE_ENDNUL</name></decl>, 
<decl><name>STATE_PLAIN</name></decl>, 
<decl><name>STATE_DEL</name></decl>, 
<decl><name>STATE_INS_PREP</name></decl>, 
<decl><name>STATE_INS</name></decl>, 
<decl><name>STATE_SWAP</name></decl>, 
<decl><name>STATE_UNSWAP</name></decl>, 
<decl><name>STATE_SWAP3</name></decl>, 
<decl><name>STATE_UNSWAP3</name></decl>, 
<decl><name>STATE_UNROT3L</name></decl>, 
<decl><name>STATE_UNROT3R</name></decl>, 
<decl><name>STATE_REP_INI</name></decl>, 
<decl><name>STATE_REP</name></decl>, 
<decl><name>STATE_REP_UNDO</name></decl>, 
<decl><name>STATE_FINAL</name></decl> 
}</block></enum></type> <name>state_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>trystate_S</name>
<block>{
<decl_stmt><decl><type><name>state_T</name></type> <name>ts_state</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ts_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name></type> <name>ts_arridx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>ts_curi</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fidxtry</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_twordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_prefixdepth</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>ts_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_tcharlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_tcharidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_isdiff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_fcharstart</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_prewordlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_splitoff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_splitfidx</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_complen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_compsplit</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_save_badflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>ts_delidx</name></decl>;</decl_stmt> 

}</block></struct></type> <name>trystate_T</name>;</typedef>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_NONE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_YES</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DIFF_INSERT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_PREFIXOK</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_DIDSPLIT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TSF_DIDDEL</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_NOPREFIX</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_PREFIXTREE</name></cpp:macro> <cpp:value>0xfe</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFD_NOTSPECIAL</name></cpp:macro> <cpp:value>0xfd</cpp:value></cpp:define> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_find_suggest</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badlen</name></decl></parameter>, <parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxcount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>banbadword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>need_cap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_expr</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_file</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_suggest_intern</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_find_cleanup</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_special</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_change</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_trie_walk</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>soundfold</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>go_deeper</name><parameter_list>(<parameter><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>score_add</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_keepcap_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>kword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>score_comp_sal</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>score_combine</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>stp_sal_score</name><parameter_list>(<parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>, <parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike_prep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>suggest_try_soundalike_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_sound_suggest</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>soundfold_find</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>similar_chars</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_suggestion</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>badlen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>altscore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>had_bonus</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxsf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_suggestions</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_banned</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rescore_suggestions</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rescore_one</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cleanup_suggestions</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxscore</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keep</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>soundalike_score</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodsound</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score_limit</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_edit_score_limit_w</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>;</function_decl>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>can_be_compound</name><parameter_list>(
<parameter><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>,
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>
?</condition><then> <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr> </then><else>: <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></else></ternary></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>match_compoundrule</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>score_wordcount_adj</name><parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>split</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordcount_T</name> <modifier>*</modifier></type><name>wc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bonus</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newscore</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>&lt;</operator> <name>SCORE_THRES2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON1</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>&lt;</operator> <name>SCORE_THRES3</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON2</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>bonus</name> <operator>=</operator> <name>SCORE_COMMON3</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>score</name> <operator>-</operator> <name>bonus</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>score</name> <operator>-</operator> <name>bonus</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>newscore</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>score</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>badword_captype</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><call><name>captype</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>, <decl><type ref="prev"/><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>first</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>u</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>u</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>word</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>first</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>l</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>





<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;</operator> <name>l</name> <operator>&amp;&amp;</operator> <name>u</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ALLCAP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_MIXCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>bytes2offset</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>pp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x00</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>c</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xc0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x80</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x3f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xe0</literal><operator>)</operator> <operator>==</operator> <literal type="number">0xc0</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x1f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x0f</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">255</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<return>return <expr><name>nr</name></expr>;</return>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_BEST</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_FAST</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPS_DOUBLE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sps_flags</name> <init>= <expr><name>SPS_BEST</name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>sps_limit</name> <init>= <expr><literal type="number">9999</literal></expr></init></decl>;</decl_stmt> 





<function><type><name>int</name></type>
<name>spell_check_sps</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>p_sps</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"best"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"fast"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_FAST</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"double"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <name>SPS_DOUBLE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"expr:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>f</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>(</operator><name>sps_flags</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>f</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sps_limit</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>sps_flags</name> <operator>=</operator> <name>SPS_BEST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>spell_suggest</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pos_T</name></type> <name>prev_cursor</name> <init>= <expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>wcopy</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suginfo_T</name></type> <name>sug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>mouse_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_cap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>selected</name> <init>= <expr><name>count</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>msg_scroll_save</name> <init>= <expr><name>msg_scroll</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>VIsual_active</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <name><name>VIsual</name><operator>.</operator><name>lnum</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_beep</name><argument_list>(<argument><expr><name>BO_SPELL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>VIsual</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>-</operator><name>badlen</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name><name>VIsual</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><operator>++</operator><name>badlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>end_visual_mode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>spell_move_to</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>FORWARD</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>&gt;</operator> <name><name>prev_cursor</name><operator>.</operator><name>col</name></name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>prev_cursor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_curline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>line</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <call><name>check_need_cap</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>ml_get_curline</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>skip</name>;</goto></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>sps_limit</name> <operator>&gt;</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Rows</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>Rows</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>limit</name> <operator>=</operator> <name>sps_limit</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>spell_find_suggest</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>, <argument><expr><name>badlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>need_cap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, no suggestions"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Sorry, only %ld suggestions"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>cmdmsg_rl</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_p_rl</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <name>Columns</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_row</name> <operator>=</operator> <name>Rows</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>lines_left</name> <operator>=</operator> <name>Rows</name></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Change \"%.*s\" to:"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"Change"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">":ot \"%.*s\" egnahC"</literal></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>wcopy</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&gt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rl_mirror</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name>wcopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&lt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" &lt; \"%.*s\""</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <operator>(</operator><name>SPS_DOUBLE</name> <operator>|</operator> <name>SPS_BEST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" (%s%d - %d)"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name></expr> ?</condition><then> <expr><literal type="string">"s "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">" (%d)"</literal></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>cmdmsg_rl</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rl_mirror</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>msg_advance</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_RIGHTLEFT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>cmdmsg_rl</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>selected</name> <operator>=</operator> <call><name>prompt_for_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mouse_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>mouse_used</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>selected</name> <operator>-=</operator> <name>lines_left</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lines_left</name> <operator>=</operator> <name>Rows</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>msg_scroll_save</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>selected</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selected</name> <operator>&lt;=</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <call><name>u_save_cursor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>selected</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>&gt;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>repl_from</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s%.*s"</literal></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>,
<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repl_to</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>repl_from</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repl_to</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>c</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendToRedobuff</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ciw"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendToRedobuffLit</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>c</name></expr></argument>,
<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <name><name>sug</name><operator>.</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>AppendCharToRedobuff</name><argument_list>(<argument><expr><name>ESC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>prev_cursor</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>spell_find_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>skip</name>:</label>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><name>void</name></type>
<name>spell_suggest_list</name><parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxcount</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>need_cap</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suginfo_T</name></type> <name>sug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>spell_find_suggest</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>need_cap</name></expr></argument>, <argument><expr><name>interactive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sug</name><operator>.</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>wcopy</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name>
<operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wcopy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>wcopy</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>, <argument><expr><name><name>sug</name><operator>.</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>wcopy</name></expr>;</expr_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>spell_find_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_find_suggest</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badptr</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>badlen</name></decl></parameter>, 
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxcount</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>banbadword</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>need_cap</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name> <init>= <expr><name>HLF_COUNT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>do_combine</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sps_copy</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>expr_busy</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suginfo_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>badptr</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>=</operator> <name>badptr</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <call><name>spell_check</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name> <operator>=</operator> <name>maxcount</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_MAXINIT</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>&gt;=</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>=</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>need_cap</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sal_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>attr</name> <operator>==</operator> <name>HLF_COUNT</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>WF_ONECAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>, <argument><expr><name>SCORE_ICASE</name></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>banbadword</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_banned</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><name>sps_copy</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>p_sps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sps_copy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>sps_copy</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"expr:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>expr_busy</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>expr_busy</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_suggest_expr</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>expr_busy</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"file:"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_suggest_file</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><call><name>spell_suggest_intern</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>interactive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>do_combine</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>sps_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>do_combine</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>score_combine</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>



<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_suggest_expr</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>




<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>eval_spell_expr</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>list</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<macro><name>FOR_ALL_LIST_ITEMS</name><argument_list>(<argument>list</argument>, <argument>li</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>get_spellword</name><argument_list>(<argument><expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>score</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>score</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>list_unref</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_suggest_file</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>line</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRICMP</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><operator>++</operator><name>len</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>captype</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>SCORE_FILE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_suggest_intern</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>interactive</name></decl></parameter>)</parameter_list>
<block>{<block_content>

<expr_stmt><expr><call><name>suggest_load_files</name><argument_list>()</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>suggest_try_special</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><call><name>suggest_try_change</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>score_comp_sal</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_FAST</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_BEST</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>rescore_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>









<expr_stmt><expr><call><name>suggest_try_soundalike_prep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX1</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>=</operator> <name>SCORE_MAXINIT</name> <operator>*</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&lt;</operator> <call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&lt;</operator> <call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name>SCORE_SFMAX3</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>suggest_try_soundalike_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><call><name>ui_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>interactive</name> <operator>&amp;&amp;</operator> <name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vgetc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_BEST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>rescore_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_find_cleanup</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_try_special</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>



<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><call><name>RESCORE</name><argument_list>(<argument><expr><name>SCORE_REP</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUGGEST_PROFILE</name></cpp:macro></cpp:define>
proftime_T current;
proftime_T total;
proftime_T times[STATE_FINAL + 1];
long counts[STATE_FINAL + 1];

static void
prof_init(void)
{
for (int i = 0; i &lt;= STATE_FINAL; ++i)
{
profile_zero(&amp;times[i]);
counts[i] = 0;
}
profile_start(&amp;current);
profile_start(&amp;total);
}


static void
prof_store(state_T state)
{
profile_end(&amp;current);
profile_add(&amp;times[state], &amp;current);
++counts[state];
profile_start(&amp;current);
}
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROF_STORE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>prof_store(state);</cpp:value></cpp:define>

static void
prof_report(char *name)
{
FILE *fd = fopen("suggestprof", "a");

profile_end(&amp;total);
fprintf(fd, "-----------------------\n");
fprintf(fd, "%s: %s\n", name, profile_msg(&amp;total));
for (int i = 0; i &lt;= STATE_FINAL; ++i)
fprintf(fd, "%d: %s (%ld)\n", i, profile_msg(&amp;times[i]), counts[i]);
fclose(fd);
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROF_STORE</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_try_change</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>




<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>suggest_trie_walk</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_report</name><argument_list>(<argument><expr><literal type="string">"try_change"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></for>
</block_content>}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRY_DEEPER</name><parameter_list>(<parameter><type><name>su</name></type></parameter>, <parameter><type><name>stack</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>, <parameter><type><name>add</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(stack[depth].ts_score + (add) &lt; su-&gt;su_maxscore)</cpp:value></cpp:define>

































<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_trie_walk</name><parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>soundfold</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>tword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>trystate_T</name></type> <name><name>stack</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>preword</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt> 




<decl_stmt><decl><type><name>char_u</name></type> <name><name>compflags</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fbyts</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pbyts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fidxs</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pidxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>, <decl><type ref="prev"/><name>c3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fl</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>repextra</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fword_ends</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodword_ends</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>changename</name><index>[<expr><name>MAXWLEN</name></expr>]</index><index>[<expr><literal type="number">80</literal></expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>int</name></type> <name>breakcheckcount</name> <init>= <expr><literal type="number">1000</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>compound_ok</name></decl>;</decl_stmt>





<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>trystate_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbyts</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pidxs</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>


<expr_stmt><expr><name>fbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>fidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pbyts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pidxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pbyts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_PREFIXTREE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_NOPREFIX</name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>






<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>STATE_START</name></expr>:</case>
<case>case <expr><name>STATE_NOPREFIX</name></expr>:</case>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt> 
<expr_stmt><expr><name>arridx</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>==</operator> <name>PFD_PREFIXTREE</name></expr>)</condition>
<block>{<block_content>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name> <operator>+</operator> <name>n</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_ENDNUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name>STATE_NOPREFIX</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name>len</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_ENDNUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NOSUGGEST</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>fword_ends</name> <operator>=</operator> <operator>(</operator><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <name>NUL</name>
<operator>||</operator> <operator>(</operator><ternary><condition><expr><name>soundfold</name></expr>
?</condition><then> <expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>
</then><else>: <expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>&lt;=</operator> <name>PFD_NOTSPECIAL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_PREFIXOK</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>




<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name></expr>]</index></name><operator>.</operator><name>ts_arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>pbyts</name><index>[<expr><name>n</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>pbyts</name><index>[<expr><name>n</name> <operator>+</operator> <name>c</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control><block type="pseudo"><block_content>
<empty_stmt>;</empty_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>





<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>|=</operator> <name>TSF_PREFIXOK</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name> <operator>&amp;&amp;</operator> <name>fword_ends</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name>
<operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>preword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>newscore</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>match_checkcompoundpattern</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compound_ok</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>fword_ends</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>compound_ok</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>find_keepcap_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>



<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_ALLCAP</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>==</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>|=</operator> <name>flags</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>&amp;=</operator> <operator>~</operator><name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>add_banned</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <call><name>WAS_BANNED</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <call><name>WAS_BANNED</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>goodword_ends</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_REGION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_valid_case</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr></argument>,
<argument><expr><call><name>captype</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>fword_ends</name>
<operator>&amp;&amp;</operator> <name>goodword_ends</name>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name>
<operator>&amp;&amp;</operator> <name>compound_ok</name></expr>)</condition>
<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><literal type="string">"smwrd"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>


<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><literal type="string">"------ %s -------"</literal></expr></argument>, <argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>depth</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>changename</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>add_sound_suggest</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>preword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_NONWORD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>+</operator> <name>newscore</name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>score</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>&amp;</operator> <name>WF_MIXCAP</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <name>WF_ALLCAP</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><ternary><condition><expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>WF_ALLCAP</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>preword</name></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name></expr></argument>,
<argument><expr><name>score</name> <operator>+</operator> <name>SCORE_ICASE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name> <operator>||</operator> <name>fword_ends</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>has_mbyte</name> <operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>try_compound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>try_split</name></decl>;</decl_stmt>






<expr_stmt><expr><name>try_split</name> <operator>=</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <name>repextra</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name></expr>;</expr_stmt>













<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nocompoundsugs</name></name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name>
<operator>&gt;=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>has_mbyte</name>
<operator>||</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name></expr></argument>)</argument_list></call>
<operator>&gt;=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>can_be_compound</name><argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>compflags</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>

<block>{<block_content>
<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nocompoundsugs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>




<if type="elseif">else if <condition>(<expr><operator>!</operator><name>fword_ends</name>
<operator>&amp;&amp;</operator> <name>try_compound</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDSPLIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>try_compound</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>|=</operator> <name>TSF_DIDSPLIT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>compflags</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>TSF_DIDSPLIT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>try_split</name> <operator>||</operator> <name>try_compound</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>fword_ends</name> <operator>||</operator> <operator>!</operator><name>goodword_ends</name><operator>)</operator></expr>)</condition>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>preword</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>,
<argument><expr><name>compflags</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nosplitsugs</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_SPLIT_NO</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>+=</operator> <name>SCORE_SPLIT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>,
<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fword_ends</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: split"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: compound"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SPLITUNDO</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>fword_ends</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>preword</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>preword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitoff</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_splitfidx</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><operator>!</operator><name>try_compound</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>fword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator>
<operator>||</operator> <name>fword_ends</name><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name>goodword_ends</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fword_ends</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>preword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr></argument>,
<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>preword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prewordlen</name></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SPLIT</name> <operator>-</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>try_compound</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_compsplit</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_complen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_NOPREFIX</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <call><name>badword_captype</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>n</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>pbyts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_prefixdepth</name></name> <operator>=</operator> <name>PFD_PREFIXTREE</name></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_NOPREFIX</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_SPLITUNDO</name></expr>:</case>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name></expr>;</expr_stmt>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>


<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>fbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>fidxs</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>STATE_ENDNUL</name></expr>:</case>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_save_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_DEL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_PLAIN</name></expr>;</expr_stmt>


<case>case <expr><name>STATE_PLAIN</name></expr>:</case>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_DEL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>arridx</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>






<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>!=</operator> <name>DIFF_NONE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>newscore</name> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&gt;=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDDEL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name>c</name> <operator>!=</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_delidx</name></name></expr>]</index></name><operator>)</operator><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: subst %c to %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: accept %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>==</operator> <name>SCORE_SUBST</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <name>DIFF_YES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <call><name>MB_BYTE2LEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>newscore</name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>
?</condition><then> <expr><name>DIFF_YES</name></expr> </then><else>: <expr><name>DIFF_NONE</name></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_INSERT</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><operator>--</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>==</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_YES</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name>
<operator>+</operator> <call><name>mb_ptr2len</name><argument_list>(
<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>enc_utf8</name>
<operator>&amp;&amp;</operator> <call><name>utf_iscomposing</name><argument_list>(
<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>tword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name>
<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>utf_iscomposing</name><argument_list>(
<argument><expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>fword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator>
<name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SUBCOMP</name></expr>;</expr_stmt></block_content></block></if>



<if type="elseif">else if <condition>(<expr><operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>tword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name>
<operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>fword</name>
<operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fcharstart</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator>
<name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>==</operator> <name>DIFF_INSERT</name>
<operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>&gt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>tword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enc_utf8</name> <operator>&amp;&amp;</operator> <call><name>utf_iscomposing</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name> <operator>-</operator> <name>SCORE_INSCOMP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>





<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>tword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name>
<operator>-</operator> <name>SCORE_INSDUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>newscore</name> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_SUBST</name> <operator>-</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_DEL</name></expr>:</case>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_INS_PREP</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_DEL</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_DEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: delete %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_flags</name> <operator>|=</operator> <name>TSF_DIDDEL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_delidx</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidx</name> <operator>+=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enc_utf8</name> <operator>&amp;&amp;</operator> <call><name>utf_iscomposing</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>-=</operator> <name>SCORE_DEL</name> <operator>-</operator> <name>SCORE_DELCOMP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidx</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>-=</operator> <name>SCORE_DEL</name> <operator>-</operator> <name>SCORE_DELDUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name> <operator>==</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>-=</operator> <name>SCORE_DEL</name> <operator>-</operator> <name>SCORE_DELDUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<case>case <expr><name>STATE_INS_PREP</name></expr>:</case>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_flags</name></name> <operator>&amp;</operator> <name>TSF_DIDDEL</name></expr>)</condition>
<block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_INS</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>



<case>case <expr><name>STATE_INS</name></expr>:</case>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>soundfold</name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name>newscore</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_INS</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>newscore</name> <operator>=</operator> <name>SCORE_INS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>newscore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: insert %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sp</name> <operator>=</operator> <operator>&amp;</operator><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_arridx</name></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_BYTE2LEN</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharlen</name></name> <operator>=</operator> <name>fl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_tcharidx</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_isdiff</name></name> <operator>=</operator> <name>DIFF_INSERT</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>&gt;=</operator> <literal type="number">2</literal>
<operator>&amp;&amp;</operator> <name><name>tword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>-=</operator> <name>SCORE_INS</name> <operator>-</operator> <name>SCORE_INSDUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_SWAP</name></expr>:</case>



<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>n</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c2</name></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_SWAP3</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: swap %c and %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNSWAP</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>mb_char2len</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNSWAP</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<case>case <expr><name>STATE_SWAP3</name></expr>:</case>


<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c3</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>







<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>c3</name> <operator>||</operator> <name>c3</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: swap3 %c and %c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name>c</name></expr></argument>, <argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNSWAP3</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>mb_char2len</name><argument_list>(<argument><expr><name>c3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNSWAP3</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>fl</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>soundfold</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>


<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: rotate left %c%c%c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNROT3L</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>+=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNROT3L</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_SWAP3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: rotate right %c%c%c"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_UNROT3R</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>n</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_INI</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<break>break;</break>

<case>case <expr><name>STATE_UNROT3R</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>+=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<case>case <expr><name>STATE_REP_INI</name></expr>:</case>





<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>soundfold</name><operator>)</operator>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_score</name></name> <operator>+</operator> <name>SCORE_REP</name> <operator>&gt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name>
<operator>||</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>&lt;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidxtry</name></name></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_repsal_first</name><index>[<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep_first</name><index>[<expr><name><name>fword</name><index>[<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP</name></expr>;</expr_stmt>


<case>case <expr><name>STATE_REP</name></expr>:</case>



<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<while>while <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name><operator>++</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name> <operator>!=</operator> <operator>*</operator><name>p</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>TRY_DEEPER</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_REP</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>go_deeper</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>SCORE_REP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DEBUG_TRIEWALK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>changename</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%.*s-%s: replace %s with %s"</literal></expr></argument>,
<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_twordlen</name></name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr></argument>,
<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP_UNDO</name></expr>;</expr_stmt>


<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>!=</operator> <name>tl</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repextra</name> <operator>+=</operator> <name>tl</name> <operator>-</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_fidxtry</name> <operator>=</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_tcharlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>&gt;=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>==</operator> <name>STATE_REP</name></expr>)</condition>
<block>{<block_content>

<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_FINAL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>STATE_REP_UNDO</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>soundfold</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name><operator>-&gt;</operator><name>sl_rep</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_curi</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>fl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tl</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>sp</name><operator>-&gt;</operator><name>ts_fidx</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fl</name> <operator>!=</operator> <name>tl</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>fl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repextra</name> <operator>-=</operator> <name>tl</name> <operator>-</operator> <name>fl</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name>fl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PROF_STORE</name><argument_list>(<argument>sp-&gt;ts_state</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>ts_state</name></name> <operator>=</operator> <name>STATE_REP</name></expr>;</expr_stmt>
<break>break;</break>

<default>default:</default>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_prefixdepth</name> <operator>==</operator> <name>PFD_PREFIXTREE</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name>pbyts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name>pidxs</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><operator>--</operator><name>breakcheckcount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>ui_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>breakcheckcount</name> <operator>=</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></switch>
</block_content>}</block></while>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>go_deeper</name><parameter_list>(<parameter><decl><type><name>trystate_T</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>score_add</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_state</name> <operator>=</operator> <name>STATE_START</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>depth</name></expr>]</index></name><operator>.</operator><name>ts_score</name> <operator>+</operator> <name>score_add</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_curi</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>ts_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_keepcap_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>kword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>uword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>tryidx</name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>round</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>fwordidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>uwordidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>kwordlen</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>, <decl><type ref="prev"/><name>ulen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name> <init>= <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name> <init>= <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>kword</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>allcap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>uword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>round</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fwordidx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uwordidx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>fword</name><index>[<expr><name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>kword</name><index>[<expr><name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>++</operator><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ulen</name> <operator>=</operator> <call><name>MB_CPTR2LEN</name><argument_list>(<argument><expr><name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>ulen</name> <operator>=</operator> <name>flen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>flen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <name>ulen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<for>for <control>(<init><expr><name>tryidx</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</init> <condition><expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>l</name></expr></incr>)</control>
<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>tryidx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>tryidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>tryidx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><name>tryidx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>kword</name> <operator>+</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><name>fword</name> <operator>+</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>,
<argument><expr><name>flen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>flen</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>kword</name> <operator>+</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>, <argument><expr><name>uword</name> <operator>+</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name></expr></argument>,
<argument><expr><name>ulen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>kwordlen</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>kwordlen</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>ulen</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name><name>fwordidx</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>fwordidx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>flen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>uwordidx</name><index>[<expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>uwordidx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name>ulen</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name>tryidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>round</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>


<expr_stmt><expr><operator>*</operator><name>kword</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>score_comp_sal</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>sstp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>score</name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>SCORE_MAXMAX</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>sstp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sstp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>sstp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>score_combine</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">3</literal> <operator>+</operator> <name>SCORE_BIG</name><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">3</literal>
<operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>spell_edit_score</name><argument_list>(<argument><expr><name>slang</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name>SCORE_BIG</name> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <operator>(</operator><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name><operator>)</operator> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_salscore</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_suggestions</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>cleanup_suggestions</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>suginfo_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name> <operator>||</operator> <name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>


<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></else></ternary></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>.</operator><name>st_word</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxcount</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name> <operator>=</operator> <name>ga</name></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>stp_sal_score</name><parameter_list>(
<parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>,
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pbad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pgood</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>badsound2</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>goodsound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>goodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lendiff</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lendiff</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>-</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lendiff</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pbad</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name><index>[<expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <operator>*</operator><call><name>skiptowhite</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>fword</name></expr>;</init> <condition><expr><operator>*</operator><operator>(</operator><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>badsound2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbad</name> <operator>=</operator> <name>badsound2</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lendiff</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>+</operator> <name>lendiff</name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>goodword</name> <operator>+</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name> <operator>-</operator> <name>lendiff</name></expr></argument>, <argument><expr><name>lendiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pgood</name> <operator>=</operator> <name>goodword</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>pgood</name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>pgood</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>goodsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>soundalike_score</name><argument_list>(<argument><expr><name>goodsound</name></expr></argument>, <argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>



<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>short</name></type> <name>sft_score</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sft_word</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>sftword_T</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>sftword_T</name></type> <name>dumsft</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HIKEY2SFT</name><parameter_list>(<parameter><type><name>p</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((sftword_T *)(p - (dumsft.sft_word - (char_u *)&amp;dumsft)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2SFT</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>HIKEY2SFT((hi)-&gt;hi_key)</cpp:value></cpp:define>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_try_soundalike_prep</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_try_soundalike</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>salword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>salword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>suggest_trie_walk</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>salword</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SUGGEST_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>prof_report</name><argument_list>(<argument><expr><literal type="string">"soundalike"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>suggest_try_soundalike_finish</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>



<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>todo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name><operator>.</operator><name>ht_used</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name><operator>.</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><call><name>HI2SFT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>


<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_sound_suggest</name><parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>, 
<parameter><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sfwordnr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>nrline</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orgnr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>theword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sftword_T</name> <modifier>*</modifier></type><name>sft</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>limit</name></decl>;</decl_stmt>





<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sft</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sftword_T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sft</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_word</name></name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sounddone</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_word</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>sft</name> <operator>=</operator> <call><name>HI2SFT</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&gt;=</operator> <name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>sft</name><operator>-&gt;</operator><name>sft_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><name>sfwordnr</name> <operator>=</operator> <call><name>soundfold_find</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sfwordnr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>internal_error</name><argument_list>(<argument><expr><literal type="string">"add_sound_suggest()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>nrline</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>sfwordnr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>orgnr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>nrline</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>orgnr</name> <operator>+=</operator> <call><name>bytes2offset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nrline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>wordcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>wlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wlen</name> <operator>&lt;</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>wlen</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wordcount</name> <operator>==</operator> <name>orgnr</name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>wordcount</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<for>for <control>( <init>;</init> <condition><expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>theword</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><literal type="string">"BAD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wlen</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<goto>goto <name>badword</name>;</goto>
</block_content>}</block></if></if_stmt></block_content></block></for>


<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>wc</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>wordcount</name> <operator>+</operator> <name>wc</name> <operator>&gt;</operator> <name>orgnr</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>wordcount</name> <operator>+=</operator> <name>wc</name></expr>;</expr_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>theword</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></for>
<label><name>badword</name>:</label>
<expr_stmt><expr><name><name>theword</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NOSUGGEST</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>find_keepcap_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>theword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badflags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_CAPMASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>theword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>theword</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>sps_flags</name> <operator>&amp;</operator> <name>SPS_DOUBLE</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_sga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>score</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <name>SCORE_REGION</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>





<expr_stmt><expr><name>gc</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <name>SCORE_ICASE</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>








<expr_stmt><expr><name>limit</name> <operator>=</operator> <call><name>MAXSCORE</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>-</operator> <name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>limit</name> <operator>&gt;</operator> <name>SCORE_LIMITMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <call><name>spell_edit_score</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>goodscore</name> <operator>+=</operator> <call><name>spell_edit_score_limit</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badword</name></name></expr></argument>,
<argument><expr><name>p</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name>goodscore</name> <operator>&lt;</operator> <name>SCORE_MAXMAX</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <call><name>score_wordcount_adj</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>goodscore</name> <operator>=</operator> <call><name>RESCORE</name><argument_list>(<argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>goodscore</name> <operator>&lt;=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>add_suggestion</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badlen</name></name></expr></argument>,
<argument><expr><name>goodscore</name></expr></argument>, <argument><expr><name>score</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

</block_content>}</block></while>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>soundfold_find</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>word</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordnr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>



<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>


<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 
<expr_stmt><expr><operator>++</operator><name>wordnr</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<while>while <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>wordnr</name> <operator>+=</operator> <name><name>idxs</name><index>[<expr><name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>wordnr</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>similar_chars</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>m1</name></decl>, <decl><type ref="prev"/><name>m2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MB_MAXBYTES</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c1</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>m1</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>c1</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>m1</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c2</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>m2</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>c2</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>m1</name> <operator>==</operator> <name>m2</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_suggestion</name><parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>badlenarg</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>score</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>altscore</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>had_bonus</name></decl></parameter>, 
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>maxsf</name></decl></parameter>)</parameter_list> 

<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>goodlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name></type> <name>new_sug</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pgood</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pbad</name></decl>;</decl_stmt>



<expr_stmt><expr><name>pgood</name> <operator>=</operator> <name>goodword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pbad</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name>badlenarg</name></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pgood</name> <operator>-</operator> <name>goodword</name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>pbad</name> <operator>-</operator> <name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>goodlen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>badlen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>pgood</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name></expr></argument>, <argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>pgood</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>pbad</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>pgood</name> <operator>!=</operator> <operator>*</operator><name>pbad</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>badlen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>goodlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>


<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>



<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>stp</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>==</operator> <name>goodlen</name>
<operator>&amp;&amp;</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>==</operator> <name>badlen</name>
<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>goodlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_altscore</name></name> <operator>=</operator> <name>altscore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>had_bonus</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>!=</operator> <name>had_bonus</name></expr>)</condition>
<block>{<block_content>






<if_stmt><if>if <condition>(<expr><name>had_bonus</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_word</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_wordlen</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_slang</name></name> <operator>=</operator> <name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_sug</name><operator>.</operator><name>st_orglen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_sug</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>&gt;</operator> <name><name>new_sug</name><operator>.</operator><name>st_score</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_score</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_altscore</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name><name>new_sug</name><operator>.</operator><name>st_had_bonus</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>goodlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_word</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_wordlen</name></name> <operator>=</operator> <name>goodlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name>altscore</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>had_bonus</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_orglen</name></name> <operator>=</operator> <name>badlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <call><name>SUG_MAX_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>maxsf</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name> <operator>=</operator> <call><name>cleanup_suggestions</name><argument_list>(<argument><expr><name>gap</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_sfmaxscore</name></name></expr></argument>, <argument><expr><call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name> <operator>=</operator> <call><name>cleanup_suggestions</name><argument_list>(<argument><expr><name>gap</name></expr></argument>,
<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_maxscore</name></name></expr></argument>, <argument><expr><call><name>SUG_CLEAN_COUNT</name><argument_list>(<argument><expr><name>su</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_suggestions</name><parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>longword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>stp</name> <operator>=</operator> <operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>longword</name></expr></argument>, <argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_wordlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>longword</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_badptr</name></name> <operator>+</operator> <name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_orglen</name></expr></argument>,
<argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_check</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>longword</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>HLF_COUNT</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>stp</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>stp</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_banned</name><parameter_list>(
<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>su</name><operator>-&gt;</operator><name>su_banned</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>rescore_suggestions</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>su</name><operator>-&gt;</operator><name>su_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>rescore_one</name><argument_list>(<argument><expr><name>su</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_ga</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>rescore_one</name><parameter_list>(<parameter><decl><type><name>suginfo_T</name> <modifier>*</modifier></type><name>su</name></decl></parameter>, <parameter><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>stp</name><operator>-&gt;</operator><name>st_slang</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sal_badword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sallang</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>su</name><operator>-&gt;</operator><name>su_sal_badword</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>su</name><operator>-&gt;</operator><name>su_fbadword</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>sal_badword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>sal_badword</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <call><name>stp_sal_score</name><argument_list>(<argument><expr><name>stp</name></expr></argument>, <argument><expr><name>su</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>==</operator> <name>SCORE_MAXMAX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>=</operator> <name>SCORE_BIG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name> <operator>=</operator> <call><name>RESCORE</name><argument_list>(<argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_score</name></name></expr></argument>, <argument><expr><name><name>stp</name><operator>-&gt;</operator><name>st_altscore</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stp</name><operator>-&gt;</operator><name>st_had_bonus</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sug_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>;</function_decl>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>sug_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator><name>suggest_T</name> <operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><name>suggest_T</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><name><name>p1</name><operator>-&gt;</operator><name>st_score</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>st_score</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>st_altscore</name></name> <operator>-</operator> <name><name>p2</name><operator>-&gt;</operator><name>st_altscore</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>STRICMP</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>st_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>cleanup_suggestions</name><parameter_list>(
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxscore</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>keep</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>suggest_T</name> <modifier>*</modifier></type><name>stp</name> <init>= <expr><operator>&amp;</operator><call><name>SUG</name><argument_list>(<argument><expr><operator>*</operator><name>gap</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>suggest_T</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>sug_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <name>keep</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>keep</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>stp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <name>keep</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>keep</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name><name>stp</name><index>[<expr><name>keep</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>st_score</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>maxscore</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>soundalike_score</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodstart</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badstart</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodsound</name> <init>= <expr><name>goodstart</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badsound</name> <init>= <expr><name>badstart</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ps</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pl2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ps2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>badsound</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>*</operator><name>goodsound</name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>badsound</name> <operator>!=</operator> <operator>*</operator><name>goodsound</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>badsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>goodsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>badsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <name><name>goodsound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>badsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name><name>goodsound</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <name><name>badsound</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <name><name>goodsound</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition>
<block>{<block_content>

</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <name>SCORE_DEL</name> <operator>/</operator> <literal type="number">3</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>badsound</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>badsound</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>goodsound</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>goodsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>badsound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<expr_stmt><expr><name>n</name> <operator>=</operator> <name>goodlen</name> <operator>-</operator> <name>badlen</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>n</name> <argument_list type="generic">&lt; <argument><expr><operator>-</operator><literal type="number">2</literal> <operator>||</operator> <name>n</name></expr></argument> &gt;</argument_list></name> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <name>goodsound</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>pl</name> <operator>=</operator> <name>badsound</name></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps</name> <operator>=</operator> <name>goodsound</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<while>while <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <operator>*</operator><name>ps</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pl</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps</name></expr>;</expr_stmt>
</block_content>}</block></while>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>
<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt> 
<while>while <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <operator>*</operator><name>ps</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>*</operator> <literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
<case>case <expr><literal type="number">1</literal></expr>:</case>



<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_DEL</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>



<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>pl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>


<if_stmt><if>if <condition>(<expr><name><name>pl2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>pl2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>ps2</name><index>[<expr><literal type="number">0</literal></expr>]</index></name>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_SWAP</name></expr>;</return></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_SUBST</name> <operator>+</operator> <name>SCORE_SUBST</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ps2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_INS</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>pl2</name> <operator>=</operator> <name>pl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>ps2</name> <operator>=</operator> <name>ps</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>pl2</name> <operator>==</operator> <operator>*</operator><name>ps2</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>pl2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>ps2</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>pl2</name></expr></argument>, <argument><expr><name>ps2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>score</name> <operator>+</operator> <name>SCORE_INS</name> <operator>+</operator> <name>SCORE_DEL</name></expr>;</return></block_content></block></if></if_stmt>


<break>break;</break>
</block_content>}</block></switch>

<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_edit_score</name><parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>badlen</name></decl>, <decl><type ref="prev"/><name>goodlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pbc</name></decl>, <decl><type ref="prev"/><name>pgc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wgoodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>badword</name></expr><operator>,</operator> <expr><name>badlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>badlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>badlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>goodword</name></expr><operator>,</operator> <expr><name>goodlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>goodlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>goodlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>badlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>badword</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>goodlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>goodword</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CNT</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>cnt[(a) + (b) * (badlen + 1)]</cpp:value></cpp:define>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><operator>(</operator><name>badlen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <operator>(</operator><name>goodlen</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>goodlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>SCORE_INS</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>badlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>SCORE_DEL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>goodlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_ICASE</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_SIMILAR</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>SCORE_SUBST</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pbc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pgc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>pbc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pgc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>pgc</name> <operator>&amp;&amp;</operator> <name>pbc</name> <operator>==</operator> <name>gc</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_SWAP</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_DEL</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>t</name> <operator>=</operator> <name>SCORE_INS</name> <operator>+</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>t</name> <operator>&lt;</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>CNT</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>t</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>CNT</name><argument_list>(<argument><expr><name>badlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>goodlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<typedef>typedef <type><struct>struct
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>badi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>goodi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
}</block></struct></type> <name>limitscore_T</name>;</typedef>









<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_edit_score_limit</name><parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>limitscore_T</name></type> <name><name>stack</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>stackidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi</name></decl>, <decl><type ref="prev"/><name>gi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi2</name></decl>, <decl><type ref="prev"/><name>gi2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><call><name>spell_edit_score_limit_w</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>badword</name></expr></argument>, <argument><expr><name>goodword</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>








<expr_stmt><expr><name>stackidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>badword</name><index>[<expr><name>bi</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>goodword</name><index>[<expr><name>gi</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>!=</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>pop</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_DEL</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>badword</name><index>[<expr><operator>++</operator><name>bi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_INS</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>goodword</name><index>[<expr><operator>++</operator><name>gi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>




<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>score_off</name> <operator>=</operator> <name>score</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SCORE_DEL</name></expr> </then><else>: <expr><name>SCORE_INS</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>+</operator> <name>SCORE_EDIT_MIN</name> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><name>bi2</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi2</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>goodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name><name>badword</name><index>[<expr><name>bi2</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>goodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi2</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>stackidx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name><name>badword</name><index>[<expr><name>bi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>bc</name> <operator>==</operator> <name><name>goodword</name><index>[<expr><name>gi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>gi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SWAP</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>pop</name>:</label>

<if_stmt><if>if <condition>(<expr><name>stackidx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>stackidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name></expr>;</expr_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><name>minscore</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>minscore</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_edit_score_limit_w</name><parameter_list>(
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>badword</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>goodword</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>limitscore_T</name></type> <name><name>stack</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>stackidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi</name></decl>, <decl><type ref="prev"/><name>gi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bi2</name></decl>, <decl><type ref="prev"/><name>gi2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bc</name></decl>, <decl><type ref="prev"/><name>gc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>score_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>minscore</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wbadword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wgoodword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>



<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>badword</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>bi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>wbadword</name><index>[<expr><name>bi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>goodword</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>gi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>wgoodword</name><index>[<expr><name>gi</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>








<expr_stmt><expr><name>stackidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>limit</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>bc</name> <operator>=</operator> <name><name>wbadword</name><index>[<expr><name>bi</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>gc</name> <operator>=</operator> <name><name>wgoodword</name><index>[<expr><name>gi</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>!=</operator> <name>gc</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<goto>goto <name>pop</name>;</goto> 
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_DEL</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>wbadword</name><index>[<expr><operator>++</operator><name>bi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>bc</name> <operator>==</operator> <name>NUL</name></expr>)</condition> 
<block>{<block_content>
<do>do
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>score</name> <operator>+=</operator> <name>SCORE_INS</name><operator>)</operator> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>pop</name>;</goto></block_content></block></if></if_stmt> 
</block_content>}</block> while <condition>(<expr><name><name>wgoodword</name><index>[<expr><operator>++</operator><name>gi</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>




<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>score_off</name> <operator>=</operator> <name>score</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>SCORE_DEL</name></expr> </then><else>: <expr><name>SCORE_INS</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>score_off</name> <operator>+</operator> <name>SCORE_EDIT_MIN</name> <operator>&gt;=</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><name>bi2</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi2</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>wgoodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name><name>wbadword</name><index>[<expr><name>bi2</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>wgoodword</name><index>[<expr><name>gi2</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>minscore</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>bi2</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>gi2</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name> <operator>=</operator> <name>bi</name> <operator>+</operator> <literal type="number">1</literal> <operator>-</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name> <operator>=</operator> <name>gi</name> <operator>+</operator> <name>round</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name> <operator>=</operator> <name>score_off</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>stackidx</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>+</operator> <name>SCORE_SWAP</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>gc</name> <operator>==</operator> <name><name>wbadword</name><index>[<expr><name>bi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>bc</name> <operator>==</operator> <name><name>wgoodword</name><index>[<expr><name>gi</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>gi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SWAP</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>bc</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>gc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_ICASE</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_has_map</name></name>
<operator>&amp;&amp;</operator> <call><name>similar_chars</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>gc</name></expr></argument>, <argument><expr><name>bc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SIMILAR</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>score</name> <operator>+=</operator> <name>SCORE_SUBST</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>score</name> <operator>&lt;</operator> <name>minscore</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>gi</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>bi</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<label><name>pop</name>:</label>

<if_stmt><if>if <condition>(<expr><name>stackidx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>stackidx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>gi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>goodi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bi</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>badi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>score</name> <operator>=</operator> <name><name>stack</name><index>[<expr><name>stackidx</name></expr>]</index></name><operator>.</operator><name>score</name></expr>;</expr_stmt>
</block_content>}</block></for>




<if_stmt><if>if <condition>(<expr><name>minscore</name> <operator>&gt;</operator> <name>limit</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SCORE_MAXMAX</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>minscore</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
