<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats_featurelocations\vim\src\spellfile.c">














































































































































































































































<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BY_NOFLAGS</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BY_INDEX</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BY_FLAGS</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BY_FLAGS2</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BY_SPECIAL</name></cpp:macro> <cpp:value>BY_FLAGS2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO_FLAG</name></cpp:macro> <cpp:value>65009</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAL_F0LLOWUP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAL_COLLAPSE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SAL_REM_ACCENTS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSPELLMAGIC</name></cpp:macro> <cpp:value>"VIMspell"</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSPELLMAGICL</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSPELLVERSION</name></cpp:macro> <cpp:value>50</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_REGION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_CHARFLAGS</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_MIDWORD</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_PREFCOND</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_REP</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_SAL</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_SOFO</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_MAP</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_COMPOUND</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_SYLLABLE</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_NOBREAK</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_SUGFILE</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_REPSAL</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_WORDS</name></cpp:macro> <cpp:value>13</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_NOSPLITSUGS</name></cpp:macro> <cpp:value>14</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_INFO</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_NOCOMPOUNDSUGS</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SN_END</name></cpp:macro> <cpp:value>255</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SNF_REQUIRED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CF_WORD</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CF_UPPER</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_ALL_NODE_SIBLINGS</name><parameter_list>(<parameter><type><name>node</name></type></parameter>, <parameter><type><name>np</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for ((np) = (node); (np) != NULL; (np) = (np)-&gt;wn_sibling)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_spell_finish</name><parameter_list>(<parameter><decl><type><name>spelltab_T</name> <modifier>*</modifier></type><name>new_st</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>write_spell_prefcond</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_region_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_charflags_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_prefcond_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_rep_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>first</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_sal_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_words_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_sofo_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>read_compound</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_sofo</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_sal_first</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>mb_str2wide</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_read_tree</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>bytsp</name></decl></parameter>, <parameter><decl><type><name>idx_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>idxsp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefixcnt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>idx_T</name></type> <name>read_tree_node</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl></parameter>, <parameter><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxidx</name></decl></parameter>, <parameter><decl><type><name>idx_T</name></type> <name>startidx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxprefcondnr</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_spell_charflags</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>upp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>set_spell_chartab</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fol</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>low</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>upp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_map_str</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_spell_trunc</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E758: Truncated spell file"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_afftrailing</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Trailing text in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_affname</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Affix name too long in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_affform</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E761: Format error in affix file FOL, LOW or UPP"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_affrange</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E762: Character in FOL, LOW or UPP is out of range"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>msg_compressing</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"Compressing word tree..."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>














<function><type><name>slang_T</name> <modifier>*</modifier></type>
<name>spell_load_file</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>,
<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>old_lp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>silent</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>VIMSPELLMAGICL</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>did_estack_push</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ESTACK_CHECK_DECLARATION</name></type>

<name>fd</name> <init>= <expr><call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>silent</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>e_notopen</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading spell file \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>old_lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>slang_alloc</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fname</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_add</name></name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gettail</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SPL_FNAME_ADD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name>old_lp</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>estack_push</name><argument_list>(<argument><expr><name>ETYPE_SPELL</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>ESTACK_CHECK_SETUP</name></type>
<name>did_estack_push</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>VIMSPELLMAGICL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>VIMSPELLMAGIC</name></expr></argument>, <argument><expr><name>VIMSPELLMAGICL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E757: This does not look like a spell file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>VIMSPELLVERSION</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E771: Old spell file, needs to be updated"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>VIMSPELLVERSION</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E772: Spell file is for newer version of Vim"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>






<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>SN_END</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>get4c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncerr</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>SN_INFO</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_info</name></name> <operator>=</operator> <call><name>read_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_info</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SN_REGION</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_region_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_CHARFLAGS</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_charflags_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_MIDWORD</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name> <operator>=</operator> <call><name>read_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<case>case <expr><name>SN_PREFCOND</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_prefcond_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_REP</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_rep_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_rep_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_REPSAL</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_rep_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr></argument>, <argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal_first</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_SAL</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_sal_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_SOFO</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_sofo_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_MAP</name></expr>:</case>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>read_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>set_map_str</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_WORDS</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_words_section</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_SUGFILE</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugtime</name></name> <operator>=</operator> <call><name>get8ctime</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<break>break;</break>

<case>case <expr><name>SN_NOSPLITSUGS</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_nosplitsugs</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_NOCOMPOUNDSUGS</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_nocompoundsugs</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_COMPOUND</name></expr>:</case>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_compound</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>lp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_NOBREAK</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<break>break;</break>

<case>case <expr><name>SN_SYLLABLE</name></expr>:</case>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_syllable</name></name> <operator>=</operator> <call><name>read_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_syllable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>init_syl_tab</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
<break>break;</break>

<default>default:</default>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>SNF_REQUIRED</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E770: Unsupported section in spell file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>
<while>while <condition>(<expr><operator>--</operator><name>len</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>truncerr</name>;</goto></block_content></block></if></if_stmt></block_content></block></while>
<break>break;</break>
</block_content>}</block></switch>
<label><name>someerror</name>:</label>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SP_FORMERROR</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SP_TRUNCERROR</name></expr>)</condition>
<block>{<block_content>
<label><name>truncerr</name>:</label>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_spell_trunc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>endFAIL</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>SP_OTHERERROR</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>endFAIL</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>spell_read_tree</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>spell_read_tree</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>


<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>spell_read_tree</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>old_lp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_next</name></name> <operator>=</operator> <name>first_lang</name></expr>;</expr_stmt>
<expr_stmt><expr><name>first_lang</name> <operator>=</operator> <name>lp</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<goto>goto <name>endOK</name>;</goto>

<label><name>endFAIL</name>:</label>
<if_stmt><if>if <condition>(<expr><name>lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>lang</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old_lp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>slang_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<label><name>endOK</name>:</label>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>did_estack_push</name></expr>)</condition>
<block>{<block_content>
<function_decl><type><name>ESTACK_CHECK_NOW</name></type>
<name>estack_pop</name><parameter_list>()</parameter_list>;</function_decl>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>lp</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>tree_count_words</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl></parameter>, <parameter><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wordcount</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>idxs</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fast_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>



<while>while <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>suggest_load_files</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dotp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>timestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordnr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugtime</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sugloaded</name></name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugloaded</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dotp</name> <operator>=</operator> <call><name>vim_strrchr</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dotp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>fnamecmp</name><argument_list>(<argument><expr><name>dotp</name></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>dotp</name></expr></argument>, <argument><expr><literal type="string">".sug"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>nextone</name>;</goto></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>VIMSUGMAGICL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>VIMSUGMAGIC</name></expr></argument>, <argument><expr><name>VIMSUGMAGICL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E778: This does not look like a .sug file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextone</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name>VIMSUGVERSION</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E779: Old .sug file, needs to be updated: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextone</name>;</goto>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&gt;</operator> <name>VIMSUGVERSION</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E780: .sug file is for newer version of Vim: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextone</name>;</goto>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>get8ctime</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>timestamp</name> <operator>!=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sugtime</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E781: .sug file doesn't match .spl file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextone</name>;</goto>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><call><name>spell_read_tree</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<label><name>someerror</name>:</label>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E782: error while reading .sug file: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>slang_clear_sug</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>nextone</name>;</goto>
</block_content>}</block></if></if_stmt>








<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugbuf</name></name> <operator>=</operator> <call><name>open_spellbuf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>wcount</name> <operator>=</operator> <call><name>get4c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wcount</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>wordnr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>wordnr</name> <operator>&lt;</operator> <name>wcount</name></expr>;</condition> <incr><expr><operator>++</operator><name>wordnr</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><call><name>ml_append_buf</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sugbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>wordnr</name></expr></argument>,
<argument><expr><name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>someerror</name>;</goto></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><call><name>tree_count_words</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tree_count_words</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>nextone</name>:</label>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>dotp</name></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>









<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>
<name>read_cnt_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt_bytes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>cntp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt_bytes</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>cnt</name> <operator>=</operator> <operator>(</operator><name>cnt</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cntp</name> <operator>=</operator> <name>SP_TRUNCERROR</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>cntp</name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>read_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>cntp</name> <operator>=</operator> <name>SP_OTHERERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_region_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>MAXREGIONS</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_regions</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_regions</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_charflags_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flagslen</name></decl>, <decl><type ref="prev"/><name>follen</name></decl>;</decl_stmt>


<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>flagslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flagslen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>flagslen</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>fol</name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>follen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>follen</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>follen</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>fol</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>set_spell_charflags</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>flagslen</name></expr></argument>, <argument><expr><name>fol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>==</operator> <name>NULL</name><operator>)</operator> <operator>!=</operator> <operator>(</operator><name>fol</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_prefcond_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>get2c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name></name> <operator>=</operator> <call><name>ALLOC_CLEAR_MULT</name><argument_list>(<argument><expr><name>regprog_T</name> <operator>*</operator></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name> <operator>=</operator> <name>cnt</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while> 
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_rep_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>short</name> <modifier>*</modifier></type><name>first</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>get2c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init>;</init> <condition><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>first</name><index>[<expr><operator>*</operator><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>first</name><index>[<expr><operator>*</operator><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_sal_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ccnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sofo</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;</operator> <name>SAL_F0LLOWUP</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_followup</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;</operator> <name>SAL_COLLAPSE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_collapse</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&amp;</operator> <name>SAL_REM_ACCENTS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_rem_accents</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cnt</name> <operator>=</operator> <call><name>get2c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>salitem_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>cnt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init>;</init> <condition><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>smp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name>ccnt</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>ccnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>ccnt</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ccnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"0123456789(-&lt;^$"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_leadlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name><operator>)</operator></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><operator>++</operator><name>i</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ccnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>++</operator><name>i</name> <operator>&lt;</operator> <name>ccnt</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_rules</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>ccnt</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<for>for <control>(<init><expr><operator>++</operator><name>i</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ccnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for> 
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ccnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ccnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ccnt</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name> <operator>=</operator> <call><name>mb_str2wide</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_leadlen</name></name> <operator>=</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name> <operator>=</operator> <call><name>mb_str2wide</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name> <operator>=</operator> <call><name>mb_str2wide</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>(</operator><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>smp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_leadlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_rules</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name> <operator>=</operator> <call><name>mb_str2wide</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_leadlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>set_sal_first</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_words_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>done</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><call><name>count_common_word</name><argument_list>(<argument><expr><name>lp</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> <operator>+=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_sofo_section</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sofo</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>


<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cnt</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>from</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>to</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>set_sofo</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>from</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>to</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_FORMERROR</name></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>read_compound</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>atstart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>crp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>todo</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
<else>else
<block>{<block_content>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compoptions</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>get2c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>todo</name> <operator>-=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><operator>--</operator><name>c</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator>
<call><name>read_cnt_string</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>cnt</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>todo</name> <operator>-=</operator> <name>cnt</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></while></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>todo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>





<expr_stmt><expr><name>c</name> <operator>=</operator> <name>todo</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">7</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>+=</operator> <name>todo</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><name>cp</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>todo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name> <operator>=</operator> <name>cp</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ap</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>todo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ap</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name> <operator>=</operator> <name>ap</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ap</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>




<expr_stmt><expr><name>crp</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>todo</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name> <operator>=</operator> <name>crp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>atstart</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>todo</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"?*+[]/"</literal></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>ap</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>ap</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>atstart</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>atstart</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>atstart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>cp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>atstart</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>atstart</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>crp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>crp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>crp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'|'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>atstart</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>pp</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name><operator>++</operator> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>crp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>crp</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name> <operator>+</operator> <name>RE_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_sofo</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>




<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">256</literal></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>from</name></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <name>to</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_CPTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>



<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>salfirst_T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>from</name></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <name>to</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>inp</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>inp</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>inp</name></expr>;</expr_stmt></block_content></block></while>
<expr_stmt><expr><operator>*</operator><name>inp</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt> 
<expr_stmt><expr><operator>*</operator><name>inp</name><operator>++</operator> <operator>=</operator> <name>i</name></expr>;</expr_stmt> 
<expr_stmt><expr><operator>*</operator><name>inp</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>to</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name><name>from</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>to</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_sal_first</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>salfirst_T</name> <modifier>*</modifier></type><name>sfirst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name> <init>= <expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sfirst</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>sl_sal_first</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>sfirst</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name>smp</name> <operator>=</operator> <operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>



<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name><name>smp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name><name>smp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sm_lead</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>sfirst</name><index>[<expr><name>c</name></expr>]</index></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>sfirst</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>




<while>while <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name><name>smp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>sm_lead_w</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></while>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <name>n</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name><name>smp</name><index>[<expr><name>i</name> <operator>+</operator> <name>n</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <name>c</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>salitem_T</name></type> <name>tsal</name></decl>;</decl_stmt>



<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tsal</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>i</name> <operator>+</operator> <name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>smp</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>smp</name> <operator>+</operator> <name>i</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>salitem_T</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>smp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>tsal</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type>
<name>mb_str2wide</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><call><name>mb_charlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><name><name>res</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_read_tree</name><parameter_list>(
<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>bytsp</name></decl></parameter>,
<parameter><decl><type><name>idx_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>idxsp</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>prefixcnt</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>long</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>



<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>get4c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>LONG_MAX</name> <operator>/</operator> <operator>(</operator><name>long</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>bp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>bytsp</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>


<expr_stmt><expr><name>ip</name> <operator>=</operator> <call><name>lalloc_clear</name><argument_list>(<argument><expr><name>len</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>idxsp</name> <operator>=</operator> <name>ip</name></expr>;</expr_stmt>


<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>read_tree_node</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>ip</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>prefixtree</name></expr></argument>, <argument><expr><name>prefixcnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>idx</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>











<function><type><specifier>static</specifier> <name>idx_T</name></type>
<name>read_tree_node</name><parameter_list>(
<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl></parameter>,
<parameter><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>maxidx</name></decl></parameter>, 
<parameter><decl><type><name>idx_T</name></type> <name>startidx</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>maxprefcondnr</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>idx</name> <init>= <expr><name>startidx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c2</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHARED_MASK</name></cpp:macro> <cpp:value>0x8000000</cpp:value></cpp:define>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>startidx</name> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <name>maxidx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>byts</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_TRUNCERROR</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;=</operator> <name>BY_SPECIAL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>BY_NOFLAGS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prefixtree</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>idxs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>c</name> <operator>!=</operator> <name>BY_INDEX</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>prefixtree</name></expr>)</condition>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>BY_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt></block_content></block></if> 
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>c</name> <operator>|=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get2c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <name>maxprefcondnr</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>c</name> <operator>|=</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>



<expr_stmt><expr><name>c2</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>==</operator> <name>BY_FLAGS2</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_AFX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>idxs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else 
<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get3c</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>n</name> <operator>&gt;=</operator> <name>maxidx</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>idxs</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>n</name> <operator>+</operator> <name>SHARED_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>byts</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
</block_content>}</block></for>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>startidx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>idxs</name><index>[<expr><name>startidx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>SHARED_MASK</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>idxs</name><index>[<expr><name>startidx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>&amp;=</operator> <operator>~</operator><name>SHARED_MASK</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>idxs</name><index>[<expr><name>startidx</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>
<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>read_tree_node</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>byts</name></expr></argument>, <argument><expr><name>idxs</name></expr></argument>, <argument><expr><name>maxidx</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>,
<argument><expr><name>prefixtree</name></expr></argument>, <argument><expr><name>maxprefcondnr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>

<return>return <expr><name>idx</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_reload_one</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>added_word</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>didit</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>fullpathcmp</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FPC_SAME</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>slang_clear</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_load_file</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>slang_clear</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>redraw_all_later</name><argument_list>(<argument><expr><name>SOME_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>didit</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block>



<if_stmt><if>if <condition>(<expr><name>added_word</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>didit</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>did_set_spelllang</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXLINELEN</name></cpp:macro> <cpp:value>500</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>afffile_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>af_enc</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>af_flagtype</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_rare</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_keepcase</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_bad</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_needaffix</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_circumfix</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_needcomp</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_comproot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_compforbid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_comppermit</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>af_nosuggest</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>af_pfxpostpone</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>af_ignoreextra</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>af_pref</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>af_suff</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>af_comp</name></decl>;</decl_stmt> 
}</block></struct></type> <name>afffile_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFT_CHAR</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFT_LONG</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFT_CAPLONG</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AFT_NUM</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<typedef>typedef <type><name><name>struct</name> <name>affentry_S</name></name></type> <name>affentry_T</name>;</typedef>

<struct>struct <name>affentry_S</name>
<block>{
<decl_stmt><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>ae_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ae_chop</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ae_add</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ae_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ae_cond</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>ae_prog</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>ae_compforbid</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char</name></type> <name>ae_comppermit</name></decl>;</decl_stmt> 
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AH_KEY_LEN</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define> 


<typedef>typedef <type><struct>struct <name>affheader_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>ah_key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>ah_flag</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ah_newID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ah_combine</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ah_follows</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>ah_first</name></decl>;</decl_stmt> 
}</block></struct></type> <name>affheader_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2AH</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((affheader_T *)(hi)-&gt;hi_key)</cpp:value></cpp:define>


<typedef>typedef <type><struct>struct <name>compitem_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>ci_key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>unsigned</name></type> <name>ci_flag</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>ci_newID</name></decl>;</decl_stmt> 
}</block></struct></type> <name>compitem_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2CI</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((compitem_T *)(hi)-&gt;hi_key)</cpp:value></cpp:define>









<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SBLOCKSIZE</name></cpp:macro> <cpp:value>16000</cpp:value></cpp:define> 
<typedef>typedef <type><name><name>struct</name> <name>sblock_S</name></name></type> <name>sblock_T</name>;</typedef>
<struct>struct <name>sblock_S</name>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>sb_used</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>sblock_T</name> <modifier>*</modifier></type><name>sb_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>sb_data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block>;</struct>




<typedef>typedef <type><name><name>struct</name> <name>wordnode_S</name></name></type> <name>wordnode_T</name>;</typedef>
<struct>struct <name>wordnode_S</name>
<block>{
<union>union 
<block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>hashkey</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt> 

}</block> <decl><name>wn_u1</name></decl>;</union>
<union>union 
<block>{
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>wnode</name></decl>;</decl_stmt> 
}</block> <decl><name>wn_u2</name></decl>;</union>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>wn_child</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>wn_sibling</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>wn_refs</name></decl>;</decl_stmt> 



<decl_stmt><decl><type><name>char_u</name></type> <name>wn_byte</name></decl>;</decl_stmt> 





<decl_stmt><decl><type><name>char_u</name></type> <name>wn_affixID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short_u</name></type> <name>wn_flags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name>wn_region</name></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>wn_nr</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WN_MASK</name></cpp:macro> <cpp:value>0xffff</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2WN</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(wordnode_T *)((hi)-&gt;hi_key)</cpp:value></cpp:define>




<typedef>typedef <type><struct>struct <name>spellinfo_S</name>
<block>{
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>si_foldroot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>si_foldwcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>si_keeproot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>si_keepwcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>si_prefroot</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>si_sugtree</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>sblock_T</name> <modifier>*</modifier></type><name>si_blocks</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>long</name></type> <name>si_blocks_cnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_did_emsg</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>si_compress_cnt</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>si_first_free</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>long</name></type> <name>si_free_count</name></decl>;</decl_stmt> 
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>si_wordnode_nr</name></decl>;</decl_stmt> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>si_spellbuf</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>si_ascii</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_add</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_clear_chartab</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_region</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>vimconv_T</name></type> <name>si_conv</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_memtot</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_verbose</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_msg_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_info</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_region_count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>si_region_name</name><index>[<expr><name>MAXREGIONS</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>



<decl_stmt><decl><type><name>garray_T</name></type> <name>si_rep</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>si_repsal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>si_sal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_sofofr</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_sofoto</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_nosugfile</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_nosplitsugs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_nocompoundsugs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_followup</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_collapse</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>si_commonwords</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>time_t</name></type> <name>si_sugtime</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_rem_accents</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>si_map</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_midword</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_compmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_compminlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_compsylmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_compoptions</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>si_comppat</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_compflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>si_nobreak</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>si_syllable</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>si_prefcond</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>si_newprefID</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>si_newcompID</name></decl>;</decl_stmt> 
}</block></struct></type> <name>spellinfo_T</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>is_aff_rule</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemcnt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mincount</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>aff_process_flags</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_info_item</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>affitem2flag</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flagtype</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>item</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lnum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name></type> <name>get_affitem</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flagtype</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>process_compflags</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>aff</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_renumber</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>aff_check_number</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>spinval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>affval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>aff_check_string</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spinval</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>affval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>str_equal</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_fromto</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sal_to_bool</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_affix_flags</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>get_pfxlist</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>store_afflist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>get_compflags</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>store_afflist</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>store_aff_word</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>, <parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>xht</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>condit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pfxlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pfxlen</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>getroom</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>align</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>getroom_save</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>store_word</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>region</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pfxlist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>need_affix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>tree_add_word</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>tree</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>region</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>affixID</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>wordnode_T</name> <modifier>*</modifier></type><name>get_wordnode</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>free_wordnode</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wordtree_compress</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>node_compress</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>node_equal</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_node</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>put_node</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regionmask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sug_filltree</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sug_maketable</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sug_filltable</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startwordnr</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>offset2bytes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sug_write</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_message</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_spellfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PFX_FLAGS</name></cpp:macro> <cpp:value>-256</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDIT_COMB</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDIT_CFIX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDIT_SUF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONDIT_AFF</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 




<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>compress_start</name> <init>= <expr><literal type="number">30000</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>compress_inc</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt> 
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>compress_added</name> <init>= <expr><literal type="number">500000</literal></expr></init></decl>;</decl_stmt> 





<function><type><name>int</name></type>
<name>spell_check_msm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>p_msm</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>start</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>incr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>added</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>start</name> <operator>=</operator> <operator>(</operator><call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">10</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>SBLOCKSIZE</name> <operator>/</operator> <literal type="number">102</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>incr</name> <operator>=</operator> <operator>(</operator><call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">102</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>SBLOCKSIZE</name> <operator>/</operator> <literal type="number">10</literal><operator>)</operator></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>added</name> <operator>=</operator> <call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>incr</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>added</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>incr</name> <operator>&gt;</operator> <name>start</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>compress_start</name> <operator>=</operator> <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>compress_inc</name> <operator>=</operator> <name>incr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>compress_added</name> <operator>=</operator> <name>added</name></expr>;</expr_stmt>
<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>






<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTLINESIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTWIDTH</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PRINTSOME</name><parameter_list>(<parameter><type><name>l</name></type></parameter>, <parameter><type><name>depth</name></type></parameter>, <parameter><type><name>fmt</name></type></parameter>, <parameter><type><name>a1</name></type></parameter>, <parameter><type><name>a2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>vim_snprintf(l + depth * PRINTWIDTH, PRINTLINESIZE - PRINTWIDTH * depth, fmt, a1, a2)</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>line1</name><index>[<expr><name>PRINTLINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>line2</name><index>[<expr><name>PRINTLINESIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>line3</name><index>[<expr><name>PRINTLINESIZE</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_clear_flags</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_clear_flags</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_print_node</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">"(%d)"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_nr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line2</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line3</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" %c -&gt; "</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" %c ???"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" $ "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line2</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">"%d/%d "</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_nr</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line3</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" | "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>PRINTSOME</name><argument_list>(<argument><expr><name>line3</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>line3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_print_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>line3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>line2</name></expr></argument>, <argument><expr><name>line3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_print_node</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_print_tree</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>root</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>spell_clear_flags</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>spell_print_node</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 





<function><type><specifier>static</specifier> <name>afffile_T</name> <modifier>*</modifier></type>
<name>spell_read_aff</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>aff</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>rline</name><index>[<expr><name>MAXLINELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXITEMCNT</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>
<expr_stmt><expr><call><name>char_u</name> <argument_list>*<argument><expr><operator>(</operator><name><name>items</name><index>[<expr><name>MAXITEMCNT</name></expr>]</index></name><operator>)</operator></expr></argument>;
<argument><expr><name>int</name> <name>itemcnt</name></expr></argument>;
<argument><expr><name>char_u</name> <operator>*</operator><name>p</name></expr></argument>;
<argument><expr><name>int</name> <name>lnum</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>;
<argument><expr><name>affheader_T</name> <operator>*</operator><name>cur_aff</name> <operator>=</operator> <name>NULL</name></expr></argument>;
<argument><expr><name>int</name> <name>did_postpone_prefix</name> <operator>=</operator> <name>FALSE</name></expr></argument>;
<argument><expr><name>int</name> <name>aff_todo</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>;
<argument><expr><name>hashtab_T</name> <operator>*</operator><name>tp</name></expr></argument>;
<argument><expr><name>char_u</name> <operator>*</operator><name>low</name> <operator>=</operator> <name>NULL</name></expr></argument>;
<argument><expr><name>char_u</name> <operator>*</operator><name>fol</name> <operator>=</operator> <name>NULL</name></expr></argument>;
<argument><expr><name>char_u</name> <operator>*</operator><name>upp</name> <operator>=</operator> <name>NULL</name></expr></argument>;
<argument><expr><name>int</name> <name>do_rep</name></expr></argument>;
<argument><expr><name>int</name> <name>do_repsal</name></expr></argument>;
<argument><expr><name>int</name> <name>do_sal</name></expr></argument>;
<argument><expr><name>int</name> <name>do_mapline</name></expr></argument>;
<argument><expr><name>int</name> <name>found_map</name> <operator>=</operator> <name>FALSE</name></expr></argument>;
<argument><expr><name>hashitem_T</name> <operator>*</operator><name>hi</name></expr></argument>;
<argument><expr><name>int</name> <name>l</name></expr></argument>;
<argument><expr><name>int</name> <name>compminlen</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>; 
<argument><expr><name>int</name> <name>compsylmax</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>; 
<argument><expr><name>int</name> <name>compoptions</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>; 
<argument><expr><name>int</name> <name>compmax</name> <operator>=</operator> <literal type="number">0</literal></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>compflags</name> <operator>=</operator> <name>NULL</name></expr></argument>; 

<argument><expr><name>char_u</name> <operator>*</operator><name>midword</name> <operator>=</operator> <name>NULL</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>syllable</name> <operator>=</operator> <name>NULL</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>sofofrom</name> <operator>=</operator> <name>NULL</name></expr></argument>; 
<argument><expr><name>char_u</name> <operator>*</operator><name>sofoto</name> <operator>=</operator> <name>NULL</name></expr></argument>; 




<argument><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr></argument>;
if <argument><expr><operator>(</operator><name>fd</name> <operator>==</operator> <name>NULL</name><operator>)</operator>
<block>{
<expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;
<return>return <expr><name>NULL</name></expr>;</return>
}</block></expr></argument></argument_list></call></expr></expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading affix file %s..."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>do_rep</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_rep</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>do_repsal</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_repsal</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>do_sal</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_sal</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>


<expr_stmt><expr><name>do_mapline</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>




<expr_stmt><expr><name>aff</name> <operator>=</operator> <operator>(</operator><name>afffile_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>afffile_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aff</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_comp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>rline</name></expr></argument>, <argument><expr><name>MAXLINELEN</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rline</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>string_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name>rline</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Conversion failure for word in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>rline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>rline</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name>itemcnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>line</name></expr>;</init> <condition>;</condition> <incr/>)</control>
<block>{<block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>==</operator> <name>MAXITEMCNT</name></expr>)</condition><block type="pseudo"><block_content> 
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>items</name><index>[<expr><name>itemcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <call><name>spell_info_item</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"SET"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name> <operator>=</operator> <call><name>enc_canonize</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name>
<operator>&amp;&amp;</operator> <call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name></expr></argument>,
<argument><expr><name>p_enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Conversion in %s not supported: from %s to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name></expr></argument>, <argument><expr><name>p_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_fail</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"FLAG"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>==</operator> <name>AFT_CHAR</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"long"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>=</operator> <name>AFT_LONG</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"num"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>=</operator> <name>AFT_NUM</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"caplong"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>=</operator> <name>AFT_CAPLONG</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Invalid value for FLAG in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff</name><operator>-&gt;</operator><name>af_rare</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_keepcase</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_bad</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needaffix</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_circumfix</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needcomp</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_comproot</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_nosuggest</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name>compflags</name> <operator>!=</operator> <name>NULL</name>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_suff</name><operator>.</operator><name>ht_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_pref</name><operator>.</operator><name>ht_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"FLAG after using flags in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>spell_info_item</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>,
<argument><expr><operator>(</operator><ternary><condition><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator>
<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>
<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"MIDWORD"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>midword</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>midword</name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"TRY"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"RAR"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"RARE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_rare</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_rare</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"KEP"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"KEEPCASE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_keepcase</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_keepcase</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"BAD"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"FORBIDDENWORD"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_bad</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_bad</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NEEDAFFIX"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needaffix</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_needaffix</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CIRCUMFIX"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_circumfix</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_circumfix</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NOSUGGEST"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_nosuggest</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_nosuggest</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NEEDCOMPOUND"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"ONLYINCOMPOUND"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needcomp</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_needcomp</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDROOT"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_comproot</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_comproot</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDFORBIDFLAG"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_compforbid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_compforbid</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name><operator>.</operator><name>ht_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Defining COMPOUNDFORBIDFLAG after PFX item may give wrong results in %s line %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDPERMITFLAG"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_comppermit</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_comppermit</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name><operator>.</operator><name>ht_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Defining COMPOUNDPERMITFLAG after PFX item may give wrong results in %s line %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDFLAG"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>compflags</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compflags</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDRULES"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wrong COMPOUNDRULES value in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDRULE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>compflags</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><call><name>skipdigits</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compflags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>l</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>compflags</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>compflags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>compflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>compflags</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDWORDMAX"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>compmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compmax</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wrong COMPOUNDWORDMAX value in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDMIN"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>compminlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compminlen</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compminlen</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wrong COMPOUNDMIN value in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDSYLMAX"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>compsylmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compsylmax</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>compsylmax</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wrong COMPOUNDSYLMAX value in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDDUP"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compoptions</name> <operator>|=</operator> <name>COMP_CHECKDUP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDREP"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compoptions</name> <operator>|=</operator> <name>COMP_CHECKREP</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDCASE"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compoptions</name> <operator>|=</operator> <name>COMP_CHECKCASE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDTRIPLE"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>compoptions</name> <operator>|=</operator> <name>COMP_CHECKTRIPLE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDPATTERN"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Wrong CHECKCOMPOUNDPATTERN value in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"CHECKCOMPOUNDPATTERN"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name> <init>= <expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr></argument>,
<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index>
<operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index>
<operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"SYLLABLE"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>syllable</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>syllable</name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NOBREAK"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_nobreak</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NOSPLITSUGS"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_nosplitsugs</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NOCOMPOUNDSUGS"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_nocompoundsugs</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"NOSUGFILE"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_nosugfile</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"PFXPOSTPONE"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"IGNOREEXTRA"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff</name><operator>-&gt;</operator><name>af_ignoreextra</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"PFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"SFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <name>aff_todo</name> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>itemcnt</name> <operator>&gt;=</operator> <literal type="number">4</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>lasti</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tp</name> <operator>=</operator> <operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_suff</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>





<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>AH_KEY_LEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>cur_aff</name> <operator>=</operator> <call><name>HI2AH</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_combine</name></name> <operator>!=</operator> <operator>(</operator><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'Y'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Different combining flag in continued affix block in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_follows</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Duplicate affix in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>cur_aff</name> <operator>=</operator> <operator>(</operator><name>affheader_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>affheader_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>cur_aff</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>=</operator> <call><name>affitem2flag</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>AH_KEY_LEN</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_bad</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_rare</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_keepcase</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needaffix</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_circumfix</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_nosuggest</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_needcomp</name></name>
<operator>||</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_flag</name></name> <operator>==</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_comproot</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Affix also used for BAD/RARE/KEEPCASE/NEEDAFFIX/NEEDCOMPOUND/NOSUGGEST in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_key</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_combine</name></name> <operator>=</operator> <operator>(</operator><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'Y'</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>&gt;</operator> <name>lasti</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"S"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>lasti</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_follows</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_follows</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>



<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>&gt;</operator> <name>lasti</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_afftrailing</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"Y"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"N"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected Y or N in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_newID</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>check_renumber</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_newID</name></name> <operator>=</operator> <operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name></expr>;</expr_stmt>




<expr_stmt><expr><name>did_postpone_prefix</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>did_postpone_prefix</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aff_todo</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>items</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"PFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"SFX"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <name>aff_todo</name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_key</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name>itemcnt</name> <operator>&gt;=</operator> <literal type="number">5</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>aff_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>upper</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lasti</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>




<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>&gt;</operator> <name>lasti</name>
<operator>&amp;&amp;</operator> <operator>!</operator><name><name>aff</name><operator>-&gt;</operator><name>af_ignoreextra</name></name>
<operator>&amp;&amp;</operator> <operator>*</operator><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>
<operator>||</operator> <name>itemcnt</name> <operator>!=</operator> <name>lasti</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_afftrailing</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><name>lasti</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<expr_stmt><expr><operator>--</operator><name>aff_todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>aff_entry</name> <operator>=</operator> <operator>(</operator><name>affentry_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>affentry_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>aff_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_flags</name></name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>aff_process_flags</name><argument_list>(<argument><expr><name>aff</name></expr></argument>, <argument><expr><name>aff_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>||</operator> <operator>!</operator><operator>(</operator><call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_next</name></name> <operator>=</operator> <name><name>cur_aff</name><operator>-&gt;</operator><name>ah_first</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_first</name></name> <operator>=</operator> <name>aff_entry</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXLINELEN</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s$"</literal></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_prog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name> <operator>+</operator> <name>RE_STRICT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_prog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Broken condition in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>





<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'P'</literal> <operator>&amp;&amp;</operator> <name><name>aff</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name>
<operator>&amp;&amp;</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>





<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name><index>[<expr><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(
<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>c_up</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c_up</name> <operator>=</operator> <call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c_up</name> <operator>!=</operator> <name>c</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>c</name><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name>
<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>c_up</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXLINELEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>onecap_copy</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(
<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>=</operator> <name>c_up</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"^%s"</literal></expr></argument>,
<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_prog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_prog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>==</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name><operator>.</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition>
<incr><expr><operator>--</operator><name>idx</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>idx</name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>str_equal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>;</expr_stmt>
<expr_stmt><expr><name>pp</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>
<operator>+</operator> <name>idx</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>,
<argument><expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_cond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>aff_entry</name><operator>-&gt;</operator><name>ae_add</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>



<expr_stmt><expr><name>n</name> <operator>=</operator> <name>PFX_FLAGS</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_combine</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <name>WFP_NC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>upper</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <name>WFP_UP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_comppermit</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <name>WFP_COMPPERMIT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff_entry</name><operator>-&gt;</operator><name>ae_compforbid</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>|=</operator> <name>WFP_COMPFORBID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>tree_add_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_prefroot</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>,
<argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_newID</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>did_postpone_prefix</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>aff_todo</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>did_postpone_prefix</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>--</operator><name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cur_aff</name><operator>-&gt;</operator><name>ah_newID</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"FOL"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>fol</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>fol</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"LOW"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>low</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>low</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"UPP"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>upp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>upp</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"REP"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>||</operator> <call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"REPSAL"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected REP(SAL) count in %s line %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"REP"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"REPSAL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>&amp;&amp;</operator> <name>itemcnt</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>itemcnt</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><literal type="number">3</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_afftrailing</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'S'</literal></expr> ?</condition><then> <expr><name>do_repsal</name></expr> </then><else>: <expr><name>do_rep</name></expr></else></ternary></expr>)</condition>
<block>{<block_content>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
<expr_stmt><expr><call><name>add_fromto</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'S'</literal></expr>
?</condition><then> <expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_repsal</name></name></expr>
</then><else>: <expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_rep</name></name></expr></else></ternary></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"MAP"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_map</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>found_map</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>*</operator><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Expected MAP count in %s line %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>do_mapline</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_data</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call>
<operator>!=</operator> <name>NULL</name><operator>)</operator>
<operator>||</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Duplicate character in MAP in %s line %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>



<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_map</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_map</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"SAL"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>do_sal</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"followup"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_followup</name></name> <operator>=</operator> <call><name>sal_to_bool</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"collapse_result"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_collapse</name></name> <operator>=</operator> <call><name>sal_to_bool</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"remove_accents"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_rem_accents</name></name> <operator>=</operator> <call><name>sal_to_bool</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>add_fromto</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_sal</name></name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
<argument><expr><ternary><condition><expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"_"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>
</then><else>: <expr><name><name>items</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"SOFOFROM"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>sofofrom</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sofofrom</name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>is_aff_rule</name><argument_list>(<argument><expr><name>items</name></expr></argument>, <argument><expr><name>itemcnt</name></expr></argument>, <argument><expr><literal type="string">"SOFOTO"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call>
<operator>&amp;&amp;</operator> <name>sofoto</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>sofoto</name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"COMMON"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>itemcnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_commonwords</name></name></expr></argument>,
<argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hash_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_commonwords</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unrecognized or duplicate item in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>fol</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>low</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>upp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_clear_chartab</name></name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>init_spell_chartab</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_clear_chartab</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>enc_utf8</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fol</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>low</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>upp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Missing FOL/LOW/UPP line in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>set_spell_chartab</name><argument_list>(<argument><expr><name>fol</name></expr></argument>, <argument><expr><name>low</name></expr></argument>, <argument><expr><name>upp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>low</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>upp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>compmax</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_number</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compmax</name></name></expr></argument>, <argument><expr><name>compmax</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDWORDMAX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compmax</name></name> <operator>=</operator> <name>compmax</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compminlen</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_number</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compminlen</name></name></expr></argument>, <argument><expr><name>compminlen</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDMIN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compminlen</name></name> <operator>=</operator> <name>compminlen</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compsylmax</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>syllable</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"COMPOUNDSYLMAX used without SYLLABLE"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>aff_check_number</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compsylmax</name></name></expr></argument>, <argument><expr><name>compsylmax</name></expr></argument>, <argument><expr><literal type="string">"COMPOUNDSYLMAX"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compsylmax</name></name> <operator>=</operator> <name>compsylmax</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compoptions</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_number</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compoptions</name></name></expr></argument>, <argument><expr><name>compoptions</name></expr></argument>, <argument><expr><literal type="string">"COMPOUND options"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compoptions</name></name> <operator>|=</operator> <name>compoptions</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compflags</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>process_compflags</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>aff</name></expr></argument>, <argument><expr><name>compflags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>&lt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>==</operator> <literal type="number">127</literal> <operator>||</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>==</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Too many postponed prefixes"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name> <operator>==</operator> <literal type="number">127</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Too many compound flags"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Too many postponed prefixes and/or compound flags"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>syllable</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_string</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_syllable</name></name></expr></argument>, <argument><expr><name>syllable</name></expr></argument>, <argument><expr><literal type="string">"SYLLABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_syllable</name></name> <operator>=</operator> <name>syllable</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sofofrom</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>sofoto</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>sofofrom</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>sofoto</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Missing SOFO%s line in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name>sofofrom</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">"FROM"</literal></expr> </then><else>: <expr><literal type="string">"TO"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Both SAL and SOFO lines in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_string</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name></expr></argument>, <argument><expr><name>sofofrom</name></expr></argument>, <argument><expr><literal type="string">"SOFOFROM"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>aff_check_string</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name></expr></argument>, <argument><expr><name>sofoto</name></expr></argument>, <argument><expr><literal type="string">"SOFOTO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name> <operator>=</operator> <name>sofofrom</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name> <operator>=</operator> <name>sofoto</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>midword</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>aff_check_string</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_midword</name></name></expr></argument>, <argument><expr><name>midword</name></expr></argument>, <argument><expr><literal type="string">"MIDWORD"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_midword</name></name> <operator>=</operator> <name>midword</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>aff</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_aff_rule</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>items</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>itemcnt</name></decl></parameter>,
<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>rulename</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>mincount</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>items</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rulename</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name>itemcnt</name> <operator>==</operator> <name>mincount</name>
<operator>||</operator> <operator>(</operator><name>itemcnt</name> <operator>&gt;</operator> <name>mincount</name> <operator>&amp;&amp;</operator> <name><name>items</name><index>[<expr><name>mincount</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>aff_process_flags</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>prevp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flag</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>affile</name><operator>-&gt;</operator><name>af_compforbid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>affile</name><operator>-&gt;</operator><name>af_comppermit</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ae_flags</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>prevp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>get_affitem</name><argument_list>(<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <name><name>affile</name><operator>-&gt;</operator><name>af_comppermit</name></name> <operator>||</operator> <name>flag</name> <operator>==</operator> <name><name>affile</name><operator>-&gt;</operator><name>af_compforbid</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>prevp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>prevp</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>==</operator> <name><name>affile</name><operator>-&gt;</operator><name>af_comppermit</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ae_comppermit</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ae_compforbid</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>==</operator> <name>AFT_NUM</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_info_item</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"NAME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"HOME"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"VERSION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"AUTHOR"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"EMAIL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"COPYRIGHT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>affitem2flag</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>flagtype</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>item</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>lnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>unsigned</name></type> <name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>item</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>get_affitem</name><argument_list>(<argument><expr><name>flagtype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>flagtype</name> <operator>==</operator> <name>AFT_NUM</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Flag is not a number in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Illegal flag in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_affname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>unsigned</name></type>
<name>get_affitem</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flagtype</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flagtype</name> <operator>==</operator> <name>AFT_NUM</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>pp</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><operator>*</operator><name>pp</name></expr>;</expr_stmt> 
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>getdigits</name><argument_list>(<argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>ZERO_FLAG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><name>pp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flagtype</name> <operator>==</operator> <name>AFT_LONG</name> <operator>||</operator> <operator>(</operator><name>flagtype</name> <operator>==</operator> <name>AFT_CAPLONG</name>
<operator>&amp;&amp;</operator> <name>res</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>res</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>pp</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><name>pp</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>res</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></else></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_compflags</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>aff</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>prevp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>flag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>compitem_T</name> <modifier>*</modifier></type><name>ci</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>




<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>compflags</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>compflags</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"/?*+[]"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>tp</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>prevp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>flag</name> <operator>=</operator> <call><name>get_affitem</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>flag</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>prevp</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prevp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_comp</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>HI2CI</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ci_newID</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>(</operator><name>compitem_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>compitem_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>ci</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ci_key</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ci_flag</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>


<do>do
<block>{<block_content>
<expr_stmt><expr><call><name>check_renumber</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block> while <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"/?*+[]\\-^"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><name><name>ci</name><operator>-&gt;</operator><name>ci_newID</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_add</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_comp</name></name></expr></argument>, <argument><expr><name><name>ci</name><operator>-&gt;</operator><name>ci_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>*</operator><name>tp</name><operator>++</operator> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>aff</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>==</operator> <name>AFT_NUM</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>tp</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_renumber</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name> <operator>==</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>&lt;</operator> <literal type="number">128</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_newprefID</name></name> <operator>=</operator> <literal type="number">127</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_newcompID</name></name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>flag_in_afflist</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flagtype</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>, <parameter><decl><type><name>unsigned</name></type> <name>flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>flagtype</name></expr>)</condition>
<block>{<block_content>
<case>case <expr><name>AFT_CHAR</name></expr>:</case>
<return>return <expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>

<case>case <expr><name>AFT_CAPLONG</name></expr>:</case>
<case>case <expr><name>AFT_LONG</name></expr>:</case>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>afflist</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flagtype</name> <operator>==</operator> <name>AFT_LONG</name> <operator>||</operator> <operator>(</operator><name>n</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>n</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>

<case>case <expr><name>AFT_NUM</name></expr>:</case>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>afflist</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name>ZERO_FLAG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>flag</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
<break>break;</break>
</block_content>}</block></switch>
<return>return <expr><name>FALSE</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>aff_check_number</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>spinval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>affval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>spinval</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>spinval</name> <operator>!=</operator> <name>affval</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s value differs from what is used in another .aff file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>aff_check_string</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spinval</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>affval</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>spinval</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>spinval</name></expr></argument>, <argument><expr><name>affval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%s value differs from what is used in another .aff file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>str_equal</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>s2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>s1</name> <operator>==</operator> <name>s2</name></expr>;</return></block_content></block></if></if_stmt>
<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_fromto</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name> <operator>=</operator> <call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>sal_to_bool</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"1"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_free_aff</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>aff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>affheader_T</name> <modifier>*</modifier></type><name>ah</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>ae</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>aff</name><operator>-&gt;</operator><name>af_enc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>ht</name> <operator>=</operator> <operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name></name></expr>;</init> <condition>;</condition> <incr><expr><name>ht</name> <operator>=</operator> <operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_suff</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>todo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>ht_used</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ah</name> <operator>=</operator> <call><name>HI2AH</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>ae</name> <operator>=</operator> <name><name>ah</name><operator>-&gt;</operator><name>ah_first</name></name></expr>;</init> <condition><expr><name>ae</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ae</name> <operator>=</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_prog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>ht</name> <operator>==</operator> <operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_suff</name></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_pref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_suff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>aff</name><operator>-&gt;</operator><name>af_comp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_read_dic</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>ht</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>line</name><index>[<expr><name>MAXLINELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>store_afflist</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pfxlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_affix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lnum</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>non_ascii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>message</name><index>[<expr><name>MAXLINELEN</name> <operator>+</operator> <name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>duplicate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>




<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading dictionary file %s..."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_msg_count</name></name> <operator>=</operator> <literal type="number">999999</literal></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXLINELEN</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_isdigit</name><argument_list>(<argument><expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E760: No word count in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>






<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXLINELEN</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator> <name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 



<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>l</name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><name><name>line</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>string_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Conversion failure for word in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>w</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>



<expr_stmt><expr><name>afflist</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>w</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>afflist</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>non_ascii</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_msg_count</name></name> <operator>&gt;</operator> <literal type="number">10000</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_msg_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>message</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"line %6d, word %6ld - %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldwcount</name></name> <operator>+</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_keepwcount</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_outtrans_long_attr</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_didout</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name>dw</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>getroom_save</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>dw</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>dw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Duplicate word in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>duplicate</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"First duplicate word in %s line %d: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>duplicate</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>store_afflist</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pfxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>need_affix</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>afflist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <call><name>get_affix_flags</name><argument_list>(<argument><expr><name>affile</name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_needaffix</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_needaffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need_affix</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>pfxlen</name> <operator>=</operator> <call><name>get_pfxlist</name><argument_list>(<argument><expr><name>affile</name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>store_afflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>get_compflags</name><argument_list>(<argument><expr><name>affile</name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>store_afflist</name> <operator>+</operator> <name>pfxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>store_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region</name></name></expr></argument>,
<argument><expr><name>store_afflist</name></expr></argument>, <argument><expr><name>need_affix</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>afflist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>store_aff_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>affile</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_suff</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_pref</name></name></expr></argument>,
<argument><expr><name>CONDIT_SUF</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>store_afflist</name></expr></argument>, <argument><expr><name>pfxlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>store_aff_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>dw</name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>affile</name></expr></argument>,
<argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_pref</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>CONDIT_SUF</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>store_afflist</name></expr></argument>, <argument><expr><name>pfxlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>duplicate</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%d duplicate word(s) in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>duplicate</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <name>non_ascii</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Ignored %d word(s) with non-ASCII characters in %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>non_ascii</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_affix_flags</name><parameter_list>(<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_keepcase</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_keepcase</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_KEEPCAP</name> <operator>|</operator> <name>WF_FIXCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_rare</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_rare</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_bad</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_bad</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_BANNED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_needcomp</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_needcomp</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_NEEDCOMP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_comproot</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_comproot</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_COMPROOT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_nosuggest</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_nosuggest</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_NOSUGGEST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>flags</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_pfxlist</name><parameter_list>(
<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>store_afflist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>prevp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>afflist</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>prevp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_affitem</name><argument_list>(<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>prevp</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prevp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_pref</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>id</name> <operator>=</operator> <call><name>HI2AH</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ah_newID</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>store_afflist</name><index>[<expr><name>cnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>==</operator> <name>AFT_NUM</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>store_afflist</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_compflags</name><parameter_list>(
<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>store_afflist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>prevp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>key</name><index>[<expr><name>AH_KEY_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>afflist</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>prevp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>get_affitem</name><argument_list>(<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>prevp</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>prevp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_comp</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>store_afflist</name><index>[<expr><name>cnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>HI2CI</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>ci_newID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name> <operator>==</operator> <name>AFT_NUM</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><name><name>store_afflist</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>store_aff_word</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>afflist</name></decl></parameter>, 
<parameter><decl><type><name>afffile_T</name> <modifier>*</modifier></type><name>affile</name></decl></parameter>,
<parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
<parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>xht</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>condit</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pfxlist</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>pfxlen</name></decl></parameter>)</parameter_list> 

<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>affheader_T</name> <modifier>*</modifier></type><name>ah</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>affentry_T</name> <modifier>*</modifier></type><name>ae</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>newword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>use_pfxlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_pfxlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_affix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>store_afflist</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>pfx_pfxlist</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>wordlen</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>use_condit</name></decl>;</decl_stmt>

<expr_stmt><expr><name>todo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>ht</name><operator>-&gt;</operator><name>ht_used</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>retval</name> <operator>==</operator> <name>OK</name></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ah</name> <operator>=</operator> <call><name>HI2AH</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>condit</name> <operator>&amp;</operator> <name>CONDIT_COMB</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ah</name><operator>-&gt;</operator><name>ah_combine</name></name><operator>)</operator>
<operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name>afflist</name></expr></argument>,
<argument><expr><name><name>ah</name><operator>-&gt;</operator><name>ah_flag</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>

<for>for <control>(<init><expr><name>ae</name> <operator>=</operator> <name><name>ah</name><operator>-&gt;</operator><name>ah_first</name></name></expr>;</init> <condition><expr><name>ae</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>ae</name> <operator>=</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_next</name></name></expr></incr>)</control>
<block>{<block_content>










<if_stmt><if>if <condition>(<expr><operator>(</operator><name>xht</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>affile</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name>
<operator>||</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>!=</operator> <name>NULL</name>
<operator>||</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>wordlen</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>ae</name><operator>-&gt;</operator><name>ae_prog</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <call><name>vim_regexec_prog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ae</name><operator>-&gt;</operator><name>ae_prog</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>word</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>condit</name> <operator>&amp;</operator> <name>CONDIT_CFIX</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>
<operator>==</operator> <operator>(</operator><operator>(</operator><name>condit</name> <operator>&amp;</operator> <name>CONDIT_AFF</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <operator>!</operator><call><name>flag_in_afflist</name><argument_list>(<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>,
<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>, <argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_circumfix</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>xht</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ae</name><operator>-&gt;</operator><name>ae_add</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>newword</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>mb_charlen</name><argument_list>(<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>newword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>newword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>MB_CHARLEN</name><argument_list>(<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_chop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>( <init>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ae</name><operator>-&gt;</operator><name>ae_add</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_add</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>use_flags</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name>use_pfxlist</name> <operator>=</operator> <name>pfxlist</name></expr>;</expr_stmt>
<expr_stmt><expr><name>use_pfxlen</name> <operator>=</operator> <name>pfxlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>need_affix</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>use_condit</name> <operator>=</operator> <name>condit</name> <operator>|</operator> <name>CONDIT_COMB</name> <operator>|</operator> <name>CONDIT_AFF</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>use_flags</name> <operator>|=</operator> <call><name>get_affix_flags</name><argument_list>(<argument><expr><name>affile</name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_needaffix</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>,
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_needaffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need_affix</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_circumfix</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>flag_in_afflist</name><argument_list>(
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_flagtype</name></name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>,
<argument><expr><name><name>affile</name><operator>-&gt;</operator><name>af_circumfix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>use_condit</name> <operator>|=</operator> <name>CONDIT_CFIX</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>condit</name> <operator>&amp;</operator> <name>CONDIT_CFIX</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>need_affix</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name>
<operator>||</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>affile</name><operator>-&gt;</operator><name>af_pfxpostpone</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>use_pfxlen</name> <operator>=</operator> <call><name>get_pfxlist</name><argument_list>(<argument><expr><name>affile</name></expr></argument>,
<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>, <argument><expr><name>store_afflist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>use_pfxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>use_pfxlist</name> <operator>=</operator> <name>store_afflist</name></expr>;</expr_stmt>



<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pfxlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>use_pfxlen</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>pfxlist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>use_pfxlist</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>use_pfxlen</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>use_pfxlist</name><index>[<expr><name>use_pfxlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pfxlist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>get_compflags</name><argument_list>(<argument><expr><name>affile</name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>,
<argument><expr><name>use_pfxlist</name> <operator>+</operator> <name>use_pfxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>




<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>pfxlen</name></expr>;</init> <condition><expr><name><name>pfxlist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>use_pfxlen</name></expr>;</init>
<condition><expr><name><name>use_pfxlist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>pfxlist</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>use_pfxlist</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name><name>use_pfxlist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>use_pfxlist</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>pfxlist</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>use_pfxlist</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>use_pfxlist</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_compforbid</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>pfx_pfxlist</name></expr></argument>, <argument><expr><name>use_pfxlist</name></expr></argument>, <argument><expr><name>use_pfxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>use_pfxlist</name> <operator>=</operator> <name>pfx_pfxlist</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_prefroot</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_prefroot</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>use_flags</name> <operator>|=</operator> <name>WF_HAS_AFF</name></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ah</name><operator>-&gt;</operator><name>ah_combine</name></name> <operator>&amp;&amp;</operator> <name>use_pfxlist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_pfxlist</name> <operator>+=</operator> <name>use_pfxlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ae</name><operator>-&gt;</operator><name>ae_comppermit</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>xht</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>use_flags</name> <operator>|=</operator> <name>WF_NOCOMPAFT</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>use_flags</name> <operator>|=</operator> <name>WF_NOCOMPBEF</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>store_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name>use_flags</name></expr></argument>,
<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region</name></name></expr></argument>, <argument><expr><name>use_pfxlist</name></expr></argument>,
<argument><expr><name>need_affix</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><operator>(</operator><name>condit</name> <operator>&amp;</operator> <name>CONDIT_SUF</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>store_aff_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>, <argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>,
<argument><expr><name>affile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>affile</name><operator>-&gt;</operator><name>af_suff</name></name></expr></argument>, <argument><expr><name>xht</name></expr></argument>,
<argument><expr><name>use_condit</name> <operator>&amp;</operator> <operator>(</operator><ternary><condition><expr><name>xht</name> <operator>==</operator> <name>NULL</name></expr>
?</condition><then> <expr><operator>~</operator><literal type="number">0</literal></expr> </then><else>: <expr><operator>~</operator><name>CONDIT_SUF</name></expr></else></ternary><operator>)</operator></expr></argument>,
<argument><expr><name>use_flags</name></expr></argument>, <argument><expr><name>use_pfxlist</name></expr></argument>, <argument><expr><name>pfxlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>xht</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ah</name><operator>-&gt;</operator><name>ah_combine</name></name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>store_aff_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>,
<argument><expr><name>afflist</name></expr></argument>, <argument><expr><name>affile</name></expr></argument>,
<argument><expr><name>xht</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>use_condit</name></expr></argument>,
<argument><expr><name>use_flags</name></expr></argument>, <argument><expr><name>use_pfxlist</name></expr></argument>,
<argument><expr><name>pfxlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>
<operator>||</operator> <operator>(</operator><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>store_aff_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>newword</name></expr></argument>,
<argument><expr><name><name>ae</name><operator>-&gt;</operator><name>ae_flags</name></name></expr></argument>, <argument><expr><name>affile</name></expr></argument>,
<argument><expr><name>xht</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>use_condit</name></expr></argument>,
<argument><expr><name>use_flags</name></expr></argument>, <argument><expr><name>use_pfxlist</name></expr></argument>,
<argument><expr><name>pfxlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>spell_read_wordfile</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>rline</name><index>[<expr><name>MAXLINELEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>did_word</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>non_ascii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regionmask</name></decl>;</decl_stmt>




<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading word file %s..."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>rline</name></expr></argument>, <argument><expr><name>MAXLINELEN</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rline</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>rline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rline</name><index>[<expr><name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>--</operator><name>l</name></expr>;</expr_stmt></block_content></block></while>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt> 
<expr_stmt><expr><name><name>rline</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <call><name>string_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name>rline</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>pc</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Conversion failure for word in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>rline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>pc</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>pc</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> <operator>=</operator> <name>rline</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>line</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"encoding="</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Duplicate /encoding= line ignored in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>did_word</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"/encoding= line after word ignored in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name></decl>;</decl_stmt>


<expr_stmt><expr><name>line</name> <operator>+=</operator> <literal type="number">9</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>enc</name> <operator>=</operator> <call><name>enc_canonize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name>
<operator>&amp;&amp;</operator> <call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>p_enc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Conversion in %s not supported: from %s to %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>p_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_conv</name><operator>.</operator><name>vc_fail</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="string">"regions="</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Duplicate /regions= line ignored in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>line</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>MAXREGIONS</name> <operator>*</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Too many regions in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region_name</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region</name></name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"/ line ignored in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>line</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>regionmask</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_region</name></name></expr>;</expr_stmt>


<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_KEEPCAP</name> <operator>|</operator> <name>WF_FIXCAP</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_BANNED</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>regionmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_REGION</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>l</name> <operator>&gt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Invalid region nr in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>regionmask</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name>l</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Unrecognized flags in %s line %ld: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>non_ascii</name></expr>;</expr_stmt>
<continue>continue;</continue>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>store_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>regionmask</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>did_word</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <name>non_ascii</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Ignored %d words with non-ASCII characters"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>non_ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>getroom</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>align</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sblock_T</name> <modifier>*</modifier></type><name>bl</name> <init>= <expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <name>bl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name> <operator>=</operator> <operator>(</operator><name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator>
<operator>&amp;</operator> <operator>~</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bl</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>SBLOCKSIZE</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>SBLOCKSIZE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>bl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>bl</name> <operator>=</operator> <call><name>alloc_clear</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sblock_T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>SBLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>bl</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_did_emsg</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E845: Insufficient memory, word list will be incomplete"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_did_emsg</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>sb_next</name></name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks</name></name> <operator>=</operator> <name>bl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>sb_data</name></name> <operator>+</operator> <name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>bl</name><operator>-&gt;</operator><name>sb_used</name></name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>
<name>getroom_save</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sc</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>sc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>sc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<return>return <expr><name>sc</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_blocks</name><parameter_list>(<parameter><decl><type><name>sblock_T</name> <modifier>*</modifier></type><name>bl</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>sblock_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>bl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>bl</name><operator>-&gt;</operator><name>sb_next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bl</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>wordnode_T</name> <modifier>*</modifier></type>
<name>wordtree_alloc</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<return>return <expr><operator>(</operator><name>wordnode_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wordnode_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>










<function><type><specifier>static</specifier> <name>int</name></type>
<name>store_word</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>region</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pfxlist</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>need_affix</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ct</name> <init>= <expr><call><name>captype</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>foldword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>foldword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pfxlist</name></expr>;</init> <condition><expr><name>res</name> <operator>==</operator> <name>OK</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_affix</name> <operator>||</operator> <operator>(</operator><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>tree_add_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>foldword</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name></expr></argument>, <argument><expr><name>ct</name> <operator>|</operator> <name>flags</name></expr></argument>,
<argument><expr><name>region</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>*</operator><name>p</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_foldwcount</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>OK</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ct</name> <operator>==</operator> <name>WF_KEEPCAP</name> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>pfxlist</name></expr>;</init> <condition><expr><name>res</name> <operator>==</operator> <name>OK</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>need_affix</name> <operator>||</operator> <operator>(</operator><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>tree_add_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_keeproot</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
<argument><expr><name>region</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>*</operator><name>p</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_keepwcount</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>tree_add_word</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>region</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>affixID</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>copyp</name></decl>, <decl><type ref="prev"><modifier>*</modifier><modifier>*</modifier></type><name>copyprev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>



<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>--</operator><name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>copyprev</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>copyp</argument>)</argument_list></macro>
<block>{<block_content>

<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>get_wordnode</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>np</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>=</operator> <name><name>copyp</name><operator>-&gt;</operator><name>wn_child</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_refs</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>=</operator> <name><name>copyp</name><operator>-&gt;</operator><name>wn_byte</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>=</operator> <name><name>copyp</name><operator>-&gt;</operator><name>wn_flags</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>=</operator> <name><name>copyp</name><operator>-&gt;</operator><name>wn_region</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>=</operator> <name><name>copyp</name><operator>-&gt;</operator><name>wn_affixID</name></name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>copyprev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>copyprev</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name>copyprev</name> <operator>=</operator> <operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>copyp</name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block>
</block_content>}</block></if></if_stmt>





<while>while <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>&lt;</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name>flags</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>
?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>affixID</name></expr>
</then><else>: <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WN_MASK</name><operator>)</operator>
<operator>||</operator> <operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>==</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WN_MASK</name><operator>)</operator>
<operator>&amp;&amp;</operator> <operator>(</operator><ternary><condition><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sugtree</name></name></expr>
?</condition><then> <expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator> <operator>&lt;</operator> <name>region</name></expr>
</then><else>: <expr><name><name>node</name><operator>-&gt;</operator><name>wn_affixID</name></name>
<operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>affixID</name></expr></else></ternary><operator>)</operator><operator>)</operator><operator>)</operator></expr></else></ternary><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name>
<operator>||</operator> <operator>(</operator><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&lt;</operator> <literal type="number">0</literal>
<operator>||</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_sugtree</name></name>
<operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>!=</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WN_MASK</name><operator>)</operator>
<operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>!=</operator> <name>affixID</name><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>get_wordnode</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>np</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>*</operator><name>prev</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <name>np</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>|=</operator> <name>region</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>=</operator> <name>affixID</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>node</name><operator>-&gt;</operator><name>wn_child</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>*</operator><name>prev</name></expr>;</expr_stmt>
</block_content>}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><literal type="string">"Added \"%s\""</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_print_tree</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<expr_stmt><expr><operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_msg_count</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compress_cnt</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>spin</name><operator>-&gt;</operator><name>si_compress_cnt</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name> <operator>+=</operator> <name>compress_inc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>













<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_COMPRESS_ALLWAYS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compress_cnt</name></name> <operator>==</operator> <literal type="number">1</literal></expr>
?</condition><then> <expr><name><name>spin</name><operator>-&gt;</operator><name>si_free_count</name></name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>
</then><else>: <expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name> <operator>&gt;=</operator> <name>compress_start</name></expr></else></ternary></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>




<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name> <operator>-=</operator> <name>compress_inc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compress_cnt</name></name> <operator>=</operator> <name>compress_added</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>msg_compressing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_didout</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>





<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>affixID</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_keeproot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>wordnode_T</name> <modifier>*</modifier></type>
<name>get_wordnode</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>wordnode_T</name> <operator>*</operator><operator>)</operator><call><name>getroom</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wordnode_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>wn_child</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wordnode_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>--</operator><name><name>spin</name><operator>-&gt;</operator><name>si_free_count</name></name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>wn_nr</name></name> <operator>=</operator> <operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_wordnode_nr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>n</name></expr>;</return>
</block_content>}</block></function>







<function><type><specifier>static</specifier> <name>int</name></type>
<name>deref_wordnode</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name><name>node</name><operator>-&gt;</operator><name>wn_refs</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>cnt</name> <operator>+=</operator> <call><name>deref_wordnode</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free_wordnode</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt>
</block_content>}</block>
<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_wordnode</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>spin</name><operator>-&gt;</operator><name>si_free_count</name></name></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>wordtree_compress</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>root</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>ht</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tot</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>perc</name></decl>;</decl_stmt>



<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>node_compress</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name> <operator>||</operator> <name>p_verbose</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>tot</name> <operator>&gt;</operator> <literal type="number">1000000</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>perc</name> <operator>=</operator> <operator>(</operator><name>tot</name> <operator>-</operator> <name>n</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>tot</name> <operator>/</operator> <literal type="number">100</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>tot</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>perc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>perc</name> <operator>=</operator> <operator>(</operator><name>tot</name> <operator>-</operator> <name>n</name><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>/</operator> <name>tot</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Compressed %d of %d nodes; %d (%d%%) remaining"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>n</name></expr></argument>, <argument><expr><name>tot</name></expr></argument>, <argument><expr><name>tot</name> <operator>-</operator> <name>n</name></expr></argument>, <argument><expr><name>perc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPELL_PRINTTREE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>spell_print_tree</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_compress</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
<parameter><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl></parameter>,
<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>tot</name></decl></parameter>)</parameter_list> 

<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>nr</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>compressed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>







<for>for <control>(<init><expr><name>np</name> <operator>=</operator> <name>node</name></expr>;</init> <condition><expr><name>np</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>child</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>compressed</name> <operator>+=</operator> <call><name>node_compress</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr><name>tot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name><name>child</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>



<for>for <control>(<init><expr><name>tp</name> <operator>=</operator> <call><name>HI2WN</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>tp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>tp</name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>next</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>node_equal</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><operator>++</operator><name><name>tp</name><operator>-&gt;</operator><name>wn_refs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>compressed</name> <operator>+=</operator> <call><name>deref_wordnode</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>tp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>HI2WN</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>child</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name><name>tp</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tp</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>


<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><operator>*</operator><name>tot</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 






<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>+</operator> <operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>+</operator> <operator>(</operator><operator>(</operator><name>long_u</name><operator>)</operator><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><name>nr</name> <operator>=</operator> <name>nr</name> <operator>*</operator> <literal type="number">101</literal> <operator>+</operator> <name>n</name></expr>;</expr_stmt>
</block_content>}</block>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name>nr</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>nr</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>nr</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>nr</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><name>n</name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>hashkey</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>fast_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>compressed</name></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>node_equal</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n1</name></decl></parameter>, <parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>n2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p1</name> <operator>=</operator> <name>n1</name></expr><operator>,</operator> <expr><name>p2</name> <operator>=</operator> <name>n2</name></expr>;</init> <condition><expr><name>p1</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
<incr><expr><name>p1</name> <operator>=</operator> <name><name>p1</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr><operator>,</operator> <expr><name>p2</name> <operator>=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>p1</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_byte</name></name>
<operator>||</operator> <operator>(</operator><ternary><condition><expr><name><name>p1</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>
?</condition><then> <expr><operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>!=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_flags</name></name>
<operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>!=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_region</name></name>
<operator>||</operator> <name><name>p1</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>!=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_affixID</name></name><operator>)</operator></expr>
</then><else>: <expr><operator>(</operator><name><name>p1</name><operator>-&gt;</operator><name>wn_child</name></name> <operator>!=</operator> <name><name>p2</name><operator>-&gt;</operator><name>wn_child</name></name><operator>)</operator></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>p1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>==</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>rep_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>;</function_decl>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>rep_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>p1</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>, <argument><expr><name><name>p2</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>write_vim_spell</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>regionmask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>fwv</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>



<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>VIMSPELLMAGIC</name></expr></argument>, <argument><expr><name>VIMSPELLMAGICL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fwv</name> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>VIMSPELLVERSION</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 






<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_INFO</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_info</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_REGION</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SNF_REQUIRED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>l</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_region_name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regionmask</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_region_count</name></name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>regionmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>










<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_ascii</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_add</name></name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>folchars</name><index>[<expr><literal type="number">128</literal> <operator>*</operator> <literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_CHARFLAGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SNF_REQUIRED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>l</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>folchars</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>folchars</name><index>[<expr><name>l</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><operator>(</operator><literal type="number">1</literal> <operator>+</operator> <literal type="number">128</literal> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>l</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">128</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CF_WORD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CF_UPPER</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></for>

<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>folchars</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_midword</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_MIDWORD</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SNF_REQUIRED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_midword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_midword</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_PREFCOND</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SNF_REQUIRED</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>write_spell_prefcond</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>write_spell_prefcond</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_prefcond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>








<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_rep</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_sal</name></name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>spin</name><operator>-&gt;</operator><name>si_repsal</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<continue>continue;</continue></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name>round</name> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rep_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name>SN_REP</name></expr> </then><else>: <expr><operator>(</operator><ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>SN_SAL</name></expr> </then><else>: <expr><name>SN_REPSAL</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>l</name> <operator>+=</operator> <literal type="number">1</literal> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></for>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><operator>++</operator><name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_followup</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>|=</operator> <name>SAL_F0LLOWUP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_collapse</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>|=</operator> <name>SAL_COLLAPSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_rem_accents</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>i</name> <operator>|=</operator> <name>SAL_REM_ACCENTS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>


<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>rr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>rr</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>rr</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>rr</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr> </then><else>: <expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></else></ternary></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></for>

</block_content>}</block></for>



<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_SOFO</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><operator>(</operator><name>l</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_commonwords</name><operator>.</operator><name>ht_used</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_WORDS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 



<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>todo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>todo</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>spin</name><operator>-&gt;</operator><name>si_commonwords</name><operator>.</operator><name>ht_used</name></name></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_commonwords</name><operator>.</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
</block_content>}</block></for>
</block_content>}</block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_MAP</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>l</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_map</name><operator>.</operator><name>ga_data</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_nosugfile</name></name>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>spin</name><operator>-&gt;</operator><name>si_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>
<operator>||</operator> <operator>(</operator><name><name>spin</name><operator>-&gt;</operator><name>si_sofofr</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_sofoto</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_SUGFILE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sugtime</name></name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_time</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sugtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_nosplitsugs</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_NOSPLITSUGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_nocompoundsugs</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_NOCOMPOUNDSUGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_COMPOUND</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name>l</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><operator>(</operator><name>l</name> <operator>+</operator> <literal type="number">7</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compmax</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compminlen</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compsylmax</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compoptions</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name><operator>.</operator><name>ga_len</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>spin</name><operator>-&gt;</operator><name>si_comppat</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compflags</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_nobreak</name></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_NOBREAK</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_syllable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_SYLLABLE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_syllable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name>fwv</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_syllable</name></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>SN_END</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 





<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_keeproot</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_prefroot</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


<expr_stmt><expr><call><name>clear_node</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>nodecount</name> <operator>=</operator> <call><name>put_node</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regionmask</name></expr></argument>, <argument><expr><name>round</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>nodecount</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name> <operator>+=</operator> <name>nodecount</name> <operator>+</operator> <name>nodecount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>put_node</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>regionmask</name></expr></argument>, <argument><expr><name>round</name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<label><name>theend</name>:</label>
<if_stmt><if>if <condition>(<expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fwv</name> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>clear_node</name><parameter_list>(<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<block>{<block_content>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>wnode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>clear_node</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></block_content></block></if></if_stmt>
</block_content>}</block></function>














<function><type><specifier>static</specifier> <name>int</name></type>
<name>put_node</name><parameter_list>(
<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, 
<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>regionmask</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>prefixtree</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>newindex</name> <init>= <expr><name>idx</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>siblingcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>


<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call>
<operator>++</operator><name>siblingcount</name></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>siblingcount</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 


<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>prefixtree</name></expr>)</condition>
<block>{<block_content>




<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>==</operator> <operator>(</operator><name>short_u</name><operator>)</operator><name>PFX_FLAGS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_NOFLAGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_FLAGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_affixID</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>regionmask</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>!=</operator> <name>regionmask</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_REGION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_affixID</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_AFX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_NOFLAGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>&gt;=</operator> <literal type="number">0x100</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_FLAGS2</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_FLAGS</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_AFX</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_affixID</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name> <operator>!=</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>wnode</name></name> <operator>!=</operator> <name>node</name></expr>)</condition>
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>BY_INDEX</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u1</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>wnode</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>wnode</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>putc</name><argument_list>(<argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>



<expr_stmt><expr><name>newindex</name> <operator>+=</operator> <name>siblingcount</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>


<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>np</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_child</name><operator>-&gt;</operator><name>wn_u2</name><operator>.</operator><name>wnode</name></name> <operator>==</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>newindex</name> <operator>=</operator> <call><name>put_node</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>np</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>, <argument><expr><name>newindex</name></expr></argument>, <argument><expr><name>regionmask</name></expr></argument>,
<argument><expr><name>prefixtree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>newindex</name></expr>;</return>
</block_content>}</block></function>






<function><type><name>void</name></type>
<name>ex_mkspell</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>fcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ascii</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"-ascii"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>ascii</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>get_arglist_exp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcount</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fnames</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>mkspell</name><argument_list>(<argument><expr><name>fcount</name></expr></argument>, <argument><expr><name>fnames</name></expr></argument>, <argument><expr><name>ascii</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name>fcount</name></expr></argument>, <argument><expr><name>fnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_make_sugfile</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wfname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>free_slang</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>








<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>
<if_stmt><if>if <condition>(<expr><call><name>fullpathcmp</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FPC_SAME</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Reading back spell file..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slang</name> <operator>=</operator> <call><name>spell_load_file</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><name>free_slang</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_compress_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_free_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_first_free</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldwcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>





<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Performing soundfolding..."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>sug_filltree</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>







<if_stmt><if>if <condition>(<expr><call><name>sug_maketable</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Number of words after soundfolding: %ld"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>msg_compressing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>wfname</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fname</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'u'</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fname</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'g'</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sug_write</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>theend</name>:</label>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>free_slang</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>slang_free</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>free_blocks</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close_spellbuf</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>int</name></type>
<name>sug_filltree</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>tword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>tsalword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>idx_T</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>words_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>wordcount</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>


<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name> <operator>=</operator> <call><name>wordtree_alloc</name><argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>


<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sugtree</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>





<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>idxs</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name> <operator>=</operator> <name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>+=</operator> <name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>


<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name><name>tword</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>tword</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>tsalword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>



<if_stmt><if>if <condition>(<expr><call><name>tree_add_word</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>tsalword</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name></name></expr></argument>,
<argument><expr><name>words_done</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>words_done</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>,
<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>words_done</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>



<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_blocks_cnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>



<while>while <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><operator>++</operator><name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>
</block_content>}</block></while>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name><name>tword</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>wordcount</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Total number of words: %d"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>words_done</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>








<function><type><specifier>static</specifier> <name>int</name></type>
<name>sug_maketable</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name></name> <operator>=</operator> <call><name>open_spellbuf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>



<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><call><name>sug_filltable</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>res</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>sug_filltable</name><parameter_list>(
<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>,
<parameter><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>startwordnr</name></decl></parameter>,
<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wordnr</name> <init>= <expr><name>startwordnr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prev_nr</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_NODE_SIBLINGS</name><argument_list>(<argument>node</argument>, <argument>p</argument>)</argument_list></macro>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_nr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<for>for <control>(<init><expr><name>np</name> <operator>=</operator> <name>p</name></expr>;</init> <condition><expr><name>np</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>np</name> <operator>=</operator> <name><name>np</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>np</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>&amp;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>;</expr_stmt>




<expr_stmt><expr><name>nr</name> <operator>-=</operator> <name>prev_nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_nr</name> <operator>+=</operator> <name>nr</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+=</operator> <call><name>offset2bytes</name><argument_list>(<argument><expr><name>nr</name></expr></argument>,
<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>


<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ml_append_buf</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>wordnr</name></expr></argument>,
<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><operator>++</operator><name>wordnr</name></expr>;</expr_stmt>



<while>while <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>wn_sibling</name><operator>-&gt;</operator><name>wn_byte</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wn_sibling</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>wn_sibling</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt></block_content></block></while>



<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wn_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>wn_region</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>
<expr_stmt><expr><name>wordnr</name> <operator>=</operator> <call><name>sug_filltable</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>wn_child</name></name></expr></argument>, <argument><expr><name>wordnr</name></expr></argument>, <argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>wordnr</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block>
<return>return <expr><name>wordnr</name></expr>;</return>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>offset2bytes</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>rem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>b1</name></decl>, <decl><type ref="prev"/><name>b2</name></decl>, <decl><type ref="prev"/><name>b3</name></decl>, <decl><type ref="prev"/><name>b4</name></decl>;</decl_stmt>


<expr_stmt><expr><name>b1</name> <operator>=</operator> <name>nr</name> <operator>%</operator> <literal type="number">255</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rem</name> <operator>=</operator> <name>nr</name> <operator>/</operator> <literal type="number">255</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b2</name> <operator>=</operator> <name>rem</name> <operator>%</operator> <literal type="number">255</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>rem</name> <operator>=</operator> <name>rem</name> <operator>/</operator> <literal type="number">255</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b3</name> <operator>=</operator> <name>rem</name> <operator>%</operator> <literal type="number">255</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>b4</name> <operator>=</operator> <name>rem</name> <operator>/</operator> <literal type="number">255</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>b4</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>b3</name> <operator>&gt;</operator> <literal type="number">0x1f</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xe0</literal> <operator>+</operator> <name>b4</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>b2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">4</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>b3</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>b2</name> <operator>&gt;</operator> <literal type="number">0x3f</literal></expr> )</condition> 
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0xc0</literal> <operator>+</operator> <name>b3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">3</literal></expr>;</return>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>b2</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>b1</name> <operator>&gt;</operator> <literal type="number">0x7f</literal></expr> )</condition> 
<block>{<block_content>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0x80</literal> <operator>+</operator> <name>b2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">2</literal></expr>;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>b1</name></expr>;</expr_stmt>
<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>sug_write</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>wordnode_T</name> <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nodecount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wcount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Writing suggestion file %s..."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>VIMSUGMAGIC</name></expr></argument>, <argument><expr><name>VIMSUGMAGICL</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> 
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>putc</name><argument_list>(<argument><expr><name>VIMSUGVERSION</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 


<expr_stmt><expr><call><name>put_time</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_sugtime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 




<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name>tree</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_foldroot</name><operator>-&gt;</operator><name>wn_sibling</name></name></expr>;</expr_stmt>


<expr_stmt><expr><call><name>clear_node</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>nodecount</name> <operator>=</operator> <call><name>put_node</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>nodecount</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name> <operator>+=</operator> <name>nodecount</name> <operator>+</operator> <name>nodecount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>


<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>put_node</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>tree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<expr_stmt><expr><name>wcount</name> <operator>=</operator> <name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>wcount</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>lnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lnum</name> <operator>&lt;=</operator> <operator>(</operator><name>linenr_T</name><operator>)</operator><name>wcount</name></expr>;</condition> <incr><expr><operator>++</operator><name>lnum</name></expr></incr>)</control>
<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_spellbuf</name></name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fwrite</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></for>


<if_stmt><if>if <condition>(<expr><call><name>putc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_write</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Estimated runtime memory use: %d bytes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>spin</name><operator>-&gt;</operator><name>si_memtot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>









<function><type><name>void</name></type>
<name>mkspell</name><parameter_list>(
<parameter><decl><type><name>int</name></type> <name>fcount</name></decl></parameter>,
<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnames</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>ascii</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>over_write</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>added_word</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wfname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>innames</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>incount</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>afffile_T</name> <argument_list>*<argument><expr><operator>(</operator><name><name>afile</name><index>[<expr><name>MAXREGIONS</name></expr>]</index></name><operator>)</operator></expr></argument>;
<argument><expr><name>int</name> <name>i</name></expr></argument>;
<argument><expr><name>int</name> <name>len</name></expr></argument>;
<argument><expr><name>stat_T</name> <name>st</name></expr></argument>;
<argument><expr><name>int</name> <name>error</name> <operator>=</operator> <name>FALSE</name></expr></argument>;
<argument><expr><name>spellinfo_T</name> <name>spin</name></expr></argument>;

<argument><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>spin</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><name><name>spin</name><operator>.</operator><name>si_verbose</name></name> <operator>=</operator> <operator>!</operator><name>added_word</name></expr></argument>;
<argument><expr><name><name>spin</name><operator>.</operator><name>si_ascii</name></name> <operator>=</operator> <name>ascii</name></expr></argument>;
<argument><expr><name><name>spin</name><operator>.</operator><name>si_followup</name></name> <operator>=</operator> <name>TRUE</name></expr></argument>;
<argument><expr><name><name>spin</name><operator>.</operator><name>si_rem_accents</name></name> <operator>=</operator> <name>TRUE</name></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_rep</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_repsal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_sal</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_map</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_comppat</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_prefcond</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_commonwords</name></name></expr></argument>)</argument_list></call></expr></argument>;
<argument><expr><name><name>spin</name><operator>.</operator><name>si_newcompID</name></name> <operator>=</operator> <literal type="number">127</literal></expr></argument>; 


<argument><expr><name>innames</name> <operator>=</operator> <operator>&amp;</operator><name><name>fnames</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>;
<argument><expr><name>incount</name> <operator>=</operator> <name>fcount</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>;

<argument><expr><name>wfname</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></argument>;
if <argument><expr><operator>(</operator><name>wfname</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr></argument>
<return>return;</return></argument_list></call></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcount</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fcount</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".add"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>innames</name> <operator>=</operator> <operator>&amp;</operator><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>incount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>wfname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">"%s.spl"</literal></expr></argument>, <argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>fcount</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><name>innames</name> <operator>=</operator> <operator>&amp;</operator><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>incount</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>wfname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>SPL_FNAME_TMPL</name></expr></argument>,
<argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>spin</name><operator>.</operator><name>si_ascii</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ascii"</literal></expr> </then><else>: <expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>, <argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>wfname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>SPL_FNAME_TMPL</name></expr></argument>,
<argument><expr><name><name>fnames</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>spin</name><operator>.</operator><name>si_ascii</name></name></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ascii"</literal></expr> </then><else>: <expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gettail</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SPL_FNAME_ASCII</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_ascii</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>


<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gettail</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>SPL_FNAME_ADD</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_add</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>incount</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if> 
<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><call><name>gettail</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E751: Output file name must not have region name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>incount</name> <operator>&gt;</operator> <name>MAXREGIONS</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E754: Only up to %d regions supported"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXREGIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><operator>!</operator><name>over_write</name> <operator>&amp;&amp;</operator> <call><name>mch_stat</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>wfname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_exists</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>mch_isdir</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_isadir2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>





<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>incount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>incount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><call><name>gettail</name><argument_list>(<argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">5</literal>
<operator>||</operator> <name><name>innames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E755: Invalid region in %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_region_name</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_region_name</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
<call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_region_count</name></name> <operator>=</operator> <name>incount</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_foldroot</name></name> <operator>=</operator> <call><name>wordtree_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_keeproot</name></name> <operator>=</operator> <call><name>wordtree_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_prefroot</name></name> <operator>=</operator> <call><name>wordtree_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>.</operator><name>si_foldroot</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name><name>spin</name><operator>.</operator><name>si_keeproot</name></name> <operator>==</operator> <name>NULL</name>
<operator>||</operator> <name><name>spin</name><operator>.</operator><name>si_prefroot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>free_blocks</name><argument_list>(<argument><expr><name><name>spin</name><operator>.</operator><name>si_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>theend</name>;</goto>
</block_content>}</block></if></if_stmt>






<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>.</operator><name>si_add</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_clear_chartab</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>






<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>incount</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>error</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_conv</name><operator>.</operator><name>vc_type</name></name> <operator>=</operator> <name>CONV_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>spin</name><operator>.</operator><name>si_region</name></name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">"%s.aff"</literal></expr></argument>, <argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>mch_stat</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>spell_read_aff</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">"%s.dic"</literal></expr></argument>,
<argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>spell_read_dic</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><call><name>spell_read_wordfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name><name>innames</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>error</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></else></if_stmt>


<expr_stmt><expr><call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_conv</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>.</operator><name>si_compflags</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>spin</name><operator>.</operator><name>si_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: both compounding and NOBREAK specified"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>msg_compressing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>.</operator><name>si_foldroot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>.</operator><name>si_keeproot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>wordtree_compress</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name><name>spin</name><operator>.</operator><name>si_prefroot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Writing spell file %s..."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>error</name> <operator>=</operator> <call><name>write_vim_spell</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>wfname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Done!"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Estimated runtime memory use: %d bytes"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>spin</name><operator>.</operator><name>si_memtot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>spell_message</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>




<if_stmt><if>if <condition>(<expr><operator>!</operator><name>error</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_reload_one</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>, <argument><expr><name>added_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>


<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_rep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_repsal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_sal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_comppat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_prefcond</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>spin</name><operator>.</operator><name>si_commonwords</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>incount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_free_aff</name><argument_list>(<argument><expr><name><name>afile</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>


<expr_stmt><expr><call><name>free_blocks</name><argument_list>(<argument><expr><name><name>spin</name><operator>.</operator><name>si_blocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>





<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>.</operator><name>si_sugtime</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>error</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>spell_make_sugfile</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spin</name></expr></argument>, <argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<label><name>theend</name>:</label>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>wfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>spell_message</name><parameter_list>(<parameter><decl><type><name>spellinfo_T</name> <modifier>*</modifier></type><name>spin</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name> <operator>||</operator> <name>p_verbose</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>spin</name><operator>-&gt;</operator><name>si_verbose</name></name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>







<function><type><name>void</name></type>
<name>ex_spell</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<expr_stmt><expr><call><name>spell_add_word</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_spellwrong</name></expr> ?</condition><then> <expr><name>SPELL_ADD_BAD</name></expr> </then><else>:
<expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_spellrare</name></expr> ?</condition><then> <expr><name>SPELL_ADD_RARE</name></expr> </then><else>: <expr><name>SPELL_ADD_GOOD</name></expr></else></ternary></expr></else></ternary></expr></argument>,
<argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr></else></ternary></expr></argument>,
<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_spellundo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><name>void</name></type>
<name>spell_add_word</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>, 
<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>undo</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>new_spf</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fnamebuf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name></type> <name><name>line</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>fpos</name></decl>, <decl><type ref="prev"/><name>fpos_next</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> 
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>int_wordlist</name> <operator>=</operator> <call><name>vim_tempname</name><argument_list>(<argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>int_wordlist</name></expr>;</expr_stmt>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>init_spellfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_spf</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notset</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"spellfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>fnamebuf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fnamebuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>spf</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>spf</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spf</name></expr></argument>, <argument><expr><name>fnamebuf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>spf</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E765: 'spellfile' does not have %d entries"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>


<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buflist_findname_exp</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_mfp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>bufIsChanged</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_bufloaded</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>fnamebuf</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SPELL_ADD_BAD</name> <operator>||</operator> <name>undo</name></expr>)</condition>
<block>{<block_content>


<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>fpos</name> <operator>=</operator> <name>fpos_next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fpos_next</name> <operator>=</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
<operator>&amp;&amp;</operator> <operator>(</operator><name><name>line</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <name><name>line</name><index>[<expr><name>len</name></expr>]</index></name> <operator>&lt;</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition>
<block>{<block_content>



<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<break>break;</break></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>undo</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>home_replace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Word '%.*s' removed from %s"</literal></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>len</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fpos_next</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>undo</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>new_spf</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>





<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dir_of_file_exists</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>=</operator> <call><name>gettail_sep</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>fname</name></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><name>p</name></expr></init></decl>;</decl_stmt>



<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_mkdir</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notopen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SPELL_ADD_BAD</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%.*s/!\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<if type="elseif">else if <condition>(<expr><name>what</name> <operator>==</operator> <name>SPELL_ADD_RARE</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%.*s/?\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"%.*s\n"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>home_replace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Word '%.*s' added to %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>

<expr_stmt><expr><call><name>mkspell</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>fname</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>buf_reload</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_orig_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>redraw_all_later</name><argument_list>(<argument><expr><name>SOME_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fnamebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_spellfile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rtp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>aspath</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lstart</name> <init>= <expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_p_spl</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>



<for>for <control>(<init><expr><name>lend</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name></expr>;</init> <condition><expr><operator>*</operator><name>lend</name> <operator>!=</operator> <name>NUL</name>
<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">",._"</literal></expr></argument>, <argument><expr><operator>*</operator><name>lend</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>lend</name></expr></incr>)</control><block type="pseudo"><block_content>
<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>lend</name></expr></argument>)</argument_list></call></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>aspath</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lstart</name> <operator>=</operator> <name>lend</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt></block_content></block></for>



<expr_stmt><expr><name>rtp</name> <operator>=</operator> <name>p_rtp</name></expr>;</expr_stmt>
<while>while <condition>(<expr><operator>*</operator><name>rtp</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>aspath</name></expr>)</condition><block type="pseudo"><block_content>


<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_p_spl</name></name></expr></argument>,
<argument><expr><name>lstart</name> <operator>-</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_p_spl</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rtp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<if_stmt><if>if <condition>(<expr><call><name>filewritable</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>
<block>{<block_content>


<if_stmt><if>if <condition>(<expr><name>aspath</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_p_spl</name></name></expr></argument>,
<argument><expr><name>lend</name> <operator>-</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_p_spl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <name>l</name></expr></argument>, <argument><expr><literal type="string">"/spell"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>filewritable</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>vim_mkdir</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <name>l</name></expr></argument>,
<argument><expr><literal type="string">"/%.*s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>lend</name> <operator>-</operator> <name>lstart</name><operator>)</operator></expr></argument>, <argument><expr><name>lstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>
<operator>-&gt;</operator><name><name>lp_slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <name>l</name></expr></argument>, <argument><expr><literal type="string">".%s.add"</literal></expr></argument>,
<argument><expr><ternary><condition><expr><name>fname</name> <operator>!=</operator> <name>NULL</name>
<operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gettail</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">".ascii."</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>
?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ascii"</literal></expr> </then><else>: <expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"spellfile"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>aspath</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
</block_content>}</block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></function>






<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_spell_chartab</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fol</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>low</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>upp</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<decl_stmt><decl><type><name>spelltab_T</name></type> <name>new_st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pf</name> <init>= <expr><name>fol</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pl</name> <init>= <expr><name>low</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pu</name> <init>= <expr><name>upp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>f</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>u</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_spell_chartab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl</name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <operator>*</operator><name>pu</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_affform</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isw</name><index>[<expr><name>f</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isw</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isw</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>



<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>!=</operator> <name>f</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_affrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_fold</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>u</name> <operator>!=</operator> <name>f</name></expr>)</condition>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_affrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_fold</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isu</name><index>[<expr><name>u</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_upper</name><index>[<expr><name>f</name></expr>]</index></name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pl</name> <operator>!=</operator> <name>NUL</name> <operator>||</operator> <operator>*</operator><name>pu</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_affform</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>set_spell_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_st</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>




<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_spell_charflags</name><parameter_list>(
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>,
<parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>, 
<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fol</name></decl></parameter>)</parameter_list>
<block>{<block_content>


<decl_stmt><decl><type><name>spelltab_T</name></type> <name>new_st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>fol</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_spell_chartab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">128</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">128</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CF_WORD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">128</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;</operator> <name>CF_UPPER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">128</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">128</literal> <operator>!=</operator> <name>c</name> <operator>&amp;&amp;</operator> <name><name>new_st</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">128</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>new_st</name><operator>.</operator><name>st_upper</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">128</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>set_spell_finish</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_spell_finish</name><parameter_list>(<parameter><decl><type><name>spelltab_T</name> <modifier>*</modifier></type><name>new_st</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>did_set_spelltab</name></expr>)</condition>
<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>new_st</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name>
<operator>||</operator> <name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>new_st</name><operator>-&gt;</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name>
<operator>||</operator> <name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>new_st</name><operator>-&gt;</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name>
<operator>||</operator> <name><name>spelltab</name><operator>.</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>new_st</name><operator>-&gt;</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E763: Word characters differ between spell files"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>FAIL</name></expr>;</return>
</block_content>}</block></if></if_stmt>
</block_content>}</block></for>
</block_content>}</block></if>
<else>else
<block>{<block_content>

<expr_stmt><expr><name>spelltab</name> <operator>=</operator> <operator>*</operator><name>new_st</name></expr>;</expr_stmt>
<expr_stmt><expr><name>did_set_spelltab</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>int</name></type>
<name>write_spell_prefcond</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>totlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>x</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>put_bytes</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>totlen</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> <operator>&amp;=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name>totlen</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
</block_content>}</block></if>
<if type="elseif">else if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></for>

<return>return <expr><name>totlen</name></expr>;</return>
</block_content>}</block></function>





<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_map_str</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>headc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>map</name> <operator>==</operator> <name>NUL</name></expr>)</condition>
<block>{<block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_has_map</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
<return>return;</return>
</block_content>}</block></if></if_stmt>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_has_map</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>


<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></for>
<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>






<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>map</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>
<block>{<block_content>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>headc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>
<if_stmt><if>if <condition>(<expr><name>headc</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><name>headc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>




<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;=</operator> <literal type="number">256</literal></expr>)</condition>
<block>{<block_content>
<decl_stmt><decl><type><name>int</name></type> <name>cl</name> <init>= <expr><call><name>mb_char2len</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>headcl</name> <init>= <expr><call><name>mb_char2len</name><argument_list>(<argument><expr><name>headc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>cl</name> <operator>+</operator> <name>headcl</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
<return>return;</return></block_content></block></if></if_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><index>[<expr><name>cl</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>headc</name></expr></argument>, <argument><expr><name>b</name> <operator>+</operator> <name>cl</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name><index>[<expr><name>cl</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>headcl</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<else>else
<block>{<block_content>


<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E783: duplicate char in MAP entry"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></if>
<else>else<block type="pseudo"><block_content>
<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_map_array</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>headc</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></else></if_stmt>
</block_content>}</block></for>
</block_content>}</block></function>


<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 
</unit>
