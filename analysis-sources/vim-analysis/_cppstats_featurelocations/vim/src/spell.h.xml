<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats_featurelocations\vim\src\spell.h">














<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_PRINTTREE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_COMPRESS_ALLWAYS</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_TRIEWALK</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXWLEN</name></cpp:macro> <cpp:value>254</cpp:value></cpp:define> 




<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXREGIONS</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 



<typedef>typedef <type><name>int</name></type> <name>idx_T</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>salfirst_T</name>;</typedef>
















<typedef>typedef <type><name><name>struct</name> <name>slang_S</name></name></type> <name>slang_T</name>;</typedef>
<struct>struct <name>slang_S</name>
<block>{
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>sl_next</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_name</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_fname</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_add</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_fbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_fidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_kbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_kidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_pbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_pidxs</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_info</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sl_regions</name><index>[<expr><name>MAXREGIONS</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>


<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_midword</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_wordcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_compmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compminlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compsylmax</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_compoptions</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_comppat</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>sl_compprog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_comprules</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_compstartflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_compallflags</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name>sl_nobreak</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_syllable</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_syl_items</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_prefixcnt</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>sl_prefprog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_rep</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name><name>sl_rep_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_sal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>salfirst_T</name></type> <name><name>sl_sal_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_followup</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_collapse</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_rem_accents</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_sofo</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>garray_T</name></type> <name>sl_repsal</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>short</name></type> <name><name>sl_repsal_first</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_nosplitsugs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_nocompoundsugs</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>time_t</name></type> <name>sl_sugtime</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sl_sbyts</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>sl_sidxs</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>sl_sugbuf</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sl_sugloaded</name></decl>;</decl_stmt> 


<decl_stmt><decl><type><name>int</name></type> <name>sl_has_map</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_map_hash</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name><name>sl_map_array</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>hashtab_T</name></type> <name>sl_sounddone</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_TMPL</name></cpp:macro> <cpp:value>"%s_%s.spl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ADD</name></cpp:macro> <cpp:value>"_add."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ASCII</name></cpp:macro> <cpp:value>"_ascii."</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_TMPL</name></cpp:macro> <cpp:value>"%s.%s.spl"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ADD</name></cpp:macro> <cpp:value>".add."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPL_FNAME_ASCII</name></cpp:macro> <cpp:value>".ascii."</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_REGION</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_ONECAP</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_ALLCAP</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_RARE</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_BANNED</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_AFX</name></cpp:macro> <cpp:value>0x20</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_FIXCAP</name></cpp:macro> <cpp:value>0x40</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_KEEPCAP</name></cpp:macro> <cpp:value>0x80</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_CAPMASK</name></cpp:macro> <cpp:value>(WF_ONECAP | WF_ALLCAP | WF_KEEPCAP | WF_FIXCAP)</cpp:value></cpp:define>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_HAS_AFF</name></cpp:macro> <cpp:value>0x0100</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NEEDCOMP</name></cpp:macro> <cpp:value>0x0200</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOSUGGEST</name></cpp:macro> <cpp:value>0x0400</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_COMPROOT</name></cpp:macro> <cpp:value>0x0800</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOCOMPBEF</name></cpp:macro> <cpp:value>0x1000</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_NOCOMPAFT</name></cpp:macro> <cpp:value>0x2000</cpp:value></cpp:define> 


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_RARE</name></cpp:macro> <cpp:value>0x01</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_NC</name></cpp:macro> <cpp:value>0x02</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_UP</name></cpp:macro> <cpp:value>0x04</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_COMPPERMIT</name></cpp:macro> <cpp:value>0x08</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WFP_COMPFORBID</name></cpp:macro> <cpp:value>0x10</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_RAREPFX</name></cpp:macro> <cpp:value>(WFP_RARE &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_NC</name></cpp:macro> <cpp:value>(WFP_NC &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_UP</name></cpp:macro> <cpp:value>(WFP_UP &lt;&lt; 24)</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_COMPPERMIT</name></cpp:macro> <cpp:value>(WFP_COMPPERMIT &lt;&lt; 24)</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WF_PFX_COMPFORBID</name></cpp:macro> <cpp:value>(WFP_COMPFORBID &lt;&lt; 24)</cpp:value></cpp:define> 



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKDUP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKREP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKCASE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMP_CHECKTRIPLE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>fromto_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ft_from</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ft_to</name></decl>;</decl_stmt>
}</block></struct></type> <name>fromto_T</name>;</typedef>




<typedef>typedef <type><struct>struct <name>salitem_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_lead</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>sm_leadlen</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_oneof</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_rules</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sm_to</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_lead_w</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_oneof_w</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>sm_to_w</name></decl>;</decl_stmt> 
}</block></struct></type> <name>salitem_T</name>;</typedef>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_TRUNCERROR</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_FORMERROR</name></cpp:macro> <cpp:value>-2</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_OTHERERROR</name></cpp:macro> <cpp:value>-3</cpp:value></cpp:define> 




<typedef>typedef <type><struct>struct <name>langp_S</name>
<block>{
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_slang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_sallang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp_replang</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>int</name></type> <name>lp_region</name></decl>;</decl_stmt> 
}</block></struct></type> <name>langp_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANGP_ENTRY</name><parameter_list>(<parameter><type><name>ga</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((langp_T *)(ga).ga_data) + (i))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGIC</name></cpp:macro> <cpp:value>"VIMsug"</cpp:value></cpp:define> 
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGICL</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGVERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>





<typedef>typedef <type><struct>struct <name>spelltab_S</name>
<block>{
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_isw</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_isu</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_fold</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>st_upper</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>spelltab_T</name>;</typedef>






<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include> 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>



<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TOWLOWER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOFOLD</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_fold(c) : (c) &lt; 256 ? (int)spelltab.st_fold[c] : (int)towlower(c))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOFOLD</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_fold(c) : (c) &lt; 256 ? (int)spelltab.st_fold[c] : (c))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TOWUPPER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_toupper(c) : (c) &lt; 256 ? (int)spelltab.st_upper[c] : (int)towupper(c))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_TOUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_toupper(c) : (c) &lt; 256 ? (int)spelltab.st_upper[c] : (c))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_ISWUPPER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ISUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt; 256 ? spelltab.st_isu[c] : iswupper(c))</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ISUPPER</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(enc_utf8 &amp;&amp; (c) &gt;= 128 ? utf_isupper(c) : (c) &lt; 256 ? spelltab.st_isu[c] : (FALSE))</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IN_SPELL_C</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_EXTERN</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_EXTERN</name></cpp:macro> <cpp:value>extern</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_INIT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>slang_T</name> <modifier>*</modifier><name>first_lang</name></type> <name>SPELL_INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>char_u</name> <modifier>*</modifier><name>int_wordlist</name></type> <name>SPELL_INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>char</name> <name><name>e_format</name><index>[]</index></name></type> <name>SPELL_INIT</name><argument_list>(<argument><expr><operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E759: Format error in spell file"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>spelltab_T</name></type> <name>spelltab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>int</name></type> <name>did_set_spelltab</name></decl>;</decl_stmt>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ADD_GOOD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ADD_BAD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPELL_ADD_RARE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>wordcount_S</name>
<block>{
<decl_stmt><decl><type><name>short_u</name></type> <name>wc_count</name></decl>;</decl_stmt> 
<decl_stmt><decl><type><name>char_u</name></type> <name><name>wc_word</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 
}</block></struct></type> <name>wordcount_T</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WC_KEY_OFF</name></cpp:macro> <cpp:value>offsetof(wordcount_T, wc_word)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HI2WC</name><parameter_list>(<parameter><type><name>hi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((wordcount_T *)((hi)-&gt;hi_key - WC_KEY_OFF))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXWORDCOUNT</name></cpp:macro> <cpp:value>0xffff</cpp:value></cpp:define>


<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>char_u</name> <modifier>*</modifier><name>repl_from</name></type> <name>SPELL_INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SPELL_EXTERN</name> <name>char_u</name> <modifier>*</modifier><name>repl_to</name></type> <name>SPELL_INIT</name><argument_list>(<argument><expr><operator>=</operator> <name>NULL</name></expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
