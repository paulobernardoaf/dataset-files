<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\cmdexpand.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>cmd_showtail</name></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_expand_context</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>ExpandGeneric</name><argument_list>(<argument><expr><name>expand_T</name> <operator>*</operator><name>xp</name></expr></argument>, <argument><expr><name>regmatch_T</name> <operator>*</operator><name>regmatch</name></expr></argument>,

<argument><expr><name>int</name> <operator>*</operator><name>num_file</name></expr></argument>, <argument><expr><name>char_u</name> <operator>*</operator><operator>*</operator><operator>*</operator><name>file</name></expr></argument>,

<argument><expr><name>char_u</name> <operator>*</operator><operator>(</operator><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>expand_T</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>, <argument><expr><name>int</name> <name>escaped</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ExpandFromContext</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>expand_showtail</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>expand_shellcmd</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>filepat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flagsarg</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ExpandUserDefined</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>regmatch</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ExpandUserList</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>sort_func_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name> <init>= <expr><operator>*</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name> <init>= <expr><operator>*</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p1</name> <operator>!=</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p2</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p1</name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p2</name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ExpandEscape</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>numfiles</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>files</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_HOME_REPLACE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>tilde_replace</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>numfiles</name></expr></argument>, <argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_ESCAPE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES_IN_PATH</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SHELLCMD</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BUFFERS</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_DIRECTORIES</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfiles</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>==</operator> <name>XP_BS_THREE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave_escaped</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave_escaped</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave_fnameescape</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave_fnameescape</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_shell</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal> <operator>&amp;&amp;</operator> <name><name>files</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>escape_fname</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>=</operator> <name>XP_BS_NONE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>files</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>escape_fname</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>files</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numfiles</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strsave_escaped</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\|\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>files</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>nextwild</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>escape</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>cmdline_info_T</name> <modifier>*</modifier></type><name>ccline</name> <init>= <expr><call><name>get_cmdline_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>difflen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_expand_context</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd_showtail</name> <operator>=</operator> <call><name>expand_showtail</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_UNSUCCESSFUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_NOTHING</name></expr>)</condition>

<block>{<block_content>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>-</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name> <operator>-</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>WILD_NEXT</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>WILD_PREV</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>ExpandOne</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p1</name> <operator>=</operator> <call><name>addstar</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr></argument>,

<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>use_options</name> <init>= <expr><name>options</name> <operator>|</operator>

<name>WILD_HOME_REPLACE</name><operator>|</operator><name>WILD_ADD_SLASH</name><operator>|</operator><name>WILD_SILENT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>escape</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>use_options</name> <operator>|=</operator> <name>WILD_ESCAPE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_wic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>use_options</name> <operator>+=</operator> <name>WILD_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <call><name>ExpandOne</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>,

<argument><expr><call><name>vim_strnsave</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>use_options</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>==</operator> <name>WILD_LONGEST</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal>

<operator>||</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>j</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p2</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>difflen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name> <operator>+</operator> <name>difflen</name> <operator>+</operator> <literal type="number">4</literal> <operator>&gt;</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbufflen</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>realloc_cmdbuff</name><argument_list>(<argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name> <operator>+</operator> <name>difflen</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name> <operator>+</operator> <name>difflen</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name></expr>]</index></name></expr></argument>,

<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name> <operator>-</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name> <operator>+=</operator> <name>difflen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name> <operator>+=</operator> <name>difflen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>redrawcmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cursorcmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_MAPPINGS</name> <operator>&amp;&amp;</operator> <name>p2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ExpandOne</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>WILD_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>ExpandOne</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>findex</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>orig_save</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>orig_saved</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long_u</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>non_suf_match</name></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_NEXT</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>WILD_PREV</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_PREV</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>findex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>findex</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>findex</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>findex</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>orig_save</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>findex</name> <operator>&gt;=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>orig_save</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_WILDMENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>p_wmnu</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_redr_status_matches</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr></argument>,

<argument><expr><name>findex</name></expr></argument>, <argument><expr><name>cmd_showtail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>findex</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>orig_save</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>findex</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>!=</operator> <name>WILD_ALL</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>!=</operator> <name>WILD_LONGEST</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>orig_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_FREE</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>orig_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>orig_save</name> <operator>=</operator> <name>orig</name></expr>;</expr_stmt>

<expr_stmt><expr><name>orig_saved</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ExpandFromContext</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr></argument>,

<argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FNAME_ILLEGAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_SILENT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_LIST_NOTFOUND</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nomatch2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_SILENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nomatch2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>ExpandEscape</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>WILD_ALL</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>!=</operator> <name>WILD_ALL_KEEP</name>

<operator>&amp;&amp;</operator> <name>mode</name> <operator>!=</operator> <name>WILD_LONGEST</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>non_suf_match</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>non_suf_match</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_DIRECTORIES</name><operator>)</operator>

<operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>non_suf_match</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>match_suffix</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>non_suf_match</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>non_suf_match</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_SILENT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_toomany</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_NO_BEEP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>non_suf_match</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <name>WILD_EXPAND_FREE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_LONGEST</name> <operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>mb_len</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c0</name></decl>, <decl><type ref="prev"/><name>ci</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr>;</condition> <incr><expr><name>len</name> <operator>+=</operator> <name>mb_len</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>mb_len</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c0</name> <operator>=</operator><call>(<modifier>*</modifier> <name>mb_ptr2char</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ci</name> <operator>=</operator><call>(<modifier>*</modifier> <name>mb_ptr2char</name>)<argument_list>(<argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ci</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_fic</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_DIRECTORIES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SHELLCMD</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BUFFERS</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MB_TOLOWER</name><argument_list>(<argument><expr><name>c0</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>MB_TOLOWER</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c0</name> <operator>!=</operator> <name>ci</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_NO_BEEP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_beep</name><argument_list>(<argument><expr><name>BO_WILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ss</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>findex</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_ALL</name> <operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>long_u</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ss</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ss</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>ss</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_USE_NL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>WILD_EXPAND_FREE</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>WILD_ALL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ExpandCleanup</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>orig_saved</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ss</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ExpandInit</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>=</operator> <name>XP_BS_NONE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_shell</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_arg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_line</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ExpandCleanup</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>showmatches</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>wildmenu</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>cmdline_info_T</name> <modifier>*</modifier></type><name>ccline</name> <init>= <expr><call><name>get_cmdline_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>L_SHOWFILE</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(showtail ? sm_gettail(files_found[m]) : files_found[m])</cpp:value></cpp:define>

<decl_stmt><decl><type><name>int</name></type> <name>num_files</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>files_found</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lines</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>columns</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lastlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>showtail</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_expand_context</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>expand_cmdline</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name></expr></argument>, <argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>num_files</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>files_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>showtail</name> <operator>=</operator> <call><name>expand_showtail</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>EXPAND_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>num_files</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>files_found</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_files</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>showtail</name> <operator>=</operator> <name>cmd_showtail</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_WILDMENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wildmenu</name></expr>)</condition>

<block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>msg_didany</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmdline_row</name> <operator>=</operator> <name>msg_row</name></expr>;</expr_stmt>

<expr_stmt><expr><name>msg_didany</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_WILDMENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_WILDMENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>wildmenu</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_redr_status_matches</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>num_files</name></expr></argument>, <argument><expr><name>files_found</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>showtail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_files</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>showtail</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SHELLCMD</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BUFFERS</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>home_replace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>files_found</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>vim_strsize</name><argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>vim_strsize</name><argument_list>(<argument><expr><call><name>L_SHOWFILE</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS_LISTFILES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lines</name> <operator>=</operator> <name>num_files</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>maxlen</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>columns</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name>Columns</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name>maxlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>columns</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>columns</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lines</name> <operator>=</operator> <operator>(</operator><name>num_files</name> <operator>+</operator> <name>columns</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <name>columns</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS_LISTFILES</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"tagname"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_advance</name><argument_list>(<argument><expr><name>maxlen</name> <operator>-</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" kind file\n"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_T</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>lines</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lastlen</name> <operator>=</operator> <literal type="number">999</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>i</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>num_files</name></expr>;</condition> <incr><expr><name>k</name> <operator>+=</operator> <name>lines</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS_LISTFILES</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>msg_outtrans_attr</name><argument_list>(<argument><expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_advance</name><argument_list>(<argument><expr><name>maxlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_advance</name><argument_list>(<argument><expr><name>maxlen</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_outtrans_long_attr</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_D</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>maxlen</name> <operator>-</operator> <name>lastlen</name></expr>;</init> <condition><expr><operator>--</operator><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SHELLCMD</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BUFFERS</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>halved_slash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>exp_path</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

<expr_stmt><expr><name>exp_path</name> <operator>=</operator> <call><name>expand_env_save_opt</name><argument_list>(<argument><expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>path</name> <operator>=</operator> <ternary><condition><expr><name>exp_path</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>exp_path</name></expr> </then><else>: <expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>halved_slash</name> <operator>=</operator> <call><name>backslash_halve_save</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>mch_isdir</name><argument_list>(<argument><expr><ternary><condition><expr><name>halved_slash</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>halved_slash</name></expr>

</then><else>: <expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>exp_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>halved_slash</name> <operator>!=</operator> <name>path</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>halved_slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>mch_isdir</name><argument_list>(<argument><expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>showtail</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>L_SHOWFILE</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>home_replace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>files_found</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NameBuff</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>j</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>L_SHOWFILE</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>lastlen</name> <operator>=</operator> <call><name>msg_outtrans_attr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><ternary><condition><expr><name>j</name></expr> ?</condition><then> <expr><name>attr</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>msg_col</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>cmdline_row</name> <operator>=</operator> <name>msg_row</name></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_numfiles</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name>num_files</name></expr></argument>, <argument><expr><name>files_found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>EXPAND_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>sm_gettail</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>had_sep</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_ispathsep</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>!</operator><call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>had_sep</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>had_sep</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>had_sep</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>t</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>expand_showtail</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>!=</operator> <name>EXPAND_FILES</name>

<operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>!=</operator> <name>EXPAND_SHELLCMD</name>

<operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>!=</operator> <name>EXPAND_DIRECTORIES</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>gettail</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>end</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rem_backslash</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"*?["</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>addstar</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>context</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>retval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>new_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ends_in_star</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>EXPAND_FILES</name>

<operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>EXPAND_FILES_IN_PATH</name>

<operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>EXPAND_SHELLCMD</name>

<operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>EXPAND_DIRECTORIES</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>EXPAND_HELP</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_COLORS</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_COMPILER</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_OWNSYNTAX</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_FILETYPE</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_PACKADD</name>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>context</name> <operator>==</operator> <name>EXPAND_TAGS_LISTFILES</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_TAGS</name><operator>)</operator>

<operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>new_len</name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>new_len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>EXPAND_BUFFERS</name> <operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>new_len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>context</name> <operator>==</operator> <name>EXPAND_USER_DEFINED</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_USER_LIST</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>new_len</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></for>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>retval</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>EXPAND_USER_DEFINED</name>

<operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>EXPAND_USER_LIST</name>

<operator>&amp;&amp;</operator> <name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal>

<operator>&amp;&amp;</operator> <operator>++</operator><name>i</name> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'~'</literal></expr>:</case> <expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> <expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>

<continue>continue;</continue>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>EXPAND_BUFFERS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>EXPAND_USER_DEFINED</name>

<operator>||</operator> <name>context</name> <operator>==</operator> <name>EXPAND_USER_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>fname</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tail</name> <operator>=</operator> <call><name>gettail</name><argument_list>(<argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ends_in_star</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>retval</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>retval</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ends_in_star</name> <operator>=</operator> <operator>!</operator><name>ends_in_star</name></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>retval</name> <operator>!=</operator> <literal type="char">'~'</literal> <operator>||</operator> <name>tail</name> <operator>!=</operator> <name>retval</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>!</operator><name>ends_in_star</name>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><literal type="char">'$'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>retval</name></expr></argument>, <argument><expr><literal type="char">'`'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>retval</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>retval</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_expand_context</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>cmdline_info_T</name> <modifier>*</modifier></type><name>ccline</name> <init>= <expr><call><name>get_cmdline_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdfirstc</name></name> <operator>!=</operator> <literal type="char">':'</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdfirstc</name></name> <operator>!=</operator> <literal type="char">'&gt;'</literal> <operator>&amp;&amp;</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdfirstc</name></name> <operator>!=</operator> <literal type="char">'='</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><name><name>ccline</name><operator>-&gt;</operator><name>input_fn</name></name></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>set_cmd_context</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name></expr></argument>, <argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name></expr></argument>, <argument><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdpos</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>set_one_cmd_context</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>exarg_T</name></type> <name>ea</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>compl</name> <init>= <expr><name>EXPAND_NOTHING</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delim</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>forceit</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>usefilter</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>ExpandInit</name><argument_list>(<argument><expr><name>xp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_COMMANDS</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cmd</name> <operator>=</operator> <name>buff</name></expr>;</init> <condition><expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" \t:|"</literal></expr></argument>, <argument><expr><operator>*</operator><name>cmd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>cmd</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>skip_range</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cmd</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'k'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'e'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <name>CMD_k</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cmd</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><call><name>ASCII_ISUPPER</name><argument_list>(<argument><expr><name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'y'</literal> <operator>&amp;&amp;</operator> <name>p</name> <operator>==</operator> <name>cmd</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'3'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>cmd</name> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"@*!=&gt;&lt;&amp;~#"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>cmd</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_UNSUCCESSFUL</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <call><name>excmd_get_cmdidx</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_SIZE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cgriI"</literal></expr></argument>, <argument><expr><name><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <name>CMD_substitute</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cmd</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name><name>cmd</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_ucmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>xp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>compl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <name>CMD_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_SIZE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_UNSUCCESSFUL</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>forceit</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_USER_CMDIDX</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>=</operator> <call><name>excmd_get_argt</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_write</name> <operator>||</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_update</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>++</operator><name>arg</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_write</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>usefilter</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_read</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>usefilter</name> <operator>=</operator> <name>forceit</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>usefilter</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lshift</name> <operator>||</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_rshift</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <operator>*</operator><name>cmd</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_CMDARG</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>usefilter</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skip_cmd_arg</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_TRLBAR</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>usefilter</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_redir</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'@'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>Ctrl_V</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>( <expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_NOTRLCOM</name><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name>p</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_EXTRA</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>!=</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"|\""</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&lt;</operator> <name>buff</name> <operator>+</operator> <name>len</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>TAB</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_XFILE</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>in_quote</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bow</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'`'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_quote</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bow</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <operator>!</operator><name>in_quote</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'|'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>||</operator> <operator>(</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SPACE_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_NOSPC</name><operator>)</operator> <operator>||</operator> <name>usefilter</name><operator>)</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'`'</literal> <operator>||</operator> <call><name>vim_isfilec_or_wc</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>in_quote</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bow</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>bow</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>in_quote</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>bow</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_FILES</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>usefilter</name> <operator>||</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_bang</name> <operator>||</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_terminal</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_shell</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>==</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_SHELLCMD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>==</operator> <literal type="char">'$'</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<operator>||</operator> <operator>*</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>==</operator> <literal type="char">'%'</literal></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_isIDc</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_ENV_VARS</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>compl</name> <operator>!=</operator> <name>EXPAND_USER_DEFINED</name> <operator>&amp;&amp;</operator> <name>compl</name> <operator>!=</operator> <name>EXPAND_USER_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>compl</name> <operator>=</operator> <name>EXPAND_ENV_VARS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>&gt;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal>

<operator>&amp;&amp;</operator> <call><name>match_user</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_USER</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_find</name></expr>:</case>

<case>case <expr><name>CMD_sfind</name></expr>:</case>

<case>case <expr><name>CMD_tabfind</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_FILES_IN_PATH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_cd</name></expr>:</case>

<case>case <expr><name>CMD_chdir</name></expr>:</case>

<case>case <expr><name>CMD_tcd</name></expr>:</case>

<case>case <expr><name>CMD_tchdir</name></expr>:</case>

<case>case <expr><name>CMD_lcd</name></expr>:</case>

<case>case <expr><name>CMD_lchdir</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_DIRECTORIES</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_help</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_HELP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_aboveleft</name></expr>:</case>

<case>case <expr><name>CMD_argdo</name></expr>:</case>

<case>case <expr><name>CMD_belowright</name></expr>:</case>

<case>case <expr><name>CMD_botright</name></expr>:</case>

<case>case <expr><name>CMD_browse</name></expr>:</case>

<case>case <expr><name>CMD_bufdo</name></expr>:</case>

<case>case <expr><name>CMD_cdo</name></expr>:</case>

<case>case <expr><name>CMD_cfdo</name></expr>:</case>

<case>case <expr><name>CMD_confirm</name></expr>:</case>

<case>case <expr><name>CMD_debug</name></expr>:</case>

<case>case <expr><name>CMD_folddoclosed</name></expr>:</case>

<case>case <expr><name>CMD_folddoopen</name></expr>:</case>

<case>case <expr><name>CMD_hide</name></expr>:</case>

<case>case <expr><name>CMD_keepalt</name></expr>:</case>

<case>case <expr><name>CMD_keepjumps</name></expr>:</case>

<case>case <expr><name>CMD_keepmarks</name></expr>:</case>

<case>case <expr><name>CMD_keeppatterns</name></expr>:</case>

<case>case <expr><name>CMD_ldo</name></expr>:</case>

<case>case <expr><name>CMD_leftabove</name></expr>:</case>

<case>case <expr><name>CMD_lfdo</name></expr>:</case>

<case>case <expr><name>CMD_lockmarks</name></expr>:</case>

<case>case <expr><name>CMD_noautocmd</name></expr>:</case>

<case>case <expr><name>CMD_noswapfile</name></expr>:</case>

<case>case <expr><name>CMD_rightbelow</name></expr>:</case>

<case>case <expr><name>CMD_sandbox</name></expr>:</case>

<case>case <expr><name>CMD_silent</name></expr>:</case>

<case>case <expr><name>CMD_tab</name></expr>:</case>

<case>case <expr><name>CMD_tabdo</name></expr>:</case>

<case>case <expr><name>CMD_topleft</name></expr>:</case>

<case>case <expr><name>CMD_verbose</name></expr>:</case>

<case>case <expr><name>CMD_vertical</name></expr>:</case>

<case>case <expr><name>CMD_windo</name></expr>:</case>

<return>return <expr><name>arg</name></expr>;</return>

<case>case <expr><name>CMD_filter</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skip_vimgrep_pat</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>arg</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCH_EXTRA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_match</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <operator>!</operator><call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_context_in_echohl_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skiptowhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skip_regexp</name><argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>p_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>find_nextcmd</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_command</name></expr>:</case>

<return>return <expr><call><name>set_context_in_user_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_delcommand</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_USER_COMMANDS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_global</name></expr>:</case>

<case>case <expr><name>CMD_vglobal</name></expr>:</case>

<expr_stmt><expr><name>delim</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>delim</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<while>while <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>delim</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_and</name></expr>:</case>

<case>case <expr><name>CMD_substitute</name></expr>:</case>

<expr_stmt><expr><name>delim</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>delim</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skip_regexp</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>delim</name></expr></argument>, <argument><expr><name>p_magic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>delim</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"|\"#"</literal></expr></argument>, <argument><expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_isearch</name></expr>:</case>

<case>case <expr><name>CMD_dsearch</name></expr>:</case>

<case>case <expr><name>CMD_ilist</name></expr>:</case>

<case>case <expr><name>CMD_dlist</name></expr>:</case>

<case>case <expr><name>CMD_ijump</name></expr>:</case>

<case>case <expr><name>CMD_psearch</name></expr>:</case>

<case>case <expr><name>CMD_djump</name></expr>:</case>

<case>case <expr><name>CMD_isplit</name></expr>:</case>

<case>case <expr><name>CMD_dsplit</name></expr>:</case>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skipdigits</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> 

<block>{<block_content>

<for>for <control>(<init><expr><operator>++</operator><name>arg</name></expr>;</init> <condition><expr><operator>*</operator><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'/'</literal></expr>;</condition> <incr><expr><name>arg</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"|\"\n"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>arg</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_autocmd</name></expr>:</case>

<return>return <expr><call><name>set_context_in_autocmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_doautocmd</name></expr>:</case>

<case>case <expr><name>CMD_doautoall</name></expr>:</case>

<return>return <expr><call><name>set_context_in_autocmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_set</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_set_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_setglobal</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_set_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>OPT_GLOBAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_setlocal</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_set_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_tag</name></expr>:</case>

<case>case <expr><name>CMD_stag</name></expr>:</case>

<case>case <expr><name>CMD_ptag</name></expr>:</case>

<case>case <expr><name>CMD_ltag</name></expr>:</case>

<case>case <expr><name>CMD_tselect</name></expr>:</case>

<case>case <expr><name>CMD_stselect</name></expr>:</case>

<case>case <expr><name>CMD_ptselect</name></expr>:</case>

<case>case <expr><name>CMD_tjump</name></expr>:</case>

<case>case <expr><name>CMD_stjump</name></expr>:</case>

<case>case <expr><name>CMD_ptjump</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_wop</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_TAGS_LISTFILES</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_TAGS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_augroup</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_AUGROUP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_syntax</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_syntax_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_const</name></expr>:</case>

<case>case <expr><name>CMD_let</name></expr>:</case>

<case>case <expr><name>CMD_if</name></expr>:</case>

<case>case <expr><name>CMD_elseif</name></expr>:</case>

<case>case <expr><name>CMD_while</name></expr>:</case>

<case>case <expr><name>CMD_for</name></expr>:</case>

<case>case <expr><name>CMD_echo</name></expr>:</case>

<case>case <expr><name>CMD_echon</name></expr>:</case>

<case>case <expr><name>CMD_execute</name></expr>:</case>

<case>case <expr><name>CMD_echomsg</name></expr>:</case>

<case>case <expr><name>CMD_echoerr</name></expr>:</case>

<case>case <expr><name>CMD_call</name></expr>:</case>

<case>case <expr><name>CMD_return</name></expr>:</case>

<case>case <expr><name>CMD_cexpr</name></expr>:</case>

<case>case <expr><name>CMD_caddexpr</name></expr>:</case>

<case>case <expr><name>CMD_cgetexpr</name></expr>:</case>

<case>case <expr><name>CMD_lexpr</name></expr>:</case>

<case>case <expr><name>CMD_laddexpr</name></expr>:</case>

<case>case <expr><name>CMD_lgetexpr</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_for_expression</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_unlet</name></expr>:</case>

<while>while <condition>(<expr><operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_USER_VARS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_ENV_VARS</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_function</name></expr>:</case>

<case>case <expr><name>CMD_delfunction</name></expr>:</case>

<case>case <expr><name>CMD_disassemble</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_USER_FUNC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_echohl</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_echohl_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_highlight</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_highlight_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CSCOPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_cscope</name></expr>:</case>

<case>case <expr><name>CMD_lcscope</name></expr>:</case>

<case>case <expr><name>CMD_scscope</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_cscope_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_sign</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_sign_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_bdelete</name></expr>:</case>

<case>case <expr><name>CMD_bwipeout</name></expr>:</case>

<case>case <expr><name>CMD_bunload</name></expr>:</case>

<while>while <condition>(<expr><operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<case>case <expr><name>CMD_buffer</name></expr>:</case>

<case>case <expr><name>CMD_sbuffer</name></expr>:</case>

<case>case <expr><name>CMD_checktime</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_BUFFERS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_diffget</name></expr>:</case>

<case>case <expr><name>CMD_diffput</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_DIFF_BUFFERS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_USER</name></expr>:</case>

<case>case <expr><name>CMD_USER_BUF</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>compl</name> <operator>!=</operator> <name>EXPAND_NOTHING</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>ea</name><operator>.</operator><name>argt</name></name> <operator>&amp;</operator> <name>EX_XFILE</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>compl</name> <operator>==</operator> <name>EXPAND_MENUS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>set_context_in_menu_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>compl</name> <operator>==</operator> <name>EXPAND_COMMANDS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>compl</name> <operator>==</operator> <name>EXPAND_MAPPINGS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>set_context_in_map_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"map"</literal></expr></argument>,

<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>CMD_map</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>compl</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>CMD_map</name></expr>:</case> <case>case <expr><name>CMD_noremap</name></expr>:</case>

<case>case <expr><name>CMD_nmap</name></expr>:</case> <case>case <expr><name>CMD_nnoremap</name></expr>:</case>

<case>case <expr><name>CMD_vmap</name></expr>:</case> <case>case <expr><name>CMD_vnoremap</name></expr>:</case>

<case>case <expr><name>CMD_omap</name></expr>:</case> <case>case <expr><name>CMD_onoremap</name></expr>:</case>

<case>case <expr><name>CMD_imap</name></expr>:</case> <case>case <expr><name>CMD_inoremap</name></expr>:</case>

<case>case <expr><name>CMD_cmap</name></expr>:</case> <case>case <expr><name>CMD_cnoremap</name></expr>:</case>

<case>case <expr><name>CMD_lmap</name></expr>:</case> <case>case <expr><name>CMD_lnoremap</name></expr>:</case>

<case>case <expr><name>CMD_smap</name></expr>:</case> <case>case <expr><name>CMD_snoremap</name></expr>:</case>

<case>case <expr><name>CMD_tmap</name></expr>:</case> <case>case <expr><name>CMD_tnoremap</name></expr>:</case>

<case>case <expr><name>CMD_xmap</name></expr>:</case> <case>case <expr><name>CMD_xnoremap</name></expr>:</case>

<return>return <expr><call><name>set_context_in_map_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_unmap</name></expr>:</case>

<case>case <expr><name>CMD_nunmap</name></expr>:</case>

<case>case <expr><name>CMD_vunmap</name></expr>:</case>

<case>case <expr><name>CMD_ounmap</name></expr>:</case>

<case>case <expr><name>CMD_iunmap</name></expr>:</case>

<case>case <expr><name>CMD_cunmap</name></expr>:</case>

<case>case <expr><name>CMD_lunmap</name></expr>:</case>

<case>case <expr><name>CMD_sunmap</name></expr>:</case>

<case>case <expr><name>CMD_tunmap</name></expr>:</case>

<case>case <expr><name>CMD_xunmap</name></expr>:</case>

<return>return <expr><call><name>set_context_in_map_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_mapclear</name></expr>:</case>

<case>case <expr><name>CMD_nmapclear</name></expr>:</case>

<case>case <expr><name>CMD_vmapclear</name></expr>:</case>

<case>case <expr><name>CMD_omapclear</name></expr>:</case>

<case>case <expr><name>CMD_imapclear</name></expr>:</case>

<case>case <expr><name>CMD_cmapclear</name></expr>:</case>

<case>case <expr><name>CMD_lmapclear</name></expr>:</case>

<case>case <expr><name>CMD_smapclear</name></expr>:</case>

<case>case <expr><name>CMD_tmapclear</name></expr>:</case>

<case>case <expr><name>CMD_xmapclear</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_MAPCLEAR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_abbreviate</name></expr>:</case> <case>case <expr><name>CMD_noreabbrev</name></expr>:</case>

<case>case <expr><name>CMD_cabbrev</name></expr>:</case> <case>case <expr><name>CMD_cnoreabbrev</name></expr>:</case>

<case>case <expr><name>CMD_iabbrev</name></expr>:</case> <case>case <expr><name>CMD_inoreabbrev</name></expr>:</case>

<return>return <expr><call><name>set_context_in_map_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>CMD_unabbreviate</name></expr>:</case>

<case>case <expr><name>CMD_cunabbrev</name></expr>:</case>

<case>case <expr><name>CMD_iunabbrev</name></expr>:</case>

<return>return <expr><call><name>set_context_in_map_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>CMD_menu</name></expr>:</case> <case>case <expr><name>CMD_noremenu</name></expr>:</case> <case>case <expr><name>CMD_unmenu</name></expr>:</case>

<case>case <expr><name>CMD_amenu</name></expr>:</case> <case>case <expr><name>CMD_anoremenu</name></expr>:</case> <case>case <expr><name>CMD_aunmenu</name></expr>:</case>

<case>case <expr><name>CMD_nmenu</name></expr>:</case> <case>case <expr><name>CMD_nnoremenu</name></expr>:</case> <case>case <expr><name>CMD_nunmenu</name></expr>:</case>

<case>case <expr><name>CMD_vmenu</name></expr>:</case> <case>case <expr><name>CMD_vnoremenu</name></expr>:</case> <case>case <expr><name>CMD_vunmenu</name></expr>:</case>

<case>case <expr><name>CMD_omenu</name></expr>:</case> <case>case <expr><name>CMD_onoremenu</name></expr>:</case> <case>case <expr><name>CMD_ounmenu</name></expr>:</case>

<case>case <expr><name>CMD_imenu</name></expr>:</case> <case>case <expr><name>CMD_inoremenu</name></expr>:</case> <case>case <expr><name>CMD_iunmenu</name></expr>:</case>

<case>case <expr><name>CMD_cmenu</name></expr>:</case> <case>case <expr><name>CMD_cnoremenu</name></expr>:</case> <case>case <expr><name>CMD_cunmenu</name></expr>:</case>

<case>case <expr><name>CMD_tlmenu</name></expr>:</case> <case>case <expr><name>CMD_tlnoremenu</name></expr>:</case> <case>case <expr><name>CMD_tlunmenu</name></expr>:</case>

<case>case <expr><name>CMD_tmenu</name></expr>:</case> <case>case <expr><name>CMD_tunmenu</name></expr>:</case>

<case>case <expr><name>CMD_popup</name></expr>:</case> <case>case <expr><name>CMD_tearoff</name></expr>:</case> <case>case <expr><name>CMD_emenu</name></expr>:</case>

<return>return <expr><call><name>set_context_in_menu_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_colorscheme</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_COLORS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_compiler</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_COMPILER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_ownsyntax</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_OWNSYNTAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_setfiletype</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_FILETYPE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_packadd</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_PACKADD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALE_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>X_LOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>CMD_language</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_LANGUAGE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>( <expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"messages"</literal></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"ctype"</literal></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"time"</literal></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_LOCALES</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_NOTHING</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>CMD_profile</name></expr>:</case>

<expr_stmt><expr><call><name>set_context_in_profile_cmd</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_behave</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_BEHAVE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_messages</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_MESSAGES</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_history</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_HISTORY</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<case>case <expr><name>CMD_syntime</name></expr>:</case>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_SYNTIME</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>CMD_argdelete</name></expr>:</case>

<while>while <condition>(<expr><operator>(</operator><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_ARGLIST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>set_cmd_context</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <name>use_ccline</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>cmdline_info_T</name> <modifier>*</modifier></type><name>ccline</name> <init>= <expr><call><name>get_cmdline_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>old_char</name> <init>= <expr><name>NUL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>nextcomm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>col</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>old_char</name> <operator>=</operator> <name><name>str</name><index>[<expr><name>col</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>col</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nextcomm</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>use_ccline</name> <operator>&amp;&amp;</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdfirstc</name></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_context_for_expression</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>CMD_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>use_ccline</name> <operator>&amp;&amp;</operator> <name><name>ccline</name><operator>-&gt;</operator><name>input_fn</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>xp_context</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_arg</name></name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>xp_arg</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<while>while <condition>(<expr><name>nextcomm</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nextcomm</name> <operator>=</operator> <call><name>set_one_cmd_context</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>nextcomm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_line</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_col</name></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>col</name></expr>]</index></name> <operator>=</operator> <name>old_char</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>expand_cmdline</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>matchcount</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>matches</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>file_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>WILD_ADD_SLASH</name><operator>|</operator><name>WILD_SILENT</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_UNSUCCESSFUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>beep_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>EXPAND_UNSUCCESSFUL</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_NOTHING</name></expr>)</condition>

<block>{<block_content>

<return>return <expr><name>EXPAND_NOTHING</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>str</name> <operator>+</operator> <name>col</name> <operator>-</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>file_str</name> <operator>=</operator> <call><name>addstar</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>file_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EXPAND_UNSUCCESSFUL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_wic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>options</name> <operator>+=</operator> <name>WILD_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ExpandFromContext</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>file_str</name></expr></argument>, <argument><expr><name>matchcount</name></expr></argument>, <argument><expr><name>matches</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>matchcount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>matches</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>file_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>EXPAND_OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>

<name>cleanup_help_tags</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>num_file</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p_hlg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p_hlg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'e'</literal> <operator>||</operator> <name><name>p_hlg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'n'</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name><name>p_hlg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name><name>p_hlg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_file</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"@en"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>num_file</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>!=</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name> <operator>+</operator> <literal type="number">3</literal>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>file</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>num_file</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_file</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>file</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>get_behave_arg</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier><name>xp</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"mswin"</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xterm"</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>get_messages_arg</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier><name>xp</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"clear"</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>get_mapclear_arg</name><parameter_list>(<parameter><decl><type><name>expand_T</name> <modifier>*</modifier><name>xp</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"&lt;buffer&gt;"</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ExpandFromContext</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>options</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>EW_DIR</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_LIST_NOTFOUND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_NOTFOUND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_ADD_SLASH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_ADDSLASH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_KEEP_ALL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_KEEPALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_SILENT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_SILENT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_NOERROR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_NOERROR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_ALLLINKS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_ALLLINKS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_DIRECTORIES</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES_IN_PATH</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>free_pat</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>!=</operator> <name>XP_BS_NONE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>free_pat</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>==</operator> <name>XP_BS_THREE</name>

<operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal>

<operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal>

<operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>pat</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>pat</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_backslash</name></name> <operator>==</operator> <name>XP_BS_ONE</name>

<operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>pat</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>pat</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_FILE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILES_IN_PATH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <operator>(</operator><name>EW_FILE</name> <operator>|</operator> <name>EW_PATH</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>flags</name> <operator>|</operator> <name>EW_DIR</name><operator>)</operator> <operator>&amp;</operator> <operator>~</operator><name>EW_FILE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>options</name> <operator>&amp;</operator> <name>WILD_ICASE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>expand_wildcards_eval</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>free_pat</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>p_csl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>options</name> <operator>&amp;</operator> <name>WILD_IGNORE_COMPLETESLASH</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_file</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>(</operator><operator>*</operator><name>file</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>ptr</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p_csl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'/'</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p_csl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_HELP</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>find_help_tags</name><argument_list>(<argument><expr><ternary><condition><expr><operator>*</operator><name>pat</name> <operator>==</operator> <name>NUL</name></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"help"</literal></expr> </then><else>: <expr><name>pat</name></expr></else></ternary></expr></argument>,

<argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>cleanup_help_tags</name><argument_list>(<argument><expr><operator>*</operator><name>num_file</name></expr></argument>, <argument><expr><operator>*</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SHELLCMD</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>expand_shellcmd</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_OLD_SETTING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>ExpandOldSetting</name><argument_list>(<argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BUFFERS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>ExpandBufnames</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_DIFF_BUFFERS</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>ExpandBufnames</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>options</name> <operator>|</operator> <name>BUF_DIFF_FILTER</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS_LISTFILES</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>expand_tags</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_TAGS</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_COLORS</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>directories</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"colors"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ExpandRTDir</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>DIP_START</name> <operator>+</operator> <name>DIP_OPT</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,

<argument><expr><name>directories</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_COMPILER</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>directories</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"compiler"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ExpandRTDir</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_OWNSYNTAX</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>directories</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"syntax"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ExpandRTDir</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FILETYPE</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name><name>directories</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"syntax"</literal></expr>, <expr><literal type="string">"indent"</literal></expr>, <expr><literal type="string">"ftplugin"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>ExpandRTDir</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>directories</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_USER_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>ExpandUserList</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_PACKADD</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>ExpandPackAddDir</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_USER_FUNC</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="string">"^s:"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">20</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tofree</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>tofree</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"^&lt;SNR&gt;\\d\\+_%s"</literal></expr></argument>, <argument><expr><name>pat</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <name>tofree</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><ternary><condition><expr><name>p_magic</name></expr> ?</condition><then> <expr><name>RE_MAGIC</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <call><name>ignorecase</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SETTINGS</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_BOOL_SETTINGS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExpandSettings</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_MAPPINGS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExpandMappings</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_USER_DEFINED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExpandUserDefined</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else

<block>{<block_content>

<struct><specifier>static</specifier> struct <name>expgen</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>context</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>char_u</name> <argument_list>*<argument><expr><operator>(</operator><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>expand_T</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>;</argument_list></call></expr></expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ic</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>escaped</name></decl>;</decl_stmt>

}</block> <decl><name><name>tab</name><index>[]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><name>EXPAND_COMMANDS</name></expr>, <expr><name>get_command_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_BEHAVE</name></expr>, <expr><name>get_behave_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_MAPCLEAR</name></expr>, <expr><name>get_mapclear_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_MESSAGES</name></expr>, <expr><name>get_messages_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_HISTORY</name></expr>, <expr><name>get_history_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_COMMANDS</name></expr>, <expr><name>get_user_commands</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_ADDR_TYPE</name></expr>, <expr><name>get_user_cmd_addr_type</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_CMD_FLAGS</name></expr>, <expr><name>get_user_cmd_flags</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_NARGS</name></expr>, <expr><name>get_user_cmd_nargs</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_COMPLETE</name></expr>, <expr><name>get_user_cmd_complete</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_USER_VARS</name></expr>, <expr><name>get_user_var_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_FUNCTIONS</name></expr>, <expr><name>get_function_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER_FUNC</name></expr>, <expr><name>get_user_func_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_EXPRESSION</name></expr>, <expr><name>get_expr_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_MENUS</name></expr>, <expr><name>get_menu_name</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_MENUNAMES</name></expr>, <expr><name>get_menu_names</name></expr>, <expr><name>FALSE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_SYNTAX</name></expr>, <expr><name>get_syntax_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_SYNTIME</name></expr>, <expr><name>get_syntime_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>EXPAND_HIGHLIGHT</name></expr>, <expr><name>get_highlight_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_EVENTS</name></expr>, <expr><name>get_event_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_AUGROUP</name></expr>, <expr><name>get_augroup_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CSCOPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_CSCOPE</name></expr>, <expr><name>get_cscope_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_SIGN</name></expr>, <expr><name>get_sign_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>EXPAND_PROFILE</name></expr>, <expr><name>get_profile_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LOCALE_H</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>X_LOCALE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><block>{<expr><name>EXPAND_LANGUAGE</name></expr>, <expr><name>get_lang_arg</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>FALSE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_LOCALES</name></expr>, <expr><name>get_locales</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>FALSE</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>EXPAND_ENV_VARS</name></expr>, <expr><name>get_env_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_USER</name></expr>, <expr><name>get_users</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>FALSE</name></expr>}</block></expr>,

<expr><block>{<expr><name>EXPAND_ARGLIST</name></expr>, <expr><name>get_arglist_name</name></expr>, <expr><name>TRUE</name></expr>, <expr><name>FALSE</name></expr>}</block></expr>,

}</block></expr></init></decl>;</struct>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>expgen</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>context</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>ic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ExpandGeneric</name><argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>,

<argument><expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>func</name></expr></argument>, <argument><expr><name><name>tab</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt></block_content></block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>

<name>ExpandGeneric</name><argument_list>(

<argument><expr><name>expand_T</name> <operator>*</operator><name>xp</name></expr></argument>,

<argument><expr><name>regmatch_T</name> <operator>*</operator><name>regmatch</name></expr></argument>,

<argument><expr><name>int</name> <operator>*</operator><name>num_file</name></expr></argument>,

<argument><expr><name>char_u</name> <operator>*</operator><operator>*</operator><operator>*</operator><name>file</name></expr></argument>,

<argument><expr><name>char_u</name> <operator>*</operator><operator>(</operator><call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>expand_T</name> <operator>*</operator></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,

<argument><expr><name>int</name> <name>escaped</name></expr></argument>)</argument_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call>(<modifier>*</modifier><name>func</name>)<argument_list>(<argument><expr><name>xp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_regexec</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>escaped</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>vim_strsave_escaped</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" \t\\."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><operator>*</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>file</name><operator>)</operator><index>[<expr><name>count</name></expr>]</index> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>func</name> <operator>==</operator> <name>get_menu_names</name> <operator>&amp;&amp;</operator> <name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\001'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>str</name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>file</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>!=</operator> <name>EXPAND_MENUNAMES</name> <operator>&amp;&amp;</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>!=</operator> <name>EXPAND_MENUS</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_EXPRESSION</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_FUNCTIONS</name>

<operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_USER_FUNC</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>file</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>*</operator><name>num_file</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name>sort_func_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sort_strings</name><argument_list>(<argument><expr><operator>*</operator><name>file</name></expr></argument>, <argument><expr><operator>*</operator><name>num_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>reset_expand_highlight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>expand_shellcmd</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>filepat</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>flagsarg</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mustfree</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>flagsarg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>did_curdir</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hashtab_T</name></type> <name>found_ht</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>filepat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>pat</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>pat</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>pat</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>pat</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_FILE</name> <operator>|</operator> <name>EW_EXEC</name> <operator>|</operator> <name>EW_SHELLCMD</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pat</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>(</operator><name><name>pat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>pat</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mch_isFullName</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>vim_getenv</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PATH"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mustfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>path</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>path</name></expr>;</init> <condition>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>e</name></expr></incr>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>did_curdir</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>did_curdir</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_DIR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>did_curdir</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>EW_DIR</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>EW_DIR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <name>e</name> <operator>-</operator> <name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>MAXPATHL</name> <operator>-</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>expand_wildcards</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>*</operator><name>num_file</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><operator>*</operator><name>num_file</name></expr></argument>, <argument><expr><operator>*</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>num_file</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><operator>*</operator><name>file</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>l</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_ht</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_ht</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><operator>*</operator><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>e</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mustfree</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>hash_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>

<name>call_user_expand_func</name><parameter_list>(

<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>user_expand_func</name>)<parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>,

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>cmdline_info_T</name> <modifier>*</modifier></type><name>ccline</name> <init>= <expr><call><name>get_cmdline_info</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keep</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name><name>args</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>sctx_T</name></type> <name>save_current_sctx</name> <init>= <expr><name>current_sctx</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xp</name><operator>-&gt;</operator><name>xp_arg</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_arg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_line</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>keep</name> <operator>=</operator> <name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_pattern_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>pat</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_line</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_col</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name>current_sctx</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_script_ctx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>user_expand_func</name><argument_list>(<argument><expr><name><name>xp</name><operator>-&gt;</operator><name>xp_arg</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>current_sctx</name> <operator>=</operator> <name>save_current_sctx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdbuff</name><index>[<expr><name><name>ccline</name><operator>-&gt;</operator><name>cmdlen</name></name></expr>]</index></name> <operator>=</operator> <name>keep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ExpandUserDefined</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>regmatch</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>retstr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>skip</name></decl>;</decl_stmt>

<expr_stmt><expr><name>retstr</name> <operator>=</operator> <call><name>call_user_expand_func</name><argument_list>(<argument><expr><name>call_func_retstr</name></expr></argument>, <argument><expr><name>xp</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retstr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>retstr</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>s</name> <operator>=</operator> <name>e</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>keep</name> <operator>=</operator> <operator>*</operator><name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>e</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <name><name>xp</name><operator>-&gt;</operator><name>xp_pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>vim_regexec</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>e</name> <operator>=</operator> <name>keep</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>e</name> <operator>-</operator> <name>s</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>e</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>e</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>ExpandUserList</name><parameter_list>(

<parameter><decl><type><name>expand_T</name> <modifier>*</modifier></type><name>xp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_file</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>file</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>retlist</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><name>retlist</name> <operator>=</operator> <call><name>call_user_expand_func</name><argument_list>(<argument><expr><name>call_func_retlist</name></expr></argument>, <argument><expr><name>xp</name></expr></argument>, <argument><expr><name>num_file</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retlist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_LIST_ITEMS</name><argument_list>(<argument>retlist</argument>, <argument>li</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name> <operator>||</operator> <name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator>

<call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>list_unref</name><argument_list>(<argument><expr><name>retlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>num_file</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>globpath</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>file</name></decl></parameter>,

<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>ga</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>expand_options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>expand_T</name></type> <name>xpc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ExpandInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>=</operator> <name>EXPAND_FILES</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>path</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;</operator> <name>MAXPATHL</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>after_pathsep</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ExpandFromContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>,

<argument><expr><name>WILD_SILENT</name><operator>|</operator><name>expand_options</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <name>num_p</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ExpandEscape</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>num_p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>WILD_SILENT</name><operator>|</operator><name>expand_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>num_p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_p</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ga</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>ga</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <name><name>p</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ga</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>f_getcompletion</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>expand_T</name></type> <name>xpc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>filtered</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>options</name> <init>= <expr><name>WILD_SILENT</name> <operator>|</operator> <name>WILD_USE_NL</name> <operator>|</operator> <name>WILD_ADD_SLASH</name>

<operator>|</operator> <name>WILD_NO_BEEP</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>filtered</name> <operator>=</operator> <call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_wic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>WILD_ICASE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filtered</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>options</name> <operator>|=</operator> <name>WILD_KEEP_ALL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ExpandInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name> <operator>=</operator> <call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>=</operator> <call><name>cmdcomplete_str_to_type</name><argument_list>(<argument><expr><call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_NOTHING</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_MENUS</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_context_in_menu_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"menu"</literal></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CSCOPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_CSCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_context_in_cscope_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name>CMD_cscope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name> <operator>==</operator> <name>EXPAND_SIGN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_context_in_sign_cmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern_len</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>addstar</name><argument_list>(<argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern</name></name></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_pattern_len</name></name></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>rettv_list_alloc</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FAIL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pat</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ExpandOne</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>WILD_ALL_KEEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>xpc</name><operator>.</operator><name>xp_numfiles</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>list_append_string</name><argument_list>(<argument><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>, <argument><expr><name><name>xpc</name><operator>.</operator><name>xp_files</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ExpandCleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>xpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
