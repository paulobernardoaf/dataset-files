<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\misc2.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>coladvance2</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addspaces</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>finetune</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name></type> <name>wcol</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>

<name>virtual_active</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>virtual_op</name> <operator>!=</operator> <name>MAYBE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>virtual_op</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>ve_flags</name> <operator>==</operator> <name>VE_ALL</name>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>ve_flags</name> <operator>&amp;</operator> <name>VE_BLOCK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>VIsual_active</name> <operator>&amp;&amp;</operator> <name>VIsual_mode</name> <operator>==</operator> <name>Ctrl_V</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>ve_flags</name> <operator>&amp;</operator> <name>VE_INSERT</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>State</name> <operator>&amp;</operator> <name>INSERT</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>getviscol</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>x</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>getvvcol</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>coladvance_force</name><parameter_list>(<parameter><decl><type><name>colnr_T</name></type> <name>wcol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>coladvance2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>wcol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>==</operator> <name>MAXCOL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_valid</name></name> <operator>&amp;=</operator> <operator>~</operator><name>VALID_VIRTCOL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_valid</name></name> <operator>|=</operator> <name>VALID_VIRTCOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_virtcol</name></name> <operator>=</operator> <name>wcol</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>rc</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>getviscol2</name><parameter_list>(<parameter><decl><type><name>colnr_T</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name> <name>coladd</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>x</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>pos</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pos</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pos</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <name>coladd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>getvvcol</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>coladvance</name><parameter_list>(<parameter><decl><type><name>colnr_T</name></type> <name>wcol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>getvpos</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>, <argument><expr><name>wcol</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>==</operator> <name>MAXCOL</name> <operator>||</operator> <name>rc</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_valid</name></name> <operator>&amp;=</operator> <operator>~</operator><name>VALID_VIRTCOL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><call><name>ml_get_cursor</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>TAB</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_valid</name></name> <operator>|=</operator> <name>VALID_VIRTCOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_virtcol</name></name> <operator>=</operator> <name>wcol</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>rc</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>getvpos</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name></type> <name>wcol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>coladvance2</name><argument_list>(<argument><expr><name>pos</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><call><name>virtual_active</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>wcol</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>coladvance2</name><parameter_list>(

<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>addspaces</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>finetune</name></decl></parameter>, 

<parameter><decl><type><name>colnr_T</name></type> <name>wcol_arg</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>wcol</name> <init>= <expr><name>wcol_arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>csize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>one_more</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>head</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>one_more</name> <operator>=</operator> <operator>(</operator><name>State</name> <operator>&amp;</operator> <name>INSERT</name><operator>)</operator>

<operator>||</operator> <name>restart_edit</name> <operator>!=</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><name>VIsual_active</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p_sel</name> <operator>!=</operator> <literal type="char">'o'</literal><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>ve_flags</name> <operator>&amp;</operator> <name>VE_ONEMORE</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>wcol</name> <operator>&lt;</operator> <name>MAXCOL</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>&gt;=</operator> <name>MAXCOL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>one_more</name></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <name>wcol</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addspaces</name> <operator>||</operator> <name>finetune</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>VIsual_active</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_curswant</name></name> <operator>=</operator> <call><name>linetabsize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>one_more</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_curswant</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_curswant</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>-</operator> <call><name>win_col_off</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>finetune</name>

<operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_p_wrap</name></name>

<operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <name>wcol</name> <operator>&gt;=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><name>width</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>csize</name> <operator>=</operator> <call><name>linetabsize</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>csize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>csize</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>/</operator> <name>width</name> <operator>&gt;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><name>csize</name> <operator>/</operator> <name>width</name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>State</name> <operator>&amp;</operator> <name>INSERT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><name>wcol</name> <operator>&gt;</operator> <name>csize</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>wcol</name> <operator>=</operator> <operator>(</operator><name>csize</name> <operator>/</operator> <name>width</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>width</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>col</name> <operator>&lt;=</operator> <name>wcol</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>csize</name> <operator>=</operator> <call><name>win_lbr_chartabsize</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>col</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>csize</name> <operator>=</operator> <call><name>lbr_chartabsize_adv</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>col</name> <operator>+=</operator> <name>csize</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>ptr</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>col</name> <operator>&gt;</operator> <name>wcol</name> <operator>||</operator> <operator>(</operator><operator>!</operator><call><name>virtual_active</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>one_more</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_LINEBREAK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>csize</name> <operator>-=</operator> <name>head</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>col</name> <operator>-=</operator> <name>csize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>virtual_active</name><argument_list>()</argument_list></call>

<operator>&amp;&amp;</operator> <name>addspaces</name>

<operator>&amp;&amp;</operator> <name>wcol</name> <operator>&gt;=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>col</name> <operator>!=</operator> <name>wcol</name> <operator>&amp;&amp;</operator> <name>col</name> <operator>!=</operator> <name>wcol</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <name>csize</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>correct</name> <init>= <expr><name>wcol</name> <operator>-</operator> <name>col</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>newline</name> <init>= <expr><call><name>alloc</name><argument_list>(<argument><expr><name>idx</name> <operator>+</operator> <name>correct</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>idx</name></expr>;</condition> <incr><expr><operator>++</operator><name>t</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>t</name></expr>]</index></name> <operator>=</operator> <name><name>line</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>correct</name></expr>;</condition> <incr><expr><operator>++</operator><name>t</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>t</name> <operator>+</operator> <name>idx</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>idx</name> <operator>+</operator> <name>correct</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>newline</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>correct</name></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <name>wcol</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>linelen</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>correct</name> <init>= <expr><name>wcol</name> <operator>-</operator> <name>col</name> <operator>-</operator> <name>csize</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>newline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>t</name></decl>, <decl><type ref="prev"/><name>s</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>-</operator><name>correct</name> <operator>&gt;</operator> <name>csize</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>newline</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>linelen</name> <operator>+</operator> <name>csize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newline</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>t</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>t</name> <operator>&lt;</operator> <name>linelen</name></expr>;</condition> <incr><expr><name>t</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>t</name> <operator>!=</operator> <name>idx</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>s</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>line</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>v</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>v</name> <operator>&lt;</operator> <name>csize</name></expr>;</condition> <incr><expr><name>v</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>s</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>newline</name><index>[<expr><name>linelen</name> <operator>+</operator> <name>csize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>newline</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>(</operator><name>csize</name> <operator>-</operator> <literal type="number">1</literal> <operator>+</operator> <name>correct</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>+=</operator> <name>correct</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>finetune</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>==</operator> <name>MAXCOL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>one_more</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>scol</name></decl>, <decl><type ref="prev"/><name>ecol</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>getvcol</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>scol</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ecol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <name>ecol</name> <operator>-</operator> <name>scol</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>b</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name>wcol</name> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><name>col</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>b</name> <operator>&lt;</operator> <operator>(</operator><name>MAXCOL</name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>col</name> <operator>+=</operator> <name>b</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mb_adjustpos</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wcol</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>col</name> <operator>&lt;</operator> <name>wcol</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>inc_cursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>inc</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>inc</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>!=</operator> <name>MAXCOL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ml_get_pos</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><index>[<expr><name>l</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name> <operator>!=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>incl</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>inc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>col</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>inc</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>dec_cursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>dec</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>dec</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>==</operator> <name>MAXCOL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>-=</operator> <call>(<modifier>*</modifier><name>mb_head_off</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>lp</name><operator>-&gt;</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>-=</operator> <call>(<modifier>*</modifier><name>mb_head_off</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>lp</name><operator>-&gt;</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>col</name></name> <operator>-=</operator> <call>(<modifier>*</modifier><name>mb_head_off</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name><name>lp</name><operator>-&gt;</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>decl</name><parameter_list>(<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>r</name> <operator>=</operator> <call><name>dec</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>col</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>dec</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>r</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>linenr_T</name></type>

<name>get_cursor_rel_lnum</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>cursor</name> <init>= <expr><name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>hasAnyFolding</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <name>cursor</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <name>cursor</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>hasFoldingWin</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <name>cursor</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lnum</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name>cursor</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name>cursor</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>hasFoldingWin</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lnum</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name>cursor</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lnum</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>lnum</name> <operator>-</operator> <name>cursor</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>check_pos</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&gt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pos</name><operator>-&gt;</operator><name>col</name></name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pos</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>check_cursor_lnum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&gt;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasFolding</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>check_cursor_col</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_cursor_col_win</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>check_cursor_col_win</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>oldcol</name> <init>= <expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>oldcoladd</name> <init>= <expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+</operator> <name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>&gt;=</operator> <name>len</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>State</name> <operator>&amp;</operator> <name>INSERT</name><operator>)</operator> <operator>||</operator> <name>restart_edit</name>

<operator>||</operator> <operator>(</operator><name>VIsual_active</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p_sel</name> <operator>!=</operator> <literal type="char">'o'</literal><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>ve_flags</name> <operator>&amp;</operator> <name>VE_ONEMORE</name><operator>)</operator>

<operator>||</operator> <call><name>virtual_active</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mb_adjustpos</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oldcol</name> <operator>==</operator> <name>MAXCOL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ve_flags</name> <operator>==</operator> <name>VE_ALL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>oldcoladd</name> <operator>&gt;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <name>oldcoladd</name> <operator>-</operator> <name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cs</name></decl>, <decl><type ref="prev"/><name>ce</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>getvcol</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ce</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>&gt;</operator> <name>ce</name> <operator>-</operator> <name>cs</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <name>ce</name> <operator>-</operator> <name>cs</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>check_cursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>check_cursor_lnum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_cursor_col</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TEXTOBJ</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>adjust_cursor_col</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>VIsual_active</name> <operator>||</operator> <operator>*</operator><name>p_sel</name> <operator>==</operator> <literal type="char">'o'</literal><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>gchar_cursor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>leftcol_changed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long</name></type> <name>lastcol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>s</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>siso</name> <init>= <expr><call><name>get_sidescrolloff_value</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>changed_cline_bef_curs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lastcol</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_leftcol</name></name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>-</operator> <call><name>curwin_col_off</name><argument_list>()</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>validate_virtcol</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_virtcol</name></name> <operator>&gt;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>lastcol</name> <operator>-</operator> <name>siso</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>coladvance</name><argument_list>(<argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>lastcol</name> <operator>-</operator> <name>siso</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_virtcol</name></name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_leftcol</name></name> <operator>+</operator> <name>siso</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>coladvance</name><argument_list>(<argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_leftcol</name></name> <operator>+</operator> <name>siso</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>getvvcol</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&gt;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><name>lastcol</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>coladvance</name><argument_list>(<argument><expr><name>s</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_leftcol</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>coladvance</name><argument_list>(<argument><expr><name>e</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_leftcol</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>changed_cline_bef_curs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_set_curswant</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>redraw_later</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MEM_PROFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MEM_SIZES</name></cpp:macro> <cpp:value>8200</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name><name>mem_allocs</name><index>[<expr><name>MEM_SIZES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name><name>mem_frees</name><index>[<expr><name>MEM_SIZES</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name>mem_allocated</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name>mem_freed</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name>mem_peak</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name>num_alloc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long_u</name></type> <name>num_freed</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mem_pre_alloc_s</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mem_pre_alloc_l</name><parameter_list>(<parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>sizep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sizep</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mem_post_alloc</name><parameter_list>(

<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>-=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>long_u</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>pp</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>MEM_SIZES</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mem_allocs</name><index>[<expr><name>size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mem_allocs</name><index>[<expr><name>MEM_SIZES</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>mem_allocated</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mem_allocated</name> <operator>-</operator> <name>mem_freed</name> <operator>&gt;</operator> <name>mem_peak</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>mem_peak</name> <operator>=</operator> <name>mem_allocated</name> <operator>-</operator> <name>mem_freed</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>num_alloc</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>pp</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mem_pre_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>long_u</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>pp</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>pp</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>size_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>size_t</name> <operator>*</operator><operator>)</operator><operator>*</operator><name>pp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>MEM_SIZES</name><operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mem_frees</name><index>[<expr><name>size</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mem_frees</name><index>[<expr><name>MEM_SIZES</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>mem_freed</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_freed</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>vim_mem_profile_dump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MEM_SIZES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <name><name>mem_frees</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mem_frees</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ERROR: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[%4d / %4lu-%-4lu] "</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mem_frees</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>MEM_SIZES</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"\r\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mem_frees</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>puts</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"ERROR: "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><literal type="string">"[&gt;%d / %4lu-%-4lu]"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>mem_allocs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mem_frees</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"\n[bytes] total alloc-freed %lu-%lu, in use %lu, peak use %lu\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>mem_allocated</name></expr></argument>, <argument><expr><name>mem_freed</name></expr></argument>, <argument><expr><name>mem_allocated</name> <operator>-</operator> <name>mem_freed</name></expr></argument>, <argument><expr><name>mem_peak</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"[calls] total re/malloc()'s %lu, total free()'s %lu\n\n"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>num_alloc</name></expr></argument>, <argument><expr><name>num_freed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>int</name></type>

<name>alloc_does_fail</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>alloc_fail_countdown</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>alloc_fail_repeat</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>alloc_fail_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>do_outofmem_msg</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>alloc_fail_countdown</name></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEP_ROOM</name></cpp:macro> <cpp:value>(2 * 8192L)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEP_ROOM_KB</name></cpp:macro> <cpp:value>(KEEP_ROOM / 1024L)</cpp:value></cpp:define>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>alloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>lalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>alloc_id</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>alloc_id_T</name> <name>id</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>alloc_fail_id</name> <operator>==</operator> <name>id</name> <operator>&amp;&amp;</operator> <call><name>alloc_does_fail</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>lalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>alloc_clear</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vim_memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>alloc_clear_id</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>alloc_id_T</name> <name>id</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>alloc_fail_id</name> <operator>==</operator> <name>id</name> <operator>&amp;&amp;</operator> <call><name>alloc_does_fail</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><call><name>alloc_clear</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>lalloc_clear</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>message</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>lalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vim_memset</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>lalloc</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>message</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>releasing</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>try_again</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_AVAIL_MEM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>allocated</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E341: Internal error: lalloc(0, )"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MEM_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>mem_pre_alloc_l</name><argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_AVAIL_MEM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<goto>goto <name>theend</name>;</goto>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>allocated</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>allocated</name> <operator>&lt;</operator> <name>KEEP_ROOM</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>allocated</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mch_avail_mem</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>KEEP_ROOM_KB</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>releasing</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>releasing</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>releasing</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_sb_text</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>try_again</name> <operator>=</operator> <call><name>mf_release_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>releasing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>try_again</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>message</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_outofmem_msg</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>theend</name>:</label>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MEM_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>mem_post_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>lalloc_id</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>message</name></decl></parameter>, <parameter><decl><type><name>alloc_id_T</name> <name>id</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>alloc_fail_id</name> <operator>==</operator> <name>id</name> <operator>&amp;&amp;</operator> <call><name>alloc_does_fail</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><operator>(</operator><call><name>lalloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MEM_PROFILE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name> <modifier>*</modifier></type>

<name>mem_realloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>mem_pre_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mem_pre_alloc_s</name><argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mem_post_alloc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>do_outofmem_msg</name><parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_outofmem_msg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>did_outofmem_msg</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E342: Out of memory! (allocating %lu bytes)"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>long_u</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>starting</name> <operator>==</operator> <name>NO_SCREEN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_exit</name><argument_list>(<argument><expr><literal type="number">123</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>free_all_mem</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>nextbuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entered_free_all_mem</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entered_free_all_mem</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>block_autocmds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p_ea</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first_tabpage</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>first_tabpage</name><operator>-&gt;</operator><name>tp_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"tabonly!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ONE_WINDOW</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"only!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>spell_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BEVAL_TERM</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>ui_remove_balloon</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ex_comclear</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MENU</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"aunmenu *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"menutranslate clear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lmapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xmapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"mapclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"mapclear!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"abclear"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"breakdel *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"profdel *"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_KEYMAP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"set keymap="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TITLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>free_titles</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCHPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>free_findfile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free_all_autocmds</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_termcodes</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_all_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>alist_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>global_alist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_homedir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_users</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_search_patterns</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_old_sub</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_last_insert</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_insexpand_stuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_prev_shellcmd</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_regexp_stuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_tag_stuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_cd_dir</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SIGNS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>free_signs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>set_expr_line</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>curtab</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>diff_clear</name><argument_list>(<argument><expr><name>curtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>clear_sb_text</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CLIPBOARD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name>clip_exclude_prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>last_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>new_last_cmdline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_keep_msg</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p_hi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_history</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROP_POPUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>clear_global_prop_types</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tab</argument>, <argument>win</argument>)</argument_list></macro>

<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>close_all_scripts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curwin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>free_all_options</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_AUTOCHDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>p_acd</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>buf</name> <operator>=</operator> <name>firstbuf</name></expr>;</init> <condition><expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>bufref_T</name></type> <name>bufref</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nextbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_buffer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>DOBUF_WIPE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>nextbuf</name></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>firstbuf</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_ARABIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>free_arshape_buf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>clear_registers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ResetRedobuff</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CLIENTSERVER</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_X11</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>serverDelayedStartName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free_highlight</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>reset_last_sourcing</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first_tabpage</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>free_tabpage</name><argument_list>(<argument><expr><name>first_tabpage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>first_tabpage</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>mch_free_mem</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>delete_first_msg</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>channel_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TIMERS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>timer_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>eval_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>job_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free_termoptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_screenlines</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SOUND</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>sound_free</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_XSMP</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>xsmp_close</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>gui_mch_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>clear_hl_tables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>NameBuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>check_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strsave</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strnsave</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_memsave</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strsave_escaped</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>esc_chars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>vim_strsave_escaped_ext</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><literal type="char">'\\'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strsave_escaped_ext</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>esc_chars</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>cc</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>bsl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>escaped_string</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>string</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>length</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>bsl</name> <operator>&amp;&amp;</operator> <call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

</block_content>}</block></for>

<expr_stmt><expr><name>escaped_string</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>escaped_string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>escaped_string</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>string</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>esc_chars</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>bsl</name> <operator>&amp;&amp;</operator> <call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <name>cc</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>p2</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>escaped_string</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>csh_like_shell</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>gettail</name><argument_list>(<argument><expr><name>p_sh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"csh"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strsave_shellescape</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_special</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_newline</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>length</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>escaped_string</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>csh_like</name></decl>;</decl_stmt>

<expr_stmt><expr><name>csh_like</name> <operator>=</operator> <call><name>csh_like_shell</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>length</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>string</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if>

<if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>length</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_newline</name><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_special</name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>csh_like</name> <operator>&amp;&amp;</operator> <name>do_special</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_special</name> <operator>&amp;&amp;</operator> <call><name>find_cmdline_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>length</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>escaped_string</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>escaped_string</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>escaped_string</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>string</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_newline</name><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>csh_like</name> <operator>||</operator> <name>do_special</name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>csh_like</name> <operator>&amp;&amp;</operator> <name>do_special</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>do_special</name> <operator>&amp;&amp;</operator> <call><name>find_cmdline_var</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt> 

<while>while <condition>(<expr><operator>--</operator><name>l</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MB_COPY_CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_ssl</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <literal type="char">'\''</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>escaped_string</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strsave_up</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strup</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p1</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strnsave_up</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strup</name><argument_list>(<argument><expr><name>p1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p1</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>vim_strup</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p2</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EBCDIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><call><name>isalpha</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>c</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></while>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><operator>*</operator><name>p2</name><operator>++</operator> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>c</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'a'</literal> <operator>||</operator> <name>c</name></expr></argument> &gt;</argument_list></name> <literal type="char">'z'</literal><operator>)</operator></expr> ?</condition><then> <expr><name>c</name></expr> </then><else>: <expr><operator>(</operator><name>c</name> <operator>-</operator> <literal type="number">0x20</literal><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>strup_save</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>uc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>utf_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>uc</name> <operator>=</operator> <call><name>utf_toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newl</name> <operator>=</operator> <call><name>utf_char2len</name><argument_list>(<argument><expr><name>uc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newl</name> <operator>!=</operator> <name>l</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>newl</name> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator> <operator>+</operator> <name>newl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>uc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>newl</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if> 

<else>else

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>TOUPPER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>strlow_save</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>orig</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>p</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>orig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>lc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>utf_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>utf_tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newl</name> <operator>=</operator> <call><name>utf_char2len</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newl</name> <operator>!=</operator> <name>l</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>newl</name> <operator>-</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator> <operator>+</operator> <name>newl</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>res</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>utf_char2bytes</name><argument_list>(<argument><expr><name>lc</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>newl</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if> 

<else>else

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while></block_content></block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>del_trailing_spaces</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>--</operator><name>q</name> <operator>&gt;</operator> <name>ptr</name> <operator>&amp;&amp;</operator> <call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>q</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>q</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>Ctrl_V</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>vim_strncpy</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>STRNCPY</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>vim_strcat</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>tosize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>tolen</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fromlen</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tolen</name> <operator>+</operator> <name>fromlen</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>tosize</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>to</name> <operator>+</operator> <name>tolen</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>tosize</name> <operator>-</operator> <name>tolen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to</name><index>[<expr><name>tosize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>to</name> <operator>+</operator> <name>tolen</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>fromlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>copy_option_part</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>option</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>,

<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sep_chars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>option</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>sep_chars</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>sep_chars</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>maxlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_to_option_part</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>option</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>vim_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>really_exiting</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MEM_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>mem_pre_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name> <modifier>*</modifier></type>

<name>vim_memset</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ptr</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>size</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRCASECMP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRICMP</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>vim_stricmp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>s1</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>s2</name></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNCASECMP</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRNICMP</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>vim_strnicmp</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s1</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>TOLOWER_LOC</name><argument_list>(<argument><expr><operator>*</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s1</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>s1</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>s2</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><literal type="number">0</literal></expr>;</return> 

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strchr</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>string</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;=</operator> <literal type="number">0x80</literal></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>utfc_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>utf_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>c</name> <operator>&amp;&amp;</operator> <name>l</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_dbcs</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n2</name> <init>= <expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>c</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>c</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>n2</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>(</operator><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name>b</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>b</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strbyte</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strrchr</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>retval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>string</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STRPBRK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>vim_strpbrk</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>vim_strpbrk</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vim_strpbrk</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>charset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name>charset</name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>s</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>vim_isspace</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>x</name> <operator>&gt;=</operator> <literal type="number">9</literal> <operator>&amp;&amp;</operator> <name>x</name> <operator>&lt;=</operator> <literal type="number">13</literal><operator>)</operator> <operator>||</operator> <name>x</name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ga_clear</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ga_clear_strings</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ga_init</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_maxlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ga_init2</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>itemsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>growsize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_init</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_itemsize</name></name> <operator>=</operator> <name>itemsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_growsize</name></name> <operator>=</operator> <name>growsize</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ga_grow</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>old_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>new_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_maxlen</name></name> <operator>-</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&lt;</operator> <name>n</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_growsize</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_growsize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_len</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_itemsize</name></name> <operator>*</operator> <operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+</operator> <name>n</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>old_len</name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_itemsize</name></name> <operator>*</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_maxlen</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>pp</name> <operator>+</operator> <name>old_len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>new_len</name> <operator>-</operator> <name>old_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_maxlen</name></name> <operator>=</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>=</operator> <name>pp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCHPATH</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>ga_concat_strings</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sep</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sep_len</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call> <operator>+</operator> <name>sep_len</name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>s</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>sep_len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_VIMINFO</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>ga_add_string</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cp</name> <init>= <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>++</operator></expr>]</index> <operator>=</operator> <name>cp</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>ga_concat</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ga_append</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>+</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name><operator>)</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_SYSTEM</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>append_ga_line</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_bin</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <name>CAR</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>NUL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name><operator>++</operator></expr></argument>, <argument><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<struct><specifier>static</specifier> struct <name>modmasktable</name>

<block>{

<decl_stmt><decl><type><name>short</name></type> <name>mod_mask</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>short</name></type> <name>mod_flag</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>name</name></decl>;</decl_stmt> 

}</block> <decl><name><name>mod_mask_table</name><index>[]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><name>MOD_MASK_ALT</name></expr>, <expr><name>MOD_MASK_ALT</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'M'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_META</name></expr>, <expr><name>MOD_MASK_META</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'T'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_CTRL</name></expr>, <expr><name>MOD_MASK_CTRL</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'C'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>MOD_MASK_SHIFT</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'S'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_MULTI_CLICK</name></expr>, <expr><name>MOD_MASK_2CLICK</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'2'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_MULTI_CLICK</name></expr>, <expr><name>MOD_MASK_3CLICK</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'3'</literal></expr>}</block></expr>,

<expr><block>{<expr><name>MOD_MASK_MULTI_CLICK</name></expr>, <expr><name>MOD_MASK_4CLICK</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'4'</literal></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_X</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>MOD_MASK_CMD</name></expr>, <expr><name>MOD_MASK_CMD</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'D'</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>MOD_MASK_ALT</name></expr>, <expr><name>MOD_MASK_ALT</name></expr>, <expr><operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'A'</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NUL</name></expr>}</block></expr>

}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MOD_KEYS_ENTRY_SIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name></type> <name><name>modifier_keys_table</name><index>[]</index></name> <init>=

<expr><block>{

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'D'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'L'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'7'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'7'</literal></expr>, 

<expr><name>MOD_MASK_CTRL</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_C_END</name></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'7'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'*'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, <expr><literal type="char">'@'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'#'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'#'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, 

<expr><name>MOD_MASK_CTRL</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_C_HOME</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'#'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'I'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'#'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'l'</literal></expr>, 

<expr><name>MOD_MASK_CTRL</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_C_LEFT</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'l'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'a'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'b'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'4'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'c'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'7'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'e'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'8'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'f'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'9'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'g'</literal></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'0'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'h'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'i'</literal></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, 

<expr><name>MOD_MASK_CTRL</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_C_RIGHT</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'r'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'%'</literal></expr>, <expr><literal type="char">'j'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'5'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'!'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'6'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'!'</literal></expr>, <expr><literal type="char">'2'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'7'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'!'</literal></expr>, <expr><literal type="char">'3'</literal></expr>, <expr><literal type="char">'&amp;'</literal></expr>, <expr><literal type="char">'8'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_UP</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'u'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_DOWN</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'d'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_XF1</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_XF1</name></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_XF2</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_XF2</name></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_XF3</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_XF3</name></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_XF4</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_XF4</name></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F1</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'1'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F2</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'2'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F3</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'3'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F4</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'4'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F5</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'5'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F6</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'6'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F7</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F8</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'8'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F9</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'9'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F10</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">';'</literal></expr>, 

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F11</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'1'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F12</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'2'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F13</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'3'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F14</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'4'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F15</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'5'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F16</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'6'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F17</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'7'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F18</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'8'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F19</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'9'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F20</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'A'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F21</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'B'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F22</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'C'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F23</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'D'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F24</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'E'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F25</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'F'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F26</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'G'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F27</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'H'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F28</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'I'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F29</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'J'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F30</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'K'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F31</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'L'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F32</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'M'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F33</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'N'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F34</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'O'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F35</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'P'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F36</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'Q'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_S_F37</name></expr>, <expr><literal type="char">'F'</literal></expr>, <expr><literal type="char">'R'</literal></expr>,

<expr><name>MOD_MASK_SHIFT</name></expr>, <expr><literal type="char">'k'</literal></expr>, <expr><literal type="char">'B'</literal></expr>, <expr><name>KS_EXTRA</name></expr>, <expr><operator>(</operator><name>int</name><operator>)</operator><name>KE_TAB</name></expr>,

<expr><name>NUL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<struct><specifier>static</specifier> struct <name>key_name_entry</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>key</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt> 

}</block> <decl><name><name>key_names_table</name><index>[]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><literal type="char">' '</literal></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Space"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>TAB</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Tab"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_TAB</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Tab"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>NL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"NL"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>NL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"NewLine"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>NL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LineFeed"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>NL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LF"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>CAR</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"CR"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>CAR</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Return"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>CAR</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Enter"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>K_BS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"BS"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_BS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"BackSpace"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>ESC</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Esc"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>CSI</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"CSI"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_CSI</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xCSI"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'|'</literal></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Bar"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'\\'</literal></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Bslash"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_DEL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Del"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_DEL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Delete"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>K_KDEL</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kDel"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_UP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Up"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_DOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Down"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Left"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_RIGHT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Right"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XUP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xUp"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XDOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xDown"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XLEFT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xLeft"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XRIGHT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xRight"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_PS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PasteStart"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_PE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PasteEnd"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F1</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F1"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F2</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F2"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F3</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F3"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F4</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F4"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F5</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F5"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F6</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F6"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F7</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F7"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F8</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F8"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F9</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F9"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F10</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F10"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F11</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F11"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F12</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F12"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F13</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F13"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F14</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F14"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F15</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F15"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F16</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F16"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F17</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F17"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F18</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F18"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F19</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F19"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F20</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F20"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F21</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F21"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F22</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F22"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F23</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F23"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F24</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F24"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F25</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F25"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F26</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F26"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F27</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F27"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F28</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F28"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F29</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F29"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F30</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F30"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F31</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F31"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F32</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F32"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F33</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F33"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F34</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F34"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F35</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F35"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F36</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F36"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_F37</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"F37"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XF1</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xF1"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XF2</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xF2"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XF3</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xF3"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XF4</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xF4"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_HELP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Help"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_UNDO</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Undo"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_INS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Insert"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_INS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Ins"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>K_KINS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kInsert"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_HOME</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Home"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KHOME</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kHome"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XHOME</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xHome"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_ZHOME</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"zHome"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_END</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"End"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KEND</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kEnd"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_XEND</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"xEnd"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_ZEND</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"zEnd"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_PAGEUP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PageUp"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_PAGEDOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PageDown"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KPAGEUP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kPageUp"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KPAGEDOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kPageDown"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KPLUS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kPlus"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KMINUS</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kMinus"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KDIVIDE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kDivide"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KMULTIPLY</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kMultiply"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KENTER</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kEnter"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_KPOINT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"kPoint"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K0</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k0"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K1</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k1"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K2</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k2"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K3</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k3"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K4</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k4"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K5</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k5"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K6</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k6"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K7</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k7"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K8</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k8"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_K9</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"k9"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'&lt;'</literal></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lt"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Mouse"</literal></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSE_NET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_NETTERM_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"NetMouse"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSE_DEC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_DEC_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"DecMouse"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSE_JSB</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_JSBTERM_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"JsbMouse"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSE_PTERM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_PTERM_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PtermMouse"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSE_URXVT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_URXVT_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"UrxvtMouse"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>K_SGR_MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"SgrMouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_SGR_MOUSERELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"SgrMouseRelelase"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFTMOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LeftMouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFTMOUSE_NM</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LeftMouseNM"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFTDRAG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LeftDrag"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFTRELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LeftRelease"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_LEFTRELEASE_NM</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"LeftReleaseNM"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSEMOVE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MouseMove"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MIDDLEMOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MiddleMouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MIDDLEDRAG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MiddleDrag"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MIDDLERELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MiddleRelease"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_RIGHTMOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"RightMouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_RIGHTDRAG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"RightDrag"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_RIGHTRELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"RightRelease"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSEDOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ScrollWheelUp"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSEUP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ScrollWheelDown"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSELEFT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ScrollWheelRight"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSERIGHT</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ScrollWheelLeft"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_MOUSEDOWN</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MouseDown"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>K_MOUSEUP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"MouseUp"</literal></expr>}</block></expr>, 

<expr><block>{<expr><name>K_X1MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X1Mouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_X1DRAG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X1Drag"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_X1RELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X1Release"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_X2MOUSE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X2Mouse"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_X2DRAG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X2Drag"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_X2RELEASE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"X2Release"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_DROP</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Drop"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_ZERO</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Nul"</literal></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>K_SNR</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"SNR"</literal></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>K_PLUG</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Plug"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_CURSORHOLD</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"CursorHold"</literal></expr>}</block></expr>,

<expr><block>{<expr><name>K_IGNORE</name></expr>, <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Ignore"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>}</block></expr>

}</block></expr></init></decl>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEY_NAMES_TABLE_LEN</name></cpp:macro> <cpp:value>(sizeof(key_names_table) / sizeof(struct key_name_entry))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>name_to_mod_mask</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>TOUPPER_ASC</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mod_mask</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mod_flag</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>simplify_key</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>modifiers</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>key0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>key1</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>modifiers</name> <operator>&amp;</operator> <operator>(</operator><name>MOD_MASK_SHIFT</name> <operator>|</operator> <name>MOD_MASK_CTRL</name> <operator>|</operator> <name>MOD_MASK_ALT</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>TAB</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_SHIFT</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>modifiers</name> <operator>&amp;=</operator> <operator>~</operator><name>MOD_MASK_SHIFT</name></expr>;</expr_stmt>

<return>return <expr><name>K_S_TAB</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key0</name> <operator>=</operator> <call><name>KEY2TERMCAP0</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key1</name> <operator>=</operator> <call><name>KEY2TERMCAP1</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>MOD_KEYS_ENTRY_SIZE</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>key0</name> <operator>==</operator> <name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name>

<operator>&amp;&amp;</operator> <name>key1</name> <operator>==</operator> <name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>modifiers</name> <operator>&amp;</operator> <name><name>modifier_keys_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>modifiers</name> <operator>&amp;=</operator> <operator>~</operator><name><name>modifier_keys_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><call><name>TERMCAP2KEY</name><argument_list>(<argument><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>key</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>handle_x_keys</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>key</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>K_XUP</name></expr>:</case> <return>return <expr><name>K_UP</name></expr>;</return>

<case>case <expr><name>K_XDOWN</name></expr>:</case> <return>return <expr><name>K_DOWN</name></expr>;</return>

<case>case <expr><name>K_XLEFT</name></expr>:</case> <return>return <expr><name>K_LEFT</name></expr>;</return>

<case>case <expr><name>K_XRIGHT</name></expr>:</case> <return>return <expr><name>K_RIGHT</name></expr>;</return>

<case>case <expr><name>K_XHOME</name></expr>:</case> <return>return <expr><name>K_HOME</name></expr>;</return>

<case>case <expr><name>K_ZHOME</name></expr>:</case> <return>return <expr><name>K_HOME</name></expr>;</return>

<case>case <expr><name>K_XEND</name></expr>:</case> <return>return <expr><name>K_END</name></expr>;</return>

<case>case <expr><name>K_ZEND</name></expr>:</case> <return>return <expr><name>K_END</name></expr>;</return>

<case>case <expr><name>K_XF1</name></expr>:</case> <return>return <expr><name>K_F1</name></expr>;</return>

<case>case <expr><name>K_XF2</name></expr>:</case> <return>return <expr><name>K_F2</name></expr>;</return>

<case>case <expr><name>K_XF3</name></expr>:</case> <return>return <expr><name>K_F3</name></expr>;</return>

<case>case <expr><name>K_XF4</name></expr>:</case> <return>return <expr><name>K_F4</name></expr>;</return>

<case>case <expr><name>K_S_XF1</name></expr>:</case> <return>return <expr><name>K_S_F1</name></expr>;</return>

<case>case <expr><name>K_S_XF2</name></expr>:</case> <return>return <expr><name>K_S_F2</name></expr>;</return>

<case>case <expr><name>K_S_XF3</name></expr>:</case> <return>return <expr><name>K_S_F3</name></expr>;</return>

<case>case <expr><name>K_S_XF4</name></expr>:</case> <return>return <expr><name>K_S_F4</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>key</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>get_special_key_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modifiers</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name></type> <name><name>string</name><index>[<expr><name>MAX_KEY_NAME_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>table_idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'&lt;'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>KEY2TERMCAP0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>KS_KEY</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>KEY2TERMCAP1</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>MOD_KEYS_ENTRY_SIZE</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>( <expr><call><name>KEY2TERMCAP0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>KEY2TERMCAP1</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>modifiers</name> <operator>|=</operator> <name><name>modifier_keys_table</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>TERMCAP2KEY</name><argument_list>(<argument><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>,

<argument><expr><name><name>modifier_keys_table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt></block_content></block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>table_idx</name> <operator>=</operator> <call><name>find_special_key_in_table</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call>(<modifier>*</modifier><name>mb_char2len</name>)<argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>table_idx</name> <operator>&lt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>vim_isprintc</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x7f</literal><operator>)</operator> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0x80</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>&amp;=</operator> <literal type="number">0x7f</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>modifiers</name> <operator>|=</operator> <name>MOD_MASK_ALT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>table_idx</name> <operator>=</operator> <call><name>find_special_key_in_table</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>table_idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>vim_isprintc</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;</operator> <literal type="char">' '</literal></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EBCDIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>CtrlChar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>c</name> <operator>+=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>modifiers</name> <operator>|=</operator> <name>MOD_MASK_CTRL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <literal type="char">'A'</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mod_mask</name><operator>)</operator>

<operator>==</operator> <name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mod_flag</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>mod_mask_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><literal type="char">'-'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>table_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>KEY2TERMCAP0</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>KEY2TERMCAP1</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <call>(<modifier>*</modifier><name>mb_char2len</name>)<argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <call>(<modifier>*</modifier><name>mb_char2bytes</name>)<argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>string</name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_isprintc</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>transchar</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else 

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>key_names_table</name><index>[<expr><name>table_idx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <name>idx</name> <operator>+</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>MAX_KEY_NAME_LEN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>string</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name><name>key_names_table</name><index>[<expr><name>table_idx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'&gt;'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>string</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>trans_special</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>keycode</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>in_string</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>simplify</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>did_simplify</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>modifiers</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>key</name></decl>;</decl_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>find_special_key</name><argument_list>(<argument><expr><name>srcp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modifiers</name></expr></argument>, <argument><expr><name>keycode</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>in_string</name></expr></argument>,

<argument><expr><name>simplify</name></expr></argument>, <argument><expr><name>did_simplify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>special_to_buf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>modifiers</name></expr></argument>, <argument><expr><name>keycode</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>special_to_buf</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>modifiers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>keycode</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>dlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>modifiers</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>K_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>KS_MODIFIER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>modifiers</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>K_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>KEY2TERMCAP0</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <call><name>KEY2TERMCAP1</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>keycode</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dlen</name> <operator>+=</operator> <call>(<modifier>*</modifier><name>mb_char2bytes</name>)<argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>dst</name> <operator>+</operator> <name>dlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>keycode</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>add_char2buf</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>dst</name> <operator>+</operator> <name>dlen</name></expr></argument>)</argument_list></call> <operator>-</operator> <name>dst</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>dst</name><index>[<expr><name>dlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>dlen</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>find_special_key</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>modp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>keycode</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>keep_x_key</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>in_string</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>simplify</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>did_simplify</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>last_dash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end_of_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>src</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>modifiers</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>key</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>uvarnumber_T</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>*</operator><name>srcp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>last_dash</name> <operator>=</operator> <name>src</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>bp</name> <operator>=</operator> <name>src</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <call><name>vim_isIDc</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>bp</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>last_dash</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>bp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>in_string</name> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>in_string</name> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal>

<operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>bp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bp</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"char-"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><name>bp</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>STR2NR_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bp</name> <operator>+=</operator> <name>l</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bp</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>end_of_name</name> <operator>=</operator> <name>bp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>modifiers</name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>bp</name> <operator>=</operator> <name>src</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>bp</name> <operator>&lt;</operator> <name>last_dash</name></expr>;</condition> <incr><expr><name>bp</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>bp</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>bit</name> <operator>=</operator> <call><name>name_to_mod_mask</name><argument_list>(<argument><expr><operator>*</operator><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bit</name> <operator>==</operator> <literal type="number">0x0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>modifiers</name> <operator>|=</operator> <name>bit</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>bp</name> <operator>&gt;=</operator> <name>last_dash</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>last_dash</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"char-"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><name><name>last_dash</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_str2nr</name><argument_list>(<argument><expr><name>last_dash</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>l</name></expr></argument>, <argument><expr><name>STR2NR_ALL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>in_string</name> <operator>&amp;&amp;</operator> <name><name>last_dash</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>last_dash</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>last_dash</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>modifiers</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>last_dash</name><index>[<expr><name>l</name> <operator>+</operator> <name>off</name></expr>]</index></name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>last_dash</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>get_special_key_code</name><argument_list>(<argument><expr><name>last_dash</name> <operator>+</operator> <name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keep_x_key</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>handle_x_keys</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>simplify_key</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modifiers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keycode</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <name>K_BS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>BS</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>key</name> <operator>==</operator> <name>K_DEL</name> <operator>||</operator> <name>key</name> <operator>==</operator> <name>K_KDEL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>DEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_SPECIAL</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>extract_modifiers</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>modifiers</name></expr></argument>,

<argument><expr><name>simplify</name></expr></argument>, <argument><expr><name>did_simplify</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>modifiers</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>srcp</name> <operator>=</operator> <name>end_of_name</name></expr>;</expr_stmt>

<return>return <expr><name>key</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>extract_modifiers</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>modp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>simplify</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>did_simplify</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>modifiers</name> <init>= <expr><operator>*</operator><name>modp</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_X</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_CMD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_SHIFT</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>TOUPPER_ASC</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>simplify</name> <operator>||</operator> <name>modifiers</name> <operator>==</operator> <name>MOD_MASK_SHIFT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>modifiers</name> <operator>&amp;=</operator> <operator>~</operator><name>MOD_MASK_SHIFT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_CTRL</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>TOUPPER_ASC</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>simplify</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_CTRL</name><operator>)</operator>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EBCDIC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call>

<operator>!=</operator> <name>NULL</name>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>key</name> <operator>&gt;=</operator> <literal type="char">'?'</literal> <operator>&amp;&amp;</operator> <name>key</name> <operator>&lt;=</operator> <literal type="char">'_'</literal><operator>)</operator> <operator>||</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call><operator>)</operator></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition>

<block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>Ctrl_chr</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>modifiers</name> <operator>&amp;=</operator> <operator>~</operator><name>MOD_MASK_CTRL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name>K_ZERO</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>did_simplify</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>did_simplify</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_X</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_CMD</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>simplify</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>modifiers</name> <operator>&amp;</operator> <name>MOD_MASK_ALT</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>key</name> <operator>&lt;</operator> <literal type="number">0x80</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><name>enc_dbcs</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>key</name> <operator>|=</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>modifiers</name> <operator>&amp;=</operator> <operator>~</operator><name>MOD_MASK_ALT</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>did_simplify</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>did_simplify</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>modp</name> <operator>=</operator> <name>modifiers</name></expr>;</expr_stmt>

<return>return <expr><name>key</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>find_special_key_in_table</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>i</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_special_key_code</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>table_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>string</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>string</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>string</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>add_termcap_entry</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>TERMCAP2KEY</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>table_name</name> <operator>=</operator> <name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><call><name>vim_isIDc</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>table_name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name><name>table_name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_isIDc</name><argument_list>(<argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>table_name</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>key</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for></block_content></block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>get_key_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>KEY_NAMES_TABLE_LEN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>key_names_table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_fileformat</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><operator>*</operator><name><name>buf</name><operator>-&gt;</operator><name>b_p_ff</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_bin</name></name> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOL_UNIX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOL_MAC</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>EOL_DOS</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_fileformat_force</name><parameter_list>(

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eap</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>force_ff</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>force_ff</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>(</operator><name>eap</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>force_bin</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>

?</condition><then> <expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>force_bin</name></name> <operator>==</operator> <name>FORCE_BIN</name><operator>)</operator></expr> </then><else>: <expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_bin</name></name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOL_UNIX</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name><name>buf</name><operator>-&gt;</operator><name>b_p_ff</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOL_UNIX</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>EOL_MAC</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>EOL_DOS</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>set_fileformat</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>t</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>opt_flags</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>t</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>EOL_DOS</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>FF_DOS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_tx</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EOL_UNIX</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>FF_UNIX</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_tx</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EOL_MAC</name></expr>:</case>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>FF_MAC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_tx</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_string_option_direct</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ff"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>,

<argument><expr><name>OPT_FREE</name> <operator>|</operator> <name>opt_flags</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>check_status</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>redraw_tabline</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TITLE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>need_maketitle</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>default_fileformat</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>p_ffs</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> <return>return <expr><name>EOL_MAC</name></expr>;</return>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> <return>return <expr><name>EOL_DOS</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>EOL_UNIX</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>call_shell</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ncmd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>proftime_T</name></type> <name>wait_time</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>p_verbose</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>verbose_enter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Calling shell to execute: \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>p_sh</name></expr> </then><else>: <expr><name>cmd</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_char</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cursor_on</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>verbose_leave</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>do_profiling</name> <operator>==</operator> <name>PROF_YES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>prof_child_enter</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sh</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_shellempty</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>gui_mch_mousehide</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>++</operator><name>hold_gui_events</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>tag_freematch</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>p_sxq</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>mch_call_shell</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ecmd</name> <init>= <expr><name>cmd</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sxe</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p_sxq</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ecmd</name> <operator>=</operator> <call><name>vim_strsave_escaped_ext</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>p_sxe</name></expr></argument>, <argument><expr><literal type="char">'^'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ecmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ecmd</name> <operator>=</operator> <name>cmd</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ncmd</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>ecmd</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p_sxq</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ncmd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>p_sxq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>ecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>p_sxq</name> <operator>==</operator> <literal type="char">'('</literal></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">")"</literal></expr>

</then><else>: <expr><ternary><condition><expr><operator>*</operator><name>p_sxq</name> <operator>==</operator> <literal type="char">'"'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>p_sxq</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'('</literal></expr> ?</condition><then> <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">")\""</literal></expr>

</then><else>: <expr><name>p_sxq</name></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>mch_call_shell</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>, <argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ncmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ecmd</name> <operator>!=</operator> <name>cmd</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>--</operator><name>hold_gui_events</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>shell_resized_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>set_vim_var_nr</name><argument_list>(<argument><expr><name>VV_SHELL_ERROR</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>retval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PROFILE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>do_profiling</name> <operator>==</operator> <name>PROF_YES</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>prof_child_exit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wait_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_real_state</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>State</name> <operator>&amp;</operator> <name>NORMAL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>VIsual_active</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>VIsual_select</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SELECTMODE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>VISUAL</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>finish_op</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>OP_PENDING</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>State</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>after_pathsep</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>p</name> <operator>&gt;</operator> <name>b</name> <operator>&amp;&amp;</operator> <call><name>vim_ispathsep</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>has_mbyte</name> <operator>||</operator> <call>(<modifier>*</modifier><name>mb_head_off</name>)<argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>same_directory</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>f1</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>f2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>ffname</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>f2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>vim_FullName</name><argument_list>(<argument><expr><name>f1</name></expr></argument>, <argument><expr><name>ffname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>gettail_sep</name><argument_list>(<argument><expr><name>ffname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>gettail_sep</name><argument_list>(<argument><expr><name>f2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>t1</name> <operator>-</operator> <name>ffname</name> <operator>==</operator> <name>t2</name> <operator>-</operator> <name>f2</name>

<operator>&amp;&amp;</operator> <call><name>pathcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>ffname</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>f2</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>t1</name> <operator>-</operator> <name>ffname</name><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SESSION</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_AUTOCHDIR</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_NETBEANS_INTG</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>vim_chdirfile</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>trigger_autocmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>old_dir</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>new_dir</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mch_dirname</name><argument_list>(<argument><expr><name>old_dir</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>old_dir</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><call><name>gettail_sep</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>pathcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>old_dir</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>new_dir</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><call><name>mch_chdir</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>new_dir</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>OK</name></expr> </then><else>: <expr><name>FAIL</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>OK</name> <operator>&amp;&amp;</operator> <name>trigger_autocmd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_DIRCHANGED</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>trigger_autocmd</name></expr></argument>,

<argument><expr><name>new_dir</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>STAT_IGNORES_SLASH</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>illegal_slash</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>mch_isdir</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt> 

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>vim_stat</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>stat_T</name> <modifier>*</modifier></type><name>stp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><ternary><condition><expr><call><name>illegal_slash</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><call><name>stat</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>stp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>CURSOR_SHAPE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>cursorentry_T</name></type> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_COUNT</name></expr>]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"n"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"v"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"i"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"r"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"c"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"ci"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"cr"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"o"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">700L</literal></expr>, <expr><literal type="number">400L</literal></expr>, <expr><literal type="number">250L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"ve"</literal></expr>, <expr><name>SHAPE_CURSOR</name><operator>+</operator><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"e"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"s"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"sd"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"vs"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"vd"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"m"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"ml"</literal></expr>, <expr><name>SHAPE_MOUSE</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100L</literal></expr>, <expr><literal type="number">100L</literal></expr>, <expr><literal type="number">100L</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"sm"</literal></expr>, <expr><name>SHAPE_CURSOR</name></expr>}</block></expr>,

}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type> <name><name>mshape_names</name><index>[]</index></name> <init>=

<expr><block>{

<expr><literal type="string">"arrow"</literal></expr>, 

<expr><literal type="string">"blank"</literal></expr>, 

<expr><literal type="string">"beam"</literal></expr>,

<expr><literal type="string">"updown"</literal></expr>,

<expr><literal type="string">"udsizing"</literal></expr>,

<expr><literal type="string">"leftright"</literal></expr>,

<expr><literal type="string">"lrsizing"</literal></expr>,

<expr><literal type="string">"busy"</literal></expr>,

<expr><literal type="string">"no"</literal></expr>,

<expr><literal type="string">"crosshair"</literal></expr>,

<expr><literal type="string">"hand1"</literal></expr>,

<expr><literal type="string">"hand2"</literal></expr>,

<expr><literal type="string">"pencil"</literal></expr>,

<expr><literal type="string">"question"</literal></expr>,

<expr><literal type="string">"rightup-arrow"</literal></expr>,

<expr><literal type="string">"up-arrow"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>parse_shape_opt</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>what</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>modep</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>colonp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>commap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>slashp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>all_idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_ve</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SHAPE_MOUSE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>modep</name> <operator>=</operator> <name>p_mouseshape</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>modep</name> <operator>=</operator> <name>p_guicursor</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>modep</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>colonp</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>modep</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>commap</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>modep</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>colonp</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><name>commap</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>commap</name> <operator>&lt;</operator> <name>colonp</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E545: Missing colon"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>colonp</name> <operator>==</operator> <name>modep</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E546: Illegal mode"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>all_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>modep</name> <operator>&lt;</operator> <name>colonp</name> <operator>||</operator> <name>all_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>all_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>modep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>modep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name><name>modep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>all_idx</name> <operator>=</operator> <name>SHAPE_IDX_COUNT</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>SHAPE_IDX_COUNT</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>modep</name></expr></argument>, <argument><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>

<operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name>SHAPE_IDX_COUNT</name>

<operator>||</operator> <operator>(</operator><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>used_for</name> <operator>&amp;</operator> <name>what</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E546: Illegal mode"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>modep</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal> <operator>&amp;&amp;</operator> <name><name>modep</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>found_ve</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>modep</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>all_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name>all_idx</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SHAPE_MOUSE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>mshape</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>shape</name> <operator>=</operator> <name>SHAPE_BLOCK</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkwait</name> <operator>=</operator> <literal type="number">700L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkon</name> <operator>=</operator> <literal type="number">400L</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkoff</name> <operator>=</operator> <literal type="number">250L</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>colonp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SHAPE_MOUSE</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mshape_names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E547: Illegal mouseshape"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>mshape</name> <operator>=</operator>

<call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>MSHAPE_NUMBERED</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>mshape_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>mshape_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>mshape</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"ver"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"hor"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"blinkwait"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"blinkon"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"blinkoff"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E548: digit expected"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getdigits</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E549: Illegal percentage"</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>TOLOWER_ASC</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>shape</name> <operator>=</operator> <name>SHAPE_VER</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>shape</name> <operator>=</operator> <name>SHAPE_HOR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>percentage</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkwait</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkon</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>blinkoff</name> <operator>=</operator> <name>n</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>shape</name> <operator>=</operator> <name>SHAPE_BLOCK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else 

<block>{<block_content>

<expr_stmt><expr><name>endp</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>commap</name> <operator>==</operator> <name>NULL</name></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>p</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>endp</name> <operator>&gt;</operator> <name>commap</name> <operator>||</operator> <name>endp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>commap</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>slashp</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slashp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>slashp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>syn_check_group</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>slashp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>slashp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <call><name>syn_check_group</name><argument_list>(<argument><expr><name>p</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>endp</name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>id_lm</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slashp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>slashp</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></while>

<expr_stmt><expr><name>modep</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>modep</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>modep</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_ve</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>what</name> <operator>==</operator> <name>SHAPE_MOUSE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>mshape</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>mshape</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>shape</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>shape</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>percentage</name> <operator>=</operator>

<name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>percentage</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>blinkwait</name> <operator>=</operator>

<name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>blinkwait</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>blinkon</name> <operator>=</operator>

<name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>blinkon</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>blinkoff</name> <operator>=</operator>

<name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>blinkoff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>id</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VE</name></expr>]</index></name><operator>.</operator><name>id_lm</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_V</name></expr>]</index></name><operator>.</operator><name>id_lm</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MCH_CURSOR_SHAPE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>get_shape_idx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mouse</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>mouse</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>State</name> <operator>==</operator> <name>HITRETURN</name> <operator>||</operator> <name>State</name> <operator>==</operator> <name>ASKMORE</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gui_mch_getmouse</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>Y_2_ROW</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>Rows</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_MOREL</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>SHAPE_IDX_MORE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mouse</name> <operator>&amp;&amp;</operator> <name>drag_status_line</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_SDRAG</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mouse</name> <operator>&amp;&amp;</operator> <name>drag_sep_line</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_VDRAG</name></expr>;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mouse</name> <operator>&amp;&amp;</operator> <name>State</name> <operator>==</operator> <name>SHOWMATCH</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_SM</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>State</name> <operator>&amp;</operator> <name>VREPLACE_FLAG</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_R</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>State</name> <operator>&amp;</operator> <name>REPLACE_FLAG</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_R</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>State</name> <operator>&amp;</operator> <name>INSERT</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_I</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>State</name> <operator>&amp;</operator> <name>CMDLINE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>cmdline_at_end</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_C</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cmdline_overstrike</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_CR</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>SHAPE_IDX_CI</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>finish_op</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_O</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>VIsual_active</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sel</name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_VE</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>SHAPE_IDX_V</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>SHAPE_IDX_N</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MOUSESHAPE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>old_mouse_shape</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>update_mouseshape</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>shape_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>new_mouse_shape</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gui</name><operator>.</operator><name>in_use</name></name> <operator>||</operator> <name><name>gui</name><operator>.</operator><name>starting</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shape_idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>char_avail</name><argument_list>()</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>postponed_mouseshape</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_mouse</name> <operator>==</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>shape_idx</name> <operator>==</operator> <name>SHAPE_IDX_CLINE</name>

<operator>||</operator> <name>shape_idx</name> <operator>==</operator> <name>SHAPE_IDX_STATUS</name>

<operator>||</operator> <name>shape_idx</name> <operator>==</operator> <name>SHAPE_IDX_VSEP</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>shape_idx</name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shape_idx</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal>

<operator>&amp;&amp;</operator> <name>old_mouse_shape</name> <operator>!=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_CLINE</name></expr>]</index></name><operator>.</operator><name>mshape</name>

<operator>&amp;&amp;</operator> <name>old_mouse_shape</name> <operator>!=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_STATUS</name></expr>]</index></name><operator>.</operator><name>mshape</name>

<operator>&amp;&amp;</operator> <name>old_mouse_shape</name> <operator>!=</operator> <name><name>shape_table</name><index>[<expr><name>SHAPE_IDX_VSEP</name></expr>]</index></name><operator>.</operator><name>mshape</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shape_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>new_mouse_shape</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><call><name>get_shape_idx</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>]</index></name><operator>.</operator><name>mshape</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>new_mouse_shape</name> <operator>=</operator> <name><name>shape_table</name><index>[<expr><name>shape_idx</name></expr>]</index></name><operator>.</operator><name>mshape</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>new_mouse_shape</name> <operator>!=</operator> <name>old_mouse_shape</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_set_mouse_shape</name><argument_list>(<argument><expr><name>new_mouse_shape</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>old_mouse_shape</name> <operator>=</operator> <name>new_mouse_shape</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>postponed_mouseshape</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><name>int</name></type>

<name>vim_chdir</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>new_dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SEARCHPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>mch_chdir</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>new_dir</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dir_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dir_name</name> <operator>=</operator> <call><name>find_directory_in_path</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>new_dir</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>FNAME_MESS</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dir_name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>mch_chdir</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>dir_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>dir_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>r</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_user_name</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>username</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>mch_get_user_name</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>username</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_QSORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>qsort</name><parameter_list>(

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>elm_count</name></decl></parameter>,

<parameter><decl><type><name>size_t</name></type> <name>elm_size</name></decl></parameter>,

<parameter><function_decl><type><name>int</name></type> (<modifier>*</modifier><name>cmp</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>gap</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>elm_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>gap</name> <operator>=</operator> <name>elm_count</name> <operator>/</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>gap</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>gap</name> <operator>/=</operator> <literal type="number">2</literal></expr></incr>)</control><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>gap</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>elm_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>i</name> <operator>-</operator> <name>gap</name></expr>;</init> <condition><expr><name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>j</name> <operator>-=</operator> <name>gap</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p1</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>base</name> <operator>+</operator> <name>j</name> <operator>*</operator> <name>elm_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p2</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>base</name> <operator>+</operator> <operator>(</operator><name>j</name> <operator>+</operator> <name>gap</name><operator>)</operator> <operator>*</operator> <name>elm_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>cmp</name>)<argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p1</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>p2</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p1</name></expr></argument>, <argument><expr><name>elm_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p1</name></expr></argument>, <argument><expr><name>p2</name></expr></argument>, <argument><expr><name>elm_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p2</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>elm_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for></block_content></block></for></block_content></block></for>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>sort_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>sort_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>s2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>STRCMP</name><argument_list>(<argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s1</name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator><name>s2</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>sort_strings</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>files</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>files</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>count</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char_u</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETENV</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_PUTENV</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXTRASIZE</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>envsize</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>environ</name></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>findenv</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>newenv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>moreenv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl> 

<function><type><name>int</name></type>

<name>putenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>envsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>newenv</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>findenv</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content><empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>envsize</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>

<block>{<block_content> 

<if_stmt><if>if <condition>(<expr><call><name>moreenv</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>environ</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else

<block>{<block_content> 

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>findenv</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>namechar</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>envchar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>found</name></decl>;</decl_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>envchar</name> <operator>=</operator> <name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>namechar</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>namechar</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>namechar</name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>namechar</name> <operator>==</operator> <operator>*</operator><name>envchar</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>namechar</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>envchar</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>*</operator><name>namechar</name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>*</operator><name>namechar</name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>*</operator><name>envchar</name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><ternary><condition><expr><name>found</name></expr> ?</condition><then> <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>newenv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>elem</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>esize</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>esize</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>EXTRASIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>esize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>env</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>elem</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>elem</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>env</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>elem</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>elem</name></expr></argument>, <argument><expr><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>env</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>environ</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<expr_stmt><expr><name>envsize</name> <operator>=</operator> <name>esize</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>moreenv</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>esize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>

<expr_stmt><expr><name>esize</name> <operator>=</operator> <name>envsize</name> <operator>+</operator> <name>EXTRASIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>environ</name></expr></argument>, <argument><expr><name>esize</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>env</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>env</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>environ</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<expr_stmt><expr><name>envsize</name> <operator>=</operator> <name>esize</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_VIMPTY_GETENV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>vimpty_getenv</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char_u</name> <modifier>*</modifier></type><name>string</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>envsize</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>findenv</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>environ</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>filewritable</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>perm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>perm</name> <operator>=</operator> <call><name>mch_getperm</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><call><name>mch_writable</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>

<operator>(</operator><name>perm</name> <operator>&amp;</operator> <literal type="number">0222</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<call><name>mch_access</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><name>W_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>

)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>retval</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mch_isdir</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>retval</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_PERSISTENT_UNDO</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>get2c</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get3c</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <name>c</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get4c</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content> <return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>n</name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>c</name></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><name>n</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>read_string</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cnt</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>cnt</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>cnt</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>getc</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>EOF</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>put_bytes</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>long_u</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>putc</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>nr</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator><operator>)</operator></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>has_non_ascii</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="number">128</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELAPSED_TIMEVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>long</name></type>

<name>elapsed</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>start_tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now_tv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now_tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name><name>now_tv</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name><name>start_tv</name><operator>-&gt;</operator><name>tv_sec</name></name><operator>)</operator> <operator>*</operator> <literal type="number">1000L</literal>

<operator>+</operator> <operator>(</operator><name><name>now_tv</name><operator>.</operator><name>tv_usec</name></name> <operator>-</operator> <name><name>start_tv</name><operator>-&gt;</operator><name>tv_usec</name></name><operator>)</operator> <operator>/</operator> <literal type="number">1000L</literal></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ELAPSED_TICKCOUNT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>long</name></type>

<name>elapsed</name><parameter_list>(<parameter><decl><type><name>DWORD</name></type> <name>start_tick</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>DWORD</name></type> <name>now</name> <init>= <expr><call><name>GetTickCount</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name>long</name><operator>)</operator><name>now</name> <operator>-</operator> <operator>(</operator><name>long</name><operator>)</operator><name>start_tick</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_SYSTEM</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_TERMINAL</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>mch_parse_cmd</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>use_shcf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inquote</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>inquote</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>argc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>argc</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>inquote</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>TAB</name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>inquote</name> <operator>=</operator> <operator>!</operator><name>inquote</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rem_backslash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_shcf</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p_shcf</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skiptowhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>argc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>argv</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><operator>*</operator><name>argc</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>int</name></type>

<name>build_argv_from_string</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd_copy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cmd_copy</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd_copy</name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <call><name>mch_parse_cmd</name><argument_list>(<argument><expr><name>cmd_copy</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cmd_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strsave</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>argc</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cmd_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>build_argv_from_list</name><parameter_list>(<parameter><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>argv</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>argv</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>argc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>FOR_ALL_LIST_ITEMS</name><argument_list>(<argument>l</argument>, <argument>li</argument>)</argument_list></macro>

<block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>li</name><operator>-&gt;</operator><name>li_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>*</operator><name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>argc</name></expr>]</index> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>vim_strsave</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>argc</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>argv</name><operator>)</operator><index>[<expr><operator>*</operator><name>argc</name></expr>]</index> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>get_special_pty_type</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>get_conpty_type</name><argument_list>()</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

</unit>
