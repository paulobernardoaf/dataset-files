<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\spell.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IN_SPELL_C</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SPELL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>UNIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REGION_ALL</name></cpp:macro> <cpp:value>0xff</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGIC</name></cpp:macro> <cpp:value>"VIMsug"</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGMAGICL</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIMSUGVERSION</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_BANNED</name></cpp:macro> <cpp:value>-1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_RARE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_LOCAL</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SP_BAD</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>matchinf_S</name>

<block>{

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>mi_lp</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_word</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_end</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_fend</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_cend</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>mi_fword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_fwordlen</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_prefarridx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_prefcnt</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_prefixlen</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_cprefixlen</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_compoff</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>mi_compflags</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_complen</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_compextra</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_result</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_capflags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>mi_win</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>mi_result2</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mi_end2</name></decl>;</decl_stmt> 

}</block></struct></type> <name>matchinf_T</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_mb_isword_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cl</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_FOLDWORD</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_KEEPWORD</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_PREFIX</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_COMPOUND</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIND_KEEPCOMPOUND</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_word</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>find_prefix</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>fold_more</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_load_cb</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>count_syllables</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>clear_midword</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>use_midword</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_region</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_soundfold_sofo</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_soundfold_sal</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>spell_soundfold_wsal</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_word</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>round</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>linenr_T</name></type> <name>dump_prefixes</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>round</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>linenr_T</name></type> <name>startlnum</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>int</name></type>

<name>spell_check</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,

<parameter><decl><type><name>hlf_T</name> <modifier>*</modifier></type><name>attrp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>capcol</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>docount</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>matchinf_T</name></type> <name>mi</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>nrlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wrongcaplen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count_word</name> <init>= <expr><name>docount</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>matchinf_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'B'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <call><name>skipbin</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>==</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <name><name>ptr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'X'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <call><name>skiphex</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <call><name>skipdigits</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>nrlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_word</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<do>do<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>

while <condition>(<expr><operator>*</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>capcol</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wrongcaplen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>capcol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_capflags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_cend</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_win</name></name> <operator>=</operator> <name>wp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_fend</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>, <argument><expr><name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr></argument>,

<argument><expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_fwordlen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result2</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_FOLDWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_KEEPWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_FOLDWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name>

<operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result2</name></name> <operator>!=</operator> <name>SP_BAD</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_result2</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_end2</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>count_word</name> <operator>&amp;&amp;</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>count_common_word</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>count_word</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>!=</operator> <name>SP_OK</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>nrlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BANNED</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>nrlen</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>capcol</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>regmatch</name><operator>.</operator><name>endp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>==</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name>

<operator>&amp;&amp;</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>save_result</name> <init>= <expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_word</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <name><name>mi</name><operator>.</operator><name>mi_fword</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;=</operator> <name><name>mi</name><operator>.</operator><name>mi_end</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_compoff</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>fp</name> <operator>-</operator> <name><name>mi</name><operator>.</operator><name>mi_fword</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mi</name></expr></argument>, <argument><expr><name>FIND_COMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>!=</operator> <name>SP_BAD</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>=</operator> <name>save_result</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BANNED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPB</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_RARE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPR</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wrongcaplen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name> <operator>||</operator> <name><name>mi</name><operator>.</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_RARE</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>HLF_SPC</name></expr>;</expr_stmt>

<return>return <expr><name>wrongcaplen</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mi</name><operator>.</operator><name>mi_end</name></name> <operator>-</operator> <name>ptr</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>find_word</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>endlen</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>idx_T</name></type> <name><name>endidx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>endidxcnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>SP_BAD</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>word_ends</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prefix_found</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nobreak_result</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_KEEPWORD</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <literal type="number">9999</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wlen</name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_PREFIX</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>endidxcnt</name> <operator>==</operator> <name>MAXWLEN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>endidx</name><index>[<expr><name>endidxcnt</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>arridx</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>arridx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>arridx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>!=</operator> <name>TAB</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><name>endidxcnt</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>endidxcnt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>endidx</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call>(<modifier>*</modifier><name>mb_head_off</name>)<argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>word_ends</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>word_ends</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>prefix_found</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>FIND_KEEPWORD</name> <operator>&amp;&amp;</operator> <name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>ptr</name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name>wlen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name>wlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</init> <condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>;</condition>

<incr><expr><operator>--</operator><name>len</name></expr><operator>,</operator> <expr><operator>++</operator><name>arridx</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>arridx</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_FOLDWORD</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name> <operator>!=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name> <operator>==</operator> <name>WF_KEEPCAP</name>

<operator>||</operator> <operator>!</operator><call><name>spell_valid_case</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_capflags</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_PREFIX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>prefix_found</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefarridx</name></name></expr></argument>,

<argument><expr><name>flags</name></expr></argument>,

<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_RARE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prefix_found</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name> <operator>||</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPCOMPOUND</name>

<operator>||</operator> <operator>!</operator><name>word_ends</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <name>wlen</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name>

<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>mb_charlen_len</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>,

<argument><expr><name>wlen</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compminlen</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name> <operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name> <operator>+</operator> <literal type="number">2</literal>

<operator>&gt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name>

<operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>==</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NOCOMPBEF</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NOCOMPAFT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>byte_in_str</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>==</operator> <literal type="number">0</literal></expr>

?</condition><then> <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr>

</then><else>: <expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></else></ternary></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>match_checkcompoundpattern</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>capflags</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>,

<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>ptr</name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>capflags</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>capflags</name> <operator>==</operator> <name>WF_KEEPCAP</name> <operator>||</operator> <operator>(</operator><name>capflags</name> <operator>==</operator> <name>WF_ALLCAP</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>capflags</name> <operator>!=</operator> <name>WF_ALLCAP</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>

?</condition><then> <expr><name>capflags</name> <operator>==</operator> <name>WF_ONECAP</name></expr>

</then><else>: <expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <name>capflags</name> <operator>!=</operator> <name>WF_ONECAP</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name><index>[<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name><index>[<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>word_ends</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_compound</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>match_compoundrule</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compflags</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>nobreak_result</name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>word_ends</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>save_result</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_end</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>save_lp</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>SP_BAD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <name><name>endlen</name><index>[<expr><name>endidxcnt</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <name>FIND_KEEPWORD</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>ptr</name></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>ptr</name> <operator>+</operator> <name>wlen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

c = mip-&gt;mi_compoff;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>++</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_COMPROOT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_win</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>!</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_COMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>||</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_BAD</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_KEEPCOMPOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if> 

if (!slang-&gt;sl_nobreak || mip-&gt;mi_result == SP_BAD)

{

mip-&gt;mi_compoff = c;

find_prefix(mip, FIND_COMPOUND);

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>--</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_complen</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_COMPROOT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_compextra</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name></name> <operator>=</operator> <name>save_lp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>nobreak_result</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>save_result</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name>save_end</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_BANNED</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_region</name></name> <operator>&amp;</operator> <operator>(</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_LOCAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_RARE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name>SP_OK</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nobreak_result</name> <operator>==</operator> <name>SP_BAD</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>&gt;</operator> <name>res</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result2</name></name> <operator>==</operator> <name>res</name>

<operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end2</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>&gt;</operator> <name>res</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>=</operator> <name>res</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>res</name> <operator>&amp;&amp;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>&lt;</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_end</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name> <operator>+</operator> <name>wlen</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>mip</name><operator>-&gt;</operator><name>mi_result</name></name> <operator>==</operator> <name>SP_OK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>match_checkcompoundpattern</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>wlen</name></decl></parameter>,

<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <name>wlen</name> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <name>wlen</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>can_compound</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>uflags</name><index>[<expr><name>MAXWLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uflags</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>utf_char2bytes</name><argument_list>(<argument><expr><name><name>flags</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>uflags</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_regexec_prog</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_compprog</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>&lt;</operator> <name>MAXWLEN</name>

<operator>&amp;&amp;</operator> <call><name>count_syllables</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compsylmax</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_compmax</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>match_compoundrule</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>compflags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_comprules</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>compflags</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'/'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>match</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">']'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator> <operator>==</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>match</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>valid_word_prefix</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>totprefcnt</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>arridx</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,

<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>cond_req</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>prefcnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>rp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prefid</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prefid</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>prefcnt</name> <operator>=</operator> <name>totprefcnt</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>prefcnt</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>prefcnt</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>pidx</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name><index>[<expr><name>arridx</name> <operator>+</operator> <name>prefcnt</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prefid</name> <operator>!=</operator> <operator>(</operator><name>pidx</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_HAS_AFF</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>pidx</name> <operator>&amp;</operator> <name>WF_PFX_NC</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_prefprog</name><index>[<expr><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>pidx</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_regexec_prog</name><argument_list>(<argument><expr><name>rp</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cond_req</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<return>return <expr><name>pidx</name></expr>;</return>

</block_content>}</block></for>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>find_prefix</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>idx_T</name></type> <name>arridx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name></type> <name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name> <init>= <expr><name><name>mip</name><operator>-&gt;</operator><name>mi_lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>-=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flen</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <call><name>fold_more</name><argument_list>(<argument><expr><name>mip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>arridx</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefarridx</name></name> <operator>=</operator> <name>arridx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>byts</name><index>[<expr><name>arridx</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arridx</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefcnt</name></name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name> <operator>=</operator> <name>wlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <name>FIND_COMPOUND</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name> <operator>+=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_compoff</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name> <operator>=</operator> <call><name>nofold_len</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name></expr></argument>,

<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_word</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_cprefixlen</name></name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_prefixlen</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>find_word</name><argument_list>(<argument><expr><name>mip</name></expr></argument>, <argument><expr><name>FIND_PREFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ptr</name><index>[<expr><name>wlen</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>arridx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>arridx</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>lo</name> <operator>&lt;</operator> <name>hi</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>m</name> <operator>=</operator> <operator>(</operator><name>lo</name> <operator>+</operator> <name>hi</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&gt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>m</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>byts</name><index>[<expr><name>m</name></expr>]</index></name> <operator>&lt;</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>m</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name> <operator>=</operator> <name>m</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name> <operator>||</operator> <name><name>byts</name><index>[<expr><name>lo</name></expr>]</index></name> <operator>!=</operator> <name>c</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>arridx</name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>lo</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>wlen</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>flen</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>fold_more</name><parameter_list>(<parameter><decl><type><name>matchinf_T</name> <modifier>*</modifier></type><name>mip</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr>;</expr_stmt>

<do>do<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>

while <condition>(<expr><operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>, <argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_win</name></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>mip</name><operator>-&gt;</operator><name>mi_fend</name></name> <operator>-</operator> <name>p</name><operator>)</operator></expr></argument>,

<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>,

<argument><expr><name>MAXWLEN</name> <operator>-</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fword</name></name> <operator>+</operator> <name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mip</name><operator>-&gt;</operator><name>mi_fwordlen</name></name> <operator>+=</operator> <name>flen</name></expr>;</expr_stmt>

<return>return <expr><name>flen</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_valid_case</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>wordflags</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>treeflags</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>wordflags</name> <operator>==</operator> <name>WF_ALLCAP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <operator>(</operator><name>WF_ALLCAP</name> <operator>|</operator> <name>WF_KEEPCAP</name><operator>)</operator><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>treeflags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <operator>(</operator><name>wordflags</name> <operator>&amp;</operator> <name>WF_ONECAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>no_spell_checking</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>wp</name><operator>-&gt;</operator><name>w_p_spell</name></name> <operator>||</operator> <operator>*</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E756: Spell checking is not enabled"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_move_to</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>allwords</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>curline</name></decl></parameter>,

<parameter><decl><type><name>hlf_T</name> <modifier>*</modifier></type><name>attrp</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pos_T</name></type> <name>found_pos</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hlf_T</name></type> <name>attr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>has_syntax</name> <init>= <expr><call><name>syntax_present</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>can_spell</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buflen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>capcol</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_one</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wrapped</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CLEAR_POS</name><argument_list>(<argument><expr><operator>&amp;</operator><name>found_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;</operator> <name>len</name> <operator>+</operator> <name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>len</name> <operator>+</operator> <name>MAXWLEN</name> <operator>+</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>capcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>capcol</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>capcol</name> <operator>=</operator> <call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>curline</name> <operator>&amp;&amp;</operator> <name>wp</name> <operator>==</operator> <name>curwin</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_need_cap</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>capcol</name> <operator>=</operator> <name>col</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_cat_line</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>, <argument><expr><name>lnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>skip</name></expr>;</expr_stmt>

<expr_stmt><expr><name>endp</name> <operator>=</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>endp</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name>

<operator>&amp;&amp;</operator> <name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name>

<operator>&amp;&amp;</operator> <operator>!</operator><name>wrapped</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator> <operator>&gt;=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>spell_check</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>capcol</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>!=</operator> <name>HLF_COUNT</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>allwords</name> <operator>||</operator> <name>attr</name> <operator>==</operator> <name>HLF_SPB</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name>

<operator>||</operator> <name>lnum</name> <operator>!=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name>

<operator>||</operator> <operator>(</operator><name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>wrapped</name>

<operator>||</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>curline</name></expr> ?</condition><then> <expr><name>p</name> <operator>-</operator> <name>buf</name> <operator>+</operator> <name>len</name></expr>

</then><else>: <expr><name>p</name> <operator>-</operator> <name>buf</name></expr></else></ternary><operator>)</operator>

<operator>&gt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>has_syntax</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>syn_get_id</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><name>col</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>can_spell</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_spell</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>attr</name> <operator>=</operator> <name>HLF_COUNT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>can_spell</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>can_spell</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>FORWARD</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>found_pos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>attrp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>attrp</name> <operator>=</operator> <name>attr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>curline</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>found_pos</name><operator>.</operator><name>col</name></name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>found_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>capcol</name> <operator>-=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name> <operator>&amp;&amp;</operator> <name><name>found_pos</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>found_pos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>found_len</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>curline</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name>wrapped</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>BACKWARD</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>p_ws</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if> 

<else>else

<block>{<block_content>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>wrapped</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shortmess</name><argument_list>(<argument><expr><name>SHM_SEARCH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>give_warning</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>top_bot_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>capcol</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>p_ws</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if> 

<else>else

<block>{<block_content>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>wrapped</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>shortmess</name><argument_list>(<argument><expr><name>SHM_SEARCH</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>give_warning</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>bot_top_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found_one</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>attr</name> <operator>==</operator> <name>HLF_COUNT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>endp</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><operator>--</operator><name>capcol</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>capcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>spell_cat_line</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"*#/\"\t"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>maxlen</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>maxlen</name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <name>spelload_S</name>

<block>{

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sl_lang</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>sl_slang</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sl_nobreak</name></decl>;</decl_stmt> 

}</block></struct></type> <name>spelload_T</name>;</typedef>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>spell_load_lang</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>fname_enc</name><index>[<expr><literal type="number">85</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>spelload_T</name></type> <name>sl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>sl</name><operator>.</operator><name>sl_lang</name></name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>.</operator><name>sl_slang</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sl</name><operator>.</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname_enc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">5</literal></expr></argument>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><literal type="string">"spell/%s_%s.spl"</literal></expr></argument>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<argument><expr><literal type="string">"spell/%s.%s.spl"</literal></expr></argument>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>sl</name><operator>.</operator><name>sl_lang</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname_enc</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">5</literal></expr></argument>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><literal type="string">"spell/%s_ascii.spl"</literal></expr></argument>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<argument><expr><literal type="string">"spell/%s.ascii.spl"</literal></expr></argument>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>sl</name><operator>.</operator><name>sl_lang</name></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>round</name> <operator>==</operator> <literal type="number">1</literal>

<operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_SPELLFILEMISSING</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>smsg</name><argument_list>(

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: Cannot find word list \"%s_%s.spl\" or \"%s_ascii.spl\""</literal></expr></argument>)</argument_list></call></expr></argument>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: Cannot find word list \"%s.%s.spl\" or \"%s.ascii.spl\""</literal></expr></argument>)</argument_list></call></expr></argument>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>sl</name><operator>.</operator><name>sl_slang</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>fname_enc</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"add.spl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_in_runtimepath</name><argument_list>(<argument><expr><name>fname_enc</name></expr></argument>, <argument><expr><name>DIP_ALL</name></expr></argument>, <argument><expr><name>spell_load_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>spell_enc</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_enc</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">60</literal> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>p_enc</name></expr></argument>, <argument><expr><literal type="string">"iso-8859-15"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p_enc</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"latin1"</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>int_wordlist_spl</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>SPL_FNAME_TMPL</name></expr></argument>,

<argument><expr><name>int_wordlist</name></expr></argument>, <argument><expr><call><name>spell_enc</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>slang_T</name> <modifier>*</modifier></type>

<name>slang_alloc</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>slang_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_rep</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fromto_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>lp</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>slang_free</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>slang_clear</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>slang_clear</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>fromto_T</name> <modifier>*</modifier></type><name>ftp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <ternary><condition><expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_rep</name></name></expr> </then><else>: <expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_repsal</name></name></expr></else></ternary></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ftp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>fromto_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><operator>--</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_from</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ftp</name><operator>-&gt;</operator><name>ft_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_sal</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sofo</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<while>while <condition>(<expr><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>smp</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><operator>--</operator><name><name>gap</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_lead_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_oneof_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>smp</name><operator>-&gt;</operator><name>sm_to_w</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><name>gap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefixcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_prefprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compprog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_comprules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compstartflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compallflags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_comppat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>WC_KEY_OFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_clear_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_map_hash</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>slang_clear_sug</name><argument_list>(<argument><expr><name>lp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compminlen</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_compsylmax</name></name> <operator>=</operator> <name>MAXWLEN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_regions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>slang_clear_sug</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sbyts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sidxs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>close_spellbuf</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugbuf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugloaded</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>sl_sugtime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>spell_load_cb</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>spelload_T</name> <modifier>*</modifier></type><name>slp</name> <init>= <expr><operator>(</operator><name>spelload_T</name> <operator>*</operator><operator>)</operator><name>cookie</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <call><name>spell_load_file</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_lang</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>slp</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_add</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>slp</name><operator>-&gt;</operator><name>sl_slang</name></name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>count_common_word</name><parameter_list>(

<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>hash_T</name></type> <name>hash</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>wordcount_T</name> <modifier>*</modifier></type><name>wc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>hash_hash</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_lookup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>wordcount_T</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_word</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_add_item</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lp</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_word</name></name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>wc</name> <operator>=</operator> <call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>+=</operator> <name>count</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>count</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name><name>wc</name><operator>-&gt;</operator><name>wc_count</name></name> <operator>=</operator> <name>MAXWORDCOUNT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>byte_in_str</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SY_MAXLEN</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>syl_item_S</name>

<block>{

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sy_chars</name><index>[<expr><name>SY_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>sy_len</name></decl>;</decl_stmt>

}</block></struct></type> <name>syl_item_T</name>;</typedef>

<function><type><name>int</name></type>

<name>init_syl_tab</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>syl_item_T</name> <modifier>*</modifier></type><name>syl</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>syl_item_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>s</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;=</operator> <name>SY_MAXLEN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SP_FORMERROR</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>SP_OTHERERROR</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>syl</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>syl_item_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_len</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_chars</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name> <operator>=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>count_syllables</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>skip</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>syl_item_T</name> <modifier>*</modifier></type><name>syl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <name>len</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>syl</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>syl_item_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_syl_items</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name> <operator>&gt;</operator> <name>len</name>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_chars</name></name></expr></argument>, <argument><expr><name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>syl</name><operator>-&gt;</operator><name>sy_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_syllable</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>skip</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>cnt</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>skip</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>cnt</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>did_set_spelllang</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>splp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>region_cp</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>filename</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>region_mask</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>lang</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>spf_name</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>use_region</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dont_use_region</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nobreak</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>lp2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursive</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spl_copy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bufref_T</name></type> <name>bufref</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>, <argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>recursive</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>langp_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_midword</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>spl_copy</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>spl_copy</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>splp</name> <operator>=</operator> <name>spl_copy</name></expr>;</init> <condition><expr><operator>*</operator><name>splp</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>splp</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>region</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_spellang</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="string">"cjk"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>fnamecmp</name><argument_list>(<argument><expr><name>lang</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><call><name>gettail</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>region_cp</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>lang</name><operator>)</operator> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>region</name> <operator>=</operator> <name>region_cp</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>fullpathcmp</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FPC_SAME</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <name><name>lang</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>region</name> <operator>=</operator> <name>lang</name> <operator>+</operator> <name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>-=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lang</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>use_region</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>region</name></expr></argument>, <argument><expr><name>use_region</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dont_use_region</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>use_region</name> <operator>=</operator> <name>region</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_load_file</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>spell_load_lang</name><argument_list>(<argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>bufref</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ret_msg</name> <operator>=</operator> <call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E797: SpellFileMissing autocommand deleted buffer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>filename</name></expr> ?</condition><then> <expr><call><name>fullpathcmp</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FPC_SAME</name></expr>

</then><else>: <expr><call><name>STRICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <name>REGION_ALL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>filename</name> <operator>&amp;&amp;</operator> <name>region</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>find_region</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr></argument>, <argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <name>REGION_ALL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_add</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Warning: region %s not supported"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region_mask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_msg</name> <operator>=</operator> <name>e_outofmem</name></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_slang</name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_region</name> <operator>=</operator> <name>region_mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>use_midword</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nobreak</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>spf</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>round</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>*</operator><name>spf</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>int_wordlist_spl</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spf</name></expr></argument>, <argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>-</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><literal type="string">".spl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>c</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>c</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name><name>lp_slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>fullpathcmp</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FPC_SAME</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<macro><name>FOR_ALL_SPELL_LANGS</name><argument_list>(<argument>slang</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>fullpathcmp</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FPC_SAME</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="string">"internal wordlist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><call><name>gettail</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <call><name>spell_load_file</name><argument_list>(<argument><expr><name>spf_name</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>nobreak</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_nobreak</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>slang</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <name>REGION_ALL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>use_region</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>dont_use_region</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>find_region</name><argument_list>(<argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr></argument>, <argument><expr><name>use_region</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>REGION_ALL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_regions</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>region_mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>region_mask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_slang</name> <operator>=</operator> <name>slang</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_sallang</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_replang</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>lp_region</name> <operator>=</operator> <name>region_mask</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>use_midword</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name> <operator>=</operator> <name>ga</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp2</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>,

<argument><expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_sallang</name></name> <operator>=</operator> <name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_rep</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp2</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name>ga</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_rep</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>,

<argument><expr><name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_replang</name></name> <operator>=</operator> <name><name>lp2</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></else></if_stmt>

</block_content>}</block></for>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>spl_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>recursive</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>redraw_win_later</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret_msg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>clear_midword</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">256</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>use_midword</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>lp</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>sl_midword</name></name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>l</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call>(<modifier>*</modifier><name>mb_ptr2len</name>)<argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal> <operator>&amp;&amp;</operator> <name>l</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>bp</name> <operator>+</operator> <name>n</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>l</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></else></if_stmt></block_content></block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>find_region</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>REGION_ALL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rp</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>region</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>rp</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name><name>region</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>i</name> <operator>/</operator> <literal type="number">2</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>captype</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>firstcap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>allcap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>past_second</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>end</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr> </then><else>: <expr><name>p</name> <operator>&gt;=</operator> <name>end</name></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt></block_content></block></for> 

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>firstcap</name> <operator>=</operator> <name>allcap</name> <operator>=</operator> <call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>( <init>;</init> <condition><expr><ternary><condition><expr><name>end</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr> </then><else>: <expr><name>p</name> <operator>&lt;</operator> <name>end</name></expr></else></ternary></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SPELL_ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>past_second</name> <operator>&amp;&amp;</operator> <name>allcap</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>WF_KEEPCAP</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>allcap</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>allcap</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>WF_KEEPCAP</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>past_second</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>allcap</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>WF_ALLCAP</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>firstcap</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>WF_ONECAP</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>spell_delete_wordlist</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>fname</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>int_wordlist</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_remove</name><argument_list>(<argument><expr><name>int_wordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>int_wordlist_spl</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_remove</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>int_wordlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>spell_free_all</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><operator>-&gt;</operator><name>b_s</name><operator>.</operator><name>b_langp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>first_lang</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <name>first_lang</name></expr>;</expr_stmt>

<expr_stmt><expr><name>first_lang</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>slang_free</name><argument_list>(<argument><expr><name>slang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>spell_delete_wordlist</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>spell_reload</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>init_spell_chartab</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>spell_free_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>wp</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_p_spell</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>did_set_spelllang</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><name>buf_T</name> <modifier>*</modifier></type>

<name>open_spellbuf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>buf_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_spell</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_swf</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_CRYPT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_key</name></name> <operator>=</operator> <name>empty_option</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>ml_open</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_open_file</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>close_spellbuf</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ml_close</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>clear_spell_chartab</name><parameter_list>(<parameter><decl><type><name>spelltab_T</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="char">'z'</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sp</name><operator>-&gt;</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">0x20</literal></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>init_spell_chartab</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>did_set_spelltab</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_spell_chartab</name><argument_list>(<argument><expr><operator>&amp;</operator><name>spelltab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_dbcs</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">255</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>MB_BYTE2LEN</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>enc_utf8</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>f</name> <init>= <expr><call><name>utf_fold</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>u</name> <init>= <expr><call><name>utf_toupper</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>utf_isupper</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>||</operator> <call><name>utf_islower</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>f</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><name>f</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>u</name> <operator>&lt;</operator> <literal type="number">256</literal><operator>)</operator></expr> ?</condition><then> <expr><name>u</name></expr> </then><else>: <expr><name>i</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">128</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>MB_ISUPPER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isu</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>MB_TOLOWER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>MB_ISLOWER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>spelltab</name><operator>.</operator><name>st_upper</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>MB_TOUPPER</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_iswordp</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>,

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><name>c</name></expr>]</index></name></expr>

</then><else>: <expr><operator>(</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <name>l</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>mb_get_class</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><ternary><condition><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr> ?</condition><then> <expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></else></ternary></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_iswordp_nmw</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>mb_get_class</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>spell_mb_isword_class</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cl</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cjk</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>cl</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <name>cl</name> <operator>==</operator> <literal type="number">0x2800</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>cl</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">0x2070</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">0x2080</literal> <operator>&amp;&amp;</operator> <name>cl</name> <operator>!=</operator> <literal type="number">3</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>spell_iswordp_w</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="number">256</literal></expr> ?</condition><then> <expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw</name><index>[<expr><operator>*</operator><name>p</name></expr>]</index></name></expr>

</then><else>: <expr><operator>(</operator><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_spell_ismw_mb</name></name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;</operator> <literal type="number">255</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>enc_utf8</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(<argument><expr><call><name>utf_class</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_dbcs</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>spell_mb_isword_class</name><argument_list>(

<argument><expr><call><name>dbcs_class</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name><operator>)</operator><operator>*</operator><name>s</name> <operator>&gt;&gt;</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>spelltab</name><operator>.</operator><name>st_isw</name><index>[<expr><operator>*</operator><name>s</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_casefold</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>buflen</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>outi</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>str</name> <operator>+</operator> <name>len</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>outi</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>buflen</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>outi</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>outi</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>outi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>outi</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>spelltab</name><operator>.</operator><name>st_fold</name><index>[<expr><name><name>str</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>check_need_cap</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>colnr_T</name></type> <name>col</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>need_cap</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>endcol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_curline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>endcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>getwhitecols</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator><name>col</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get</name><argument_list>(<argument><expr><name>lnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>line_copy</name> <operator>=</operator> <call><name>concat_str</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name>line_copy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>endcol</name> <operator>=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>endcol</name> <operator>=</operator> <name>col</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>endcol</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>endcol</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>line</name> <operator>||</operator> <call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <name><name>regmatch</name><operator>.</operator><name>endp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>line</name> <operator>+</operator> <name>endcol</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>need_cap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>line_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>need_cap</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_spellrepall</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier><name>eap</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name> <init>= <expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>frompat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>addlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>save_ws</name> <init>= <expr><name>p_ws</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>prev_lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>repl_from</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>repl_to</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E752: No previous spell replacement"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>frompat</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>frompat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>frompat</name></expr></argument>, <argument><expr><literal type="string">"\\V\\&lt;%s\\&gt;"</literal></expr></argument>, <argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p_ws</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_nsubs</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sub_nlines</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>do_search</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>frompat</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>, <argument><expr><name>SEARCH_KEEP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>u_save_cursor</name><argument_list>()</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_curline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>addlen</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>,

<argument><expr><name>repl_to</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>addlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>, <argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>line</name> <operator>+</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_replace</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <name>prev_lnum</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>sub_nlines</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_lnum</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>sub_nsubs</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>+=</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>repl_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>p_ws</name> <operator>=</operator> <name>save_ws</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>frompat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sub_nsubs</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E753: Not found: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repl_from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_sub_msg</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>onecap_copy</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>upper</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>upper</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOFOLD</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>wcopy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wcopy</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>wcopy</name> <operator>+</operator> <name>l</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>l</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>allcap_copy</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>wcopy</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name>wcopy</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>enc_latin1like</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <literal type="number">0xdf</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">'S'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>-</operator> <name>wcopy</name> <operator>&gt;=</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>-</operator> <name>wcopy</name> <operator>&gt;=</operator> <name>MAXWLEN</name> <operator>-</operator> <name>MB_MAXBYTES</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>d</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>-</operator> <name>wcopy</name> <operator>&gt;=</operator> <name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>d</name><operator>++</operator> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>d</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>nofold_len</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>fword</name></expr>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>fword</name> <operator>+</operator> <name>flen</name></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt></block_content></block></for>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>i</name></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>word</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>make_case_word</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cword</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_ALLCAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>allcap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>onecap_copy</name><argument_list>(<argument><expr><name>fword</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>cword</name></expr></argument>, <argument><expr><name>fword</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>eval_soundfold</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>sound</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_p_spell</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spl</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>spell_soundfold</name><argument_list>(<argument><expr><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>sound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>sound</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>spell_soundfold</name><parameter_list>(

<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>folded</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>fword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_sofo</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_soundfold_sofo</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>inword</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>folded</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>word</name> <operator>=</operator> <name>inword</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>spell_casefold</name><argument_list>(<argument><expr><name>inword</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>inword</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fword</name></expr></argument>, <argument><expr><name>MAXWLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>word</name> <operator>=</operator> <name>fword</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_soundfold_wsal</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>spell_soundfold_sal</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>spell_soundfold_sofo</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ri</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>has_mbyte</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>prevc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ip</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>inword</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>enc_utf8</name></expr> ?</condition><then> <expr><call><name>utf_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>&lt;</operator> <literal type="number">256</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>ip</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ip</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ip</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ip</name> <operator>==</operator> <name>c</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>ip</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ip</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></for></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>prevc</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ri</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>res</name> <operator>+</operator> <name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prevc</name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>inword</name></expr>;</init> <condition><expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>ri</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>res</name><index>[<expr><name>ri</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>ri</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>ri</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>spell_soundfold_sal</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>inword</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reslen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>z0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>k0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pri</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>p0</name> <init>= <expr><operator>-</operator><literal type="number">333</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c0</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_rem_accents</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>t</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>t</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>smp</name> <operator>=</operator> <operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>reslen</name> <operator>=</operator> <name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_lead</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>c</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_oneof</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pri</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>pri</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>word</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal>

<operator>||</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'$'</literal>

<operator>||</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n0</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c0</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_followup</name></name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n0</name> <operator>&gt;=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <name>p0</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<for>for <control>( <init>;</init> <condition><expr><operator>(</operator><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_lead</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>c0</name></expr>;</condition> <incr><expr><operator>++</operator><name>n0</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>pf</name> <operator>=</operator> <name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name><operator>++</operator> <operator>!=</operator> <name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k0</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_oneof</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>k0</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>,

<argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>==</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&lt;</operator> <name>pri</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&gt;=</operator> <name>pri</name> <operator>&amp;&amp;</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name><name>sm_lead</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>c0</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_to</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><name>pf</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>z</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>res</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>c</name>

<operator>||</operator> <name><name>res</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>*</operator><name>s</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reslen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>res</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>s</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>pf</name></expr></argument>, <argument><expr><literal type="string">"^^"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>z0</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>p0</name> <operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_collapse</name></name> <operator>||</operator> <name>reslen</name> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <name><name>res</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>reslen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>spell_soundfold_wsal</name><parameter_list>(<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>inword</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>salitem_T</name> <modifier>*</modifier></type><name>smp</name> <init>= <expr><operator>(</operator><name>salitem_T</name> <operator>*</operator><operator>)</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_sal</name><operator>.</operator><name>ga_data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>wres</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>ws</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>pf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>reslen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>z0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>k0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pri</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>p0</name> <init>= <expr><operator>-</operator><literal type="number">333</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c0</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>did_white</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>wordlen</name></decl>;</decl_stmt>

<expr_stmt><expr><name>wordlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>inword</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_cptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_rem_accents</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>enc_utf8</name></expr> ?</condition><then> <expr><call><name>utf_class</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr> </then><else>: <expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>did_white</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>did_white</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>did_white</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>wordlen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>reslen</name> <operator>=</operator> <name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init>;</init> <condition><expr><operator>(</operator><operator>(</operator><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>c</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>

<operator>&amp;&amp;</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_oneof_w</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>k</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<expr_stmt><expr><name>pri</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>k</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>pri</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'^'</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><operator>(</operator><name><name>word</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal>

<operator>||</operator> <call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><name>s</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'$'</literal>

<operator>||</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c0</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n0</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_sal_first</name><index>[<expr><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_followup</name></name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>n0</name> <operator>&gt;=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <name>p0</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<for>for <control>( <init>;</init> <condition><expr><operator>(</operator><operator>(</operator><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_lead_w</name><operator>)</operator><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>

<operator>==</operator> <operator>(</operator><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>;</condition> <incr><expr><operator>++</operator><name>n0</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c0</name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_leadlen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k</name></expr>]</index></name> <operator>!=</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>pf</name> <operator>=</operator> <name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>;</condition> <incr><expr><operator>++</operator><name>j</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name><operator>++</operator> <operator>!=</operator> <name><name>ws</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k0</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>pf</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_oneof_w</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>pf</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>pf</name> <operator>!=</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>pf</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pf</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>k0</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISDIGIT</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'$'</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>spell_iswordp_w</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>,

<argument><expr><name>curwin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>k0</name> <operator>==</operator> <name>k</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&lt;</operator> <name>pri</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>&gt;=</operator> <name>pri</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>smp</name><index>[<expr><name>n0</name></expr>]</index></name><operator>.</operator><name><name>sm_lead_w</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator>

<operator>==</operator> <operator>(</operator><name>c0</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ws</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_to_w</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>smp</name><index>[<expr><name>n</name></expr>]</index></name><operator>.</operator><name>sm_rules</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p0</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>vim_strchr</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'&lt;'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p0</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>z</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ws</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>c</name>

<operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <operator>*</operator><name>ws</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>reslen</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>i</name> <operator>+</operator> <name>k0</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt>

<expr_stmt><expr><name>k0</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>ws</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&gt;</operator> <name>k0</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k0</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>k</name></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>wordlen</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>k</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>word</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>k</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><operator>*</operator><name>ws</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>ws</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reslen</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <operator>*</operator><name>ws</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ws</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ws</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name>ws</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><literal type="string">"^^"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name>wordlen</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>z0</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>z0</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>p0</name> <operator>&amp;&amp;</operator> <name>reslen</name> <operator>&lt;</operator> <name>MAXWLEN</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>!=</operator> <name>NUL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_collapse</name></name> <operator>||</operator> <name>reslen</name> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <name><name>wres</name><index>[<expr><name>reslen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>c</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wres</name><index>[<expr><name>reslen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>z</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>l</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name>reslen</name></expr>;</condition> <incr><expr><operator>++</operator><name>n</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>+=</operator> <call><name>mb_char2bytes</name><argument_list>(<argument><expr><name><name>wres</name><index>[<expr><name>n</name></expr>]</index></name></expr></argument>, <argument><expr><name>res</name> <operator>+</operator> <name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>+</operator> <name>MB_MAXBYTES</name> <operator>&gt;</operator> <name>MAXWLEN</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>l</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_spellinfo</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier><name>eap</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><literal type="string">"file: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_info</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>msg_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_KEEPCASE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_COUNT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ICASE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ONECAP</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMPFLAG_ALLCAP</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define> 

<function><type><name>void</name></type>

<name>ex_spelldump</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>dummy</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>get_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name><operator>*</operator><operator>)</operator><literal type="string">"spl"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>spl</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"new"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name><operator>*</operator><operator>)</operator><literal type="string">"spell"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name><operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name><operator>*</operator><operator>)</operator><literal type="string">"spl"</literal></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><name>spl</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>spl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BUFEMPTY</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>spell_dump_compl</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr> ?</condition><then> <expr><name>DUMPFLAG_COUNT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ml_delete</name><argument_list>(<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>redraw_later</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>spell_dump_compl</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>ic</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>dumpflags_arg</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>langp_T</name> <modifier>*</modifier></type><name>lp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>word</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>region_names</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>do_region</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lpi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dumpflags</name> <init>= <expr><name>dumpflags_arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>patlen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ic</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ICASE</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>captype</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <name>WF_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ONECAP</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>n</name> <operator>==</operator> <name>WF_ALLCAP</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <call><name>mb_ptr2len</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_ALLCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name><operator>-&gt;</operator><name>sl_regions</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>region_names</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>region_names</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>region_names</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>do_region</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> 

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>do_region</name> <operator>&amp;&amp;</operator> <name>region_names</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"/regions=%s"</literal></expr></argument>, <argument><expr><name>region_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name><operator>++</operator></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>do_region</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>lpi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>lpi</name> <operator>&lt;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>lpi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lp</name> <operator>=</operator> <call><name>LANGP_ENTRY</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_langp</name></name></expr></argument>, <argument><expr><name>lpi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>slang</name> <operator>=</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_slang</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<continue>continue;</continue></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"#file: %s"</literal></expr></argument>, <argument><expr><name><name>slang</name><operator>-&gt;</operator><name>sl_fname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name><operator>++</operator></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>patlen</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>patlen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>round</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>round</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>;</condition> <incr><expr><operator>++</operator><name>round</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>round</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>dumpflags</name> <operator>&amp;=</operator> <operator>~</operator><name>DUMPFLAG_KEEPCASE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fbyts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_fidxs</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>dumpflags</name> <operator>|=</operator> <name>DUMPFLAG_KEEPCASE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kbyts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_kidxs</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>pat</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>ins_compl_interrupted</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name><name>byts</name><index>[<expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ins_compl_check_keys</name><argument_list>(<argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>round</name> <operator>==</operator> <literal type="number">2</literal> <operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_KEEPCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_NEEDCOMP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>do_region</name>

<operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator>

<operator>&amp;</operator> <name><name>lp</name><operator>-&gt;</operator><name>lp_region</name></name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_region</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator><name>WF_REGION</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><name>flags</name> <operator>&gt;&gt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>,

<argument><expr><name>dumpflags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <call><name>dump_prefixes</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>,

<argument><expr><name>dumpflags</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&lt;=</operator> <name>patlen</name>

<operator>&amp;&amp;</operator> <call><name>MB_STRNICMP</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dump_word</name><parameter_list>(

<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dumpflags</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>wordflags</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>keepcap</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tw</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>cword</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>badword</name><index>[<expr><name>MAXWLEN</name> <operator>+</operator> <literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>wordflags</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ONECAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ONECAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ALLCAP</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WF_ALLCAP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_KEEPCASE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_CAPMASK</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>make_case_word</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>cword</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cword</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>word</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_KEEPCASE</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><call><name>captype</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>WF_KEEPCAP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>WF_FIXCAP</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>keepcap</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>tw</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>WF_BANNED</name> <operator>|</operator> <name>WF_RARE</name> <operator>|</operator> <name>WF_REGION</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>keepcap</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>keepcap</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_BANNED</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_RARE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>badword</name></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>WF_REGION</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">7</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">0x10000</literal> <operator>&lt;&lt;</operator> <name>i</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>badword</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>badword</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>badword</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_COUNT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>hash_find</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slang</name><operator>-&gt;</operator><name>sl_wordcount</name></name></expr></argument>, <argument><expr><name>tw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s\t%d"</literal></expr></argument>,

<argument><expr><name>tw</name></expr></argument>, <argument><expr><call><name>HI2WC</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>wc_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ml_append</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>dumpflags</name> <operator>&amp;</operator> <name>DUMPFLAG_ICASE</name><operator>)</operator></expr>

?</condition><then> <expr><call><name>MB_STRNICMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>

</then><else>: <expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>pat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>ins_compl_add_infercase</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>p_ic</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>*</operator><name>dir</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <name>FORWARD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>linenr_T</name></type>

<name>dump_prefixes</name><parameter_list>(

<parameter><decl><type><name>slang_T</name> <modifier>*</modifier></type><name>slang</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>word</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dumpflags</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, 

<parameter><decl><type><name>linenr_T</name></type> <name>startlnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>idx_T</name></type> <name><name>arridx</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>curi</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>prefix</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>word_up</name><index>[<expr><name>MAXWLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_word_up</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>byts</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>idx_T</name> <modifier>*</modifier></type><name>idxs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name> <init>= <expr><name>startlnum</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>PTR2CHAR</name><argument_list>(<argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SPELL_TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>c</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>onecap_copy</name><argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>has_word_up</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>byts</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pbyts</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idxs</name> <operator>=</operator> <name><name>slang</name><operator>-&gt;</operator><name>sl_pidxs</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>byts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curi</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>depth</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>&gt;</operator> <name>len</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>depth</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>+=</operator> <name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>byts</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>byts</name><index>[<expr><name>n</name> <operator>+</operator> <name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>+=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <name>depth</name></expr></argument>, <argument><expr><name>word</name></expr></argument>, <argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dumpflags</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>flags</name> <operator>|</operator> <name>WF_RARE</name><operator>)</operator></expr>

</then><else>: <expr><name>flags</name></expr></else></ternary></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_word_up</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>valid_word_prefix</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>, <argument><expr><name>slang</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>prefix</name> <operator>+</operator> <name>depth</name></expr></argument>, <argument><expr><name>word_up</name></expr></argument>,

<argument><expr><name>MAXWLEN</name> <operator>-</operator> <name>depth</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dump_word</name><argument_list>(<argument><expr><name>slang</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>dumpflags</name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>&amp;</operator> <name>WF_RAREPFX</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>flags</name> <operator>|</operator> <name>WF_RARE</name><operator>)</operator></expr>

</then><else>: <expr><name>flags</name></expr></else></ternary></expr></argument>, <argument><expr><name>lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>depth</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arridx</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <name><name>idxs</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curi</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>lnum</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>spell_to_word_end</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>spell_word_start</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>startcol</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>no_spell_checking</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>startcol</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_curline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>line</name> <operator>+</operator> <name>startcol</name></expr>;</init> <condition><expr><name>p</name> <operator>&gt;</operator> <name>line</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>spell_iswordp_nmw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>line</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>line</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MB_PTR_BACK</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>spell_iswordp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>col</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>spell_expand_need_cap</name></decl>;</decl_stmt>

<function><type><name>void</name></type>

<name>spell_expand_check_cap</name><parameter_list>(<parameter><decl><type><name>colnr_T</name></type> <name>col</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>spell_expand_need_cap</name> <operator>=</operator> <call><name>check_need_cap</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>expand_spelling</name><parameter_list>(

<parameter><decl><type><name>linenr_T</name> <name>lnum</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier><modifier>*</modifier></type><name>matchp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>spell_suggest_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>, <argument><expr><name>spell_expand_need_cap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>matchp</name> <operator>=</operator> <name><name>ga</name><operator>.</operator><name>ga_data</name></name></expr>;</expr_stmt>

<return>return <expr><name><name>ga</name><operator>.</operator><name>ga_len</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>valid_spellang</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>valid_name</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">".-_,@"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>valid_spellfile</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>val</name></expr>;</init> <condition><expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>s</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vim_isfilec</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>did_set_spell_option</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>is_spellfile</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errmsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_spellfile</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>l</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>l</name> <operator>&lt;</operator> <literal type="number">4</literal>

<operator>||</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_s</name><operator>-&gt;</operator><name>b_p_spf</name></name> <operator>+</operator> <name>l</name> <operator>-</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">".add"</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <name>e_invarg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errmsg</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>wp</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name> <operator>==</operator> <name>curbuf</name> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_p_spell</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>errmsg</name> <operator>=</operator> <call><name>did_set_spelllang</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>errmsg</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>compile_cap_prog</name><parameter_list>(<parameter><decl><type><name>synblock_T</name> <modifier>*</modifier></type><name>synblock</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>rp</name> <init>= <expr><name><name>synblock</name><operator>-&gt;</operator><name>b_cap_prog</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>re</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>synblock</name><operator>-&gt;</operator><name>b_p_spc</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name><name>synblock</name><operator>-&gt;</operator><name>b_p_spc</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>synblock</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>re</name> <operator>=</operator> <call><name>concat_str</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"^"</literal></expr></argument>, <argument><expr><name><name>synblock</name><operator>-&gt;</operator><name>b_p_spc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>re</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>synblock</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>RE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>re</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>synblock</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>synblock</name><operator>-&gt;</operator><name>b_cap_prog</name></name> <operator>=</operator> <name>rp</name></expr>;</expr_stmt> 

<return>return <expr><name>e_invarg</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name>rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
