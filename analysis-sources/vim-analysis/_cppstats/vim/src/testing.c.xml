<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\testing.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>prepare_assert_error</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sname</name> <init>= <expr><call><name>estack_sfile</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>sname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>SOURCING_LNUM</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>SOURCING_LNUM</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"line %ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>SOURCING_LNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>SOURCING_LNUM</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>sname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ga_concat_esc</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>clen</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>clen</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>clen</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content> <switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>BS</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>ESC</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\e"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>FF</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>NL</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>TAB</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CAR</name></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'\\'</literal></expr>:</case> <expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="char">' '</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>NUMBUFLEN</name></expr></argument>, <argument><expr><literal type="string">"\\x%02x"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_append</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ga_concat_shorten_esc</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>clen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>same_len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>same_len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>mb_ptr2char_adv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>clen</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>c</name> <operator>==</operator> <call><name>mb_ptr2char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>same_len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>clen</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>same_len</name> <operator>&gt;</operator> <literal type="number">20</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"\\["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat_esc</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" occurs "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>NUMBUFLEN</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>same_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" times]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>s</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat_esc</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>fill_assert_error</name><parameter_list>(

<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>opt_msg_tv</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>exp_str</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>exp_tv</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>got_tv</name></decl></parameter>,

<parameter><decl><type><name>assert_type_T</name></type> <name>atype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>numbuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>opt_msg_tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><call><name>echo_string</name><argument_list>(<argument><expr><name>opt_msg_tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>atype</name> <operator>==</operator> <name>ASSERT_MATCH</name> <operator>||</operator> <name>atype</name> <operator>==</operator> <name>ASSERT_NOTMATCH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Pattern "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>atype</name> <operator>==</operator> <name>ASSERT_NOTEQUAL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Expected not equal to "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"Expected "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>exp_str</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat_shorten_esc</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><call><name>tv2string</name><argument_list>(<argument><expr><name>exp_tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat_shorten_esc</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>exp_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>atype</name> <operator>!=</operator> <name>ASSERT_NOTEQUAL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>atype</name> <operator>==</operator> <name>ASSERT_MATCH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" does not match "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>atype</name> <operator>==</operator> <name>ASSERT_NOTMATCH</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" does match "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" but got "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>ga_concat_shorten_esc</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><call><name>tv2string</name><argument_list>(<argument><expr><name>got_tv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_equal_common</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>assert_type_T</name></type> <name>atype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>tv_equal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call>

<operator>!=</operator> <operator>(</operator><name>atype</name> <operator>==</operator> <name>ASSERT_EQUAL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_match_common</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>assert_type_T</name></type> <name>atype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf1</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf2</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name> <init>= <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>text</name> <init>= <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>text</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>pattern_match</name><argument_list>(<argument><expr><name>pat</name></expr></argument>, <argument><expr><name>text</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>atype</name> <operator>==</operator> <name>ASSERT_MATCH</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><name>atype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_bool</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isTrue</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_BOOL</name>

<operator>&amp;&amp;</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>==</operator> <operator>(</operator><ternary><condition><expr><name>isTrue</name></expr> ?</condition><then> <expr><name>VVAL_TRUE</name></expr> </then><else>: <expr><name>VVAL_FALSE</name></expr></else></ternary><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_NUMBER</name>

<operator>||</operator> <operator>(</operator><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <name>isTrue</name>

<operator>||</operator> <name>error</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><name>isTrue</name></expr> ?</condition><then> <expr><literal type="string">"True"</literal></expr> </then><else>: <expr><literal type="string">"False"</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>ASSERT_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>assert_append_cmd_or_arg</name><parameter_list>(<parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>gap</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>numbuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name> <operator>&amp;&amp;</operator> <name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><call><name>echo_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><name>gap</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_beeps</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>called_vim_beep</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>suppress_errthrow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>called_vim_beep</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"command did not beep: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>suppress_errthrow</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>emsg_on_display</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_beeps</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_beeps</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_equal</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_equal_common</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>ASSERT_EQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_equalfile</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf1</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf2</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname1</name> <init>= <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname2</name> <init>= <expr><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fname1</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>fname2</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>IObuff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>fd1</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname1</name></expr></argument>, <argument><expr><name>READBIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e_notread</name></expr></argument>, <argument><expr><name>fname1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fd2</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname2</name></expr></argument>, <argument><expr><name>READBIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>e_notread</name></expr></argument>, <argument><expr><name>fname2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>c1</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c2</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>c1</name> <operator>==</operator> <name>EOF</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>c2</name> <operator>!=</operator> <name>EOF</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"first file is shorter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c2</name> <operator>==</operator> <name>EOF</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"second file is shorter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>c1</name> <operator>!=</operator> <name>c2</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>,

<argument><expr><literal type="string">"difference at byte %ld"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>IObuff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_equalfile</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_equalfile</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_notequal</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_equal_common</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>ASSERT_NOTEQUAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_exception</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>get_vim_var_str</name><argument_list>(<argument><expr><name>VV_EXCEPTION</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"v:exception is not set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>error</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>get_vim_var_str</name><argument_list>(<argument><expr><name>VV_EXCEPTION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>error</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,

<argument><expr><call><name>get_vim_var_tv</name><argument_list>(<argument><expr><name>VV_EXCEPTION</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASSERT_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_fails</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>save_trylevel</name> <init>= <expr><name>trylevel</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>called_emsg_before</name> <init>= <expr><name>called_emsg</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>trylevel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>suppress_errthrow</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>called_emsg</name> <operator>==</operator> <name>called_emsg_before</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"command did not fail: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_append_cmd_or_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>tv_get_string_buf_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <call><name>strstr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>get_vim_var_str</name><argument_list>(<argument><expr><name>VV_ERRMSG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,

<argument><expr><call><name>get_vim_var_tv</name><argument_list>(<argument><expr><name>VV_ERRMSG</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ASSERT_OTHER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">": "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_append_cmd_or_arg</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>trylevel</name> <operator>=</operator> <name>save_trylevel</name></expr>;</expr_stmt>

<expr_stmt><expr><name>suppress_errthrow</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>emsg_silent</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>emsg_on_display</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_vim_var_string</name><argument_list>(<argument><expr><name>VV_ERRMSG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_false</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_bool</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>assert_inrange</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>msg</name><index>[<expr><literal type="number">200</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>numbuf</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_FLOAT</name>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_FLOAT</name>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>float_T</name></type> <name>flower</name> <init>= <expr><call><name>tv_get_float</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float_T</name></type> <name>fupper</name> <init>= <expr><call><name>tv_get_float</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>float_T</name></type> <name>factual</name> <init>= <expr><call><name>tv_get_float</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>factual</name> <argument_list type="generic">&lt; <argument><expr><name>flower</name> <operator>||</operator> <name>factual</name></expr></argument> &gt;</argument_list></name> <name>fupper</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><call><name>tv2string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><literal type="string">"Expected range %g - %g, but got %g"</literal></expr></argument>,

<argument><expr><name>flower</name></expr></argument>, <argument><expr><name>fupper</name></expr></argument>, <argument><expr><name>factual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>lower</name> <init>= <expr><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>upper</name> <init>= <expr><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>actual</name> <init>= <expr><call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>actual</name> <argument_list type="generic">&lt; <argument><expr><name>lower</name> <operator>||</operator> <name>actual</name></expr></argument> &gt;</argument_list></name> <name>upper</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><call><name>tv2string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><name>numbuf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="number">200</literal></expr></argument>, <argument><expr><literal type="string">"Expected range %ld - %ld, but got %ld"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>lower</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>upper</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_inrange</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_inrange</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_match</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_match_common</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>ASSERT_MATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_notmatch</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_match_common</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>ASSERT_NOTMATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_report</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name></type> <name>ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>prepare_assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_concat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>, <argument><expr><call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assert_error</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_assert_true</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>assert_bool</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_alloc_fail</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_NUMBER</name>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>&lt;=</operator> <literal type="number">0</literal>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_NUMBER</name>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>&lt;</operator> <literal type="number">0</literal>

<operator>||</operator> <name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>alloc_fail_id</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>alloc_fail_id</name> <operator>&gt;=</operator> <name>aid_last</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>alloc_fail_countdown</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>alloc_fail_repeat</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>did_outofmem_msg</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_autochdir</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_AUTOCHDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>test_autochdir</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_feedinput</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_INPUT_BUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>tv_get_string_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VIMDLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>gui</name><operator>.</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>trash_input_buf</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_to_input_buf_csi</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_getvalue</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"need_fileinfo"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>need_fileinfo</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_option_not_set</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>reset_option_was_set</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_override</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>save_starting</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_STRING</name>

<operator>||</operator> <operator>(</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name><operator>)</operator> <operator>!=</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"redraw"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disable_redraw_for_testing</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"redraw_flag"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ignore_redraw_flag_for_testing</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"char_avail"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>disable_char_avail_for_testing</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"starting"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>save_starting</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>save_starting</name> <operator>=</operator> <name>starting</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>starting</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>starting</name> <operator>=</operator> <name>save_starting</name></expr>;</expr_stmt>

<expr_stmt><expr><name>save_starting</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"nfa_fail"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>nfa_fail_for_testing</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"no_query_mouse"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>no_query_mouse_for_testing</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"no_wait_return"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>no_wait_return</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ALL"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>disable_char_avail_for_testing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>disable_redraw_for_testing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ignore_redraw_flag_for_testing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nfa_fail_for_testing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>no_query_mouse_for_testing</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>save_starting</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>starting</name> <operator>=</operator> <name>save_starting</name></expr>;</expr_stmt>

<expr_stmt><expr><name>save_starting</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_refcount</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case>

<case>case <expr><name>VAR_VOID</name></expr>:</case>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case>

<case>case <expr><name>VAR_BOOL</name></expr>:</case>

<case>case <expr><name>VAR_FLOAT</name></expr>:</case>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>

<case>case <expr><name>VAR_STRING</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>VAR_JOB</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_job</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_job</name><operator>-&gt;</operator><name>jv_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>VAR_CHANNEL</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_channel</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_channel</name><operator>-&gt;</operator><name>ch_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>VAR_FUNC</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>find_func</name><argument_list>(<argument><expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>fp</name><operator>-&gt;</operator><name>uf_refcount</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_partial</name><operator>-&gt;</operator><name>pt_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VAR_BLOB</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_blob</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_blob</name><operator>-&gt;</operator><name>bv_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VAR_LIST</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_list</name><operator>-&gt;</operator><name>lv_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>VAR_DICT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>vval</name><operator>.</operator><name>v_dict</name><operator>-&gt;</operator><name>dv_refcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>retval</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_garbagecollect_now</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>garbage_collect</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_garbagecollect_soon</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>may_garbage_collect</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_ignore_error</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>ignore_error_for_testing</name><argument_list>(<argument><expr><call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_null_blob</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BLOB</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_blob</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>f_test_null_channel</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_CHANNEL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_channel</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>f_test_null_dict</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rettv_dict_set</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>f_test_null_job</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_JOB</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_job</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>f_test_null_list</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>rettv_list_set</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_null_function</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_FUNC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_null_partial</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_PARTIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_null_string</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_unknown</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_void</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_VOID</name></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>void</name></type>

<name>f_test_scrollbar</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>which</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dragging</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scrollbar_T</name> <modifier>*</modifier></type><name>sb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>!=</operator> <name>VAR_STRING</name>

<operator>||</operator> <operator>(</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name><operator>)</operator> <operator>!=</operator> <name>VAR_NUMBER</name>

<operator>||</operator> <operator>(</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>v_type</name><operator>)</operator> <operator>!=</operator> <name>VAR_NUMBER</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>which</name> <operator>=</operator> <call><name>tv_get_string</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dragging</name> <operator>=</operator> <call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>which</name></expr></argument>, <argument><expr><literal type="string">"left"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sb</name> <operator>=</operator> <operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_scrollbars</name><index>[<expr><name>SBAR_LEFT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>which</name></expr></argument>, <argument><expr><literal type="string">"right"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sb</name> <operator>=</operator> <operator>&amp;</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_scrollbars</name><index>[<expr><name>SBAR_RIGHT</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>which</name></expr></argument>, <argument><expr><literal type="string">"hor"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sb</name> <operator>=</operator> <operator>&amp;</operator><name><name>gui</name><operator>.</operator><name>bottom_sbar</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sb</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>which</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>gui_drag_scrollbar</name><argument_list>(<argument><expr><name>sb</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>dragging</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_ON_FLY_SCROLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>exec_normal</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>f_test_setmouse</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>mouse_row</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mouse_col</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_test_settime</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>time_for_testing</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><call><name>tv_get_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
