<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\if_mzsch.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"if_mzsch.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MZSCHEME</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>int</name></type> <name>Scheme_Object</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Closed_Prim</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Env</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Hash_Table</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Type</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Thread</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Closed_Prim</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>mzshort</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>Scheme_Prim</name>;</typedef>

<typedef>typedef <type><name>int</name></type> <name>HINSTANCE</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">500</literal> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MSWIN</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>defined</name><argument_list>(<argument><expr><name>USE_THREAD_LOCAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_WIN64</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">603</literal><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_TLS_SPACE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">400</literal> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">500</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_USE_FUTURES</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>MZ_USE_PLACES</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRAMPOLINED_MZVIM_STARTUP</name></cpp:macro></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCHEME_VIMBUFFERP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SAME_TYPE(SCHEME_TYPE(obj), mz_buffer_type)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SCHEME_VIMWINDOWP</name><parameter_list>(<parameter><type><name>obj</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>SAME_TYPE(SCHEME_TYPE(obj), mz_window_type)</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>Scheme_Object</name></type> <name>so</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

}</block></struct></type> <name>vim_mz_buffer</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_BUFFER_VALUE</name></cpp:macro> <cpp:value>((buf_T *)(-1))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>Scheme_Object</name></type> <name>so</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

}</block></struct></type> <name>vim_mz_window</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_WINDOW_VALUE</name></cpp:macro> <cpp:value>((win_T *)(-1))</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type><name>prim</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mina</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>maxa</name></decl>;</decl_stmt>

}</block></struct></type> <name>Vim_Prim</name>;</typedef>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>port</name></decl>;</decl_stmt>

}</block></struct></type> <name>Port_Info</name>;</typedef>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>sandbox_file_guard</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>sandbox_network_guard</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sandbox_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>buffer_new</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>get_buffer_by_num</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>vim_mz_buffer</name> <modifier>*</modifier></type><name>get_vim_curr_buffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>window_new</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>vim_mz_window</name> <modifier>*</modifier></type><name>get_vim_curr_window</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>vim_error_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>do_mzscheme_command</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>startup_mzscheme</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>string_to_line</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">501</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_LEN_TYPE</name></cpp:macro> <cpp:value>intptr_t</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OUTPUT_LEN_TYPE</name></cpp:macro> <cpp:value>long</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_output</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>OUTPUT_LEN_TYPE</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_printf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>_apply_thunk_catch_exceptions</name><parameter_list>(

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>extract_exn_message</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>do_eval</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noargc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>noargv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>do_load</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>noargc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>noargv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>register_vim_exn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>vim_mz_buffer</name> <modifier>*</modifier></type><name>get_buffer_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>vim_mz_window</name> <modifier>*</modifier></type><name>get_window_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>line_in_range</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_line_range</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mz_fix_cursor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>eval_with_exn_handling</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>make_modules</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_exn_catching_apply</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mzscheme_env_main</name><parameter_list>(<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mzscheme_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>vim_to_mzscheme</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vim_value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>vim_to_mzscheme_impl</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vim_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mzscheme_to_vim</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mzscheme_to_vim_impl</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>vim_funcref</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>buffer_size_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>obj</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>gcBYTES_TO_WORDS</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>buffer_mark_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>buffer_size_proc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>buffer_fixup_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>buffer_size_proc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>window_size_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>obj</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>gcBYTES_TO_WORDS</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>window_mark_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>window_size_proc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>window_fixup_proc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>window_size_proc</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_REF</name><parameter_list>(<parameter><type><name>win</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>*(vim_mz_window **)((win)-&gt;w_mzscheme_ref)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFER_REF</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>*(vim_mz_buffer **)((buf)-&gt;b_mzscheme_ref)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOW_REF</name><parameter_list>(<parameter><type><name>win</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vim_mz_window *)((win)-&gt;w_mzscheme_ref)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUFFER_REF</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(vim_mz_buffer *)((buf)-&gt;b_mzscheme_ref)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>dll_scheme_eof</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>dll_scheme_false</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>dll_scheme_void</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>dll_scheme_null</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>dll_scheme_true</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Thread</name> <modifier>*</modifier><modifier>*</modifier></type><name>dll_scheme_current_thread_ptr</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>dll_scheme_console_printf_ptr</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>dll_scheme_console_output_ptr</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>OUTPUT_LEN_TYPE</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><modifier>*</modifier><name>dll_scheme_notify_multithread_ptr</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>on</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_GC_malloc</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size_in_bytes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_GC_malloc_atomic</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size_in_bytes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Env</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_basic_env</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_check_threads</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_register_static</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>size</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_set_stack_base</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>no_auto_statics</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_add_global</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>val</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_add_global_symbol</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_apply</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>rator</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_rands</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>rands</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_builtin_value</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_byte_string_to_char_string</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_path</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_close_input_port</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_count_lines</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">360</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_current_continuation_marks</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_current_continuation_marks</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>prompt_tag</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_display</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_display_to_string</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>OUTPUT_LEN_TYPE</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> (<modifier>*</modifier><name>dll_scheme_eq</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj1</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj2</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_do_eval</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>_num_rands</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>rands</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_dont_gc_ptr</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_eval</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_eval_string</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_eval_string_all</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>all</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_finish_primitive_module</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_format</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>rlen</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_format_utf8</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>, <parameter><decl><type><name>OUTPUT_LEN_TYPE</name> <modifier>*</modifier></type><name>rlen</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_get_param</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Config</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_gc_ptr_ok</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_get_sized_string_output</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_get_sized_byte_string_output</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type></decl></parameter>,

<parameter><decl><type><name>OUTPUT_LEN_TYPE</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_intern_symbol</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_lookup_global</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>symbol</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_closed_prim_w_arity</name>)

<parameter_list>(<parameter><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type><name>prim</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>mzshort</name></type> <name>mina</name></decl></parameter>,

<parameter><decl><type><name>mzshort</name></type> <name>maxa</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_integer_value</name>)<parameter_list>(<parameter><decl><type><name>long</name></type> <name>i</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_pair</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>car</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>cdr</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_prim_w_arity</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Prim</name> <modifier>*</modifier></type><name>prim</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>mzshort</name></type> <name>mina</name></decl></parameter>, <parameter><decl><type><name>mzshort</name></type> <name>maxa</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_string</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_string_output_port</name>)<parameter_list>()</parameter_list>;</function_decl>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_byte_string</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_byte_string_output_port</name>)<parameter_list>()</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_struct_instance</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>stype</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_struct_names</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>field_names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count_out</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_struct_type</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>inspector</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num_fields</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>num_uninit_fields</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>uninit_val</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>properties</name></decl></parameter>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>guard</name></decl></parameter>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_struct_values</name>)<parameter_list>(

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>struct_type</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>names</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Type</name></type> (<modifier>*</modifier><name>dll_scheme_make_type</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_vector</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>fill</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_malloc_fail_ok</name>)<parameter_list>(<parameter><function_decl><type><name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>f</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>size_t</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_open_input_file</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>who</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Env</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_primitive_module</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>for_env</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> (<modifier>*</modifier><name>dll_scheme_proper_list_length</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_raise</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>exn</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_read</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>port</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_signal_error</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_wrong_type</name>)<parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>which</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_set_param</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Config</name> <modifier>*</modifier></type><name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>o</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Config</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_current_config</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_char_string_to_byte_string</name>)

<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_char_string_to_path</name>)

<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_set_collects_path</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>Scheme_Hash_Table</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_hash_table</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_hash_set</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_hash_get</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>table</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_double</name>)<parameter_list>(<parameter><decl><type><name>double</name></type> <name>d</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_make_sized_byte_string</name>)<parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>chars</name></decl></parameter>,

<parameter><decl><type><name>long</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copy</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_namespace_require</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>req</name></decl></parameter>)</parameter_list>;</function_decl>

<expr_stmt><expr><specifier>static</specifier> <name>Scheme_Object</name> <operator>*</operator><call>(<modifier>*</modifier><name>dll_scheme_dynamic_wind</name>)<argument_list>(<argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator><name>pre</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Scheme_Object</name> <operator>*</operator><operator>(</operator><operator>*</operator> <specifier>volatile</specifier> <name>act</name><operator>)</operator><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator></expr></argument>, <argument><expr><call><call><name>void</name> <argument_list>(<argument><expr><operator>*</operator> <specifier>volatile</specifier> <name>post</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Scheme_Object</name> <operator>*</operator><call>(<modifier>*</modifier><name>jmp_handler</name>)<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>void</name> <operator>*</operator> <specifier>volatile</specifier> <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_GC_malloc_one_tagged</name>)<parameter_list>(<parameter><decl><type><name>size_t</name></type> <name>size_in_bytes</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_GC_register_traversers</name>)<parameter_list>(<parameter><decl><type><name>short</name></type> <name>tag</name></decl></parameter>, <parameter><decl><type><name>Size_Proc</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>Mark_Proc</name></type> <name>mark</name></decl></parameter>, <parameter><decl><type><name>Fixup_Proc</name></type> <name>fixup</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_constant_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_atomic</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">400</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_init_collection_paths</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>global_env</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>extra_dirs</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier><modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_malloc_immobile_box</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_free_immobile_box</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">500</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>int</name></type> (<modifier>*</modifier><name>dll_scheme_main_setup</name>)<parameter_list>(<parameter><decl><type><name>int</name></type> <name>no_auto_statics</name></decl></parameter>, <parameter><decl><type><name>Scheme_Env_Main</name></type> <name>_main</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">603</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_register_tls_space</name>)<parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tls_space</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>_tls_index</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_EXTERNALLY_VIA_PROC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>Thread_Local_Variables</name> <modifier>*</modifier></type>(<modifier>*</modifier><name>dll_scheme_external_get_thread_local_variables</name>)<parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">600</literal></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_embedded_load</name>)<parameter_list>(<parameter><decl><type><name>intptr_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>predefined</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_register_embedded_load</name>)<parameter_list>(<parameter><decl><type><name>intptr_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> (<modifier>*</modifier><name>dll_scheme_set_config_path</name>)<parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>p</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_eof</name></cpp:macro> <cpp:value>dll_scheme_eof</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_false</name></cpp:macro> <cpp:value>dll_scheme_false</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_void</name></cpp:macro> <cpp:value>dll_scheme_void</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_null</name></cpp:macro> <cpp:value>dll_scheme_null</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_true</name></cpp:macro> <cpp:value>dll_scheme_true</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_THREAD_LOCAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LINK_EXTENSIONS_BY_TABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_current_thread</name></cpp:macro> <cpp:value>(*dll_scheme_current_thread_ptr)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_console_printf</name></cpp:macro> <cpp:value>(*dll_scheme_console_printf_ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_console_output</name></cpp:macro> <cpp:value>(*dll_scheme_console_output_ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_notify_multithread</name></cpp:macro> <cpp:value>(*dll_scheme_notify_multithread_ptr)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_malloc</name></cpp:macro> <cpp:value>dll_GC_malloc</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_malloc_atomic</name></cpp:macro> <cpp:value>dll_GC_malloc_atomic</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_add_global</name></cpp:macro> <cpp:value>dll_scheme_add_global</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_add_global_symbol</name></cpp:macro> <cpp:value>dll_scheme_add_global_symbol</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_apply</name></cpp:macro> <cpp:value>dll_scheme_apply</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_basic_env</name></cpp:macro> <cpp:value>dll_scheme_basic_env</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_builtin_value</name></cpp:macro> <cpp:value>dll_scheme_builtin_value</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_byte_string_to_char_string</name></cpp:macro> <cpp:value>dll_scheme_byte_string_to_char_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_path</name></cpp:macro> <cpp:value>dll_scheme_make_path</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_check_threads</name></cpp:macro> <cpp:value>dll_scheme_check_threads</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_close_input_port</name></cpp:macro> <cpp:value>dll_scheme_close_input_port</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_count_lines</name></cpp:macro> <cpp:value>dll_scheme_count_lines</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_current_continuation_marks</name></cpp:macro> <cpp:value>dll_scheme_current_continuation_marks</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_display</name></cpp:macro> <cpp:value>dll_scheme_display</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_display_to_string</name></cpp:macro> <cpp:value>dll_scheme_display_to_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_do_eval</name></cpp:macro> <cpp:value>dll_scheme_do_eval</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_dont_gc_ptr</name></cpp:macro> <cpp:value>dll_scheme_dont_gc_ptr</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_eq</name></cpp:macro> <cpp:value>dll_scheme_eq</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_eval</name></cpp:macro> <cpp:value>dll_scheme_eval</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_eval_string</name></cpp:macro> <cpp:value>dll_scheme_eval_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_eval_string_all</name></cpp:macro> <cpp:value>dll_scheme_eval_string_all</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_finish_primitive_module</name></cpp:macro> <cpp:value>dll_scheme_finish_primitive_module</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_format</name></cpp:macro> <cpp:value>dll_scheme_format</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_format_utf8</name></cpp:macro> <cpp:value>dll_scheme_format_utf8</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_gc_ptr_ok</name></cpp:macro> <cpp:value>dll_scheme_gc_ptr_ok</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_get_sized_byte_string_output</name></cpp:macro> <cpp:value>dll_scheme_get_sized_string_output</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_get_sized_byte_string_output</name></cpp:macro> <cpp:value>dll_scheme_get_sized_byte_string_output</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_get_param</name></cpp:macro> <cpp:value>dll_scheme_get_param</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_intern_symbol</name></cpp:macro> <cpp:value>dll_scheme_intern_symbol</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_lookup_global</name></cpp:macro> <cpp:value>dll_scheme_lookup_global</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_closed_prim_w_arity</name></cpp:macro> <cpp:value>dll_scheme_make_closed_prim_w_arity</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_integer_value</name></cpp:macro> <cpp:value>dll_scheme_make_integer_value</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_pair</name></cpp:macro> <cpp:value>dll_scheme_make_pair</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_prim_w_arity</name></cpp:macro> <cpp:value>dll_scheme_make_prim_w_arity</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_byte_string</name></cpp:macro> <cpp:value>dll_scheme_make_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_byte_string_output_port</name></cpp:macro> <cpp:value>dll_scheme_make_string_output_port</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_byte_string</name></cpp:macro> <cpp:value>dll_scheme_make_byte_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_byte_string_output_port</name></cpp:macro> <cpp:value>dll_scheme_make_byte_string_output_port</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_struct_instance</name></cpp:macro> <cpp:value>dll_scheme_make_struct_instance</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_struct_names</name></cpp:macro> <cpp:value>dll_scheme_make_struct_names</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_struct_type</name></cpp:macro> <cpp:value>dll_scheme_make_struct_type</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_struct_values</name></cpp:macro> <cpp:value>dll_scheme_make_struct_values</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_type</name></cpp:macro> <cpp:value>dll_scheme_make_type</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_vector</name></cpp:macro> <cpp:value>dll_scheme_make_vector</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_malloc_fail_ok</name></cpp:macro> <cpp:value>dll_scheme_malloc_fail_ok</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_open_input_file</name></cpp:macro> <cpp:value>dll_scheme_open_input_file</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_primitive_module</name></cpp:macro> <cpp:value>dll_scheme_primitive_module</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_proper_list_length</name></cpp:macro> <cpp:value>dll_scheme_proper_list_length</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_raise</name></cpp:macro> <cpp:value>dll_scheme_raise</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_read</name></cpp:macro> <cpp:value>dll_scheme_read</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_register_static</name></cpp:macro> <cpp:value>dll_scheme_register_static</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_set_stack_base</name></cpp:macro> <cpp:value>dll_scheme_set_stack_base</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_signal_error</name></cpp:macro> <cpp:value>dll_scheme_signal_error</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_wrong_type</name></cpp:macro> <cpp:value>dll_scheme_wrong_type</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_set_param</name></cpp:macro> <cpp:value>dll_scheme_set_param</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_current_config</name></cpp:macro> <cpp:value>dll_scheme_current_config</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_char_string_to_byte_string</name></cpp:macro> <cpp:value>dll_scheme_char_string_to_byte_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_char_string_to_path</name></cpp:macro> <cpp:value>dll_scheme_char_string_to_path</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_set_collects_path</name></cpp:macro> <cpp:value>dll_scheme_set_collects_path</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_hash_table</name></cpp:macro> <cpp:value>dll_scheme_make_hash_table</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_hash_set</name></cpp:macro> <cpp:value>dll_scheme_hash_set</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_hash_get</name></cpp:macro> <cpp:value>dll_scheme_hash_get</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_double</name></cpp:macro> <cpp:value>dll_scheme_make_double</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_make_sized_byte_string</name></cpp:macro> <cpp:value>dll_scheme_make_sized_byte_string</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_namespace_require</name></cpp:macro> <cpp:value>dll_scheme_namespace_require</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_dynamic_wind</name></cpp:macro> <cpp:value>dll_scheme_dynamic_wind</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_malloc_one_tagged</name></cpp:macro> <cpp:value>dll_GC_malloc_one_tagged</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GC_register_traversers</name></cpp:macro> <cpp:value>dll_GC_register_traversers</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">400</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_main_setup</name></cpp:macro> <cpp:value>dll_scheme_main_setup</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">603</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_register_tls_space</name></cpp:macro> <cpp:value>dll_scheme_register_tls_space</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_init_collection_paths</name></cpp:macro> <cpp:value>dll_scheme_init_collection_paths</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_malloc_immobile_box</name></cpp:macro> <cpp:value>dll_scheme_malloc_immobile_box</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_free_immobile_box</name></cpp:macro> <cpp:value>dll_scheme_free_immobile_box</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">600</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_embedded_load</name></cpp:macro> <cpp:value>dll_scheme_embedded_load</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_register_embedded_load</name></cpp:macro> <cpp:value>dll_scheme_register_embedded_load</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>scheme_set_config_path</name></cpp:macro> <cpp:value>dll_scheme_set_config_path</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">500</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_EXTERNALLY_VIA_PROC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>Thread_Local_Variables</name> <modifier>*</modifier></type>

<name>scheme_external_get_thread_local_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>dll_scheme_external_get_thread_local_variables</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

}</block></struct></type> <name>Thunk_Info</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>Thunk_Info</name></type> <name><name>mzgc_imports</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="string">"GC_malloc"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_GC_malloc</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"GC_malloc_atomic"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_GC_malloc_atomic</name></expr>}</block></expr>,

<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Thunk_Info</name></type> <name><name>mzsch_imports</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{<expr><literal type="string">"scheme_eof"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_eof</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_false"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_false</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_void"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_void</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_null"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_null</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_true"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_true</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>USE_THREAD_LOCAL</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>LINK_EXTENSIONS_BY_TABLE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_current_thread"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_current_thread_ptr</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_console_printf"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_console_printf_ptr</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_console_output"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_console_output_ptr</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_notify_multithread"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_notify_multithread_ptr</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_add_global"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_add_global</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_add_global_symbol"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_add_global_symbol</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_apply"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_apply</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_basic_env"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_basic_env</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_byte_string_to_char_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_byte_string_to_char_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_path"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_path</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_builtin_value"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_builtin_value</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_check_threads"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_check_threads</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_close_input_port"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_close_input_port</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_count_lines"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_count_lines</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_current_continuation_marks"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_current_continuation_marks</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_display"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_display</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_display_to_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_display_to_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_do_eval"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_do_eval</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_dont_gc_ptr"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_dont_gc_ptr</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_eq"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_eq</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_eval"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_eval</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_eval_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_eval_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_eval_string_all"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_eval_string_all</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_finish_primitive_module"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_finish_primitive_module</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_format"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_format</name></expr>}</block></expr>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr><block>{<expr><literal type="string">"scheme_format_utf8"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_format_utf8</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_get_param"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_get_param</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_gc_ptr_ok"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_gc_ptr_ok</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_get_sized_string_output"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_get_sized_string_output</name></expr>}</block></expr>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr><block>{<expr><literal type="string">"scheme_get_sized_byte_string_output"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_get_sized_byte_string_output</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_intern_symbol"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_intern_symbol</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_lookup_global"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_lookup_global</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_closed_prim_w_arity"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_closed_prim_w_arity</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_integer_value"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_integer_value</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_pair"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_pair</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_prim_w_arity"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_prim_w_arity</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_make_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_string_output_port"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_string_output_port</name></expr>}</block></expr>,

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr><block>{<expr><literal type="string">"scheme_make_byte_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_byte_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_byte_string_output_port"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_byte_string_output_port</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_make_struct_instance"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_struct_instance</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_struct_names"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_struct_names</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_struct_type"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_struct_type</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_struct_values"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_struct_values</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_type"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_type</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_vector"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_vector</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_malloc_fail_ok"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_malloc_fail_ok</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_open_input_file"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_open_input_file</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_primitive_module"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_primitive_module</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_proper_list_length"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_proper_list_length</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_raise"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_raise</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_read"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_read</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_register_static"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_register_static</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_set_stack_base"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_set_stack_base</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_signal_error"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_signal_error</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_wrong_type"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_wrong_type</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_set_param"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_set_param</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_current_config"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_current_config</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_char_string_to_byte_string"</literal></expr>,

<expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_char_string_to_byte_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_char_string_to_path"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_char_string_to_path</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_set_collects_path"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_set_collects_path</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_make_hash_table"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_hash_table</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_hash_set"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_hash_set</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_hash_get"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_hash_get</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_double"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_double</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_make_sized_byte_string"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_make_sized_byte_string</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_namespace_require"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_namespace_require</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_dynamic_wind"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_dynamic_wind</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"GC_malloc_one_tagged"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_GC_malloc_one_tagged</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"GC_register_traversers"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_GC_register_traversers</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">400</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><literal type="string">"scheme_main_setup"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_main_setup</name></expr>}</block></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">603</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_register_tls_space"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_register_tls_space</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><literal type="string">"scheme_init_collection_paths"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_init_collection_paths</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_malloc_immobile_box"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_malloc_immobile_box</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_free_immobile_box"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_free_immobile_box</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">500</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_VIA_WIN_TLS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>IMPLEMENT_THREAD_LOCAL_EXTERNALLY_VIA_PROC</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_external_get_thread_local_variables"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_external_get_thread_local_variables</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">600</literal></expr></cpp:if>

<expr><block>{<expr><literal type="string">"scheme_embedded_load"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_embedded_load</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_register_embedded_load"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_register_embedded_load</name></expr>}</block></expr>,

<expr><block>{<expr><literal type="string">"scheme_set_config_path"</literal></expr>, <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dll_scheme_set_config_path</name></expr>}</block></expr>,

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HINSTANCE</name></type> <name>hMzGC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HINSTANCE</name></type> <name>hMzSch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dynamic_mzscheme_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mzscheme_runtime_link_init</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sch_dll</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gc_dll</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mzscheme_runtime_link_init</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sch_dll</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>gc_dll</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Thunk_Info</name> <modifier>*</modifier></type><name>thunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hMzGC</name> <operator>&amp;&amp;</operator> <name>hMzSch</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>hMzSch</name> <operator>=</operator> <call><name>vimLoadLib</name><argument_list>(<argument><expr><name>sch_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzGC</name> <operator>=</operator> <call><name>vimLoadLib</name><argument_list>(<argument><expr><name>gc_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hMzGC</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loadlib</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>gc_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hMzSch</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loadlib</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sch_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>thunk</name> <operator>=</operator> <name>mzsch_imports</name></expr>;</init> <condition><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>thunk</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name><name>thunk</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hMzSch</name></expr></argument>, <argument><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzSch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzSch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzGC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loadfunc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>thunk</name> <operator>=</operator> <name>mzgc_imports</name></expr>;</init> <condition><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>thunk</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name><name>thunk</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator>

<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><call><name>GetProcAddress</name><argument_list>(<argument><expr><name>hMzGC</name></expr></argument>, <argument><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzSch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzSch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzGC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loadfunc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>thunk</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>mzscheme_enabled</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>verbose</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>mzscheme_runtime_link_init</name><argument_list>(

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p_mzschemedll</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p_mzschemegcdll</name></expr></argument>, <argument><expr><name>verbose</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>dynamic_mzscheme_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>hMzSch</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzSch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzSch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hMzGC</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>hMzGC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hMzGC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">299</literal></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GUARANTEED_STRING_ARG</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>GUARANTEE_STRING(proc, num)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>guaranteed_byte_string_arg</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_BYTE_STRINGP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<return>return <expr><name><name>argv</name><index>[<expr><name>num</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_CHAR_STRINGP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>argv</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>scheme_char_string_to_byte_string</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>tmp</name></expr>;</return>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GUARANTEED_STRING_ARG</name><parameter_list>(<parameter><type><name>proc</name></type></parameter>, <parameter><type><name>num</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>guaranteed_byte_string_arg(proc, num, argc, argv)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_MZSCHEME_BASE</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mzscheme_base.c"</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Type</name></type> <name>mz_buffer_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Type</name></type> <name>mz_window_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>initialized</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>disabled</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>load_base_module_failed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Env</name> <modifier>*</modifier></type><name>environment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>curout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>curerr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>exn_catching_apply</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>exn_p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>exn_message</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>vim_exn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">400</literal></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>stack_base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>range_start</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>range_end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mz_threads_allow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name> <name>CALLBACK</name></type> <name>timer_proc</name><parameter_list>(<parameter><decl><type><name>HWND</name></type></decl></parameter>, <parameter><decl><type><name>UINT</name></type></decl></parameter>, <parameter><decl><type><name>UINT_PTR</name></type></decl></parameter>, <parameter><decl><type><name>DWORD</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>UINT</name></type> <name>timer_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<function_decl><type><specifier>static</specifier> <name>gboolean</name></type> <name>timer_proc</name><parameter_list>(<parameter><decl><type><name>gpointer</name></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>guint</name></type> <name>timer_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>timer_proc</name><parameter_list>(<parameter><decl><type><name>XtPointer</name></type></decl></parameter>, <parameter><decl><type><name>XtIntervalId</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>XtIntervalId</name></type> <name>timer_id</name> <init>= <expr><operator>(</operator><name>XtIntervalId</name><operator>)</operator><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<function_decl><type><name>pascal</name> <name>void</name></type> <name>timer_proc</name><parameter_list>(<parameter><decl><type><name>EventLoopTimerRef</name></type></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>EventLoopTimerRef</name></type> <name>timer_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>EventLoopTimerUPP</name></type> <name>timerUPP</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>VIMDLL</name></expr></argument>)</argument_list></call></expr></cpp:if> 

<function><type><name>void</name></type>

<name>mzvim_check_threads</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>time_t</name></type> <name>mz_last_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mz_threads_allow</name> <operator>&amp;&amp;</operator> <name>p_mzq</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>time_t</name></type> <name>now</name> <init>= <expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>now</name> <operator>-</operator> <name>mz_last_time</name><operator>)</operator> <operator>*</operator> <literal type="number">1000</literal> <operator>&gt;</operator> <name>p_mzq</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>mz_last_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_check_threads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZSCHEME_GUI_THREADS</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_timer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_timer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name> <name>CALLBACK</name></type>

<name>timer_proc</name><argument_list>(<argument><expr><name>HWND</name> <name>hwnd</name> <name>UNUSED</name></expr></argument>, <argument><expr><name>UINT</name> <name>uMsg</name> <name>UNUSED</name></expr></argument>, <argument><expr><name>UINT_PTR</name> <name>idEvent</name> <name>UNUSED</name></expr></argument>, <argument><expr><name>DWORD</name> <name>dwTime</name> <name>UNUSED</name></expr></argument>)</argument_list>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

static <name>gboolean</name>

<name>timer_proc</name><argument_list>(<argument><expr><name>gpointer</name> <name>data</name> <name>UNUSED</name></expr></argument>)</argument_list>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:elif>

static <name>void</name>

<name>timer_proc</name><argument_list>(<argument><expr><name>XtPointer</name> <name>timed_out</name> <name>UNUSED</name></expr></argument>, <argument><expr><name>XtIntervalId</name> <operator>*</operator><name>interval_id</name> <name>UNUSED</name></expr></argument>)</argument_list>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<name>pascal</name> <name>void</name>

<name>timer_proc</name><argument_list>(<argument><expr><name>EventLoopTimerRef</name> <name>theTimer</name> <name>UNUSED</name></expr></argument>, <argument><expr><name>void</name> <operator>*</operator><name>userData</name> <name>UNUSED</name></expr></argument>)</argument_list>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_check_threads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:if>

<return>return <expr><name>TRUE</name></expr>;</return> 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<if_stmt><if>if <condition>(<expr><name>mz_threads_allow</name> <operator>&amp;&amp;</operator> <name>p_mzq</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>timer_id</name> <operator>=</operator> <call><name>XtAppAddTimeOut</name><argument_list>(<argument><expr><name>app_context</name></expr></argument>, <argument><expr><name>p_mzq</name></expr></argument>,

<argument><expr><name>timer_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>setup_timer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>timer_id</name> <operator>=</operator> <call><name>SetTimer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>p_mzq</name></expr></argument>, <argument><expr><name>timer_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>timer_id</name> <operator>=</operator> <call><name>g_timeout_add</name><argument_list>(<argument><expr><operator>(</operator><name>guint</name><operator>)</operator><name>p_mzq</name></expr></argument>, <argument><expr><operator>(</operator><name>GSourceFunc</name><operator>)</operator><name>timer_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>timer_id</name> <operator>=</operator> <call><name>XtAppAddTimeOut</name><argument_list>(<argument><expr><name>app_context</name></expr></argument>, <argument><expr><name>p_mzq</name></expr></argument>, <argument><expr><name>timer_proc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><name>timerUPP</name> <operator>=</operator> <call><name>NewEventLoopTimerUPP</name><argument_list>(<argument><expr><name>timer_proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>InstallEventLoopTimer</name><argument_list>(<argument><expr><call><name>GetMainEventLoop</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>p_mzq</name> <operator>*</operator> <name>kEventDurationMillisecond</name></expr></argument>,

<argument><expr><name>p_mzq</name> <operator>*</operator> <name>kEventDurationMillisecond</name></expr></argument>, <argument><expr><name>timerUPP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>timer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>remove_timer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MSWIN</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>KillTimer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>timer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_GTK</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><call><name>g_source_remove</name><argument_list>(<argument><expr><name>timer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MOTIF</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_ATHENA</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><call><name>XtRemoveTimeOut</name><argument_list>(<argument><expr><name>timer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI_MAC</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<expr_stmt><expr><call><name>RemoveEventLoopTimer</name><argument_list>(<argument><expr><name>timer_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DisposeEventLoopTimerUPP</name><argument_list>(<argument><expr><name>timerUPP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>timer_id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>mzvim_reset_timer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>timer_id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>remove_timer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mz_threads_allow</name> <operator>&amp;&amp;</operator> <name>p_mzq</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>gui</name><operator>.</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_timer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<function><type><specifier>static</specifier> <name>void</name></type>

<name>notify_multithread</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>on</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>mz_threads_allow</name> <operator>=</operator> <name>on</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZSCHEME_GUI_THREADS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>on</name> <operator>&amp;&amp;</operator> <name>timer_id</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>p_mzq</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>gui</name><operator>.</operator><name>in_use</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setup_timer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>on</name> <operator>&amp;&amp;</operator> <name>timer_id</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>remove_timer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>mzscheme_end</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
dynamic_mzscheme_end();

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_TLS_SPACE</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><specifier>static</specifier> <macro><name>__declspec</name><argument_list>(<argument>thread</argument>)</argument_list></macro> <name>void</name> <operator>*</operator><name>tls_space</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>intptr_t</name></type> <name>_tls_index</name></decl>;</decl_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__MINGW32__</name></expr></argument>)</argument_list></call></expr></cpp:elif>

<decl_stmt><decl><type><specifier>static</specifier> <name>__thread</name> <name>void</name> <modifier>*</modifier></type><name>tls_space</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>intptr_t</name></type> <name>_tls_index</name></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>static</specifier> <name>THREAD_LOCAL</name> <name>void</name> <modifier>*</modifier></type><name>tls_space</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>intptr_t</name></type> <name>_tls_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>int</name></type>

<name>mzscheme_main</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>argv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>mzscheme_enabled</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>disabled</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><call><name>vim_main2</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_TLS_SPACE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_register_tls_space</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tls_space</name></expr></argument>, <argument><expr><name>_tls_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>scheme_main_setup</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>mzscheme_env_main</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><call><name>mzscheme_env_main</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argv</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mzscheme_env_main</name><parameter_list>(<parameter><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>env</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>environment</name> <operator>=</operator> <name>env</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>dummy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dummy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stack_base</name> <operator>=</operator> <operator>&amp;</operator><name>__gc_var_stack__</name></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>int</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>stack_base</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>dummy</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>vim_main2</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name><modifier>*</modifier></type>

<name>load_base_module</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_namespace_require</name><argument_list>(<argument><expr><call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_null</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>load_base_module_on_error</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>load_base_module_failed</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>scheme_null</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>startup_mzscheme</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_set_stack_base</name><argument_list>(<argument><expr><name>stack_base</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>TRAMPOLINED_MZVIM_STARTUP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>environment</name> <operator>=</operator> <call><name>scheme_basic_env</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>curout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>curerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>exn_catching_apply</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>exn_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>exn_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>vim_exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>INCLUDE_MZSCHEME_BASE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>declare_modules</name><argument_list>(<argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>coll_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mustfree</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>coll_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>vim_getenv</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PLTCOLLECTS"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mustfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>coll_path</name> <operator>=</operator> <call><name>scheme_make_path</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mustfree</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZSCHEME_COLLECTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>coll_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>coll_path</name> <operator>=</operator> <call><name>scheme_make_path</name><argument_list>(<argument><expr><name>MZSCHEME_COLLECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>coll_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_set_collects_path</name><argument_list>(<argument><expr><name>coll_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZSCHEME_COLLECTS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>coll_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>coll_pair</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Config</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>coll_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>coll_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>coll_string</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><name>MZSCHEME_COLLECTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>coll_pair</name> <operator>=</operator> <call><name>scheme_make_pair</name><argument_list>(<argument><expr><name>coll_string</name></expr></argument>, <argument><expr><name>scheme_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>config</name> <operator>=</operator> <call><name>scheme_current_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_set_param</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>MZCONFIG_COLLECTION_PATHS</name></expr></argument>, <argument><expr><name>coll_pair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">600</literal></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>config_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mustfree</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>config_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>vim_getenv</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"PLTCONFIGDIR"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mustfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>config_path</name> <operator>=</operator> <call><name>scheme_make_path</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mustfree</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZSCHEME_CONFIGDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>config_path</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>config_path</name> <operator>=</operator> <call><name>scheme_make_path</name><argument_list>(<argument><expr><name>MZSCHEME_CONFIGDIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>config_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_set_config_path</name><argument_list>(<argument><expr><name>config_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">400</literal></expr></cpp:if>

<expr_stmt><expr><call><name>scheme_init_collection_paths</name><argument_list>(<argument><expr><name>environment</name></expr></argument>, <argument><expr><name>scheme_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_dynamic_wind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>load_base_module</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>load_base_module_on_error</name></expr></argument>, <argument><expr><literal type="string">"racket/base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>load_base_module_failed</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>load_base_module_failed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_dynamic_wind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>load_base_module</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>load_base_module_on_error</name></expr></argument>, <argument><expr><literal type="string">"scheme/base"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>load_base_module_failed</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>register_vim_exn</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_exn_catching_apply</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scheme_console_output</name> <operator>=</operator> <name>do_output</name></expr>;</expr_stmt>

<expr_stmt><expr><name>scheme_console_printf</name> <operator>=</operator> <name>do_printf</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>make_security_guard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>make_security_guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">400</literal></expr></cpp:if>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>make_security_guard_symbol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>make_security_guard_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>make_security_guard_symbol</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"make-security-guard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>make_security_guard</name> <operator>=</operator> <call><name>scheme_lookup_global</name><argument_list>(

<argument><expr><name>make_security_guard_symbol</name></expr></argument>, <argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>make_security_guard</name> <operator>=</operator> <call><name>scheme_builtin_value</name><argument_list>(<argument><expr><literal type="string">"make-security-guard"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>make_security_guard</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name><name>args</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>guard</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Config</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_ARRAY_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>config</name> <operator>=</operator> <call><name>scheme_current_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_get_param</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>MZCONFIG_SECURITY_GUARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_make_prim_w_arity</name><argument_list>(<argument><expr><name>sandbox_file_guard</name></expr></argument>,

<argument><expr><literal type="string">"sandbox-file-guard"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_make_prim_w_arity</name><argument_list>(<argument><expr><name>sandbox_network_guard</name></expr></argument>,

<argument><expr><literal type="string">"sandbox-network-guard"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>guard</name> <operator>=</operator> <call><name>scheme_apply</name><argument_list>(<argument><expr><name>make_security_guard</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_set_param</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>MZCONFIG_SECURITY_GUARD</name></expr></argument>, <argument><expr><name>guard</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>mz_buffer_type</name> <operator>=</operator> <call><name>scheme_make_type</name><argument_list>(<argument><expr><literal type="string">"&lt;vim-buffer&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mz_window_type</name> <operator>=</operator> <call><name>scheme_make_type</name><argument_list>(<argument><expr><literal type="string">"&lt;vim-window&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>GC_register_traversers</name><argument_list>(<argument><expr><name>mz_buffer_type</name></expr></argument>,

<argument><expr><name>buffer_size_proc</name></expr></argument>, <argument><expr><name>buffer_mark_proc</name></expr></argument>, <argument><expr><name>buffer_fixup_proc</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GC_register_traversers</name><argument_list>(<argument><expr><name>mz_window_type</name></expr></argument>,

<argument><expr><name>window_size_proc</name></expr></argument>, <argument><expr><name>window_mark_proc</name></expr></argument>, <argument><expr><name>window_fixup_proc</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>make_modules</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scheme_notify_multithread</name> <operator>=</operator> <name>notify_multithread</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mzscheme_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>initialized</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DYNAMIC_MZSCHEME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>disabled</name> <operator>||</operator> <operator>!</operator><call><name>mzscheme_enabled</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E815: Sorry, this command is disabled, the MzScheme libraries could not be loaded."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>load_base_module_failed</name> <operator>||</operator> <call><name>startup_mzscheme</name><argument_list>()</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E895: Sorry, this command is disabled, the MzScheme's racket/base module could not be loaded."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>initialized</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Config</name> <modifier>*</modifier></type><name>config</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>config</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>config</name> <operator>=</operator> <call><name>scheme_current_config</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curout</name> <operator>=</operator> <call><name>scheme_make_byte_string_output_port</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curerr</name> <operator>=</operator> <call><name>scheme_make_byte_string_output_port</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_set_param</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>MZCONFIG_OUTPUT_PORT</name></expr></argument>, <argument><expr><name>curout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_set_param</name><argument_list>(<argument><expr><name>config</name></expr></argument>, <argument><expr><name>MZCONFIG_ERROR_PORT</name></expr></argument>, <argument><expr><name>curerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>eval_with_exn_handling</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>ret</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>exn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>prim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prim</name> <operator>=</operator> <call><name>scheme_make_closed_prim_w_arity</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"mzvim"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>_apply_thunk_catch_exceptions</name><argument_list>(<argument><expr><name>prim</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>extract_exn_message</name><argument_list>(<argument><expr><name>exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_display</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>curerr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>*</operator><name>ret</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>SCHEME_VOIDP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_display</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>curout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>do_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>do_mzscheme_command</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>Scheme_Closed_Prim</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>mzscheme_init</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>range_start</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line1</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>range_end</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>eval_with_exn_handling</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>mzscheme_buffer_free</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <call><name>BUFFER_REF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bp</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>INVALID_BUFFER_VALUE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_gc_ptr_ok</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>scheme_free_immobile_box</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>mzscheme_window_free</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>WINDOW_REF</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>win</name></name> <operator>=</operator> <name>INVALID_WINDOW_VALUE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_gc_ptr_ok</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>scheme_free_immobile_box</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_mzscheme</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>script</name></decl>;</decl_stmt>

<expr_stmt><expr><name>script</name> <operator>=</operator> <call><name>script_get</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>eap</name><operator>-&gt;</operator><name>skip</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>script</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_mzscheme_command</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>do_eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>do_mzscheme_command</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>script</name></expr></argument>, <argument><expr><name>do_eval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>script</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>do_load</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>noargc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>noargv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Port_Info</name> <modifier>*</modifier></type><name>pinfo</name> <init>= <expr><operator>(</operator><name>Port_Info</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>scheme_malloc_fail_ok</name><argument_list>(<argument><expr><name>scheme_malloc_atomic</name></expr></argument>, <argument><expr><name>MAXPATHL</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>expand_env</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>pinfo</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>file</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <call><name>scheme_open_input_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"mzfile"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_count_lines</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>SCHEME_EOFP</name><argument_list>(<argument><expr><name>expr</name> <operator>=</operator> <call><name>scheme_read</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_eval</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>scheme_close_input_port</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>-&gt;</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pinfo</name><operator>-&gt;</operator><name>port</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_mzfile</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Port_Info</name></type> <name>pinfo</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>pinfo</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pinfo</name><operator>.</operator><name>name</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>do_mzscheme_command</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pinfo</name></expr></argument>, <argument><expr><name>do_load</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name>

<operator>&amp;&amp;</operator> <name><name>pinfo</name><operator>.</operator><name>port</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_close_input_port</name><argument_list>(<argument><expr><name><name>pinfo</name><operator>.</operator><name>port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>init_exn_catching_apply</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>exn_catching_apply</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>e</name> <init>=

<expr><literal type="string">"(lambda (thunk) "</literal>

<literal type="string">"(with-handlers ([void (lambda (exn) (cons #f exn))]) "</literal>

<literal type="string">"(cons #t (thunk))))"</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>exn_catching_apply</name> <operator>=</operator> <call><name>scheme_eval_string</name><argument_list>(<argument><expr><name>e</name></expr></argument>, <argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exn_p</name> <operator>=</operator> <call><name>scheme_builtin_value</name><argument_list>(<argument><expr><literal type="string">"exn?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exn_message</name> <operator>=</operator> <call><name>scheme_builtin_value</name><argument_list>(<argument><expr><literal type="string">"exn-message"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>_apply_thunk_catch_exceptions</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>exn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>_scheme_apply</name><argument_list>(<argument><expr><name>exn_catching_apply</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_TRUEP</name><argument_list>(<argument><expr><call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>exn</name> <operator>=</operator> <call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>extract_exn_message</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_TRUEP</name><argument_list>(<argument><expr><call><name>_scheme_apply</name><argument_list>(<argument><expr><name>exn_p</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>_scheme_apply</name><argument_list>(<argument><expr><name>exn_message</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>v</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>do_eval</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>noargc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>noargv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>scheme_eval_string_all</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><name>environment</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_intrnl_output</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>mesg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>prev</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_output</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>OUTPUT_LEN_TYPE</name> <name>len</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>do_intrnl_output</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_err_output</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>do_intrnl_output</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_printf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>do_intrnl_output</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>do_flush</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OUTPUT_LEN_TYPE</name></type> <name>length</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>scheme_get_sized_byte_string_output</name><argument_list>(<argument><expr><name>curerr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>do_err_output</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>scheme_get_sized_byte_string_output</name><argument_list>(<argument><expr><name>curout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>length</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>do_output</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_command</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>DOCMD_NOWAIT</name><operator>|</operator><name>DOCMD_VERBOSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_screen</name><argument_list>(<argument><expr><name>VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_eval</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vim_result</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vim_result</name> <operator>=</operator> <call><name>eval_expr</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vim_result</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"invalid expression"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>vim_to_mzscheme</name><argument_list>(<argument><expr><name>vim_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_tv</name><argument_list>(<argument><expr><name>vim_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"expressions disabled at compile time"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_false</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_range_start</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>range_start</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_range_end</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>range_end</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>mzscheme_beep</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_beep</name><argument_list>(<argument><expr><name>BO_LANG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>M_global</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_option</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>value</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>rval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>save_curb</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>save_curw</name> <init>= <expr><name>curwin</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>M_global</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_global</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"global"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>M_global</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_GLOBAL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VIMBUFFERP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <call><name>get_valid_buffer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_LOCAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VIMWINDOWP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_valid_window</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_LOCAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"vim-buffer/window"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>get_option_value</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>strval</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>save_curb</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>save_curw</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>rc</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>scheme_make_integer_value</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><name>strval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>strval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>rval</name></expr>;</return>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<case>case <expr><operator>-</operator><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"hidden option"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><operator>-</operator><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"unknown option"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_option</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>save_curb</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>save_curw</name> <init>= <expr><name>curwin</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>M_global</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_global</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"global"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>M_global</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_GLOBAL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VIMBUFFERP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <call><name>get_valid_buffer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_LOCAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VIMWINDOWP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_valid_window</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_flags</name> <operator>=</operator> <name>OPT_LOCAL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"vim-buffer/window"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>command</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_set</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_screen</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>save_curb</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>save_curw</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_curr_win</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><call><name>get_vim_curr_window</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_count</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FOR_ALL_WINDOWS</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call>

<operator>++</operator><name>n</name></expr>;</expr_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name>firstwin</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name>scheme_null</name></expr>;</expr_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>w</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>w</name> <operator>=</operator> <name><name>w</name><operator>-&gt;</operator><name>w_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>w</name><operator>-&gt;</operator><name>w_buffer</name></name> <operator>==</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>scheme_make_pair</name><argument_list>(<argument><expr><call><name>window_new</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>window_new</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><call><name>WINDOW_REF</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>scheme_malloc_fail_ok</name><argument_list>(<argument><expr><name>scheme_malloc_tagged</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_dont_gc_ptr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name> <operator>=</operator> <call><name>scheme_malloc_immobile_box</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WINDOW_REF</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>win</name></name> <operator>=</operator> <name>win</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>so</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>mz_window_type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_num</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nr</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>win</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>wp</name> <operator>=</operator> <name>firstwin</name></expr>;</init> <condition><expr><name>wp</name> <operator>!=</operator> <name>win</name></expr>;</condition> <incr><expr><name>wp</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>nr</name></expr>;</expr_stmt></block_content></block></for>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_by_num</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><name>firstwin</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fnum</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fnum</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_signal_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"window index is out of range"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>win</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_next</name></name></expr><operator>,</operator> <expr><operator>--</operator><name>fnum</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>fnum</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><call><name>window_new</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>scheme_false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>buffer_new</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_height</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_height</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_window_height</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>savewin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>height</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>need_mouse_correct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>savewin</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>win</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>win_setheight</name><argument_list>(<argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>savewin</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_window_width</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_width</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_window_width</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>savewin</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>width</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>need_mouse_correct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>savewin</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>win</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>win_setwidth</name><argument_list>(<argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>savewin</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_cursor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_cursor</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>scheme_make_pair</name><argument_list>(<argument><expr><call><name>scheme_make_integer_value</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>pos</name><operator>.</operator><name>lnum</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>scheme_make_integer_value</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>pos</name><operator>.</operator><name>col</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_cursor</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>lnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>col</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sandbox_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>get_window_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>GUARANTEE_PAIR</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_INTP</name><argument_list>(<argument><expr><call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>!</operator><call><name>SCHEME_INTP</name><argument_list>(<argument><expr><call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"integer pair"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_line_range</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>w_set_curswant</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_screen</name><argument_list>(<argument><expr><name>VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>mzscheme_open_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>onum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>onum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sandbox_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>buflist_add</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>BLN_LISTED</name> <operator>|</operator> <name>BLN_CURBUF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>num</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"couldn't open buffer"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>onum</name> <operator>=</operator> <call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_by_num</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>onum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_by_num</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fnum</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_fnum</name></name> <operator>==</operator> <name>fnum</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>buffer_new</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>scheme_false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_by_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>GUARANTEED_STRING_ARG</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <name>scheme_false</name></expr>;</expr_stmt>

<macro><name>FOR_ALL_BUFFERS</name><argument_list>(<argument>buf</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_sfname</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>buffer_new</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>fnamecmp</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>, <argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>

<operator>||</operator> <operator>!</operator><call><name>fnamecmp</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_sfname</name></name></expr></argument>, <argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>buffer_new</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buffer</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_next_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>buffer_new</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_next</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_prev_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>buffer_new</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_prev</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_num</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_count</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>FOR_ALL_BUFFERS</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>++</operator><name>n</name></expr>;</expr_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_name</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>buf</name><operator>-&gt;</operator><name>b_ffname</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_curr_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><call><name>get_vim_curr_buffer</name><argument_list>()</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>buffer_new</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><call><name>BUFFER_REF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>self</name> <operator>=</operator> <call><name>scheme_malloc_fail_ok</name><argument_list>(<argument><expr><name>scheme_malloc_tagged</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vim_mz_buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>MZ_PRECISE_GC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>scheme_dont_gc_ptr</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name> <operator>=</operator> <call><name>scheme_malloc_immobile_box</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>BUFFER_REF</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>=</operator> <name>self</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>so</name><operator>.</operator><name>type</name></name> <operator>=</operator> <name>mz_buffer_type</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>self</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_size</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>scheme_make_integer</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_line</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>linenr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>linenr</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>linenr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>line</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>get_buffer_line_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name>scheme_null</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>lo</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>hi</name> <operator>&lt;</operator> <name>lo</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <name>hi</name> <operator>-</operator> <name>lo</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>--</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>scheme_make_byte_string</name><argument_list>(

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>lo</name><operator>+</operator><name>i</name><operator>)</operator></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>scheme_make_pair</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_buffer_line</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>save</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sandbox_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_STRINGP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCHEME_FALSEP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"string or #f"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_line_range</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_FALSEP</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_savedel</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ml_delete</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot delete line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mz_fix_cursor</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>deleted_lines_mark</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>save</name> <operator>=</operator> <call><name>string_to_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_savesub</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ml_replace</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>save</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot replace line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>changed_bytes</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>check_cursor_col</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_array</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>curr</name> <init>= <expr><name>array</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>curr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><operator>*</operator><name>curr</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>set_buffer_line_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>line_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>old_len</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>extra</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sandbox_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_PAIRP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCHEME_FALSEP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCHEME_NULLP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"list or #f"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line_list</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>old_len</name> <operator>=</operator> <name>hi</name> <operator>-</operator> <name>lo</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lo</name> <operator>=</operator> <name>hi</name></expr>;</expr_stmt>

<expr_stmt><expr><name>hi</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_len</name> <operator>=</operator> <operator>-</operator><name>old_len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>extra</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_line_range</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>check_line_range</name><argument_list>(<argument><expr><name>hi</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_FALSEP</name><argument_list>(<argument><expr><name>line_list</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SCHEME_NULLP</name><argument_list>(<argument><expr><name>line_list</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_savedel</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>old_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>ml_delete</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot delete line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mz_fix_cursor</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><operator>-</operator><name>old_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>deleted_lines_mark</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>old_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_len</name> <operator>=</operator> <call><name>scheme_proper_list_length</name><argument_list>(<argument><expr><name>line_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>new_len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"proper list"</literal></expr></argument>,

<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>rest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>new_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>new_len</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>line_list</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>new_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_STRINGP</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"string-list"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>string_to_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_save</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>lo</name><operator>-</operator><literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>hi</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_len</name> <operator>-</operator> <name>new_len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ml_delete</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot delete line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>extra</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>old_len</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>new_len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>ml_replace</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>lo</name><operator>+</operator><name>i</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot replace line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>new_len</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ml_append</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>lo</name> <operator>+</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot insert line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>extra</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>mark_adjust</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>hi</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>MAXLNUM</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>changed_lines</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>lo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>hi</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name> <operator>==</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mz_fix_cursor</name><argument_list>(<argument><expr><name>lo</name></expr></argument>, <argument><expr><name>hi</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>insert_buffer_line_list</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><operator>(</operator><name>Vim_Prim</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sandbox_check</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><call><name>GUARANTEE_INTEGER</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>list</name> <operator>=</operator> <name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_STRINGP</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCHEME_PAIRP</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"string or list"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>get_buffer_arg</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>check_line_range</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_STRINGP</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>string_to_line</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_save</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>n</name><operator>+</operator><literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>ml_append</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot insert line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>appended_lines_mark</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><literal type="number">1L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_screen</name><argument_list>(<argument><expr><name>VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>scheme_proper_list_length</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"proper list"</literal></expr></argument>,

<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>rest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>array</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>savebuf</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>array</name> <operator>=</operator> <call><name>ALLOC_MULT</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size</name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rest</name> <operator>=</operator> <call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>string_to_line</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>buf</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>u_save</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>n</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot save undo information"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>ml_append</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><operator>(</operator><name>n</name> <operator>+</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>array</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"cannot insert line"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>appended_lines_mark</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>n</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free_array</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name>savebuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_screen</name><argument_list>(<argument><expr><name>VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_bufferp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_VIMBUFFERP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_true</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_windowp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_VIMWINDOWP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_true</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_buffer_validp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_VIMBUFFERP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>vim_mz_buffer</name> <operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>buf</name> <operator>!=</operator> <name>INVALID_BUFFER_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_true</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_window_validp</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>data</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_VIMWINDOWP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>vim_mz_window</name> <operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>)</operator><operator>-&gt;</operator><name>win</name> <operator>!=</operator> <name>INVALID_WINDOW_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>scheme_true</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>scheme_false</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>

<name>string_to_line</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>scheme_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vim_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>OUTPUT_LEN_TYPE</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>scheme_str</name> <operator>=</operator> <call><name>scheme_display_to_string</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>memchr</name><argument_list>(<argument><expr><name>scheme_str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_signal_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"string cannot contain newlines"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>vim_str</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>scheme_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>vim_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>vim_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>scheme_str</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>vim_str</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>vim_str</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_to_mzscheme</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vim_value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>visited</name> <operator>=</operator> <call><name>scheme_make_hash_table</name><argument_list>(<argument><expr><name>SCHEME_hash_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>vim_to_mzscheme_impl</name><argument_list>(<argument><expr><name>vim_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_to_mzscheme_impl</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vim_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>, <parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>new_value</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_hash_get</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>vim_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>new_value</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_integer</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_double</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>curr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>list</name><operator>-&gt;</operator><name>lv_first</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>scheme_null</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>list</name><operator>-&gt;</operator><name>lv_u</name><operator>.</operator><name>mat</name><operator>.</operator><name>lv_last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>vim_to_mzscheme_impl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>li_tv</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_pair</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>scheme_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>curr</name> <operator>!=</operator> <name><name>list</name><operator>-&gt;</operator><name>lv_first</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curr</name> <operator>=</operator> <name><name>curr</name><operator>-&gt;</operator><name>li_prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>vim_to_mzscheme_impl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>curr</name><operator>-&gt;</operator><name>li_tv</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_pair</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><call><name>scheme_make_hash_table</name><argument_list>(<argument><expr><name>SCHEME_hash_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><operator>&amp;</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name><operator>-&gt;</operator><name>dv_hashtab</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long_u</name></type> <name>todo</name> <init>= <expr><name><name>ht</name><operator>-&gt;</operator><name>ht_used</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hashitem_T</name> <modifier>*</modifier></type><name>hi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>hi</name> <operator>=</operator> <name><name>ht</name><operator>-&gt;</operator><name>ht_array</name></name></expr>;</init> <condition><expr><name>todo</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>hi</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HASHITEM_EMPTY</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>todo</name></expr>;</expr_stmt>

<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dict_lookup</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>obj</name> <operator>=</operator> <call><name>vim_to_mzscheme_impl</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>hi</name><operator>-&gt;</operator><name>hi_key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_hash_set</name><argument_list>(<argument><expr><operator>(</operator><name>Scheme_Hash_Table</name> <operator>*</operator><operator>)</operator><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FUNC</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_closed_prim_w_arity</name><argument_list>(<argument><expr><name>vim_funcref</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_PARTIAL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>scheme_null</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>funcname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>funcname</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>partial_name</name><argument_list>(<argument><expr><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_partial</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_closed_prim_w_arity</name><argument_list>(<argument><expr><name>vim_funcref</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_BOOL</name> <operator>||</operator> <name><name>vim_value</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_SPECIAL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>&lt;=</operator> <name>VVAL_TRUE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>scheme_make_integer</name><argument_list>(<argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>vim_value</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>scheme_null</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>scheme_void</name></expr>;</expr_stmt>

<expr_stmt><expr><name>new_value</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>new_value</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_hash_set</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>vim_value</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mzscheme_to_vim</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>visited</name> <operator>=</operator> <call><name>scheme_make_hash_table</name><argument_list>(<argument><expr><name>SCHEME_hash_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>mzscheme_to_vim_impl</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>visited</name><operator>-&gt;</operator><name>size</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>visited</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_tv</name><argument_list>(<argument><expr><operator>(</operator><name>typval_T</name> <operator>*</operator><operator>)</operator><name><name>visited</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mzscheme_to_vim_impl</name><parameter_list>(<parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>,

<parameter><decl><type><name>Scheme_Hash_Table</name> <modifier>*</modifier></type><name>visited</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>found</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>depth</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <operator>(</operator><name>typval_T</name> <operator>*</operator><operator>)</operator><call><name>scheme_hash_get</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><name>found</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VOIDP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_INTP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>SCHEME_INT_VAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_BOOLP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BOOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <call><name>SCHEME_TRUEP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><call><name>SCHEME_DBLP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_FLOAT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name> <operator>=</operator> <call><name>SCHEME_DBL_VAL</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_BYTE_STRINGP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_CHAR_STRINGP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>scheme_char_string_to_byte_string</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_VECTORP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SCHEME_NULLP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>

<operator>||</operator> <call><name>SCHEME_PAIRP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SCHEME_MUTABLE_PAIRP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>list_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>curr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>cval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>cval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>list</name><operator>-&gt;</operator><name>lv_refcount</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>typval_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>visited_tv</name> <init>= <expr><call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>typval_T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>visited_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_hash_set</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>visited_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>SCHEME_VECTORP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>SCHEME_VEC_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>cval</name> <operator>=</operator> <call><name>SCHEME_VEC_ELS</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>mzscheme_to_vim_impl</name><argument_list>(<argument><expr><name>cval</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>list_append_tv</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_PAIRP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SCHEME_MUTABLE_PAIRP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>curr</name> <operator>=</operator> <name>obj</name></expr>;</init>

<condition><expr><call><name>SCHEME_PAIRP</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>SCHEME_MUTABLE_PAIRP</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</condition>

<incr><expr><name>curr</name> <operator>=</operator> <call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>cval</name> <operator>=</operator> <call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>mzscheme_to_vim_impl</name><argument_list>(<argument><expr><name>cval</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>list_append_tv</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>OK</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>SCHEME_NULLP</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>mzscheme_to_vim_impl</name><argument_list>(<argument><expr><name>cval</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>list_append_tv</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCHEME_HASHTP</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dict</name> <operator>=</operator> <call><name>dict_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dict</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>visited_tv</name> <init>= <expr><call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>typval_T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name> <operator>=</operator> <name>dict</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>dict</name><operator>-&gt;</operator><name>dv_refcount</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>visited_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_hash_set</name><argument_list>(<argument><expr><name>visited</name></expr></argument>, <argument><expr><name>obj</name></expr></argument>, <argument><expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>visited_tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><name>Scheme_Hash_Table</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name>size</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Scheme_Hash_Table</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>dictitem_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>string_to_line</name><argument_list>(

<argument><expr><operator>(</operator><operator>(</operator><name>Scheme_Hash_Table</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>keys</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mzscheme_to_vim_impl</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Scheme_Hash_Table</name> <operator>*</operator><operator>)</operator> <name>obj</name><operator>)</operator><operator>-&gt;</operator><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>item</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>depth</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>visited</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>dictitem_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>string_to_line</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>vim_funcref</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>list_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>scheme_void</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>=</operator> <name>list</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>list</name><operator>-&gt;</operator><name>lv_refcount</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>status</name> <operator>==</operator> <name>OK</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>typval_T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>mzscheme_to_vim</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>list_append_tv</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ret</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mzscheme_call_vim</name><argument_list>(<argument><expr><call><name>BYTE_STRING_VALUE</name><argument_list>(<argument><expr><operator>(</operator><name>Scheme_Object</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>vim_to_mzscheme</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"error converting Scheme values to Vim"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_if_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>do_mzeval</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mzscheme_init</name><argument_list>()</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>eval_with_exn_handling</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>do_eval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mzscheme_to_vim</name><argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vim_error_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>got_int</name> <operator>||</operator> <name>did_emsg</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>register_vim_exn</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>struct_exn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>exn_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>struct_exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>exn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exn_name</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"exn:vim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>struct_exn</name> <operator>=</operator> <call><name>scheme_builtin_value</name><argument_list>(<argument><expr><literal type="string">"struct:exn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vim_exn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>vim_exn</name> <operator>=</operator> <call><name>scheme_make_struct_type</name><argument_list>(<argument><expr><name>exn_name</name></expr></argument>,

<argument><expr><name>struct_exn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&gt;=</operator> <literal type="number">299</literal></expr></cpp:if>

, <argument><expr><name>NULL</name></expr></argument>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name><name>exn_names</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name><name>exn_values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_ARRAY_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>exn_names</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_ARRAY_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>exn_values</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>scheme_make_struct_names</name><argument_list>(<argument><expr><name>exn_name</name></expr></argument>, <argument><expr><name>scheme_null</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>nc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>exn_names</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>nc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Scheme_Object</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>scheme_make_struct_values</name><argument_list>(<argument><expr><name>vim_exn</name></expr></argument>, <argument><expr><name>exn_names</name></expr></argument>, <argument><expr><name>nc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_memmove</name><argument_list>(<argument><expr><name>exn_values</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>nc</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Scheme_Object</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>scheme_add_global_symbol</name><argument_list>(<argument><expr><name><name>exn_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><name><name>exn_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>raise_vim_exn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>add_info</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Vim error: ~a"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>exn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>byte_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_ARRAY_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>byte_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>add_info</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>c_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>c_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>info</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><name>add_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c_string</name> <operator>=</operator> <call><name>scheme_format_utf8</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>byte_string</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><name>c_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_byte_string_to_char_string</name><argument_list>(<argument><expr><name>byte_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SCHEME_SET_IMMUTABLE</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>byte_string</name> <operator>=</operator> <call><name>scheme_make_byte_string</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Vim error"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_byte_string_to_char_string</name><argument_list>(<argument><expr><name>byte_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MZSCHEME_VERSION_MAJOR</name> <operator>&lt;</operator> <literal type="number">360</literal></expr></cpp:if>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_current_continuation_marks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>scheme_current_continuation_marks</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>exn</name> <operator>=</operator> <call><name>scheme_make_struct_instance</name><argument_list>(<argument><expr><name>vim_exn</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_raise</name><argument_list>(<argument><expr><name>exn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>raise_if_error</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_error_check</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>vim_mz_buffer</name> <modifier>*</modifier></type>

<name>get_buffer_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_buffer</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <name>argnum</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>get_vim_curr_buffer</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_VIMBUFFERP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"vim-buffer"</literal></expr></argument>, <argument><expr><name>argnum</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>vim_mz_buffer</name> <operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_valid_buffer</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>b</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>vim_mz_window</name> <modifier>*</modifier></type>

<name>get_window_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>vim_mz_window</name> <modifier>*</modifier></type><name>w</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&lt;</operator> <name>argnum</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>get_vim_curr_window</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <operator>(</operator><name>vim_mz_window</name> <operator>*</operator><operator>)</operator><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SCHEME_VIMWINDOWP</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_wrong_type</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"vim-window"</literal></expr></argument>, <argument><expr><name>argnum</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_valid_window</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>argnum</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>w</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>buf_T</name> <modifier>*</modifier></type><name>get_valid_buffer</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><operator>(</operator><operator>(</operator><name>vim_mz_buffer</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name>buf</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>INVALID_BUFFER_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_signal_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"buffer is invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>win_T</name> <modifier>*</modifier></type><name>get_valid_window</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>obj</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><operator>(</operator><operator>(</operator><name>vim_mz_window</name> <operator>*</operator><operator>)</operator><name>obj</name><operator>)</operator><operator>-&gt;</operator><name>win</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>==</operator> <name>INVALID_WINDOW_VALUE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_signal_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"window is invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>win</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>mzthreads_allowed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>mz_threads_allow</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>line_in_range</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><name>lnum</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lnum</name> <operator>&lt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>check_line_range</name><parameter_list>(<parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>line_in_range</name><argument_list>(<argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>scheme_signal_error</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"linenr out of range"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mz_fix_cursor</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>lo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extra</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&gt;=</operator> <name>lo</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>&gt;=</operator> <name>hi</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>+=</operator> <name>extra</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_cursor_col</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>extra</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lo</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_cursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>check_cursor_col</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>changed_cline_bef_curs</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>invalidate_botline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>Vim_Prim</name></type> <name><name>prims</name><index>[]</index></name><init>=

<expr><block>{

<expr><block>{<expr><name>get_buffer_line</name></expr>, <expr><literal type="string">"get-buff-line"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_buffer_line</name></expr>, <expr><literal type="string">"set-buff-line"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_line_list</name></expr>, <expr><literal type="string">"get-buff-line-list"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_name</name></expr>, <expr><literal type="string">"get-buff-name"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_num</name></expr>, <expr><literal type="string">"get-buff-num"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_size</name></expr>, <expr><literal type="string">"get-buff-size"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_buffer_line_list</name></expr>, <expr><literal type="string">"set-buff-line-list"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><literal type="number">4</literal></expr>}</block></expr>,

<expr><block>{<expr><name>insert_buffer_line_list</name></expr>, <expr><literal type="string">"insert-buff-line-list"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><literal type="number">3</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_curr_buffer</name></expr>, <expr><literal type="string">"curr-buff"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_count</name></expr>, <expr><literal type="string">"buff-count"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_next_buffer</name></expr>, <expr><literal type="string">"get-next-buff"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_prev_buffer</name></expr>, <expr><literal type="string">"get-prev-buff"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>mzscheme_open_buffer</name></expr>, <expr><literal type="string">"open-buff"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_by_name</name></expr>, <expr><literal type="string">"get-buff-by-name"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_buffer_by_num</name></expr>, <expr><literal type="string">"get-buff-by-num"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_curr_win</name></expr>, <expr><literal type="string">"curr-win"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_count</name></expr>, <expr><literal type="string">"win-count"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_by_num</name></expr>, <expr><literal type="string">"get-win-by-num"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_num</name></expr>, <expr><literal type="string">"get-win-num"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_buffer</name></expr>, <expr><literal type="string">"get-win-buffer"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_height</name></expr>, <expr><literal type="string">"get-win-height"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_window_height</name></expr>, <expr><literal type="string">"set-win-height"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_width</name></expr>, <expr><literal type="string">"get-win-width"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_window_width</name></expr>, <expr><literal type="string">"set-win-width"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_cursor</name></expr>, <expr><literal type="string">"get-cursor"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_cursor</name></expr>, <expr><literal type="string">"set-cursor"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_window_list</name></expr>, <expr><literal type="string">"get-win-list"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_command</name></expr>, <expr><literal type="string">"command"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_eval</name></expr>, <expr><literal type="string">"eval"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_range_start</name></expr>, <expr><literal type="string">"range-start"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_range_end</name></expr>, <expr><literal type="string">"range-end"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>mzscheme_beep</name></expr>, <expr><literal type="string">"beep"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>,

<expr><block>{<expr><name>get_option</name></expr>, <expr><literal type="string">"get-option"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>set_option</name></expr>, <expr><literal type="string">"set-option"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">2</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_bufferp</name></expr>, <expr><literal type="string">"buff?"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_windowp</name></expr>, <expr><literal type="string">"win?"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_buffer_validp</name></expr>, <expr><literal type="string">"buff-valid?"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,

<expr><block>{<expr><name>vim_window_validp</name></expr>, <expr><literal type="string">"win-valid?"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>vim_mz_buffer</name> <modifier>*</modifier></type>

<name>get_vim_curr_buffer</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_mzscheme_ref</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>vim_mz_buffer</name> <operator>*</operator><operator>)</operator><call><name>buffer_new</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>BUFFER_REF</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>vim_mz_window</name> <modifier>*</modifier></type>

<name>get_vim_curr_window</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_mzscheme_ref</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name>vim_mz_window</name> <operator>*</operator><operator>)</operator><call><name>window_new</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><call><name>WINDOW_REF</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>make_modules</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Env</name> <modifier>*</modifier></type><name>mod</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>vimext_symbol</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>closed_prim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>MZ_GC_DECL_REG</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>vimext_symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_VAR_IN_REG</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>closed_prim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_REG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vimext_symbol</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"vimext"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mod</name> <operator>=</operator> <call><name>scheme_primitive_module</name><argument_list>(<argument><expr><name>vimext_symbol</name></expr></argument>, <argument><expr><name>environment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>prims</name></expr></argument>)</argument_list></sizeof><operator>/</operator><sizeof>sizeof<argument_list>(<argument><expr><name><name>prims</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>Vim_Prim</name> <modifier>*</modifier></type><name>prim</name> <init>= <expr><name>prims</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>closed_prim</name> <operator>=</operator> <call><name>scheme_make_closed_prim_w_arity</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>prim</name></name></expr></argument>, <argument><expr><name>prim</name></expr></argument>, <argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>mina</name></name></expr></argument>, <argument><expr><name><name>prim</name><operator>-&gt;</operator><name>maxa</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>scheme_add_global</name><argument_list>(<argument><expr><name><name>prim</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>closed_prim</name></expr></argument>, <argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>scheme_finish_primitive_module</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_UNREG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SANDBOX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>M_write</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>M_read</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>M_execute</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type><name>M_delete</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>sandbox_check</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sandbox</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not allowed in the Vim sandbox"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>sandbox_file_guard</name><parameter_list>(<parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sandbox</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>requested_access</name> <init>= <expr><name><name>argv</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>M_write</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_write</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>M_read</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_read</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>M_execute</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_execute</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_execute</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"execute"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>M_delete</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>MZ_REGISTER_STATIC</name><argument_list>(<argument><expr><name>M_delete</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>M_delete</name> <operator>=</operator> <call><name>scheme_intern_symbol</name><argument_list>(<argument><expr><literal type="string">"delete"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>MZ_GC_CHECK</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>SCHEME_NULLP</name><argument_list>(<argument><expr><name>requested_access</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>Scheme_Object</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>SCHEME_CAR</name><argument_list>(<argument><expr><name>requested_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>scheme_eq</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>M_write</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>scheme_eq</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>M_read</name></expr></argument>)</argument_list></call>

<operator>||</operator> <call><name>scheme_eq</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>M_execute</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>scheme_eq</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>M_delete</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>raise_vim_exn</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"not allowed in the Vim sandbox"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>requested_access</name> <operator>=</operator> <call><name>SCHEME_CDR</name><argument_list>(<argument><expr><name>requested_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Scheme_Object</name> <modifier>*</modifier></type>

<name>sandbox_network_guard</name><parameter_list>(<parameter><decl><type><name>int</name> <name>argc</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>Scheme_Object</name> <modifier>*</modifier><modifier>*</modifier><name>argv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>scheme_void</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
