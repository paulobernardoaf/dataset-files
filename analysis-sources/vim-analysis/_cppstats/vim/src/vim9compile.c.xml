<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\vim9compile.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USING_FLOAT_STUFF</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFINE_VIM9_GLOBALS</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim9.h"</cpp:file></cpp:include>

<typedef>typedef <type><name><name>struct</name> <name>endlabel_S</name></name></type> <name>endlabel_T</name>;</typedef>

<struct>struct <name>endlabel_S</name> <block>{

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>el_next</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>el_end_label</name></decl>;</decl_stmt> 

}</block>;</struct>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>is_if_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>is_end_label</name></decl>;</decl_stmt> 

}</block></struct></type> <name>ifscope_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>ws_top_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>ws_end_label</name></decl>;</decl_stmt> 

}</block></struct></type> <name>whilescope_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>fs_top_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>fs_end_label</name></decl>;</decl_stmt> 

}</block></struct></type> <name>forscope_T</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>int</name></type> <name>ts_try_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>ts_end_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ts_catch_label</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ts_caught_all</name></decl>;</decl_stmt> 

}</block></struct></type> <name>tryscope_T</name>;</typedef>

<typedef>typedef <type><enum>enum <block>{

<decl><name>NO_SCOPE</name></decl>,

<decl><name>IF_SCOPE</name></decl>,

<decl><name>WHILE_SCOPE</name></decl>,

<decl><name>FOR_SCOPE</name></decl>,

<decl><name>TRY_SCOPE</name></decl>,

<decl><name>BLOCK_SCOPE</name></decl>

}</block></enum></type> <name>scopetype_T</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>scope_S</name></name></type> <name>scope_T</name>;</typedef>

<struct>struct <name>scope_S</name> <block>{

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>se_outer</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>scopetype_T</name></type> <name>se_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>se_local_count</name></decl>;</decl_stmt> 

<union>union <block>{

<decl_stmt><decl><type><name>ifscope_T</name></type> <name>se_if</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>whilescope_T</name></type> <name>se_while</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>forscope_T</name></type> <name>se_for</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tryscope_T</name></type> <name>se_try</name></decl>;</decl_stmt>

}</block> <decl><name>se_u</name></decl>;</union>

}</block>;</struct>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lv_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>lv_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lv_const</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>lv_arg</name></decl>;</decl_stmt> 

}</block></struct></type> <name>lvar_T</name>;</typedef>

<struct>struct <name>cctx_S</name> <block>{

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ctx_ufunc</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ctx_lnum</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>ctx_instr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>ctx_locals</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ctx_max_local</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>ctx_imports</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>ctx_skip</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>ctx_scope</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name></type> <name>ctx_type_stack</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>ctx_type_list</name></decl>;</decl_stmt> 

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>e_var_notfound</name><index>[]</index></name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E1001: variable not found: %s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>e_syntax_at</name><index>[]</index></name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E1002: Syntax error at %s"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_expr1</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_expr2</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>compile_expr3</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>delete_def_function_contents</name><parameter_list>(<parameter><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lookup_local</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>lvar_T</name> <modifier>*</modifier></type><name>lvar</name> <init>= <expr><operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>idx</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lookup_arg</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_args</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>FUNCARG</name><argument_list>(<argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>idx</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lookup_vararg</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>va_name</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_va_name</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>va_name</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>va_name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>va_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>lookup_script</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><operator>&amp;</operator><call><name>SCRIPT_VARS</name><argument_list>(<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <name><name>name</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>find_var_in_ht</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>name</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

<return>return <expr><ternary><condition><expr><name>di</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>FAIL</name></expr></then><else>: <expr><name>OK</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>check_defined</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>lookup_script</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name>

<operator>||</operator> <operator>(</operator><name>cctx</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><call><name>lookup_local</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>find_imported</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"E1073: imported name already defined: %s"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>type_T</name> <modifier>*</modifier></type>

<name>get_list_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>member_type</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_list_any</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_VOID</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_list_empty</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_BOOL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_list_bool</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_list_number</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_list_string</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>type_list</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>)</operator><name><name>type_list</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>type_list</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>type_list</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>=</operator> <name>VAR_LIST</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>tt_member</name></name> <operator>=</operator> <name>member_type</name></expr>;</expr_stmt>

<return>return <expr><name>type</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>type_T</name> <modifier>*</modifier></type>

<name>get_dict_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>member_type</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_dict_any</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_VOID</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_dict_empty</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_BOOL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_dict_bool</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_dict_number</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>member_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_dict_string</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>type_list</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>)</operator><name><name>type_list</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>type_list</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>type_list</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>=</operator> <name>VAR_DICT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>type</name><operator>-&gt;</operator><name>tt_member</name></name> <operator>=</operator> <name>member_type</name></expr>;</expr_stmt>

<return>return <expr><name>type</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>type_T</name> <modifier>*</modifier></type>

<name>typval2type</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_number</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_BOOL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_bool</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>&amp;</operator><name>t_string</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><operator>&amp;</operator><name>t_list_string</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><operator>&amp;</operator><name>t_dict_any</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_NULL_IF_SKIP</name><parameter_list>(<parameter><type><name>cctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (cctx-&gt;ctx_skip == TRUE) return NULL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RETURN_OK_IF_SKIP</name><parameter_list>(<parameter><type><name>cctx</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>if (cctx-&gt;ctx_skip == TRUE) return OK</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>isn_T</name> <modifier>*</modifier></type>

<name>generate_instr</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_NULL_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>instr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_type</name></name> <operator>=</operator> <name>isn_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_lnum</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_lnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>isn</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>isn_T</name> <modifier>*</modifier></type>

<name>generate_instr_drop</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>drop</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_NULL_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>drop</name></expr>;</expr_stmt>

<return>return <expr><call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>isn_T</name> <modifier>*</modifier></type>

<name>generate_instr_type</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>isn</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>may_generate_2STRING</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>type</name> <init>= <expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>type</name><operator>)</operator><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>OK</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_string</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_2STRING</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_number_or_float</name><parameter_list>(<parameter><decl><type><name>vartype_T</name></type> <name>type1</name></decl></parameter>, <parameter><decl><type><name>vartype_T</name></type> <name>type2</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>type1</name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>VAR_FLOAT</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>VAR_UNKNOWN</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>type2</name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_FLOAT</name>

<operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_UNKNOWN</name><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1035: wrong argument type for +"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1036: %c requires number or float arguments"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_two_op</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vartype_T</name></type> <name>vartype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>type2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>vartype</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name>

<operator>||</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>||</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<operator>||</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_BLOB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>vartype</name> <operator>=</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>op</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>!=</operator> <name>VAR_LIST</name> <operator>&amp;&amp;</operator> <name>vartype</name> <operator>!=</operator> <name>VAR_BLOB</name>

<operator>&amp;&amp;</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name>

<operator>&amp;&amp;</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name>

<operator>&amp;&amp;</operator> <call><name>check_number_or_float</name><argument_list>(

<argument><expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name></expr></argument>, <argument><expr><name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>vartype</name> <operator>==</operator> <name>VAR_NUMBER</name></expr> ?</condition><then> <expr><name>ISN_OPNR</name></expr>

</then><else>: <expr><ternary><condition><expr><name>vartype</name> <operator>==</operator> <name>VAR_LIST</name></expr> ?</condition><then> <expr><name>ISN_ADDLIST</name></expr>

</then><else>: <expr><ternary><condition><expr><name>vartype</name> <operator>==</operator> <name>VAR_BLOB</name></expr> ?</condition><then> <expr><name>ISN_ADDBLOB</name></expr>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
</then><else>: <expr><ternary><condition><expr><name>vartype</name> <operator>==</operator> <name>VAR_FLOAT</name></expr> ?</condition><then> <expr><name>ISN_OPFLOAT</name></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</then><else>: <expr><name>ISN_OPANY</name></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_ADD</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'/'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><call><name>check_number_or_float</name><argument_list>(<argument><expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name></expr></argument>, <argument><expr><name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name></expr></argument>,

<argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_OPNR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if type="elseif">else if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_OPFLOAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_OPANY</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'*'</literal></expr>

?</condition><then> <expr><name>EXPR_MULT</name></expr> </then><else>: <expr><ternary><condition><expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'/'</literal></expr>?</condition><then> <expr><name>EXPR_DIV</name></expr> </then><else>: <expr><name>EXPR_SUB</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'%'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name>

<operator>&amp;&amp;</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_NUMBER</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name>

<operator>&amp;&amp;</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_NUMBER</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1035: % requires number arguments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>vartype</name> <operator>==</operator> <name>VAR_NUMBER</name></expr> ?</condition><then> <expr><name>ISN_OPNR</name></expr> </then><else>: <expr><name>ISN_OPANY</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_REM</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>vartype</name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><operator>&amp;</operator><name>t_any</name></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_float</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_COMPARE</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>exptype_T</name></type> <name>exptype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ic</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isntype_T</name></type> <name>isntype</name> <init>= <expr><name>ISN_DROP</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vartype_T</name></type> <name>type1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vartype_T</name></type> <name>type2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index><operator>-&gt;</operator><name>tt_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index><operator>-&gt;</operator><name>tt_type</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type1</name> <operator>==</operator> <name>type2</name></expr>)</condition>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type1</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_BOOL</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREBOOL</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPARESPECIAL</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPARENR</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREFLOAT</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_STRING</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPARESTRING</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_BLOB</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREBLOB</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_LIST</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPARELIST</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_DICT</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREDICT</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_FUNC</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREFUNC</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>VAR_PARTIAL</name></expr>:</case> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREPARTIAL</name></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREANY</name></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>type1</name> <operator>==</operator> <name>VAR_UNKNOWN</name> <operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_UNKNOWN</name>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>type1</name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>VAR_FLOAT</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>type2</name> <operator>==</operator> <name>VAR_NUMBER</name> <operator>||</operator> <name>type2</name> <operator>==</operator><name>VAR_FLOAT</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isntype</name> <operator>=</operator> <name>ISN_COMPAREANY</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>exptype</name> <operator>==</operator> <name>EXPR_IS</name> <operator>||</operator> <name>exptype</name> <operator>==</operator> <name>EXPR_ISNOT</name><operator>)</operator>

<operator>&amp;&amp;</operator> <operator>(</operator><name>isntype</name> <operator>==</operator> <name>ISN_COMPAREBOOL</name>

<operator>||</operator> <name>isntype</name> <operator>==</operator> <name>ISN_COMPARESPECIAL</name>

<operator>||</operator> <name>isntype</name> <operator>==</operator> <name>ISN_COMPARENR</name>

<operator>||</operator> <name>isntype</name> <operator>==</operator> <name>ISN_COMPAREFLOAT</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1037: Cannot use \"%s\" with %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name>exptype</name> <operator>==</operator> <name>EXPR_IS</name></expr> ?</condition><then> <expr><literal type="string">"is"</literal></expr> </then><else>: <expr><literal type="string">"isnot"</literal></expr></else></ternary></expr></argument> , <argument><expr><call><name>vartype_name</name><argument_list>(<argument><expr><name>type1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isntype</name> <operator>==</operator> <name>ISN_DROP</name>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>exptype</name> <operator>!=</operator> <name>EXPR_EQUAL</name> <operator>&amp;&amp;</operator> <name>exptype</name> <operator>!=</operator> <name>EXPR_NEQUAL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>type1</name> <operator>==</operator> <name>VAR_BOOL</name> <operator>||</operator> <name>type1</name> <operator>==</operator> <name>VAR_SPECIAL</name>

<operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_BOOL</name> <operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_SPECIAL</name><operator>)</operator><operator>)</operator><operator>)</operator>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>exptype</name> <operator>!=</operator> <name>EXPR_EQUAL</name> <operator>&amp;&amp;</operator> <name>exptype</name> <operator>!=</operator> <name>EXPR_NEQUAL</name>

<operator>&amp;&amp;</operator> <name>exptype</name> <operator>!=</operator> <name>EXPR_IS</name> <operator>&amp;&amp;</operator> <name>exptype</name> <operator>!=</operator> <name>EXPR_ISNOT</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name>type1</name> <operator>==</operator> <name>VAR_BLOB</name> <operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_BLOB</name>

<operator>||</operator> <name>type1</name> <operator>==</operator> <name>VAR_LIST</name> <operator>||</operator> <name>type2</name> <operator>==</operator> <name>VAR_LIST</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1072: Cannot compare %s with %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>vartype_name</name><argument_list>(<argument><expr><name>type1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>vartype_name</name><argument_list>(<argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isntype</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>exptype</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_ic</name></name> <operator>=</operator> <name>ic</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_bool</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_2BOOL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>invert</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_2BOOL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>invert</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_bool</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_TYPECHECK</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>vartype</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_CHECKTYPE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>type</name><operator>.</operator><name>ct_type</name></name> <operator>=</operator> <name><name>vartype</name><operator>-&gt;</operator><name>tt_type</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>type</name><operator>.</operator><name>ct_off</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <name>vartype</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHNR</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>varnumber_T</name></type> <name>number</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHNR</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_number</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHBOOL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>varnumber_T</name></type> <name>number</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHBOOL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_bool</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHSPEC</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>varnumber_T</name></type> <name>number</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHSPEC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_special</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHF</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>float_T</name></type> <name>fnumber</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHF</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_float</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>fnumber</name></name> <operator>=</operator> <name>fnumber</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHS</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHS</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_string</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHCHANNEL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>channel_T</name> <modifier>*</modifier></type><name>channel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHCHANNEL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_channel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>channel</name></name> <operator>=</operator> <name>channel</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHJOB</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>job_T</name> <modifier>*</modifier></type><name>job</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHJOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_channel</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>job</name></name> <operator>=</operator> <name>job</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHBLOB</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>blob_T</name> <modifier>*</modifier></type><name>blob</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHBLOB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_blob</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>blob</name></name> <operator>=</operator> <name>blob</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHFUNC</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHFUNC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_func_void</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PUSHPARTIAL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>partial_T</name> <modifier>*</modifier></type><name>part</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHPARTIAL</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>t_partial_any</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>partial</name></name> <operator>=</operator> <name>part</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_STORE</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_STORENR</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>varnumber_T</name></type> <name>value</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORENR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storenr</name><operator>.</operator><name>stnr_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storenr</name><operator>.</operator><name>stnr_val</name></name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_STOREOPT</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt_flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STOREOPT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storeopt</name><operator>.</operator><name>so_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storeopt</name><operator>.</operator><name>so_flags</name></name> <operator>=</operator> <name>opt_flags</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_LOAD</name><parameter_list>(

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_LOADV</name><parameter_list>(

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>vidx</name> <init>= <expr><call><name>find_vim_var</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vidx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_var_notfound</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADV</name></expr></argument>, <argument><expr><name>vidx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_OLDSCRIPT</name><parameter_list>(

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>sid</name></decl></parameter>,

<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>isn_type</name> <operator>==</operator> <name>ISN_LOADS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>loadstore</name><operator>.</operator><name>ls_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>loadstore</name><operator>.</operator><name>ls_sid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_VIM9SCRIPT</name><parameter_list>(

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>isntype_T</name></type> <name>isn_type</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>sid</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,

<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>isn_type</name> <operator>==</operator> <name>ISN_LOADSCRIPT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>isn_type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>script</name><operator>.</operator><name>script_sid</name></name> <operator>=</operator> <name>sid</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>script</name><operator>.</operator><name>script_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_NEWLIST</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_list</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_NEWLIST</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>member</name> <operator>=</operator> <operator>&amp;</operator><name>t_void</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_list_type</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_NEWDICT</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_list</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_NEWDICT</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <literal type="number">2</literal> <operator>*</operator> <name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>member</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>member</name> <operator>=</operator> <operator>&amp;</operator><name>t_void</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_dict_type</name><argument_list>(<argument><expr><name>member</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_FUNCREF</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dfunc_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_FUNCREF</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>dfunc_idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_partial_any</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_JUMP</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>jumpwhen_T</name></type> <name>when</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>where</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_JUMP</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_when</name></name> <operator>=</operator> <name>when</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name>where</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>when</name> <operator>!=</operator> <name>JUMP_ALWAYS</name> <operator>&amp;&amp;</operator> <name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_FOR</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loop_idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_FOR</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>forloop</name><operator>.</operator><name>for_idx</name></name> <operator>=</operator> <name>loop_idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_any</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_BCALL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>func_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argcount</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name><name>argtypes</name><index>[<expr><name>MAX_FUNC_ARGS</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_internal_func</name><argument_list>(<argument><expr><name>func_idx</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_BCALL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>bfunc</name><operator>.</operator><name>cbf_idx</name></name> <operator>=</operator> <name>func_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>bfunc</name><operator>.</operator><name>cbf_argcount</name></name> <operator>=</operator> <name>argcount</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argcount</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <name>argcount</name> <operator>+</operator> <name>i</name></expr>]</index></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>argcount</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator>

<call><name>internal_func_ret_type</name><argument_list>(<argument><expr><name>func_idx</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt> 

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_CALL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pushed_argcount</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regular_args</name> <init>= <expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_args</name><operator>.</operator><name>ga_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argcount</name> <init>= <expr><name>pushed_argcount</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>argcount</name> <operator>&gt;</operator> <name>regular_args</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>has_varargs</name><argument_list>(<argument><expr><name>ufunc</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_toomanyarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>argcount</name> <operator>&lt;</operator> <name>regular_args</name> <operator>-</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_args</name><operator>.</operator><name>ga_len</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_toofewarg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_va_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name>argcount</name> <operator>-</operator> <name>regular_args</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>generate_NEWLIST</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>argcount</name> <operator>=</operator> <name>regular_args</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>ISN_DCALL</name></expr> </then><else>: <expr><name>ISN_UCALL</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>dfunc</name><operator>.</operator><name>cdf_idx</name></name> <operator>=</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>dfunc</name><operator>.</operator><name>cdf_argcount</name></name> <operator>=</operator> <name>argcount</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>ufunc</name><operator>.</operator><name>cuf_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>ufunc</name><operator>.</operator><name>cuf_argcount</name></name> <operator>=</operator> <name>argcount</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>argcount</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_ret_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_UCALL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argcount</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_UCALL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>ufunc</name><operator>.</operator><name>cuf_name</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>ufunc</name><operator>.</operator><name>cuf_argcount</name></name> <operator>=</operator> <name>argcount</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>argcount</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_any</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_PCALL</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argcount</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>at_top</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PCALL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>pfunc</name><operator>.</operator><name>cpf_top</name></name> <operator>=</operator> <name>at_top</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>pfunc</name><operator>.</operator><name>cpf_argcount</name></name> <operator>=</operator> <name>argcount</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-=</operator> <name>argcount</name></expr>;</expr_stmt> 

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <operator>&amp;</operator><name>t_any</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>at_top</name> <operator>&amp;&amp;</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PCALL_END</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_MEMBER</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_MEMBER</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_DICT</name> <operator>&amp;&amp;</operator> <name>type</name> <operator>!=</operator> <operator>&amp;</operator><name>t_any</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_dictreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>=</operator> <name><name>type</name><operator>-&gt;</operator><name>tt_member</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_ECHO</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>with_white</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_ECHO</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>echo</name><operator>.</operator><name>echo_with_white</name></name> <operator>=</operator> <name>with_white</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>echo</name><operator>.</operator><name>echo_count</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_EXECUTE</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_EXECUTE</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>generate_EXEC</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>RETURN_OK_IF_SKIP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_EXEC</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>e_white_both</name><index>[]</index></name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E1004: white space required before and after '%s'"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>reserve_local</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>isConst</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lvar_T</name> <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>lookup_arg</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>lookup_vararg</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg_namelen</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1006: %s is used as an argument"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_max_local</name></name> <operator>&lt;</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_max_local</name></name> <operator>=</operator> <name>idx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_name</name></name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>len</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_const</name></name> <operator>=</operator> <name>isConst</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<return>return <expr><name>idx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unwind_locals</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>new_top</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <name>new_top</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lvar_T</name> <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <name>new_top</name></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name> <operator>=</operator> <name>new_top</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_local</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>skip_type</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_type</name><argument_list>(<argument><expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>type_T</name> <modifier>*</modifier></type>

<name>parse_type_member</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>member_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_called_emsg</name> <init>= <expr><name>called_emsg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'&lt;'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1007: No white space allowed before &lt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1008: Missing &lt;type&gt;"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>type</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>member_type</name> <operator>=</operator> <call><name>parse_type</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'&gt;'</literal> <operator>&amp;&amp;</operator> <name>called_emsg</name> <operator>==</operator> <name>prev_called_emsg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1009: Missing &gt; after type"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>type</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>get_list_type</name><argument_list>(<argument><expr><name>member_type</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>get_dict_type</name><argument_list>(<argument><expr><name>member_type</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>type_T</name> <modifier>*</modifier></type>

<name>parse_type</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"any"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"bool"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_bool</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"blob"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_blob</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"channel"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_channel</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"dict"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><call><name>parse_type_member</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_dict_any</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"float"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_float</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1055: This Vim is not compiled with float support"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_func_any</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"job"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_job</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"list"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><call><name>parse_type_member</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_list_any</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"number"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_number</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">7</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"partial"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_partial_any</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"string"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_string</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"void"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_void</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1010: Type not recognized: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>&amp;</operator><name>t_any</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>equal_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type1</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_VOID</name></expr>:</case>

<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>

<case>case <expr><name>VAR_BOOL</name></expr>:</case>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case>

<case>case <expr><name>VAR_FLOAT</name></expr>:</case>

<case>case <expr><name>VAR_STRING</name></expr>:</case>

<case>case <expr><name>VAR_BLOB</name></expr>:</case>

<case>case <expr><name>VAR_JOB</name></expr>:</case>

<case>case <expr><name>VAR_CHANNEL</name></expr>:</case>

<break>break;</break> 

<case>case <expr><name>VAR_LIST</name></expr>:</case>

<case>case <expr><name>VAR_DICT</name></expr>:</case>

<return>return <expr><call><name>equal_type</name><argument_list>(<argument><expr><name><name>type1</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><name><name>type2</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>VAR_FUNC</name></expr>:</case>

<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>

<return>return <expr><call><name>equal_type</name><argument_list>(<argument><expr><name><name>type1</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><name><name>type2</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <name><name>type1</name><operator>-&gt;</operator><name>tt_argcount</name></name> <operator>==</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_argcount</name></name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>common_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type1</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type2</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>type_list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>equal_type</name><argument_list>(<argument><expr><name>type1</name></expr></argument>, <argument><expr><name>type2</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>type1</name></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name> <operator>||</operator> <name><name>type2</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>common</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>common_type</name><argument_list>(<argument><expr><name><name>type1</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><name><name>type2</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>common</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type1</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>get_list_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>get_dict_type</name><argument_list>(<argument><expr><name>common</name></expr></argument>, <argument><expr><name>type_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>type1</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <operator>&amp;</operator><name>t_any</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>vartype_name</name><parameter_list>(<parameter><decl><type><name>vartype_T</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case> <break>break;</break>

<case>case <expr><name>VAR_VOID</name></expr>:</case> <return>return <expr><literal type="string">"void"</literal></expr>;</return>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> <return>return <expr><literal type="string">"special"</literal></expr>;</return>

<case>case <expr><name>VAR_BOOL</name></expr>:</case> <return>return <expr><literal type="string">"bool"</literal></expr>;</return>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case> <return>return <expr><literal type="string">"number"</literal></expr>;</return>

<case>case <expr><name>VAR_FLOAT</name></expr>:</case> <return>return <expr><literal type="string">"float"</literal></expr>;</return>

<case>case <expr><name>VAR_STRING</name></expr>:</case> <return>return <expr><literal type="string">"string"</literal></expr>;</return>

<case>case <expr><name>VAR_BLOB</name></expr>:</case> <return>return <expr><literal type="string">"blob"</literal></expr>;</return>

<case>case <expr><name>VAR_JOB</name></expr>:</case> <return>return <expr><literal type="string">"job"</literal></expr>;</return>

<case>case <expr><name>VAR_CHANNEL</name></expr>:</case> <return>return <expr><literal type="string">"channel"</literal></expr>;</return>

<case>case <expr><name>VAR_LIST</name></expr>:</case> <return>return <expr><literal type="string">"list"</literal></expr>;</return>

<case>case <expr><name>VAR_DICT</name></expr>:</case> <return>return <expr><literal type="string">"dict"</literal></expr>;</return>

<case>case <expr><name>VAR_FUNC</name></expr>:</case> <return>return <expr><literal type="string">"func"</literal></expr>;</return>

<case>case <expr><name>VAR_PARTIAL</name></expr>:</case> <return>return <expr><literal type="string">"partial"</literal></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><literal type="string">"any"</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>

<name>type_name</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>tofree</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>vartype_name</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>tofree</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name> <operator>||</operator> <name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>member_free</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>member_name</name> <init>= <expr><call><name>type_name</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>member_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>member_name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tofree</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tofree</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>*</operator><name>tofree</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="string">"%s&lt;%s&gt;"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>member_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>member_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>*</operator><name>tofree</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>get_script_item_idx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sid</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>check_writable</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>hashtab_T</name> <modifier>*</modifier></type><name>ht</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scriptitem_T</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>SCRIPT_ITEM</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sid</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>sid</name> <operator>&gt;</operator> <name><name>script_items</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ht</name> <operator>=</operator> <operator>&amp;</operator><call><name>SCRIPT_VARS</name><argument_list>(<argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>find_var_in_ht</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>sn_var_vals</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>svar_T</name> <modifier>*</modifier></type><name>sv</name> <init>= <expr><operator>(</operator><operator>(</operator><name>svar_T</name> <operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>sn_var_vals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sv</name><operator>-&gt;</operator><name>sv_tv</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>check_writable</name> <operator>&amp;&amp;</operator> <name><name>sv</name><operator>-&gt;</operator><name>sv_const</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_readonlyvar</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>idx</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>imported_T</name> <modifier>*</modifier></type>

<name>find_imported</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scriptitem_T</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>SCRIPT_ITEM</name><argument_list>(<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>imported_T</name> <modifier>*</modifier></type><name>import</name> <init>= <expr><operator>(</operator><operator>(</operator><name>imported_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>

</then><else>: <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>import</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>si</name><operator>-&gt;</operator><name>sn_imports</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>imported_T</name> <modifier>*</modifier></type><name>import</name> <init>= <expr><operator>(</operator><operator>(</operator><name>imported_T</name> <operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>sn_imports</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>

</then><else>: <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>len</name>

<operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>import</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_imported</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>imported_T</name> <modifier>*</modifier></type><name>import</name> <init>= <expr><operator>(</operator><operator>(</operator><name>imported_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_load_scriptvar</name><parameter_list>(

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>end</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>scriptitem_T</name> <modifier>*</modifier></type><name>si</name> <init>= <expr><call><name>SCRIPT_ITEM</name><argument_list>(<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><call><name>get_script_item_idx</name><argument_list>(<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>imported_T</name> <modifier>*</modifier></type><name>import</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>si</name><operator>-&gt;</operator><name>sn_version</name></name> <operator>!=</operator> <name>SCRIPT_VERSION_VIM9</name></expr>)</condition>

<block>{<block_content>

<return>return <expr><call><name>generate_OLDSCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADS</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>svar_T</name> <modifier>*</modifier></type><name>sv</name> <init>= <expr><operator>(</operator><operator>(</operator><name>svar_T</name> <operator>*</operator><operator>)</operator><name><name>si</name><operator>-&gt;</operator><name>sn_var_vals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>generate_VIM9SCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADSCRIPT</name></expr></argument>,

<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name><name>sv</name><operator>-&gt;</operator><name>sv_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>import</name> <operator>=</operator> <call><name>find_imported</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>import</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>import</name><operator>-&gt;</operator><name>imp_all</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>name_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1060: expected dot after name: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1074: no white space allowed after dot"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>find_exported</name><argument_list>(<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_sid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name_len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ufunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>end</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_VIM9SCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADSCRIPT</name></expr></argument>,

<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_sid</name></name></expr></argument>,

<argument><expr><name>idx</name></expr></argument>,

<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>generate_VIM9SCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADSCRIPT</name></expr></argument>,

<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_sid</name></name></expr></argument>,

<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_var_vals_idx</name></name></expr></argument>,

<argument><expr><name><name>import</name><operator>-&gt;</operator><name>imp_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1050: Item not found: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_load</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end_arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>error</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>end_arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_called_emsg</name> <init>= <expr><name>called_emsg</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>&lt;=</operator> <operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"[empty]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_LOADV</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'g'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compile_load_scriptvar</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"Namespace b: not supported yet: %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"Namespace w: not supported yet: %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"Namespace t: not supported yet: %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"E1075: Namespace not supported: %s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>end</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>gen_load</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>lookup_arg</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_arg_types</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_arg_types</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_any</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>-=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_args</name><operator>.</operator><name>ga_len</name></name> <operator>+</operator> <name>STACK_FRAME_SIZE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_va_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>idx</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>gen_load</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>lookup_vararg</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>-</operator><name>STACK_FRAME_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_va_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>gen_load</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>lookup_local</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name><operator>)</operator><operator>-&gt;</operator><name>lv_type</name></expr>;</expr_stmt>

<expr_stmt><expr><name>gen_load</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>len</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>STRNCMP</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_PUSHBOOL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'t'</literal></expr>

?</condition><then> <expr><name>VVAL_TRUE</name></expr> </then><else>: <expr><name>VVAL_FALSE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>SCRIPT_ITEM</name><argument_list>(<argument><expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>sn_version</name>

<operator>==</operator> <name>SCRIPT_VERSION_VIM9</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>compile_load_scriptvar</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>gen_load</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOAD</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>

<label><name>theend</name>:</label>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <name>error</name> <operator>&amp;&amp;</operator> <name>called_emsg</name> <operator>==</operator> <name>prev_called_emsg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_var_notfound</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_arguments</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>argcount</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>argcount</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">','</literal> <operator>&amp;&amp;</operator> <operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1068: No white space allowed before ,"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1069: white space required after ,"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_close</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_call</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>varlen</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>argcount_init</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argcount</name> <init>= <expr><name>argcount_init</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>namebuf</name><index>[<expr><literal type="number">100</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>fname_buf</name><index>[<expr><name>FLEN_FIXED</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><name>FCERR_NONE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>varlen</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>namebuf</name></expr></argument>)</argument_list></sizeof></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1011: name too long: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>fname_trans_sid</name><argument_list>(<argument><expr><name>namebuf</name></expr></argument>, <argument><expr><name>fname_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <name>varlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_arguments</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argcount</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ASCII_ISLOWER</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>find_internal_func</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_BCALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_unknownfunc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ufunc</name> <operator>=</operator> <call><name>find_func</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ufunc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_CALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ufunc</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>namebuf</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_load</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>namebuf</name> <operator>+</operator> <name>varlen</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_PCALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>generate_UCALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VIM9_NAMESPACE_CHAR</name></cpp:macro> <cpp:value>(char_u *)"bgstvw"</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>to_name_end</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>namespace</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>eval_isnamec1</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>arg</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <call><name>eval_isnamec</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>p</name> <operator>!=</operator> <name>arg</name> <operator>+</operator> <literal type="number">1</literal>

<operator>||</operator> <operator>!</operator><name>namespace</name>

<operator>||</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>VIM9_NAMESPACE_CHAR</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char_u</name> <modifier>*</modifier></type>

<name>to_name_const_end</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>to_name_end</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_list_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>eval_dict</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>p</name> <operator>==</operator> <name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>get_lambda_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NOTDONE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>eval_dict</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>type_mismatch</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>actual</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tofree1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tofree2</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1013: type mismatch, expected %s but got %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>type_name</name><argument_list>(<argument><expr><name>actual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>check_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>actual</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>give_msg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>expected</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>expected</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name><name>actual</name><operator>-&gt;</operator><name>tt_type</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>give_msg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>type_mismatch</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>expected</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_DICT</name> <operator>||</operator> <name><name>expected</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>actual</name><operator>-&gt;</operator><name>tt_member</name></name> <operator>==</operator> <operator>&amp;</operator><name>t_void</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>check_type</name><argument_list>(<argument><expr><name><name>expected</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><name><name>actual</name><operator>-&gt;</operator><name>tt_member</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <name>give_msg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>type_mismatch</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>need_type</name><parameter_list>(<parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>actual</name></decl></parameter>, <parameter><decl><type><name>type_T</name> <modifier>*</modifier></type><name>expected</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>check_type</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>actual</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>OK</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>actual</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>type_mismatch</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>actual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>generate_TYPECHECK</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_list</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_list_end</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>p</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_NEWLIST</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_lambda</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_lambda_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ufunc</name> <operator>=</operator> <name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_partial</name><operator>-&gt;</operator><name>pt_func</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_refcount</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_def_function</name><argument_list>(<argument><expr><name>ufunc</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>instr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_FUNCREF</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_lambda_call</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>argcount</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_lambda_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'('</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nowhitespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_paren</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"lambda"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ufunc</name> <operator>=</operator> <name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_partial</name><operator>-&gt;</operator><name>pt_func</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_refcount</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_def_function</name><argument_list>(<argument><expr><name>ufunc</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_arguments</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argcount</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>generate_CALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ufunc</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_dict</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>literal</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><call><name>dict_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'}'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>literal</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>to_name_end</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><operator>!</operator><name>literal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>*</operator><name>arg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1014: Invalid key: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_PUSHS</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_type</name></name> <operator>==</operator> <name>ISN_PUSHS</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>key</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_duplicate_key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>dictitem_alloc</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_add</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dictitem_free</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_dict_colon</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_dict_comma</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_dict_end</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>failret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dict_unref</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>generate_NEWDICT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>failret</name>:</label>

<expr_stmt><expr><call><name>dict_unref</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_get_option</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_option_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>vim_strnsave</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><ternary><condition><expr><name><name>rettv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr> ?</condition><then> <expr><operator>&amp;</operator><name>t_number</name></expr> </then><else>: <expr><operator>&amp;</operator><name>t_string</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADOPT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_get_env</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><operator>*</operator><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>get_env_len</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_syntax_at</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>start</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADENV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_get_register</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_syntax_at</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_yank_reg</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg_invreg</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADREG</name></expr></argument>, <argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>apply_leader</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>end</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_FLOAT</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name> <operator>=</operator> <operator>-</operator><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<block>{<block_content>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>val</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>error</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>check_not_string</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>tv_get_number_chk</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>v</name> <init>= <expr><call><name>tv2bool</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BOOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <ternary><condition><expr><name>v</name></expr> ?</condition><then> <expr><name>VVAL_FALSE</name></expr> </then><else>: <expr><name>VVAL_TRUE</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>get_vim_constant</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:true"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BOOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:false"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BOOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:null"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:none"</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_leader</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>end</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>negate</name> <init>= <expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>negate</name> <operator>=</operator> <operator>!</operator><name>negate</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_NEGATENR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_CHECKNR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>invert</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name> <operator>&gt;</operator> <name>start</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>invert</name> <operator>=</operator> <operator>!</operator><name>invert</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>generate_2BOOL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>invert</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_subscript</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>,

<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>start_leader</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end_leader</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>argcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_arguments</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argcount</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_PCALL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>argcount</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_leader</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>*</operator><name>start_leader</name></expr></argument>, <argument><expr><name>end_leader</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>start_leader</name> <operator>=</operator> <name>end_leader</name></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_lambda_call</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ASCII_ISALPHA</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<for>for <control>( <init>;</init> <condition><expr><call><name>eval_isnamec1</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'('</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_paren</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_call</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>typep</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missbrac</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_INDEX</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>typep</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>typep</name><operator>)</operator><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_LIST</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>typep</name> <operator>!=</operator> <operator>&amp;</operator><name>t_any</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_listreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>typep</name><operator>)</operator><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>typep</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>typep</name><operator>)</operator><operator>-&gt;</operator><name>tt_member</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>eval_isnamec1</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<while>while <condition>(<expr><call><name>eval_isnamec</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>MB_PTR_ADV</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <operator>*</operator><name>arg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_syntax_at</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_MEMBER</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<break>break;</break></block_content></block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr7</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>rettv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start_leader</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_leader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>start_leader</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'!'</literal> <operator>||</operator> <operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>end_leader</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'0'</literal></expr>:</case> 

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<case>case <expr><literal type="char">'3'</literal></expr>:</case>

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<case>case <expr><literal type="char">'5'</literal></expr>:</case>

<case>case <expr><literal type="char">'6'</literal></expr>:</case>

<case>case <expr><literal type="char">'7'</literal></expr>:</case>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<case>case <expr><literal type="char">'9'</literal></expr>:</case>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><call><name>get_number_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'"'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><call><name>get_string_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\''</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><call><name>get_lit_string_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> <expr_stmt><expr><call><name>get_vim_constant</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NOTDONE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'['</literal></expr>:</case> <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_list</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'#'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_dict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NOTDONE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'{'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>get_function_args</name><argument_list>(<argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><literal type="char">'-'</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>FAIL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>start</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_lambda</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_dict</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'&amp;'</literal></expr>:</case> <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_get_option</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'$'</literal></expr>:</case> <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_get_env</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'@'</literal></expr>:</case> <expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_get_register</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'('</literal></expr>:</case> <expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_close</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default> <expr_stmt><expr><name>ret</name> <operator>=</operator> <name>NOTDONE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rettv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>apply_leader</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>, <argument><expr><name>start_leader</name></expr></argument>, <argument><expr><name>end_leader</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>start_leader</name> <operator>=</operator> <name>end_leader</name></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><name><name>rettv</name><operator>.</operator><name>v_type</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_BOOL</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHBOOL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHSPEC</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHNR</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<case>case <expr><name>VAR_FLOAT</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHF</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_float</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>VAR_BLOB</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHBLOB</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_blob</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_STRING</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHS</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><literal type="string">"constant type missing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>ret</name> <operator>==</operator> <name>NOTDONE</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>eval_isnamec1</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1015: Name expected: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>to_name_end</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_call</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <operator>*</operator><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_load</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_subscript</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start_leader</name></expr></argument>, <argument><expr><name>end_leader</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>compile_leader</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>start_leader</name></expr></argument>, <argument><expr><name>end_leader</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr6</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr7</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr7</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_two_op</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr5</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>oplen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr6</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<expr_stmt><expr><name>op</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'-'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><operator>(</operator><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>oplen</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'.'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>oplen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>op</name> <operator>+</operator> <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr6</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>may_generate_2STRING</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>may_generate_2STRING</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_CONCAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>generate_two_op</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>exptype_T</name></type>

<name>get_compare_type</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>type_is</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>exptype_T</name></type> <name>type</name> <init>= <expr><name>EXPR_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'='</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_EQUAL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_MATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'!'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_NEQUAL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_NOMATCH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_GREATER</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_GEQUAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_SMALLER</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>EXPR_SEQUAL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> <if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'n'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>*</operator><name>len</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isalnum</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><name>EXPR_IS</name></expr> </then><else>: <expr><name>EXPR_ISNOT</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>type_is</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>type</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr4</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>exptype_T</name></type> <name>type</name> <init>= <expr><name>EXPR_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type_is</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr5</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_compare_type</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>EXPR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ic</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>type_is</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invexpr2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ic</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">7</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr5</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_COMPARE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ic</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_and_or</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opchar</name> <init>= <expr><operator>*</operator><name>op</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name></type> <name>end_ga</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_ga</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_ga</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>end_ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>end_ga</name><operator>.</operator><name>ga_len</name></name><operator>)</operator> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>end_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><ternary><condition><expr><name>opchar</name> <operator>==</operator> <literal type="char">'|'</literal></expr>

?</condition><then> <expr><name>JUMP_AND_KEEP_IF_TRUE</name></expr> </then><else>: <expr><name>JUMP_AND_KEEP_IF_FALSE</name></expr></else></ternary></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>opchar</name> <operator>==</operator> <literal type="char">'|'</literal></expr> ?</condition><then> <expr><call><name>compile_expr3</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>compile_expr4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name><name>end_ga</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>--</operator><name><name>end_ga</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <operator>*</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator><name><name>end_ga</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>end_ga</name><operator>.</operator><name>ga_len</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>end_ga</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr3</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>compile_and_or</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="string">"&amp;&amp;"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr2</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr3</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>compile_and_or</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="string">"||"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_expr1</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr2</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>alt_idx</name> <init>= <expr><name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>end_idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"?"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>type1</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>end_idx</name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>alt_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_colon</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">":"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>type2</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><call><name>common_type</name><argument_list>(<argument><expr><name>type1</name></expr></argument>, <argument><expr><name>type2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type2</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>end_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_return</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>set_return_type</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>stack_type</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'|'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stack_type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>set_return_type</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_ret_type</name></name> <operator>=</operator> <name>stack_type</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>need_type</name><argument_list>(<argument><expr><name>stack_type</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_ret_type</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call>

<operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_ret_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_VOID</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1003: Missing return value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>generate_PUSHNR</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_RETURN</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>assignment_len</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>heredoc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'&lt;'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>heredoc</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><literal type="number">3</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"+-*/%"</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"..="</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">3</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name><name>reserved</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"true"</literal></expr>,

<expr><literal type="string">"false"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>heredoc_getline</name><parameter_list>(

<parameter><decl><type><name>int</name> <name>c</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>cookie</name></decl></parameter>,

<parameter><decl><type><name>int</name> <name>indent</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>int</name> <name>do_concat</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name> <init>= <expr><operator>(</operator><name>cctx_T</name> <operator>*</operator><operator>)</operator><name>cookie</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_lnum</name></name> <operator>==</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_lines</name><operator>.</operator><name>ga_len</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><literal type="string">"Heredoc got to end"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_lnum</name></name></expr>;</expr_stmt>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_ufunc</name><operator>-&gt;</operator><name>uf_lines</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<index>[<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_lnum</name></name></expr>]</index></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><enum>enum <block>{

<decl><name>dest_local</name></decl>,

<decl><name>dest_option</name></decl>,

<decl><name>dest_env</name></decl>,

<decl><name>dest_global</name></decl>,

<decl><name>dest_vimvar</name></decl>,

<decl><name>dest_script</name></decl>,

<decl><name>dest_reg</name></decl>,

}</block></enum></type> <name>assign_dest_T</name>;</typedef>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_assignment</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>, <parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>var_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>semicolon</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>varlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>new_local</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>op</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>assign_dest_T</name></type> <name>dest</name> <init>= <expr><name>dest_local</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opt_flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>vimvaridx</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>oplen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>heredoc</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><operator>&amp;</operator><name>t_any</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>lvar_T</name> <modifier>*</modifier></type><name>lvar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_type</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_decl</name> <init>= <expr><name>cmdidx</name> <operator>==</operator> <name>CMD_let</name> <operator>||</operator> <name>cmdidx</name> <operator>==</operator> <name>CMD_const</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>instr_count</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_var_list</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>var_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>semicolon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>var_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><literal type="string">"Cannot handle a list yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name> <operator>&amp;&amp;</operator> <name>p</name> <operator>==</operator> <name>arg</name> <operator>+</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>varlen</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>varlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>!=</operator> <name>TRUE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'&amp;'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>numval</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_option</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmdidx</name> <operator>==</operator> <name>CMD_const</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_const_option</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1052: Cannot declare an option: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_option_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_letunexp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <operator>*</operator><name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>opt_type</name> <operator>=</operator> <call><name>get_option_value</name><argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>numval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_type</name> <operator>==</operator> <operator>-</operator><literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_unknown_option</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>opt_type</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal> <operator>||</operator> <name>opt_type</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_string</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_number</name></expr>;</expr_stmt></block_content></block></else></if_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'$'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_env</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_string</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1065: Cannot declare an environment variable: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'@'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>valid_yank_reg</name><argument_list>(<argument><expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg_invreg</name><argument_list>(<argument><expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_reg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_string</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1066: Cannot declare a register: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"g:"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_global</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1016: Cannot declare a global variable: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"v:"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>vtv</name></decl>;</decl_stmt>

<expr_stmt><expr><name>vimvaridx</name> <operator>=</operator> <call><name>find_vim_var</name><argument_list>(<argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vimvaridx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_var_notfound</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_vimvar</name></expr>;</expr_stmt>

<expr_stmt><expr><name>vtv</name> <operator>=</operator> <call><name>get_vim_var_tv</name><argument_list>(<argument><expr><name>vimvaridx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>typval2type</name><argument_list>(<argument><expr><name>vtv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1064: Cannot declare a v: variable: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>reserved</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name><name>reserved</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1034: Cannot use reserved name %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt></block_content></block></for>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>lookup_local</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1017: Variable already declared: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_const</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1018: Cannot assign to a constant: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="string">"s:"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>lookup_script</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name>

<operator>||</operator> <call><name>find_imported</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>dest</name> <operator>=</operator> <name>dest_script</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_decl</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1054: Variable already declared in the script: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>dest_option</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_decl</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>parse_type</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>has_type</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name><name>lvar</name><operator>-&gt;</operator><name>lv_type</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>op</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>oplen</name> <operator>=</operator> <call><name>assignment_len</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>heredoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><name>sp</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>op</name><index>[<expr><name>oplen</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_white_both</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>==</operator> <literal type="number">3</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>heredoc</name> <operator>&amp;&amp;</operator> <name>dest</name> <operator>!=</operator> <name>dest_global</name>

<operator>&amp;&amp;</operator> <name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_STRING</name> <operator>&amp;&amp;</operator> <name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1019: Can only concatenate to string"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>dest</name> <operator>==</operator> <name>dest_local</name> <operator>&amp;&amp;</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>!=</operator> <name>TRUE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>heredoc</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1020: cannot use an operator on a new variable: %s"</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>reserve_local</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>cmdidx</name> <operator>==</operator> <name>CMD_const</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>new_local</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>heredoc</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>eap</name><operator>-&gt;</operator><name>getline</name></name> <operator>=</operator> <name>heredoc_getline</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>eap</name><operator>-&gt;</operator><name>cookie</name></name> <operator>=</operator> <name>cctx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>heredoc_get</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>op</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>li</name> <operator>=</operator> <name><name>l</name><operator>-&gt;</operator><name>lv_first</name></name></expr>;</init> <condition><expr><name>li</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>li</name> <operator>=</operator> <name><name>li</name><operator>-&gt;</operator><name>li_next</name></name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><call><name>generate_PUSHS</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>generate_NEWLIST</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>l</name><operator>-&gt;</operator><name>lv_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>&amp;</operator><name>t_list_string</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>oplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>stacktype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<switch>switch <condition>(<expr><name>dest</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>dest_option</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADOPT</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_global</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_script</name></expr>:</case>

<expr_stmt><expr><call><name>compile_load_scriptvar</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>,

<argument><expr><name>name</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_env</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADENV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_reg</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOADREG</name></expr></argument>, <argument><expr><name><name>arg</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_vimvar</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOADV</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_local</name></expr>:</case>

<expr_stmt><expr><call><name>generate_LOAD</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_LOAD</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>new_local</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>instr_count</name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>oplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>new_local</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>stacktype</name> <operator>=</operator> <ternary><condition><expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>&amp;</operator><name>t_void</name></expr>

</then><else>: <expr><operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>is_decl</name> <operator>||</operator> <operator>!</operator><name>has_type</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>lvar</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_type</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>stacktype</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>==</operator> <name>VAR_VOID</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1031: Cannot use void value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_type</name></name> <operator>=</operator> <name>stacktype</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else

if <condition>(<expr><call><name>check_type</name><argument_list>(<argument><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_type</name></name></expr></argument>, <argument><expr><name>stacktype</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <call><name>check_type</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>stacktype</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>cmdidx</name> <operator>==</operator> <name>CMD_const</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1021: const requires a value"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>has_type</name> <operator>||</operator> <name>dest</name> <operator>==</operator> <name>dest_option</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1022: type or initialization required"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><name>instr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>type</name><operator>-&gt;</operator><name>tt_type</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>VAR_BOOL</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHBOOL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>VVAL_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_FLOAT</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FLOAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>generate_PUSHF</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>VAR_STRING</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHS</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_BLOB</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHBLOB</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_FUNC</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHFUNC</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_PARTIAL</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHPARTIAL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_LIST</name></expr>:</case>

<expr_stmt><expr><call><name>generate_NEWLIST</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_DICT</name></expr>:</case>

<expr_stmt><expr><call><name>generate_NEWDICT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_JOB</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHJOB</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_CHANNEL</name></expr>:</case>

<expr_stmt><expr><call><name>generate_PUSHCHANNEL</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>VAR_NUMBER</name></expr>:</case>

<case>case <expr><name>VAR_UNKNOWN</name></expr>:</case>

<case>case <expr><name>VAR_VOID</name></expr>:</case>

<case>case <expr><name>VAR_SPECIAL</name></expr>:</case> 

<expr_stmt><expr><call><name>generate_PUSHNR</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>op</name> <operator>!=</operator> <literal type="char">'='</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>expected</name> <init>= <expr><operator>&amp;</operator><name>t_number</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>stacktype</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>expected</name> <operator>=</operator> <operator>&amp;</operator><name>t_string</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>stacktype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>need_type</name><argument_list>(<argument><expr><name>stacktype</name></expr></argument>, <argument><expr><name>expected</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>op</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_CONCAT</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name> <init>= <expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_OPNR</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isn</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>op</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> <expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_ADD</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> <expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_SUB</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_MULT</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'/'</literal></expr>:</case> <expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_DIV</name></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="char">'%'</literal></expr>:</case> <expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>op</name><operator>.</operator><name>op_type</name></name> <operator>=</operator> <name>EXPR_REM</name></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>dest</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>dest_option</name></expr>:</case>

<expr_stmt><expr><call><name>generate_STOREOPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>opt_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_global</name></expr>:</case>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STOREG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_env</name></expr>:</case>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STOREENV</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_reg</name></expr>:</case>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STOREREG</name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_vimvar</name></expr>:</case>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STOREV</name></expr></argument>, <argument><expr><name>vimvaridx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>dest_script</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>rawname</name> <init>= <expr><name>name</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>imported_T</name> <modifier>*</modifier></type><name>import</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sid</name> <init>= <expr><name><name>current_sctx</name><operator>.</operator><name>sc_sid</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>import</name> <operator>=</operator> <call><name>find_imported</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>import</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sid</name> <operator>=</operator> <name><name>import</name><operator>-&gt;</operator><name>imp_sid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>get_script_item_idx</name><argument_list>(<argument><expr><name>sid</name></expr></argument>, <argument><expr><name>rawname</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>generate_OLDSCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORES</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>generate_VIM9SCRIPT</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORESCRIPT</name></expr></argument>,

<argument><expr><name>sid</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>dest_local</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name> <init>= <expr><operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>==</operator> <name>instr_count</name> <operator>+</operator> <literal type="number">1</literal>

<operator>&amp;&amp;</operator> <name><name>isn</name><operator>-&gt;</operator><name>isn_type</name></name> <operator>==</operator> <name>ISN_PUSHNR</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>varnumber_T</name></type> <name>val</name> <init>= <expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>number</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_type</name></name> <operator>=</operator> <name>ISN_STORENR</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storenr</name><operator>.</operator><name>stnr_idx</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storenr</name><operator>.</operator><name>stnr_val</name></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORE</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_import</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>handle_import</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_imports</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>compile_jump_to_end</name><parameter_list>(<parameter><decl><type><name>endlabel_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>jumpwhen_T</name></type> <name>when</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>endlabel</name> <init>= <expr><call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>endlabel_T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>endlabel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>endlabel</name><operator>-&gt;</operator><name>el_next</name></name> <operator>=</operator> <operator>*</operator><name>el</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>el</name> <operator>=</operator> <name>endlabel</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>endlabel</name><operator>-&gt;</operator><name>el_end_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>when</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>compile_fill_jump_to_end</name><parameter_list>(<parameter><decl><type><name>endlabel_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>el</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>el</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><operator>*</operator><name>el</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>cur</name><operator>-&gt;</operator><name>el_end_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>el</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>el_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>compile_free_jump_to_end</name><parameter_list>(<parameter><decl><type><name>endlabel_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>el</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>*</operator><name>el</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><operator>*</operator><name>el</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>el</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>el_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>scope_T</name> <modifier>*</modifier></type>

<name>new_scope</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>scopetype_T</name></type> <name>type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>scope_T</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name> <operator>=</operator> <name>scope</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<return>return <expr><name>scope</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>drop_scope</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><literal type="string">"calling drop_scope() without a scope"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>IF_SCOPE</name></expr>:</case>

<expr_stmt><expr><call><name>compile_free_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_end_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>FOR_SCOPE</name></expr>:</case>

<expr_stmt><expr><call><name>compile_free_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_for</name><operator>.</operator><name>fs_end_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>WHILE_SCOPE</name></expr>:</case>

<expr_stmt><expr><call><name>compile_free_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_end_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>TRY_SCOPE</name></expr>:</case>

<expr_stmt><expr><call><name>compile_free_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_end_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>NO_SCOPE</name></expr>:</case>

<case>case <expr><name>BLOCK_SCOPE</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_expr7</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier><name>cctx</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>start_leader</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end_leader</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>has_call</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>start_leader</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><name>end_leader</name> <operator>=</operator> <operator>*</operator><name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">4</literal></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>ASCII_ISALNUM</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>arg</name><operator>)</operator><index>[<expr><literal type="number">5</literal></expr>]</index></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_SPECIAL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <name>VVAL_FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>+=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><literal type="string">"has("</literal></expr></argument>, <argument><expr><operator>*</operator><name>arg</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>has_call</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_string_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'\''</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_lit_string_tv</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>has_call</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>*</operator><name>arg</name> <operator>!=</operator> <literal type="char">')'</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <operator>*</operator><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>tv</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>v_type</name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_NUMBER</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>f_has</name><argument_list>(<argument><expr><name>argvars</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>start_leader</name> <operator>&lt;</operator> <name>end_leader</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>start_leader</name> <operator>==</operator> <literal type="char">'!'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <operator>!</operator><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>start_leader</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_expr4</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier><name>cctx</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>exptype_T</name></type> <name>type</name> <init>= <expr><name>EXPR_UNKNOWN</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type_is</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr7</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>get_compare_type</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_is</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>EXPR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s1</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf1</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>buf2</name><index>[<expr><name>NUMBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <name>EXPR_EQUAL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>init_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr7</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <name><name>tv2</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>tv_get_string_buf</name><argument_list>(<argument><expr><name>tv</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>tv_get_string_buf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>s1</name></expr></argument>, <argument><expr><name>s2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_BOOL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <ternary><condition><expr><name>n</name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>VVAL_TRUE</name></expr> </then><else>: <expr><name>VVAL_FALSE</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>evaluate_const_expr3</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_and_or</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opchar</name> <init>= <expr><operator>*</operator><name>op</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>tv2bool</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>opchar</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv2</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv2</name><operator>.</operator><name>v_lock</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>opchar</name> <operator>==</operator> <literal type="char">'|'</literal></expr> ?</condition><then> <expr><call><name>evaluate_const_expr3</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>evaluate_const_expr4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>opchar</name> <operator>==</operator> <literal type="char">'&amp;'</literal><operator>)</operator> <operator>==</operator> <name>val</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tv</name> <operator>=</operator> <name>tv2</name></expr>;</expr_stmt>

<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>tv2bool</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_expr3</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr4</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>evaluate_const_and_or</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="string">"&amp;&amp;"</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_expr2</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr3</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>evaluate_const_and_or</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><literal type="string">"||"</literal></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>evaluate_const_expr1</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr2</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>tv2bool</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv2</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">':'</literal> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>arg</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>arg</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tv2</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tv</name> <operator>=</operator> <name>tv2</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_if</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <ternary><condition><expr><call><name>tv2bool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <name>MAYBE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>IF_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_elseif</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name></type> <name>tv</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>IF_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_elseif_without_if</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_end_label</name></name></expr></argument>,

<argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>v_type</name></name> <operator>=</operator> <name>VAR_UNKNOWN</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>evaluate_const_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <ternary><condition><expr><call><name>tv2bool</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>FALSE</name></expr> </then><else>: <expr><name>TRUE</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <name>MAYBE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>clear_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_else</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>IF_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_else_without_if</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_end_label</name></name></expr></argument>,

<argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>==</operator> <name>MAYBE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>!=</operator> <name>MAYBE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <operator>!</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_endif</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ifscope_T</name> <modifier>*</modifier></type><name>ifscope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>IF_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endif_without_if</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ifscope</name> <operator>=</operator> <operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_if</name><operator>.</operator><name>is_if_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_fill_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ifscope</name><operator>-&gt;</operator><name>is_end_label</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_skip</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_for</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>varlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>stack</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_type_stack</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>loop_idx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>var_idx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>type_T</name> <modifier>*</modifier></type><name>vartype</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>arg</name></expr>;</init> <condition><expr><call><name>eval_isnamec1</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<empty_stmt>;</empty_stmt></block_content></block></for>

<expr_stmt><expr><name>varlen</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>var_idx</name> <operator>=</operator> <call><name>lookup_local</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>var_idx</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1023: variable already defined: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRNCMP</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"in"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_missing_in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>FOR_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>loop_idx</name> <operator>=</operator> <call><name>reserve_local</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loop_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>var_idx</name> <operator>=</operator> <call><name>reserve_local</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varlen</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_any</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>var_idx</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>generate_STORENR</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>loop_idx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vartype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>type_T</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>stack</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>stack</name><operator>-&gt;</operator><name>ga_len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vartype</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_LIST</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1024: need a List to iterate over"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vartype</name><operator>-&gt;</operator><name>tt_member</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>lvar_T</name> <modifier>*</modifier></type><name>lvar</name> <init>= <expr><operator>(</operator><operator>(</operator><name>lvar_T</name> <operator>*</operator><operator>)</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_locals</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>var_idx</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>lvar</name><operator>-&gt;</operator><name>lv_type</name></name> <operator>=</operator> <name><name>vartype</name><operator>-&gt;</operator><name>tt_member</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_for</name><operator>.</operator><name>fs_top_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_FOR</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>loop_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_STORE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORE</name></expr></argument>, <argument><expr><name>var_idx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_endfor</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>forscope_T</name> <modifier>*</modifier></type><name>forscope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>FOR_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_for</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>forscope</name> <operator>=</operator> <operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_for</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name><name>forscope</name><operator>-&gt;</operator><name>fs_top_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>forscope</name><operator>-&gt;</operator><name>fs_top_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>forloop</name><operator>.</operator><name>for_end</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_fill_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>forscope</name><operator>-&gt;</operator><name>fs_end_label</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_DROP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_while</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>WHILE_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_top_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_end_label</name></name></expr></argument>,

<argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_endwhile</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>WHILE_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_while</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_top_label</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>compile_fill_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_end_label</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_continue</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_continue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>WHILE_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_ALWAYS</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name></expr> ?</condition><then> <expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_for</name><operator>.</operator><name>fs_top_label</name></name></expr>

</then><else>: <expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_top_label</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_break</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>endlabel_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>el</name></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_break</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>WHILE_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>el</name> <operator>=</operator> <operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_for</name><operator>.</operator><name>fs_end_label</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>el</name> <operator>=</operator> <operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_while</name><operator>.</operator><name>ws_end_label</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_jump_to_end</name><argument_list>(<argument><expr><name>el</name></expr></argument>, <argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_block</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>BLOCK_SCOPE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>compile_endblock</name><parameter_list>(<parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name> <operator>=</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_outer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>unwind_locals</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name><name>scope</name><operator>-&gt;</operator><name>se_local_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>scope</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_try</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>try_scope</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name></decl>;</decl_stmt>

<expr_stmt><expr><name>try_scope</name> <operator>=</operator> <call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>TRY_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>try_scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>try_scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_try_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_TRY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>BLOCK_SCOPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_catch</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier><name>cctx</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>BLOCK_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>compile_endblock</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>TRY_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_catch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_caught_all</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1033: catch unreachable after catch-all"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_end_label</name></name></expr></argument>,

<argument><expr><name>JUMP_ALWAYS</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_try_label</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_catch</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_catch</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_caught_all</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>end</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pat</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tofree</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dropped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>generate_instr_type</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_PUSHEXC</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>t_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>skip_regexp_ex</name><argument_list>(<argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tofree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dropped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>end</name> <operator>!=</operator> <operator>*</operator><name>p</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1067: Separator mismatch: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tofree</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <operator>(</operator><name>p</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>end</name> <operator>-</operator> <name>tofree</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>pat</name> <operator>=</operator> <call><name>vim_strnsave</name><argument_list>(<argument><expr><ternary><condition><expr><name>tofree</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>tofree</name></expr></else></ternary></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>tofree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <name>len</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>dropped</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pat</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_PUSHS</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_COMPARE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>EXPR_MATCH</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_JUMP</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>JUMP_IF_FALSE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_CATCH</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>new_scope</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>BLOCK_SCOPE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_finally</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>BLOCK_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>compile_endblock</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>TRY_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_finally</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_try_label</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_finally</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_finally_dup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_fill_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_end_label</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_finally</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_catch_label</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>jump</name><operator>.</operator><name>jump_where</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_endtry</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>scope_T</name> <modifier>*</modifier></type><name>scope</name> <init>= <expr><name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name> <init>= <expr><operator>&amp;</operator><name><name>cctx</name><operator>-&gt;</operator><name>ctx_instr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>BLOCK_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>compile_endblock</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <name><name>cctx</name><operator>-&gt;</operator><name>ctx_scope</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>!=</operator> <name>TRY_SCOPE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_no_endtry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>WHILE_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endwhile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endfor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endif</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>isn</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_try_label</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_catch</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_finally</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1032: missing :catch or :finally"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>compile_fill_jump_to_end</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scope</name><operator>-&gt;</operator><name>se_u</name><operator>.</operator><name>se_try</name><operator>.</operator><name>ts_end_label</name></name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_finally</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>try</name><operator>.</operator><name>try_finally</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>compile_endblock</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_ENDTRY</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>arg</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_throw</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier><name>cctx</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_argreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>may_generate_2STRING</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>ISN_THROW</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_echo</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>with_white</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>generate_ECHO</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>with_white</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>compile_execute</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>cctx_T</name> <modifier>*</modifier></type><name>cctx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>count</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>generate_EXECUTE</name><argument_list>(<argument><expr><name>cctx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>compile_def_function</name><parameter_list>(<parameter><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>set_return_type</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>exarg_T</name></type> <name>ea</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>errormsg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>had_return</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>cctx_T</name></type> <name>cctx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>garray_T</name> <modifier>*</modifier></type><name>instr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>called_emsg_before</name> <init>= <expr><name>called_emsg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>sctx_T</name></type> <name>save_current_sctx</name> <init>= <expr><name>current_sctx</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>emsg_before</name> <init>= <expr><name>called_emsg</name></expr></init></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>dfunc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>delete_def_function_contents</name><argument_list>(<argument><expr><name>dfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>ga_grow</name><argument_list>(<argument><expr><operator>&amp;</operator><name>def_functions</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>dfunc</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name><name>def_functions</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>dfunc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dfunc_T</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_idx</name></name> <operator>=</operator> <name><name>def_functions</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>=</operator> <name><name>dfunc</name><operator>-&gt;</operator><name>df_idx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_ufunc</name></name> <operator>=</operator> <name>ufunc</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>def_functions</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>.</operator><name>ctx_ufunc</name></name> <operator>=</operator> <name>ufunc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_locals</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lvar_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_type_stack</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>type_T</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_imports</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>imported_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cctx</name><operator>.</operator><name>ctx_type_list</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_type_list</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_init2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_instr</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>isn_T</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>instr</name> <operator>=</operator> <operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_instr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>current_sctx</name><operator>.</operator><name>sc_version</name></name> <operator>=</operator> <name>SCRIPT_VERSION_VIM9</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_args</name><operator>.</operator><name>ga_len</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_args</name><operator>.</operator><name>ga_len</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>off</name> <init>= <expr><name>STACK_FRAME_SIZE</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_va_name</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_arg_idx</name></name> <operator>=</operator> <call><name>ALLOC_CLEAR_MULT</name><argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_arg_idx</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_arg_idx</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><operator>(</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_args</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>generate_STORE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORE</name></expr></argument>,

<argument><expr><name>i</name> <operator>-</operator> <name>count</name> <operator>-</operator> <name>off</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_va_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>generate_NEWLIST</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>generate_STORE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>ISN_STORE</name></expr></argument>, <argument><expr><operator>-</operator><name>off</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_def_arg_idx</name><index>[<expr><name>count</name></expr>]</index></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_ex_command</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>line</name> <operator>==</operator> <literal type="char">'|'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>line</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>line</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>emsg_before</name> <operator>==</operator> <name>called_emsg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E488: Trailing characters: %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<do>do

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name> <operator>==</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_lines</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>char_u</name> <operator>*</operator><operator>*</operator><operator>)</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_lines</name><operator>.</operator><name>ga_data</name></name><operator>)</operator><index>[<expr><name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name></expr>]</index></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name> <operator>==</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_lines</name><operator>.</operator><name>ga_len</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>SOURCING_LNUM</name> <operator>=</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_script_ctx</name><operator>.</operator><name>sc_lnum</name></name> <operator>+</operator> <name><name>cctx</name><operator>.</operator><name>ctx_lnum</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>emsg_before</name> <operator>=</operator> <name>called_emsg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>had_return</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ea</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdlinep</name></name> <operator>=</operator> <operator>&amp;</operator><name>line</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'}'</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>scopetype_T</name></type> <name>stype</name> <init>= <expr><ternary><condition><expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name></name> <operator>==</operator> <name>NULL</name></expr>

?</condition><then> <expr><name>NO_SCOPE</name></expr> </then><else>: <expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name><operator>-&gt;</operator><name>se_type</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stype</name> <operator>==</operator> <name>BLOCK_SCOPE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>compile_endblock</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1025: using } outside of a block scope"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'{'</literal> <operator>&amp;&amp;</operator> <call><name>ends_excmd</name><argument_list>(<argument><expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_block</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>is_ex_command</name> <operator>=</operator> <operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">':'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>parse_command_modifiers</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errormsg</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>errormsg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>checkforcmd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><literal type="string">"call"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_ex_command</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'&amp;'</literal> <operator>||</operator> <operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>||</operator> <operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'@'</literal><operator>)</operator></expr>

?</condition><then> <expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>to_name_end</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&gt;</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>oplen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>heredoc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>oplen</name> <operator>=</operator> <call><name>assignment_len</name><argument_list>(<argument><expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>heredoc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>oplen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'&amp;'</literal>

<operator>||</operator> <operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'$'</literal>

<operator>||</operator> <operator>*</operator><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>==</operator> <literal type="char">'@'</literal>

<operator>||</operator> <operator>(</operator><operator>(</operator><name>p</name> <operator>-</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name><operator>)</operator> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmd</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal><operator>)</operator>

<operator>||</operator> <call><name>lookup_local</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal>

<operator>||</operator> <call><name>lookup_script</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name>

<operator>||</operator> <call><name>find_imported</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><name>p</name> <operator>-</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_assignment</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><name>CMD_SIZE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>=</operator> <call><name>skip_range</name><argument_list>(<argument><expr><name><name>ea</name><operator>.</operator><name>cmd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_ex_command</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><ternary><condition><expr><name>is_ex_command</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>lookup_local</name></expr></else></ternary></expr></argument>,

<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name> <operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_SIZE</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_skip</name></name> <operator>==</operator> <name>TRUE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_eval</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>ea</name><operator>.</operator><name>cmd</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>compile_expr1</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>generate_instr_drop</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>ISN_DROP</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><literal type="string">"Command from find_ex_command() not handled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_skip</name></name> <operator>==</operator> <name>TRUE</name>

<operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_elseif</name>

<operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_else</name>

<operator>&amp;&amp;</operator> <name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_endif</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>+=</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_def</name></expr>:</case>

<case>case <expr><name>CMD_function</name></expr>:</case>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><literal type="string">"Nested function not implemented yet"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>erret</name>;</goto>

<case>case <expr><name>CMD_return</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_return</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>set_return_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>had_return</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_let</name></expr>:</case>

<case>case <expr><name>CMD_const</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_assignment</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_import</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_import</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_if</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_if</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_elseif</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_elseif</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_else</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_else</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_endif</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_endif</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_while</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_while</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_endwhile</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_endwhile</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_for</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_for</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_endfor</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_endfor</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_continue</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_continue</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_break</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_break</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_try</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_try</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_catch</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_catch</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_finally</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_finally</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_endtry</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_endtry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_throw</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_throw</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_echo</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_echo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_echon</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_echo</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_execute</name></expr>:</case>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>compile_execute</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>generate_EXEC</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>erret</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_type_stack</name><operator>.</operator><name>ga_len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>iemsg</name><argument_list>(<argument><expr><literal type="string">"Type stack underflow"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>IF_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endif</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>WHILE_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endwhile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name><operator>-&gt;</operator><name>se_type</name></name> <operator>==</operator> <name>FOR_SCOPE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_endfor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1026: Missing }"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>had_return</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_ret_type</name><operator>-&gt;</operator><name>tt_type</name></name> <operator>!=</operator> <name>VAR_VOID</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1027: Missing return statement"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>erret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>generate_PUSHNR</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>generate_instr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>, <argument><expr><name>ISN_RETURN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_deleted</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_instr</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_instr_count</name></name> <operator>=</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_varcount</name></name> <operator>=</operator> <name><name>cctx</name><operator>.</operator><name>ctx_max_local</name></name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt>

<label><name>erret</name>:</label>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>instr</name><operator>-&gt;</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>delete_instr</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>isn_T</name> <operator>*</operator><operator>)</operator><name><name>instr</name><operator>-&gt;</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dfunc</name><operator>-&gt;</operator><name>df_deleted</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>def_functions</name><operator>.</operator><name>ga_len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>cctx</name><operator>.</operator><name>ctx_scope</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>drop_scope</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<expr_stmt><expr><call><name>ga_clear_strings</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ufunc</name><operator>-&gt;</operator><name>uf_lines</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errormsg</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><name>errormsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>called_emsg</name> <operator>==</operator> <name>called_emsg_before</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E1028: compile_def_function failed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>current_sctx</name> <operator>=</operator> <name>save_current_sctx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_imported</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_local</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cctx</name><operator>.</operator><name>ctx_type_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>delete_instr</name><parameter_list>(<parameter><decl><type><name>isn_T</name> <modifier>*</modifier></type><name>isn</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>isn</name><operator>-&gt;</operator><name>isn_type</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>ISN_EXEC</name></expr>:</case>

<case>case <expr><name>ISN_LOADENV</name></expr>:</case>

<case>case <expr><name>ISN_LOADG</name></expr>:</case>

<case>case <expr><name>ISN_LOADOPT</name></expr>:</case>

<case>case <expr><name>ISN_MEMBER</name></expr>:</case>

<case>case <expr><name>ISN_PUSHEXC</name></expr>:</case>

<case>case <expr><name>ISN_PUSHS</name></expr>:</case>

<case>case <expr><name>ISN_STOREENV</name></expr>:</case>

<case>case <expr><name>ISN_STOREG</name></expr>:</case>

<case>case <expr><name>ISN_PUSHFUNC</name></expr>:</case>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_LOADS</name></expr>:</case>

<case>case <expr><name>ISN_STORES</name></expr>:</case>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>loadstore</name><operator>.</operator><name>ls_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_STOREOPT</name></expr>:</case>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>storeopt</name><operator>.</operator><name>so_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_PUSHBLOB</name></expr>:</case> 

<expr_stmt><expr><call><name>blob_unref</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>blob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_PUSHPARTIAL</name></expr>:</case>

<expr_stmt><expr><call><name>partial_unref</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>partial</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_PUSHJOB</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>job_unref</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>job</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>ISN_PUSHCHANNEL</name></expr>:</case>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_JOB_CHANNEL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>channel_unref</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>channel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<break>break;</break>

<case>case <expr><name>ISN_UCALL</name></expr>:</case>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>isn</name><operator>-&gt;</operator><name>isn_arg</name><operator>.</operator><name>ufunc</name><operator>.</operator><name>cuf_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>ISN_2BOOL</name></expr>:</case>

<case>case <expr><name>ISN_2STRING</name></expr>:</case>

<case>case <expr><name>ISN_ADDBLOB</name></expr>:</case>

<case>case <expr><name>ISN_ADDLIST</name></expr>:</case>

<case>case <expr><name>ISN_BCALL</name></expr>:</case>

<case>case <expr><name>ISN_CATCH</name></expr>:</case>

<case>case <expr><name>ISN_CHECKNR</name></expr>:</case>

<case>case <expr><name>ISN_CHECKTYPE</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREANY</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREBLOB</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREBOOL</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREDICT</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREFLOAT</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREFUNC</name></expr>:</case>

<case>case <expr><name>ISN_COMPARELIST</name></expr>:</case>

<case>case <expr><name>ISN_COMPARENR</name></expr>:</case>

<case>case <expr><name>ISN_COMPAREPARTIAL</name></expr>:</case>

<case>case <expr><name>ISN_COMPARESPECIAL</name></expr>:</case>

<case>case <expr><name>ISN_COMPARESTRING</name></expr>:</case>

<case>case <expr><name>ISN_CONCAT</name></expr>:</case>

<case>case <expr><name>ISN_DCALL</name></expr>:</case>

<case>case <expr><name>ISN_DROP</name></expr>:</case>

<case>case <expr><name>ISN_ECHO</name></expr>:</case>

<case>case <expr><name>ISN_EXECUTE</name></expr>:</case>

<case>case <expr><name>ISN_ENDTRY</name></expr>:</case>

<case>case <expr><name>ISN_FOR</name></expr>:</case>

<case>case <expr><name>ISN_FUNCREF</name></expr>:</case>

<case>case <expr><name>ISN_INDEX</name></expr>:</case>

<case>case <expr><name>ISN_JUMP</name></expr>:</case>

<case>case <expr><name>ISN_LOAD</name></expr>:</case>

<case>case <expr><name>ISN_LOADSCRIPT</name></expr>:</case>

<case>case <expr><name>ISN_LOADREG</name></expr>:</case>

<case>case <expr><name>ISN_LOADV</name></expr>:</case>

<case>case <expr><name>ISN_NEGATENR</name></expr>:</case>

<case>case <expr><name>ISN_NEWDICT</name></expr>:</case>

<case>case <expr><name>ISN_NEWLIST</name></expr>:</case>

<case>case <expr><name>ISN_OPNR</name></expr>:</case>

<case>case <expr><name>ISN_OPFLOAT</name></expr>:</case>

<case>case <expr><name>ISN_OPANY</name></expr>:</case>

<case>case <expr><name>ISN_PCALL</name></expr>:</case>

<case>case <expr><name>ISN_PCALL_END</name></expr>:</case>

<case>case <expr><name>ISN_PUSHF</name></expr>:</case>

<case>case <expr><name>ISN_PUSHNR</name></expr>:</case>

<case>case <expr><name>ISN_PUSHBOOL</name></expr>:</case>

<case>case <expr><name>ISN_PUSHSPEC</name></expr>:</case>

<case>case <expr><name>ISN_RETURN</name></expr>:</case>

<case>case <expr><name>ISN_STORE</name></expr>:</case>

<case>case <expr><name>ISN_STOREV</name></expr>:</case>

<case>case <expr><name>ISN_STORENR</name></expr>:</case>

<case>case <expr><name>ISN_STOREREG</name></expr>:</case>

<case>case <expr><name>ISN_STORESCRIPT</name></expr>:</case>

<case>case <expr><name>ISN_THROW</name></expr>:</case>

<case>case <expr><name>ISN_TRY</name></expr>:</case>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>delete_def_function_contents</name><parameter_list>(<parameter><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>dfunc</name><operator>-&gt;</operator><name>df_def_args_isn</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_instr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>dfunc</name><operator>-&gt;</operator><name>df_instr_count</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>delete_instr</name><argument_list>(<argument><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_instr</name></name> <operator>+</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_instr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dfunc</name><operator>-&gt;</operator><name>df_deleted</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>delete_def_function</name><parameter_list>(<parameter><decl><type><name>ufunc_T</name> <modifier>*</modifier></type><name>ufunc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator>

<operator>+</operator> <name><name>ufunc</name><operator>-&gt;</operator><name>uf_dfunc_idx</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>delete_def_function_contents</name><argument_list>(<argument><expr><name>dfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>free_def_functions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>def_functions</name><operator>.</operator><name>ga_len</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>dfunc_T</name> <modifier>*</modifier></type><name>dfunc</name> <init>= <expr><operator>(</operator><operator>(</operator><name>dfunc_T</name> <operator>*</operator><operator>)</operator><name><name>def_functions</name><operator>.</operator><name>ga_data</name></name><operator>)</operator> <operator>+</operator> <name>idx</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>delete_def_function_contents</name><argument_list>(<argument><expr><name>dfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>ga_clear</name><argument_list>(<argument><expr><operator>&amp;</operator><name>def_functions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</unit>
