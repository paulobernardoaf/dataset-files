
































































#include "vim.h"

static void win_update(win_T *wp);
#ifdef FEAT_STL_OPT
static void redraw_custom_statusline(win_T *wp);
#endif
#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
static int did_update_one_window;
#endif






int
update_screen(int type_arg)
{
int type = type_arg;
win_T *wp;
static int did_intro = FALSE;
#ifdef FEAT_GUI
int did_one = FALSE;
int did_undraw = FALSE;
int gui_cursor_col = 0;
int gui_cursor_row = 0;
#endif
int no_update = FALSE;


if (!screen_valid(TRUE))
return FAIL;

if (type == VALID_NO_UPDATE)
{
no_update = TRUE;
type = 0;
}

#ifdef FEAT_EVAL
{
buf_T *buf;


FOR_ALL_BUFFERS(buf)
invoke_listeners(buf);
}
#endif

#ifdef FEAT_DIFF

if (need_diff_redraw)
diff_redraw(TRUE);
#endif

if (must_redraw)
{
if (type < must_redraw) 
type = must_redraw;





must_redraw = 0;
}


if (curwin->w_lines_valid == 0 && type < NOT_VALID
#ifdef FEAT_TERMINAL
&& !term_do_update_window(curwin)
#endif
)
type = NOT_VALID;



if (!redrawing() || updating_screen)
{
redraw_later(type); 
must_redraw = type;
if (type > INVERTED_ALL)
curwin->w_lines_valid = 0; 
return FAIL;
}
updating_screen = TRUE;

#ifdef FEAT_PROP_POPUP


may_update_popup_mask(type);
#endif

#ifdef FEAT_SYN_HL
++display_tick; 

#endif
if (no_update)
++no_win_do_lines_ins;


if (msg_scrolled)
{
clear_cmdline = TRUE;
if (msg_scrolled > Rows - 5) 
type = CLEAR;
else if (type != CLEAR)
{
check_for_delay(FALSE);
if (screen_ins_lines(0, 0, msg_scrolled, (int)Rows, 0, NULL)
== FAIL)
type = CLEAR;
FOR_ALL_WINDOWS(wp)
{
if (wp->w_winrow < msg_scrolled)
{
if (W_WINROW(wp) + wp->w_height > msg_scrolled
&& wp->w_redr_type < REDRAW_TOP
&& wp->w_lines_valid > 0
&& wp->w_topline == wp->w_lines[0].wl_lnum)
{
wp->w_upd_rows = msg_scrolled - W_WINROW(wp);
wp->w_redr_type = REDRAW_TOP;
}
else
{
wp->w_redr_type = NOT_VALID;
if (W_WINROW(wp) + wp->w_height + wp->w_status_height
<= msg_scrolled)
wp->w_redr_status = TRUE;
}
}
}
if (!no_update)
redraw_cmdline = TRUE;
redraw_tabline = TRUE;
}
msg_scrolled = 0;
need_wait_return = FALSE;
}


compute_cmdrow();


if (need_highlight_changed)
highlight_changed();

if (type == CLEAR) 
{
screenclear(); 
type = NOT_VALID;

must_redraw = 0;
}

if (clear_cmdline) 
check_for_delay(FALSE);

#ifdef FEAT_LINEBREAK


if (curwin->w_redr_type < NOT_VALID
&& curwin->w_nrwidth != ((curwin->w_p_nu || curwin->w_p_rnu)
? number_width(curwin) : 0))
curwin->w_redr_type = NOT_VALID;
#endif


if (type == INVERTED)
update_curswant();
if (curwin->w_redr_type < type
&& !((type == VALID
&& curwin->w_lines[0].wl_valid
#ifdef FEAT_DIFF
&& curwin->w_topfill == curwin->w_old_topfill
&& curwin->w_botfill == curwin->w_old_botfill
#endif
&& curwin->w_topline == curwin->w_lines[0].wl_lnum)
|| (type == INVERTED
&& VIsual_active
&& curwin->w_old_cursor_lnum == curwin->w_cursor.lnum
&& curwin->w_old_visual_mode == VIsual_mode
&& (curwin->w_valid & VALID_VIRTCOL)
&& curwin->w_old_curswant == curwin->w_curswant)
))
curwin->w_redr_type = type;


if (redraw_tabline || type >= NOT_VALID)
draw_tabline();

#ifdef FEAT_SYN_HL


FOR_ALL_WINDOWS(wp)
{
if (wp->w_buffer->b_mod_set)
{
win_T *wwp;


for (wwp = firstwin; wwp != wp; wwp = wwp->w_next)
if (wwp->w_buffer == wp->w_buffer)
break;
if (wwp == wp && syntax_present(wp))
syn_stack_apply_changes(wp->w_buffer);
}
}
#endif



#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)
did_update_one_window = FALSE;
#endif
#ifdef FEAT_SEARCH_EXTRA
screen_search_hl.rm.regprog = NULL;
#endif
FOR_ALL_WINDOWS(wp)
{
if (wp->w_redr_type != 0)
{
cursor_off();
#ifdef FEAT_GUI
if (!did_one)
{
did_one = TRUE;




if (gui.in_use && wp == curwin)
{
gui_cursor_col = gui.cursor_col;
gui_cursor_row = gui.cursor_row;
gui_undraw_cursor();
did_undraw = TRUE;
}
}
#endif

win_update(wp);
}


if (wp->w_redr_status)
{
cursor_off();
win_redr_status(wp, TRUE); 
}
}
#if defined(FEAT_SEARCH_EXTRA)
end_search_hl();
#endif

pum_may_redraw();



FOR_ALL_WINDOWS(wp)
wp->w_buffer->b_mod_set = FALSE;

#ifdef FEAT_PROP_POPUP

update_popups(win_update);
#endif

after_updating_screen(TRUE);



if (clear_cmdline || redraw_cmdline || redraw_mode)
showmode();

if (no_update)
--no_win_do_lines_ins;


if (!did_intro)
maybe_intro_message();
did_intro = TRUE;

#ifdef FEAT_GUI


if (gui.in_use)
{
if (did_undraw && !gui_mch_is_blink_off())
{
mch_disable_flush();
out_flush(); 
mch_enable_flush();



gui.col = gui_cursor_col;
gui.row = gui_cursor_row;
gui.col = mb_fix_col(gui.col, gui.row);
gui_update_cursor(FALSE, FALSE);
gui_may_flush();
screen_cur_col = gui.col;
screen_cur_row = gui.row;
}
else
out_flush();
gui_update_scrollbars(FALSE);
}
#endif
return OK;
}








void
win_redr_status(win_T *wp, int ignore_pum UNUSED)
{
int row;
char_u *p;
int len;
int fillchar;
int attr;
int this_ru_col;
static int busy = FALSE;



if (busy)
return;
busy = TRUE;

wp->w_redr_status = FALSE;
if (wp->w_status_height == 0)
{

redraw_cmdline = TRUE;
}
else if (!redrawing()


|| (!ignore_pum && pum_visible()))
{

wp->w_redr_status = TRUE;
}
#ifdef FEAT_STL_OPT
else if (*p_stl != NUL || *wp->w_p_stl != NUL)
{

redraw_custom_statusline(wp);
}
#endif
else
{
fillchar = fillchar_status(&attr, wp);

get_trans_bufname(wp->w_buffer);
p = NameBuff;
len = (int)STRLEN(p);

if (bt_help(wp->w_buffer)
#ifdef FEAT_QUICKFIX
|| wp->w_p_pvw
#endif
|| bufIsChanged(wp->w_buffer)
|| wp->w_buffer->b_p_ro)
*(p + len++) = ' ';
if (bt_help(wp->w_buffer))
{
STRCPY(p + len, _("[Help]"));
len += (int)STRLEN(p + len);
}
#ifdef FEAT_QUICKFIX
if (wp->w_p_pvw)
{
STRCPY(p + len, _("[Preview]"));
len += (int)STRLEN(p + len);
}
#endif
if (bufIsChanged(wp->w_buffer)
#ifdef FEAT_TERMINAL
&& !bt_terminal(wp->w_buffer)
#endif
)
{
STRCPY(p + len, "[+]");
len += 3;
}
if (wp->w_buffer->b_p_ro)
{
STRCPY(p + len, _("[RO]"));
len += (int)STRLEN(p + len);
}

this_ru_col = ru_col - (Columns - wp->w_width);
if (this_ru_col < (wp->w_width + 1) / 2)
this_ru_col = (wp->w_width + 1) / 2;
if (this_ru_col <= 1)
{
p = (char_u *)"<"; 
len = 1;
}
else if (has_mbyte)
{
int clen = 0, i;


clen = mb_string2cells(p, -1);



for (i = 0; p[i] != NUL && clen >= this_ru_col - 1;
i += (*mb_ptr2len)(p + i))
clen -= (*mb_ptr2cells)(p + i);
len = clen;
if (i > 0)
{
p = p + i - 1;
*p = '<';
++len;
}

}
else if (len > this_ru_col - 1)
{
p += len - (this_ru_col - 1);
*p = '<';
len = this_ru_col - 1;
}

row = W_WINROW(wp) + wp->w_height;
screen_puts(p, row, wp->w_wincol, attr);
screen_fill(row, row + 1, len + wp->w_wincol,
this_ru_col + wp->w_wincol, fillchar, fillchar, attr);

if (get_keymap_str(wp, (char_u *)"<%s>", NameBuff, MAXPATHL)
&& (int)(this_ru_col - len) > (int)(STRLEN(NameBuff) + 1))
screen_puts(NameBuff, row, (int)(this_ru_col - STRLEN(NameBuff)
- 1 + wp->w_wincol), attr);

#ifdef FEAT_CMDL_INFO
win_redr_ruler(wp, TRUE, ignore_pum);
#endif
}




if (wp->w_vsep_width != 0 && wp->w_status_height != 0 && redrawing())
{
if (stl_connected(wp))
fillchar = fillchar_status(&attr, wp);
else
fillchar = fillchar_vsep(&attr);
screen_putchar(fillchar, W_WINROW(wp) + wp->w_height, W_ENDCOL(wp),
attr);
}
busy = FALSE;
}

#ifdef FEAT_STL_OPT




static void
redraw_custom_statusline(win_T *wp)
{
static int entered = FALSE;
int saved_did_emsg = did_emsg;



if (entered)
return;
entered = TRUE;

did_emsg = FALSE;
win_redr_custom(wp, FALSE);
if (did_emsg)
{



set_string_option_direct((char_u *)"statusline", -1,
(char_u *)"", OPT_FREE | (*wp->w_p_stl != NUL
? OPT_LOCAL : OPT_GLOBAL), SID_ERROR);
}
did_emsg |= saved_did_emsg;
entered = FALSE;
}
#endif





void
showruler(int always)
{
if (!always && !redrawing())
return;
if (pum_visible())
{

curwin->w_redr_status = TRUE;
return;
}
#if defined(FEAT_STL_OPT)
if ((*p_stl != NUL || *curwin->w_p_stl != NUL) && curwin->w_status_height)
redraw_custom_statusline(curwin);
else
#endif
#ifdef FEAT_CMDL_INFO
win_redr_ruler(curwin, always, FALSE);
#endif

#ifdef FEAT_TITLE
if (need_maketitle
#ifdef FEAT_STL_OPT
|| (p_icon && (stl_syntax & STL_IN_ICON))
|| (p_title && (stl_syntax & STL_IN_TITLE))
#endif
)
maketitle();
#endif

if (redraw_tabline)
draw_tabline();
}

#if defined(FEAT_CMDL_INFO) || defined(PROTO)
void
win_redr_ruler(win_T *wp, int always, int ignore_pum)
{
#define RULER_BUF_LEN 70
char_u buffer[RULER_BUF_LEN];
int row;
int fillchar;
int attr;
int empty_line = FALSE;
colnr_T virtcol;
int i;
size_t len;
int o;
int this_ru_col;
int off = 0;
int width;


if (!p_ru)
return;





if (wp->w_cursor.lnum > wp->w_buffer->b_ml.ml_line_count)
return;



if (wp == lastwin && lastwin->w_status_height == 0)
if (edit_submode != NULL)
return;


if (!ignore_pum && pum_visible())
return;

#ifdef FEAT_STL_OPT
if (*p_ruf)
{
int called_emsg_before = called_emsg;

win_redr_custom(wp, TRUE);
if (called_emsg > called_emsg_before)
set_string_option_direct((char_u *)"rulerformat", -1,
(char_u *)"", OPT_FREE, SID_ERROR);
return;
}
#endif




if (!(State & INSERT)
&& *ml_get_buf(wp->w_buffer, wp->w_cursor.lnum, FALSE) == NUL)
empty_line = TRUE;




validate_virtcol_win(wp);
if ( redraw_cmdline
|| always
|| wp->w_cursor.lnum != wp->w_ru_cursor.lnum
|| wp->w_cursor.col != wp->w_ru_cursor.col
|| wp->w_virtcol != wp->w_ru_virtcol
|| wp->w_cursor.coladd != wp->w_ru_cursor.coladd
|| wp->w_topline != wp->w_ru_topline
|| wp->w_buffer->b_ml.ml_line_count != wp->w_ru_line_count
#ifdef FEAT_DIFF
|| wp->w_topfill != wp->w_ru_topfill
#endif
|| empty_line != wp->w_ru_empty)
{
cursor_off();
if (wp->w_status_height)
{
row = W_WINROW(wp) + wp->w_height;
fillchar = fillchar_status(&attr, wp);
off = wp->w_wincol;
width = wp->w_width;
}
else
{
row = Rows - 1;
fillchar = ' ';
attr = 0;
width = Columns;
off = 0;
}


virtcol = wp->w_virtcol;
if (wp->w_p_list && lcs_tab1 == NUL)
{
wp->w_p_list = FALSE;
getvvcol(wp, &wp->w_cursor, NULL, &virtcol, NULL);
wp->w_p_list = TRUE;
}





vim_snprintf((char *)buffer, RULER_BUF_LEN, "%ld,",
(wp->w_buffer->b_ml.ml_flags & ML_EMPTY)
? 0L
: (long)(wp->w_cursor.lnum));
len = STRLEN(buffer);
col_print(buffer + len, RULER_BUF_LEN - len,
empty_line ? 0 : (int)wp->w_cursor.col + 1,
(int)virtcol + 1);






i = (int)STRLEN(buffer);
get_rel_pos(wp, buffer + i + 1, RULER_BUF_LEN - i - 1);
o = i + vim_strsize(buffer + i + 1);
if (wp->w_status_height == 0) 
++o;
this_ru_col = ru_col - (Columns - width);
if (this_ru_col < 0)
this_ru_col = 0;


if (this_ru_col < (width + 1) / 2)
this_ru_col = (width + 1) / 2;
if (this_ru_col + o < width)
{

while (this_ru_col + o < width && RULER_BUF_LEN > i + 4)
{
if (has_mbyte)
i += (*mb_char2bytes)(fillchar, buffer + i);
else
buffer[i++] = fillchar;
++o;
}
get_rel_pos(wp, buffer + i, RULER_BUF_LEN - i);
}

if (has_mbyte)
{
o = 0;
for (i = 0; buffer[i] != NUL; i += (*mb_ptr2len)(buffer + i))
{
o += (*mb_ptr2cells)(buffer + i);
if (this_ru_col + o > width)
{
buffer[i] = NUL;
break;
}
}
}
else if (this_ru_col + (int)STRLEN(buffer) > width)
buffer[width - this_ru_col] = NUL;

screen_puts(buffer, row, this_ru_col + off, attr);
i = redraw_cmdline;
screen_fill(row, row + 1,
this_ru_col + off + (int)STRLEN(buffer),
(int)(off + width),
fillchar, fillchar, attr);

redraw_cmdline = i;
wp->w_ru_cursor = wp->w_cursor;
wp->w_ru_virtcol = wp->w_virtcol;
wp->w_ru_empty = empty_line;
wp->w_ru_topline = wp->w_topline;
wp->w_ru_line_count = wp->w_buffer->b_ml.ml_line_count;
#ifdef FEAT_DIFF
wp->w_ru_topfill = wp->w_topfill;
#endif
}
}
#endif





void
after_updating_screen(int may_resize_shell UNUSED)
{
updating_screen = FALSE;
#ifdef FEAT_GUI
if (may_resize_shell)
gui_may_resize_shell();
#endif
#ifdef FEAT_TERMINAL
term_check_channel_closed_recently();
#endif

#ifdef HAVE_DROP_FILE


handle_any_postponed_drop();
#endif
}




void
update_curbuf(int type)
{
redraw_curbuf_later(type);
update_screen(type);
}

#if defined(FEAT_MENU) || defined(FEAT_FOLDING)




static int
text_to_screenline(win_T *wp, char_u *text, int col)
{
int off = (int)(current_ScreenLine - ScreenLines);

if (has_mbyte)
{
int cells;
int u8c, u8cc[MAX_MCO];
int i;
int idx;
int c_len;
char_u *p;
#ifdef FEAT_ARABIC
int prev_c = 0; 
int prev_c1 = 0; 
#endif

#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)
idx = off;
else
#endif
idx = off + col;


for (p = text; *p != NUL; )
{
cells = (*mb_ptr2cells)(p);
c_len = (*mb_ptr2len)(p);
if (col + cells > wp->w_width
#ifdef FEAT_RIGHTLEFT
- (wp->w_p_rl ? col : 0)
#endif
)
break;
ScreenLines[idx] = *p;
if (enc_utf8)
{
u8c = utfc_ptr2char(p, u8cc);
if (*p < 0x80 && u8cc[0] == 0)
{
ScreenLinesUC[idx] = 0;
#ifdef FEAT_ARABIC
prev_c = u8c;
#endif
}
else
{
#ifdef FEAT_ARABIC
if (p_arshape && !p_tbidi && ARABIC_CHAR(u8c))
{

int pc, pc1, nc;
int pcc[MAX_MCO];
int firstbyte = *p;



if (wp->w_p_rl)
{
pc = prev_c;
pc1 = prev_c1;
nc = utf_ptr2char(p + c_len);
prev_c1 = u8cc[0];
}
else
{
pc = utfc_ptr2char(p + c_len, pcc);
nc = prev_c;
pc1 = pcc[0];
}
prev_c = u8c;

u8c = arabic_shape(u8c, &firstbyte, &u8cc[0],
pc, pc1, nc);
ScreenLines[idx] = firstbyte;
}
else
prev_c = u8c;
#endif

ScreenLinesUC[idx] = u8c;
for (i = 0; i < Screen_mco; ++i)
{
ScreenLinesC[i][idx] = u8cc[i];
if (u8cc[i] == 0)
break;
}
}
if (cells > 1)
ScreenLines[idx + 1] = 0;
}
else if (enc_dbcs == DBCS_JPNU && *p == 0x8e)

ScreenLines2[idx] = p[1];
else if (cells > 1)

ScreenLines[idx + 1] = p[1];
col += cells;
idx += cells;
p += c_len;
}
}
else
{
int len = (int)STRLEN(text);

if (len > wp->w_width - col)
len = wp->w_width - col;
if (len > 0)
{
#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)
mch_memmove(current_ScreenLine, text, len);
else
#endif
mch_memmove(current_ScreenLine + col, text, len);
col += len;
}
}
return col;
}
#endif

#ifdef FEAT_MENU



static void
redraw_win_toolbar(win_T *wp)
{
vimmenu_T *menu;
int item_idx = 0;
int item_count = 0;
int col = 0;
int next_col;
int off = (int)(current_ScreenLine - ScreenLines);
int fill_attr = syn_name2attr((char_u *)"ToolbarLine");
int button_attr = syn_name2attr((char_u *)"ToolbarButton");

vim_free(wp->w_winbar_items);
for (menu = wp->w_winbar->children; menu != NULL; menu = menu->next)
++item_count;
wp->w_winbar_items = ALLOC_CLEAR_MULT(winbar_item_T, item_count + 1);


for (menu = wp->w_winbar->children;
menu != NULL && col < wp->w_width; menu = menu->next)
{
space_to_screenline(off + col, fill_attr);
if (++col >= wp->w_width)
break;
if (col > 1)
{
space_to_screenline(off + col, fill_attr);
if (++col >= wp->w_width)
break;
}

wp->w_winbar_items[item_idx].wb_startcol = col;
space_to_screenline(off + col, button_attr);
if (++col >= wp->w_width)
break;

next_col = text_to_screenline(wp, menu->name, col);
while (col < next_col)
{
ScreenAttrs[off + col] = button_attr;
++col;
}
wp->w_winbar_items[item_idx].wb_endcol = col;
wp->w_winbar_items[item_idx].wb_menu = menu;
++item_idx;

if (col >= wp->w_width)
break;
space_to_screenline(off + col, button_attr);
++col;
}
while (col < wp->w_width)
{
space_to_screenline(off + col, fill_attr);
++col;
}
wp->w_winbar_items[item_idx].wb_menu = NULL; 

screen_line(wp->w_winrow, wp->w_wincol, (int)wp->w_width,
(int)wp->w_width, 0);
}
#endif

#if defined(FEAT_FOLDING) || defined(PROTO)



static void
copy_text_attr(
int off,
char_u *buf,
int len,
int attr)
{
int i;

mch_memmove(ScreenLines + off, buf, (size_t)len);
if (enc_utf8)
vim_memset(ScreenLinesUC + off, 0, sizeof(u8char_T) * (size_t)len);
for (i = 0; i < len; ++i)
ScreenAttrs[off + i] = attr;
}




static void
fold_line(
win_T *wp,
long fold_count,
foldinfo_T *foldinfo,
linenr_T lnum,
int row)
{
char_u buf[FOLD_TEXT_LEN];
pos_T *top, *bot;
linenr_T lnume = lnum + fold_count - 1;
int len;
char_u *text;
int fdc;
int col;
int txtcol;
int off = (int)(current_ScreenLine - ScreenLines);
int ri;








col = 0;



#ifdef FEAT_CMDWIN
if (cmdwin_type != 0 && wp == curwin)
{
ScreenLines[off] = cmdwin_type;
ScreenAttrs[off] = HL_ATTR(HLF_AT);
if (enc_utf8)
ScreenLinesUC[off] = 0;
++col;
}
#endif



fdc = compute_foldcolumn(wp, col);
if (fdc > 0)
{
fill_foldcolumn(buf, wp, TRUE, lnum);
#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)
{
int i;

copy_text_attr(off + wp->w_width - fdc - col, buf, fdc,
HL_ATTR(HLF_FC));

for (i = 0; i < fdc; ++i)
ScreenLines[off + wp->w_width - i - 1 - col] = buf[i];
}
else
#endif
copy_text_attr(off + col, buf, fdc, HL_ATTR(HLF_FC));
col += fdc;
}

#ifdef FEAT_RIGHTLEFT
#define RL_MEMSET(p, v, l) do { if (wp->w_p_rl) for (ri = 0; ri < l; ++ri) ScreenAttrs[off + (wp->w_width - (p) - (l)) + ri] = v; else for (ri = 0; ri < l; ++ri) ScreenAttrs[off + (p) + ri] = v; } while (0)








#else
#define RL_MEMSET(p, v, l) do { for (ri = 0; ri < l; ++ri) ScreenAttrs[off + (p) + ri] = v; } while (0)




#endif



RL_MEMSET(col, HL_ATTR(HLF_FL), wp->w_width - col);

#ifdef FEAT_SIGNS

if (signcolumn_on(wp))
{
len = wp->w_width - col;
if (len > 0)
{
if (len > 2)
len = 2;
#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)

copy_text_attr(off + wp->w_width - len - col,
(char_u *)" ", len, HL_ATTR(HLF_FL));
else
#endif
copy_text_attr(off + col, (char_u *)" ", len, HL_ATTR(HLF_FL));
col += len;
}
}
#endif


if (wp->w_p_nu || wp->w_p_rnu)
{
len = wp->w_width - col;
if (len > 0)
{
int w = number_width(wp);
long num;
char *fmt = "%*ld ";

if (len > w + 1)
len = w + 1;

if (wp->w_p_nu && !wp->w_p_rnu)

num = (long)lnum;
else
{

num = labs((long)get_cursor_rel_lnum(wp, lnum));
if (num == 0 && wp->w_p_nu && wp->w_p_rnu)
{


num = lnum;
fmt = "%-*ld ";
}
}

sprintf((char *)buf, fmt, w, num);
#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)

copy_text_attr(off + wp->w_width - len - col, buf, len,
HL_ATTR(HLF_FL));
else
#endif
copy_text_attr(off + col, buf, len, HL_ATTR(HLF_FL));
col += len;
}
}


text = get_foldtext(wp, lnum, lnume, foldinfo, buf);

txtcol = col; 




col = text_to_screenline(wp, text, col);


#ifdef FEAT_RIGHTLEFT
if (wp->w_p_rl)
col -= txtcol;
#endif
while (col < wp->w_width
#ifdef FEAT_RIGHTLEFT
- (wp->w_p_rl ? txtcol : 0)
#endif
)
{
if (enc_utf8)
{
if (fill_fold >= 0x80)
{
ScreenLinesUC[off + col] = fill_fold;
ScreenLinesC[0][off + col] = 0;
ScreenLines[off + col] = 0x80; 
}
else
{
ScreenLinesUC[off + col] = 0;
ScreenLines[off + col] = fill_fold;
}
col++;
}
else
ScreenLines[off + col++] = fill_fold;
}

if (text != buf)
vim_free(text);



if (VIsual_active && wp->w_buffer == curwin->w_buffer)
{
if (LTOREQ_POS(curwin->w_cursor, VIsual))
{

top = &curwin->w_cursor;
bot = &VIsual;
}
else
{

top = &VIsual;
bot = &curwin->w_cursor;
}
if (lnum >= top->lnum
&& lnume <= bot->lnum
&& (VIsual_mode != 'v'
|| ((lnum > top->lnum
|| (lnum == top->lnum
&& top->col == 0))
&& (lnume < bot->lnum
|| (lnume == bot->lnum
&& (bot->col - (*p_sel == 'e'))
>= (colnr_T)STRLEN(ml_get_buf(wp->w_buffer, lnume, FALSE)))))))
{
if (VIsual_mode == Ctrl_V)
{

if (wp->w_old_cursor_fcol + txtcol < (colnr_T)wp->w_width)
{
if (wp->w_old_cursor_lcol != MAXCOL
&& wp->w_old_cursor_lcol + txtcol
< (colnr_T)wp->w_width)
len = wp->w_old_cursor_lcol;
else
len = wp->w_width - txtcol;
RL_MEMSET(wp->w_old_cursor_fcol + txtcol, HL_ATTR(HLF_V),
len - (int)wp->w_old_cursor_fcol);
}
}
else
{

RL_MEMSET(txtcol, HL_ATTR(HLF_V), wp->w_width - txtcol);
}
}
}

#ifdef FEAT_SYN_HL

if (wp->w_p_cc_cols)
{
int i = 0;
int j = wp->w_p_cc_cols[i];
int old_txtcol = txtcol;

while (j > -1)
{
txtcol += j;
if (wp->w_p_wrap)
txtcol -= wp->w_skipcol;
else
txtcol -= wp->w_leftcol;
if (txtcol >= 0 && txtcol < wp->w_width)
ScreenAttrs[off + txtcol] = hl_combine_attr(
ScreenAttrs[off + txtcol], HL_ATTR(HLF_MC));
txtcol = old_txtcol;
j = wp->w_p_cc_cols[++i];
}
}


if (wp->w_p_cuc)
{
txtcol += wp->w_virtcol;
if (wp->w_p_wrap)
txtcol -= wp->w_skipcol;
else
txtcol -= wp->w_leftcol;
if (txtcol >= 0 && txtcol < wp->w_width)
ScreenAttrs[off + txtcol] = hl_combine_attr(
ScreenAttrs[off + txtcol], HL_ATTR(HLF_CUC));
}
#endif

screen_line(row + W_WINROW(wp), wp->w_wincol, (int)wp->w_width,
(int)wp->w_width, 0);



if (wp == curwin
&& lnum <= curwin->w_cursor.lnum
&& lnume >= curwin->w_cursor.lnum)
{
curwin->w_cline_row = row;
curwin->w_cline_height = 1;
curwin->w_cline_folded = TRUE;
curwin->w_valid |= (VALID_CHEIGHT|VALID_CROW);
}
}
#endif




























static void
win_update(win_T *wp)
{
buf_T *buf = wp->w_buffer;
int type;
int top_end = 0; 

int mid_start = 999;

int mid_end = 0; 

int bot_start = 999;

int scrolled_down = FALSE; 

#ifdef FEAT_SEARCH_EXTRA
int top_to_mod = FALSE; 
#endif

int row; 
linenr_T lnum; 
int idx; 
int srow; 

int eof = FALSE; 
int didline = FALSE; 
int i;
long j;
static int recursive = FALSE; 
linenr_T old_botline = wp->w_botline;
#ifdef FEAT_CONCEAL
int old_wrow = wp->w_wrow;
int old_wcol = wp->w_wcol;
#endif
#ifdef FEAT_FOLDING
long fold_count;
#endif
#ifdef FEAT_SYN_HL


#define DID_NONE 1 
#define DID_LINE 2 
#define DID_FOLD 3 
int did_update = DID_NONE;
linenr_T syntax_last_parsed = 0; 
#endif
linenr_T mod_top = 0;
linenr_T mod_bot = 0;
#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)
int save_got_int;
#endif
#ifdef SYN_TIME_LIMIT
proftime_T syntax_tm;
#endif

#if defined(FEAT_SEARCH_EXTRA) || defined(FEAT_CLIPBOARD)


if (!did_update_one_window)
{
did_update_one_window = TRUE;
#ifdef FEAT_SEARCH_EXTRA
start_search_hl();
#endif
#ifdef FEAT_CLIPBOARD

if (clip_star.available && clip_isautosel_star())
clip_update_selection(&clip_star);
if (clip_plus.available && clip_isautosel_plus())
clip_update_selection(&clip_plus);
#endif
}
#endif

type = wp->w_redr_type;

if (type == NOT_VALID)
{
wp->w_redr_status = TRUE;
wp->w_lines_valid = 0;
}


if (wp->w_height + WINBAR_HEIGHT(wp) == 0)
{
wp->w_redr_type = 0;
return;
}


if (wp->w_width == 0)
{

draw_vsep_win(wp, 0);
wp->w_redr_type = 0;
return;
}

#ifdef FEAT_TERMINAL

if (term_do_update_window(wp))
{
term_update_window(wp);
#ifdef FEAT_MENU

if (winbar_height(wp) > 0)
redraw_win_toolbar(wp);
#endif
wp->w_redr_type = 0;
return;
}
#endif

#ifdef FEAT_SEARCH_EXTRA
init_search_hl(wp, &screen_search_hl);
#endif

#ifdef FEAT_LINEBREAK


i = (wp->w_p_nu || wp->w_p_rnu) ? number_width(wp) : 0;
if (wp->w_nrwidth != i)
{
type = NOT_VALID;
wp->w_nrwidth = i;
}
else
#endif

if (buf->b_mod_set && buf->b_mod_xlines != 0 && wp->w_redraw_top != 0)
{



type = NOT_VALID;
}
else
{


mod_top = wp->w_redraw_top;
if (wp->w_redraw_bot != 0)
mod_bot = wp->w_redraw_bot + 1;
else
mod_bot = 0;
if (buf->b_mod_set)
{
if (mod_top == 0 || mod_top > buf->b_mod_top)
{
mod_top = buf->b_mod_top;
#ifdef FEAT_SYN_HL


if (syntax_present(wp))
{
mod_top -= buf->b_s.b_syn_sync_linebreaks;
if (mod_top < 1)
mod_top = 1;
}
#endif
}
if (mod_bot == 0 || mod_bot < buf->b_mod_bot)
mod_bot = buf->b_mod_bot;

#ifdef FEAT_SEARCH_EXTRA





if (screen_search_hl.rm.regprog != NULL
&& re_multiline(screen_search_hl.rm.regprog))
top_to_mod = TRUE;
else
{
matchitem_T *cur = wp->w_match_head;

while (cur != NULL)
{
if (cur->match.regprog != NULL
&& re_multiline(cur->match.regprog))
{
top_to_mod = TRUE;
break;
}
cur = cur->next;
}
}
#endif
}
#ifdef FEAT_FOLDING
if (mod_top != 0 && hasAnyFolding(wp))
{
linenr_T lnumt, lnumb;











lnumt = wp->w_topline;
lnumb = MAXLNUM;
for (i = 0; i < wp->w_lines_valid; ++i)
if (wp->w_lines[i].wl_valid)
{
if (wp->w_lines[i].wl_lastlnum < mod_top)
lnumt = wp->w_lines[i].wl_lastlnum + 1;
if (lnumb == MAXLNUM && wp->w_lines[i].wl_lnum >= mod_bot)
{
lnumb = wp->w_lines[i].wl_lnum;


if (compute_foldcolumn(wp, 0) > 0)
++lnumb;
}
}

(void)hasFoldingWin(wp, mod_top, &mod_top, NULL, TRUE, NULL);
if (mod_top > lnumt)
mod_top = lnumt;


--mod_bot;
(void)hasFoldingWin(wp, mod_bot, NULL, &mod_bot, TRUE, NULL);
++mod_bot;
if (mod_bot < lnumb)
mod_bot = lnumb;
}
#endif





if (mod_top != 0 && mod_top < wp->w_topline)
{
if (mod_bot > wp->w_topline)
mod_top = wp->w_topline;
#ifdef FEAT_SYN_HL
else if (syntax_present(wp))
top_end = 1;
#endif
}



if (mod_top != 0 && buf->b_mod_xlines != 0 && wp->w_p_nu)
mod_bot = MAXLNUM;
}
wp->w_redraw_top = 0; 
wp->w_redraw_bot = 0;



if (type == REDRAW_TOP)
{
j = 0;
for (i = 0; i < wp->w_lines_valid; ++i)
{
j += wp->w_lines[i].wl_size;
if (j >= wp->w_upd_rows)
{
top_end = j;
break;
}
}
if (top_end == 0)

type = NOT_VALID;
else

type = VALID;
}





if (screen_cleared)
screen_cleared = MAYBE;







if ((type == VALID || type == SOME_VALID
|| type == INVERTED || type == INVERTED_ALL)
#ifdef FEAT_DIFF
&& !wp->w_botfill && !wp->w_old_botfill
#endif
)
{
if (mod_top != 0 && wp->w_topline == mod_top)
{


}
else if (wp->w_lines[0].wl_valid
&& (wp->w_topline < wp->w_lines[0].wl_lnum
#ifdef FEAT_DIFF
|| (wp->w_topline == wp->w_lines[0].wl_lnum
&& wp->w_topfill > wp->w_old_topfill)
#endif
))
{

#ifdef FEAT_FOLDING
if (hasAnyFolding(wp))
{
linenr_T ln;



j = 0;
for (ln = wp->w_topline; ln < wp->w_lines[0].wl_lnum; ++ln)
{
++j;
if (j >= wp->w_height - 2)
break;
(void)hasFoldingWin(wp, ln, NULL, &ln, TRUE, NULL);
}
}
else
#endif
j = wp->w_lines[0].wl_lnum - wp->w_topline;
if (j < wp->w_height - 2) 
{
i = plines_m_win(wp, wp->w_topline, wp->w_lines[0].wl_lnum - 1);
#ifdef FEAT_DIFF

if (wp->w_lines[0].wl_lnum != wp->w_topline)
i += diff_check_fill(wp, wp->w_lines[0].wl_lnum)
- wp->w_old_topfill;
#endif
if (i < wp->w_height - 2) 
{



if (i > 0)
check_for_delay(FALSE);
if (win_ins_lines(wp, 0, i, FALSE, wp == firstwin) == OK)
{
if (wp->w_lines_valid != 0)
{


top_end = i;
scrolled_down = TRUE;



if ((wp->w_lines_valid += j) > wp->w_height)
wp->w_lines_valid = wp->w_height;
for (idx = wp->w_lines_valid; idx - j >= 0; idx--)
wp->w_lines[idx] = wp->w_lines[idx - j];
while (idx >= 0)
wp->w_lines[idx--].wl_valid = FALSE;
}
}
else
mid_start = 0; 
}
else
mid_start = 0; 
}
else
mid_start = 0; 
}
else
{





j = -1;
row = 0;
for (i = 0; i < wp->w_lines_valid; i++)
{
if (wp->w_lines[i].wl_valid
&& wp->w_lines[i].wl_lnum == wp->w_topline)
{
j = i;
break;
}
row += wp->w_lines[i].wl_size;
}
if (j == -1)
{


mid_start = 0;
}
else
{


#ifdef FEAT_DIFF


if (wp->w_lines[0].wl_lnum == wp->w_topline)
row += wp->w_old_topfill;
else
row += diff_check_fill(wp, wp->w_topline);

row -= wp->w_topfill;
#endif
if (row > 0)
{
check_for_delay(FALSE);
if (win_del_lines(wp, 0, row, FALSE, wp == firstwin, 0)
== OK)
bot_start = wp->w_height - row;
else
mid_start = 0; 
}
if ((row == 0 || bot_start < 999) && wp->w_lines_valid != 0)
{




bot_start = 0;
idx = 0;
for (;;)
{
wp->w_lines[idx] = wp->w_lines[j];


if (row > 0 && bot_start + row
+ (int)wp->w_lines[j].wl_size > wp->w_height)
{
wp->w_lines_valid = idx + 1;
break;
}
bot_start += wp->w_lines[idx++].wl_size;


if (++j >= wp->w_lines_valid)
{
wp->w_lines_valid = idx;
break;
}
}
#ifdef FEAT_DIFF


if (wp->w_p_diff && bot_start > 0)
wp->w_lines[0].wl_size =
plines_win_nofill(wp, wp->w_topline, TRUE)
+ wp->w_topfill;
#endif
}
}
}




if (mid_start == 0)
{
mid_end = wp->w_height;
if (ONE_WINDOW && !WIN_IS_POPUP(wp))
{



if (screen_cleared != TRUE)
screenclear();

if (redraw_tabline)
draw_tabline();
}
}





if (screen_cleared == TRUE)
must_redraw = 0;
}
else
{

mid_start = 0;
mid_end = wp->w_height;
}

if (type == SOME_VALID)
{

mid_start = 0;
mid_end = wp->w_height;
type = NOT_VALID;
}


if ((VIsual_active && buf == curwin->w_buffer)
|| (wp->w_old_cursor_lnum != 0 && type != NOT_VALID))
{
linenr_T from, to;

if (VIsual_active)
{
if (VIsual_active
&& (VIsual_mode != wp->w_old_visual_mode
|| type == INVERTED_ALL))
{



if (curwin->w_cursor.lnum < VIsual.lnum)
{
from = curwin->w_cursor.lnum;
to = VIsual.lnum;
}
else
{
from = VIsual.lnum;
to = curwin->w_cursor.lnum;
}

if (wp->w_old_cursor_lnum < from)
from = wp->w_old_cursor_lnum;
if (wp->w_old_cursor_lnum > to)
to = wp->w_old_cursor_lnum;
if (wp->w_old_visual_lnum < from)
from = wp->w_old_visual_lnum;
if (wp->w_old_visual_lnum > to)
to = wp->w_old_visual_lnum;
}
else
{



if (curwin->w_cursor.lnum < wp->w_old_cursor_lnum)
{
from = curwin->w_cursor.lnum;
to = wp->w_old_cursor_lnum;
}
else
{
from = wp->w_old_cursor_lnum;
to = curwin->w_cursor.lnum;
if (from == 0) 
from = to;
}

if (VIsual.lnum != wp->w_old_visual_lnum
|| VIsual.col != wp->w_old_visual_col)
{
if (wp->w_old_visual_lnum < from
&& wp->w_old_visual_lnum != 0)
from = wp->w_old_visual_lnum;
if (wp->w_old_visual_lnum > to)
to = wp->w_old_visual_lnum;
if (VIsual.lnum < from)
from = VIsual.lnum;
if (VIsual.lnum > to)
to = VIsual.lnum;
}
}




if (VIsual_mode == Ctrl_V)
{
colnr_T fromc, toc;
#if defined(FEAT_LINEBREAK)
int save_ve_flags = ve_flags;

if (curwin->w_p_lbr)
ve_flags = VE_ALL;
#endif
getvcols(wp, &VIsual, &curwin->w_cursor, &fromc, &toc);
#if defined(FEAT_LINEBREAK)
ve_flags = save_ve_flags;
#endif
++toc;
if (curwin->w_curswant == MAXCOL)
toc = MAXCOL;

if (fromc != wp->w_old_cursor_fcol
|| toc != wp->w_old_cursor_lcol)
{
if (from > VIsual.lnum)
from = VIsual.lnum;
if (to < VIsual.lnum)
to = VIsual.lnum;
}
wp->w_old_cursor_fcol = fromc;
wp->w_old_cursor_lcol = toc;
}
}
else
{

if (wp->w_old_cursor_lnum < wp->w_old_visual_lnum)
{
from = wp->w_old_cursor_lnum;
to = wp->w_old_visual_lnum;
}
else
{
from = wp->w_old_visual_lnum;
to = wp->w_old_cursor_lnum;
}
}


if (from < wp->w_topline)
from = wp->w_topline;



if (wp->w_valid & VALID_BOTLINE)
{
if (from >= wp->w_botline)
from = wp->w_botline - 1;
if (to >= wp->w_botline)
to = wp->w_botline - 1;
}








if (mid_start > 0)
{
lnum = wp->w_topline;
idx = 0;
srow = 0;
if (scrolled_down)
mid_start = top_end;
else
mid_start = 0;
while (lnum < from && idx < wp->w_lines_valid) 
{
if (wp->w_lines[idx].wl_valid)
mid_start += wp->w_lines[idx].wl_size;
else if (!scrolled_down)
srow += wp->w_lines[idx].wl_size;
++idx;
#ifdef FEAT_FOLDING
if (idx < wp->w_lines_valid && wp->w_lines[idx].wl_valid)
lnum = wp->w_lines[idx].wl_lnum;
else
#endif
++lnum;
}
srow += mid_start;
mid_end = wp->w_height;
for ( ; idx < wp->w_lines_valid; ++idx) 
{
if (wp->w_lines[idx].wl_valid
&& wp->w_lines[idx].wl_lnum >= to + 1)
{

mid_end = srow;
break;
}
srow += wp->w_lines[idx].wl_size;
}
}
}

if (VIsual_active && buf == curwin->w_buffer)
{
wp->w_old_visual_mode = VIsual_mode;
wp->w_old_cursor_lnum = curwin->w_cursor.lnum;
wp->w_old_visual_lnum = VIsual.lnum;
wp->w_old_visual_col = VIsual.col;
wp->w_old_curswant = curwin->w_curswant;
}
else
{
wp->w_old_visual_mode = 0;
wp->w_old_cursor_lnum = 0;
wp->w_old_visual_lnum = 0;
wp->w_old_visual_col = 0;
}

#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)

save_got_int = got_int;
got_int = 0;
#endif
#ifdef SYN_TIME_LIMIT

profile_setlimit(p_rdt, &syntax_tm);
syn_set_timeout(&syntax_tm);
#endif
#ifdef FEAT_FOLDING
win_foldinfo.fi_level = 0;
#endif

#ifdef FEAT_MENU


if (winbar_height(wp) > 0)
redraw_win_toolbar(wp);
#endif


idx = 0; 
row = 0;
srow = 0;
lnum = wp->w_topline; 
for (;;)
{


if (row == wp->w_height)
{
didline = TRUE;
break;
}


if (lnum > buf->b_ml.ml_line_count)
{
eof = TRUE;
break;
}



srow = row;








if (row < top_end
|| (row >= mid_start && row < mid_end)
#ifdef FEAT_SEARCH_EXTRA
|| top_to_mod
#endif
|| idx >= wp->w_lines_valid
|| (row + wp->w_lines[idx].wl_size > bot_start)
|| (mod_top != 0
&& (lnum == mod_top
|| (lnum >= mod_top
&& (lnum < mod_bot
#ifdef FEAT_SYN_HL
|| did_update == DID_FOLD
|| (did_update == DID_LINE
&& syntax_present(wp)
&& (
#ifdef FEAT_FOLDING
(foldmethodIsSyntax(wp)
&& hasAnyFolding(wp)) ||
#endif
syntax_check_changed(lnum)))
#endif
#ifdef FEAT_SEARCH_EXTRA


|| (wp->w_match_head != NULL
&& buf->b_mod_xlines != 0)
#endif
))))
#ifdef FEAT_SYN_HL
|| (wp->w_p_cul && (lnum == wp->w_cursor.lnum
|| lnum == wp->w_last_cursorline))
#endif
)
{
#ifdef FEAT_SEARCH_EXTRA
if (lnum == mod_top)
top_to_mod = FALSE;
#endif





if (lnum == mod_top
&& mod_bot != MAXLNUM
&& !(dollar_vcol >= 0 && mod_bot == mod_top + 1))
{
int old_rows = 0;
int new_rows = 0;
int xtra_rows;
linenr_T l;




for (i = idx; i < wp->w_lines_valid; ++i)
{


if (wp->w_lines[i].wl_valid
&& wp->w_lines[i].wl_lnum == mod_bot)
break;
old_rows += wp->w_lines[i].wl_size;
#ifdef FEAT_FOLDING
if (wp->w_lines[i].wl_valid
&& wp->w_lines[i].wl_lastlnum + 1 == mod_bot)
{


++i;
while (i < wp->w_lines_valid
&& !wp->w_lines[i].wl_valid)
old_rows += wp->w_lines[i++].wl_size;
break;
}
#endif
}

if (i >= wp->w_lines_valid)
{



bot_start = 0;
}
else
{


j = idx;
for (l = lnum; l < mod_bot; ++l)
{
#ifdef FEAT_FOLDING
if (hasFoldingWin(wp, l, NULL, &l, TRUE, NULL))
++new_rows;
else
#endif
#ifdef FEAT_DIFF
if (l == wp->w_topline)
new_rows += plines_win_nofill(wp, l, TRUE)
+ wp->w_topfill;
else
#endif
new_rows += plines_win(wp, l, TRUE);
++j;
if (new_rows > wp->w_height - row - 2)
{

new_rows = 9999;
break;
}
}
xtra_rows = new_rows - old_rows;
if (xtra_rows < 0)
{




if (row - xtra_rows >= wp->w_height - 2)
mod_bot = MAXLNUM;
else
{
check_for_delay(FALSE);
if (win_del_lines(wp, row,
-xtra_rows, FALSE, FALSE, 0) == FAIL)
mod_bot = MAXLNUM;
else
bot_start = wp->w_height + xtra_rows;
}
}
else if (xtra_rows > 0)
{



if (row + xtra_rows >= wp->w_height - 2)
mod_bot = MAXLNUM;
else
{
check_for_delay(FALSE);
if (win_ins_lines(wp, row + old_rows,
xtra_rows, FALSE, FALSE) == FAIL)
mod_bot = MAXLNUM;
else if (top_end > row + old_rows)


top_end += xtra_rows;
}
}



if (mod_bot != MAXLNUM && i != j)
{
if (j < i)
{
int x = row + new_rows;


for (;;)
{

if (i >= wp->w_lines_valid)
{
wp->w_lines_valid = j;
break;
}
wp->w_lines[j] = wp->w_lines[i];

if (x + (int)wp->w_lines[j].wl_size
> wp->w_height)
{
wp->w_lines_valid = j + 1;
break;
}
x += wp->w_lines[j++].wl_size;
++i;
}
if (bot_start > x)
bot_start = x;
}
else 
{

j -= i;
wp->w_lines_valid += j;
if (wp->w_lines_valid > wp->w_height)
wp->w_lines_valid = wp->w_height;
for (i = wp->w_lines_valid; i - j >= idx; --i)
wp->w_lines[i] = wp->w_lines[i - j];




while (i >= idx)
{
wp->w_lines[i].wl_size = 0;
wp->w_lines[i--].wl_valid = FALSE;
}
}
}
}
}

#ifdef FEAT_FOLDING



fold_count = foldedCount(wp, lnum, &win_foldinfo);
if (fold_count != 0)
{
fold_line(wp, fold_count, &win_foldinfo, lnum, row);
++row;
--fold_count;
wp->w_lines[idx].wl_folded = TRUE;
wp->w_lines[idx].wl_lastlnum = lnum + fold_count;
#ifdef FEAT_SYN_HL
did_update = DID_FOLD;
#endif
}
else
#endif
if (idx < wp->w_lines_valid
&& wp->w_lines[idx].wl_valid
&& wp->w_lines[idx].wl_lnum == lnum
&& lnum > wp->w_topline
&& !(dy_flags & (DY_LASTLINE | DY_TRUNCATE))
&& !WIN_IS_POPUP(wp)
&& srow + wp->w_lines[idx].wl_size > wp->w_height
#ifdef FEAT_DIFF
&& diff_check_fill(wp, lnum) == 0
#endif
)
{


row = wp->w_height + 1;
}
else
{
#ifdef FEAT_SEARCH_EXTRA
prepare_search_hl(wp, &screen_search_hl, lnum);
#endif
#ifdef FEAT_SYN_HL

if (syntax_last_parsed != 0 && syntax_last_parsed + 1 < lnum
&& syntax_present(wp))
syntax_end_parsing(syntax_last_parsed + 1);
#endif


row = win_line(wp, lnum, srow, wp->w_height,
mod_top == 0, FALSE);

#ifdef FEAT_FOLDING
wp->w_lines[idx].wl_folded = FALSE;
wp->w_lines[idx].wl_lastlnum = lnum;
#endif
#ifdef FEAT_SYN_HL
did_update = DID_LINE;
syntax_last_parsed = lnum;
#endif
}

wp->w_lines[idx].wl_lnum = lnum;
wp->w_lines[idx].wl_valid = TRUE;




if (row > wp->w_height || row + wp->w_winrow >= Rows)
{

if (dollar_vcol == -1)
wp->w_lines[idx].wl_size = plines_win(wp, lnum, TRUE);
++idx;
break;
}
if (dollar_vcol == -1)
wp->w_lines[idx].wl_size = row - srow;
++idx;
#ifdef FEAT_FOLDING
lnum += fold_count + 1;
#else
++lnum;
#endif
}
else
{
if (wp->w_p_rnu)
{
#ifdef FEAT_FOLDING


fold_count = foldedCount(wp, lnum, &win_foldinfo);
if (fold_count != 0)
fold_line(wp, fold_count, &win_foldinfo, lnum, row);
else
#endif
(void)win_line(wp, lnum, srow, wp->w_height, TRUE, TRUE);
}


row += wp->w_lines[idx++].wl_size;
if (row > wp->w_height) 
break;
#ifdef FEAT_FOLDING
lnum = wp->w_lines[idx - 1].wl_lastlnum + 1;
#else
++lnum;
#endif
#ifdef FEAT_SYN_HL
did_update = DID_NONE;
#endif
}

if (lnum > buf->b_ml.ml_line_count)
{
eof = TRUE;
break;
}
}



#ifdef FEAT_VTP

if (use_vtp())
{
int i;

for (i = 0; i < Rows; ++i)
if (enc_utf8)
if ((*mb_off2cells)(LineOffset[i] + Columns - 2,
LineOffset[i] + screen_Columns) > 1)
screen_draw_rectangle(i, Columns - 2, 1, 2, FALSE);
else
screen_draw_rectangle(i, Columns - 1, 1, 1, FALSE);
else
screen_char(LineOffset[i] + Columns - 1, i, Columns - 1);
}
#endif

if (idx > wp->w_lines_valid)
wp->w_lines_valid = idx;

#ifdef FEAT_SYN_HL

if (syntax_last_parsed != 0 && syntax_present(wp))
syntax_end_parsing(syntax_last_parsed + 1);
#endif



wp->w_empty_rows = 0;
#ifdef FEAT_DIFF
wp->w_filler_rows = 0;
#endif
if (!eof && !didline)
{
if (lnum == wp->w_topline)
{


wp->w_botline = lnum + 1;
}
#ifdef FEAT_DIFF
else if (diff_check_fill(wp, lnum) >= wp->w_height - srow)
{

wp->w_botline = lnum;
wp->w_filler_rows = wp->w_height - srow;
}
#endif
#ifdef FEAT_PROP_POPUP
else if (WIN_IS_POPUP(wp))
{

wp->w_botline = lnum;
}
#endif
else if (dy_flags & DY_TRUNCATE) 
{
int scr_row = W_WINROW(wp) + wp->w_height - 1;


screen_puts_len((char_u *)"@@", 2, scr_row, wp->w_wincol,
HL_ATTR(HLF_AT));
screen_fill(scr_row, scr_row + 1,
(int)wp->w_wincol + 2, (int)W_ENDCOL(wp),
'@', ' ', HL_ATTR(HLF_AT));
set_empty_rows(wp, srow);
wp->w_botline = lnum;
}
else if (dy_flags & DY_LASTLINE) 
{

screen_fill(W_WINROW(wp) + wp->w_height - 1,
W_WINROW(wp) + wp->w_height,
(int)W_ENDCOL(wp) - 3, (int)W_ENDCOL(wp),
'@', '@', HL_ATTR(HLF_AT));
set_empty_rows(wp, srow);
wp->w_botline = lnum;
}
else
{
win_draw_end(wp, '@', ' ', TRUE, srow, wp->w_height, HLF_AT);
wp->w_botline = lnum;
}
}
else
{
draw_vsep_win(wp, row);
if (eof) 
{
wp->w_botline = buf->b_ml.ml_line_count + 1;
#ifdef FEAT_DIFF
j = diff_check_fill(wp, wp->w_botline);
if (j > 0 && !wp->w_botfill)
{

if (char2cells(fill_diff) > 1)
i = '-';
else
i = fill_diff;
if (row + j > wp->w_height)
j = wp->w_height - row;
win_draw_end(wp, i, i, TRUE, row, row + (int)j, HLF_DED);
row += j;
}
#endif
}
else if (dollar_vcol == -1)
wp->w_botline = lnum;



if (WIN_IS_POPUP(wp))
win_draw_end(wp, ' ', ' ', FALSE, row, wp->w_height, HLF_AT);
else
win_draw_end(wp, '~', ' ', FALSE, row, wp->w_height, HLF_EOB);
}

#ifdef SYN_TIME_LIMIT
syn_set_timeout(NULL);
#endif


wp->w_redr_type = 0;
#ifdef FEAT_DIFF
wp->w_old_topfill = wp->w_topfill;
wp->w_old_botfill = wp->w_botfill;
#endif

if (dollar_vcol == -1)
{










wp->w_valid |= VALID_BOTLINE;
if (wp == curwin && wp->w_botline != old_botline && !recursive)
{
win_T *wwp;
#if defined(FEAT_CONCEAL)
linenr_T old_topline = wp->w_topline;
int new_wcol = wp->w_wcol;
#endif
recursive = TRUE;
curwin->w_valid &= ~VALID_TOPLINE;
update_topline(); 

#if defined(FEAT_CONCEAL)
if (old_wcol != new_wcol && (wp->w_valid & (VALID_WCOL|VALID_WROW))
!= (VALID_WCOL|VALID_WROW))
{








validate_cursor();
if (wp->w_wcol == old_wcol && wp->w_wrow == old_wrow
&& old_topline == wp->w_topline)
wp->w_wcol = new_wcol;
else
redrawWinline(wp, wp->w_cursor.lnum);
}
#endif

if (wp->w_redr_type != 0)
{

i = curbuf->b_mod_set;
curbuf->b_mod_set = FALSE;
j = curbuf->b_mod_xlines;
curbuf->b_mod_xlines = 0;
win_update(curwin);
curbuf->b_mod_set = i;
curbuf->b_mod_xlines = j;
}

must_redraw = 0;
FOR_ALL_WINDOWS(wwp)
if (wwp->w_redr_type > must_redraw)
must_redraw = wwp->w_redr_type;
recursive = FALSE;
}
}

#if defined(FEAT_SYN_HL) || defined(FEAT_SEARCH_EXTRA)

if (!got_int)
got_int = save_got_int;
#endif
}

#if defined(FEAT_NETBEANS_INTG) || defined(FEAT_GUI)




static void
update_prepare(void)
{
cursor_off();
updating_screen = TRUE;
#ifdef FEAT_GUI


if (gui.in_use)
gui_undraw_cursor();
#endif
#ifdef FEAT_SEARCH_EXTRA
start_search_hl();
#endif
#ifdef FEAT_PROP_POPUP

may_update_popup_mask(must_redraw);
#endif
}




static void
update_finish(void)
{
if (redraw_cmdline || redraw_mode)
showmode();

#ifdef FEAT_SEARCH_EXTRA
end_search_hl();
#endif

after_updating_screen(TRUE);

#ifdef FEAT_GUI


if (gui.in_use)
{
out_flush_cursor(FALSE, FALSE);
gui_update_scrollbars(FALSE);
}
#endif
}
#endif

#if defined(FEAT_NETBEANS_INTG) || defined(PROTO)
void
update_debug_sign(buf_T *buf, linenr_T lnum)
{
win_T *wp;
int doit = FALSE;

#ifdef FEAT_FOLDING
win_foldinfo.fi_level = 0;
#endif


redraw_buf_line_later(buf, lnum);


FOR_ALL_WINDOWS(wp)
if (wp->w_redr_type != 0)
doit = TRUE;



if (!doit || updating_screen
|| State == ASKMORE || State == HITRETURN
|| msg_scrolled
#ifdef FEAT_GUI
|| gui.starting
#endif
|| starting)
return;


update_prepare();

FOR_ALL_WINDOWS(wp)
{
if (wp->w_redr_type != 0)
win_update(wp);
if (wp->w_redr_status)
win_redr_status(wp, FALSE);
}

update_finish();
}
#endif

#if defined(FEAT_GUI) || defined(PROTO)




void
updateWindow(win_T *wp)
{

if (updating_screen)
return;

update_prepare();

#ifdef FEAT_CLIPBOARD

if (clip_star.available && clip_isautosel_star())
clip_update_selection(&clip_star);
if (clip_plus.available && clip_isautosel_plus())
clip_update_selection(&clip_plus);
#endif

win_update(wp);


if (redraw_tabline)
draw_tabline();

if (wp->w_redr_status
#ifdef FEAT_CMDL_INFO
|| p_ru
#endif
#ifdef FEAT_STL_OPT
|| *p_stl != NUL || *wp->w_p_stl != NUL
#endif
)
win_redr_status(wp, FALSE);

#ifdef FEAT_PROP_POPUP

update_popups(win_update);
#endif

update_finish();
}
#endif

#if defined(FEAT_TERMRESPONSE) || defined(PROTO)





int
redraw_asap(int type)
{
int rows;
int cols = screen_Columns;
int r;
int ret = 0;
schar_T *screenline; 
sattr_T *screenattr; 
int i;
u8char_T *screenlineUC = NULL; 
u8char_T *screenlineC[MAX_MCO]; 
schar_T *screenline2 = NULL; 

redraw_later(type);
if (msg_scrolled || (State != NORMAL && State != NORMAL_BUSY) || exiting)
return ret;


rows = screen_Rows - cmdline_row;
screenline = LALLOC_MULT(schar_T, rows * cols);
screenattr = LALLOC_MULT(sattr_T, rows * cols);
if (screenline == NULL || screenattr == NULL)
ret = 2;
if (enc_utf8)
{
screenlineUC = LALLOC_MULT(u8char_T, rows * cols);
if (screenlineUC == NULL)
ret = 2;
for (i = 0; i < p_mco; ++i)
{
screenlineC[i] = LALLOC_MULT(u8char_T, rows * cols);
if (screenlineC[i] == NULL)
ret = 2;
}
}
if (enc_dbcs == DBCS_JPNU)
{
screenline2 = LALLOC_MULT(schar_T, rows * cols);
if (screenline2 == NULL)
ret = 2;
}

if (ret != 2)
{

for (r = 0; r < rows; ++r)
{
mch_memmove(screenline + r * cols,
ScreenLines + LineOffset[cmdline_row + r],
(size_t)cols * sizeof(schar_T));
mch_memmove(screenattr + r * cols,
ScreenAttrs + LineOffset[cmdline_row + r],
(size_t)cols * sizeof(sattr_T));
if (enc_utf8)
{
mch_memmove(screenlineUC + r * cols,
ScreenLinesUC + LineOffset[cmdline_row + r],
(size_t)cols * sizeof(u8char_T));
for (i = 0; i < p_mco; ++i)
mch_memmove(screenlineC[i] + r * cols,
ScreenLinesC[i] + LineOffset[cmdline_row + r],
(size_t)cols * sizeof(u8char_T));
}
if (enc_dbcs == DBCS_JPNU)
mch_memmove(screenline2 + r * cols,
ScreenLines2 + LineOffset[cmdline_row + r],
(size_t)cols * sizeof(schar_T));
}

update_screen(0);
ret = 3;

if (must_redraw == 0)
{
int off = (int)(current_ScreenLine - ScreenLines);


for (r = 0; r < rows; ++r)
{
mch_memmove(current_ScreenLine,
screenline + r * cols,
(size_t)cols * sizeof(schar_T));
mch_memmove(ScreenAttrs + off,
screenattr + r * cols,
(size_t)cols * sizeof(sattr_T));
if (enc_utf8)
{
mch_memmove(ScreenLinesUC + off,
screenlineUC + r * cols,
(size_t)cols * sizeof(u8char_T));
for (i = 0; i < p_mco; ++i)
mch_memmove(ScreenLinesC[i] + off,
screenlineC[i] + r * cols,
(size_t)cols * sizeof(u8char_T));
}
if (enc_dbcs == DBCS_JPNU)
mch_memmove(ScreenLines2 + off,
screenline2 + r * cols,
(size_t)cols * sizeof(schar_T));
screen_line(cmdline_row + r, 0, cols, cols, 0);
}
ret = 4;
}
}

vim_free(screenline);
vim_free(screenattr);
if (enc_utf8)
{
vim_free(screenlineUC);
for (i = 0; i < p_mco; ++i)
vim_free(screenlineC[i]);
}
if (enc_dbcs == DBCS_JPNU)
vim_free(screenline2);


maybe_intro_message();

setcursor();

return ret;
}
#endif








void
redraw_after_callback(int call_update_screen)
{
++redrawing_for_callback;

if (State == HITRETURN || State == ASKMORE)
; 
else if (State & CMDLINE)
{

if (cmdline_row > 0)
{


if (msg_scrolled == 0
#ifdef FEAT_WILDMENU
&& wild_menu_showing == 0
#endif
&& call_update_screen)
update_screen(0);



redrawcmdline_ex(FALSE);
}
}
else if (State & (NORMAL | INSERT | TERMINAL))
{

update_screen(VALID_NO_UPDATE);
setcursor();
}
cursor_on();
#ifdef FEAT_GUI
if (gui.in_use && !gui_mch_is_blink_off())


out_flush_cursor(FALSE, FALSE);
else
#endif
out_flush();

--redrawing_for_callback;
}






void
redraw_later(int type)
{
redraw_win_later(curwin, type);
}

void
redraw_win_later(
win_T *wp,
int type)
{
if (!exiting && wp->w_redr_type < type)
{
wp->w_redr_type = type;
if (type >= NOT_VALID)
wp->w_lines_valid = 0;
if (must_redraw < type) 
must_redraw = type;
}
}





void
redraw_later_clear(void)
{
redraw_all_later(CLEAR);
reset_screen_attr();
}




void
redraw_all_later(int type)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
redraw_win_later(wp, type);

if (must_redraw < type)
must_redraw = type;
}




void
redraw_curbuf_later(int type)
{
redraw_buf_later(curbuf, type);
}

void
redraw_buf_later(buf_T *buf, int type)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
{
if (wp->w_buffer == buf)
redraw_win_later(wp, type);
}
#if defined(FEAT_TERMINAL) && defined(FEAT_PROP_POPUP)

if (curwin->w_buffer == buf)
redraw_win_later(curwin, type);
#endif
}

#if defined(FEAT_SIGNS) || defined(PROTO)
void
redraw_buf_line_later(buf_T *buf, linenr_T lnum)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
if (wp->w_buffer == buf && lnum >= wp->w_topline
&& lnum < wp->w_botline)
redrawWinline(wp, lnum);
}
#endif

#if defined(FEAT_JOB_CHANNEL) || defined(PROTO)
void
redraw_buf_and_status_later(buf_T *buf, int type)
{
win_T *wp;

#ifdef FEAT_WILDMENU
if (wild_menu_showing != 0)


return;
#endif
FOR_ALL_WINDOWS(wp)
{
if (wp->w_buffer == buf)
{
redraw_win_later(wp, type);
wp->w_redr_status = TRUE;
}
}
}
#endif




void
status_redraw_all(void)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
if (wp->w_status_height)
{
wp->w_redr_status = TRUE;
redraw_later(VALID);
}
}




void
status_redraw_curbuf(void)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
if (wp->w_status_height != 0 && wp->w_buffer == curbuf)
{
wp->w_redr_status = TRUE;
redraw_later(VALID);
}
}




void
redraw_statuslines(void)
{
win_T *wp;

FOR_ALL_WINDOWS(wp)
if (wp->w_redr_status)
win_redr_status(wp, FALSE);
if (redraw_tabline)
draw_tabline();
}

#if defined(FEAT_WILDMENU) || defined(PROTO)



void
win_redraw_last_status(frame_T *frp)
{
if (frp->fr_layout == FR_LEAF)
frp->fr_win->w_redr_status = TRUE;
else if (frp->fr_layout == FR_ROW)
{
FOR_ALL_FRAMES(frp, frp->fr_child)
win_redraw_last_status(frp);
}
else 
{
frp = frp->fr_child;
while (frp->fr_next != NULL)
frp = frp->fr_next;
win_redraw_last_status(frp);
}
}
#endif









void
redrawWinline(
win_T *wp,
linenr_T lnum)
{
if (wp->w_redraw_top == 0 || wp->w_redraw_top > lnum)
wp->w_redraw_top = lnum;
if (wp->w_redraw_bot == 0 || wp->w_redraw_bot < lnum)
wp->w_redraw_bot = lnum;
redraw_win_later(wp, VALID);
}
