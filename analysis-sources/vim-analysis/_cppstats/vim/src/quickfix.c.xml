<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\_cppstats\vim\src\quickfix.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"vim.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<struct>struct <name>dir_stack_T</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><name><name>struct</name> <name>qfline_S</name></name></type> <name>qfline_T</name>;</typedef>

<struct>struct <name>qfline_S</name>

<block>{

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_next</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_prev</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>linenr_T</name></type> <name>qf_lnum</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_fnum</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_col</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_nr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_module</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_pattern</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_text</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>qf_viscol</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>qf_cleared</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>qf_type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>qf_valid</name></decl>;</decl_stmt> 

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LISTCOUNT</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_QFIDX</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_QFBUFNR</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<typedef>typedef <type><enum>enum

<block>{

<decl><name>QFLT_QUICKFIX</name></decl>, 

<decl><name>QFLT_LOCATION</name></decl>, 

<decl><name>QFLT_INTERNAL</name></decl> 

}</block></enum></type> <name>qfltype_T</name>;</typedef>

<typedef>typedef <type><struct>struct <name>qf_list_S</name>

<block>{

<decl_stmt><decl><type><name>int_u</name></type> <name>qf_id</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qfltype_T</name></type> <name>qfl_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_start</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_last</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_count</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_index</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_nonevalid</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>qf_ctx</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>qf_dir_stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_directory</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>qf_file_stack</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_currfile</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_multiline</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_multiignore</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_multiscan</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>qf_changedtick</name></decl>;</decl_stmt>

}</block></struct></type> <name>qf_list_T</name>;</typedef>

<struct>struct <name>qf_info_S</name>

<block>{

<decl_stmt><decl><type><name>int</name></type> <name>qf_refcount</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_listcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_curlist</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qf_list_T</name></type> <name><name>qf_lists</name><index>[<expr><name>LISTCOUNT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfltype_T</name></type> <name>qfl_type</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>qf_bufnr</name></decl>;</decl_stmt> 

}</block>;</struct>

<decl_stmt><decl><type><specifier>static</specifier> <name>qf_info_T</name></type> <name>ql_info</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>static</specifier> <name>int_u</name></type> <name>last_qf_id</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FMT_PATTERNS</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define> 

<typedef>typedef <type><name><name>struct</name> <name>efm_S</name></name></type> <name>efm_T</name>;</typedef>

<struct>struct <name>efm_S</name>

<block>{

<decl_stmt><decl><type><name>regprog_T</name> <modifier>*</modifier></type><name>prog</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name><name>addr</name><index>[<expr><name>FMT_PATTERNS</name></expr>]</index></name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>prefix</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name></type> <name>flags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>conthere</name></decl>;</decl_stmt> 

}</block>;</struct>

<typedef>typedef <type><struct>struct <name>qf_delq_S</name>

<block>{

<decl_stmt><decl><type><name><name>struct</name> <name>qf_delq_S</name></name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

}</block></struct></type> <name>qf_delq_T</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>qf_delq_T</name> <modifier>*</modifier></type><name>qf_delq_head</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>quickfix_busy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>efm_T</name> <modifier>*</modifier></type><name>fmt_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_new_list</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>qf_add_entry</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>module</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufnum</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vis_col</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>valid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_free</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>qf_types</name><parameter_list>(<parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>qf_get_fnum</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>qf_push_dir</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_file_stack</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>qf_pop_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier><modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>qf_guess_filepath</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_jump_newwin</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newwin</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_fmt_text</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>qf_win_pos_update</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>old_qf_index</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>win_T</name> <modifier>*</modifier></type><name>qf_find_win</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type><name>qf_find_buf</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_update_buffer</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>qf_fill_buffer</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type><name>load_dummy_buffer</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>resulting_dir</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wipe_dummy_buffer</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unload_dummy_buffer</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type><name>ll_get_or_alloc_list</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>e_no_more_items</name> <init>= <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E553: No more items"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_QF_WINDOW</name><parameter_list>(<parameter><type><name>wp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bt_quickfix(wp-&gt;w_buffer) &amp;&amp; wp-&gt;w_llist_ref == NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LL_WINDOW</name><parameter_list>(<parameter><type><name>wp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(bt_quickfix(wp-&gt;w_buffer) &amp;&amp; wp-&gt;w_llist_ref != NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_QF_STACK</name><parameter_list>(<parameter><type><name>qi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(qi-&gt;qfl_type == QFLT_QUICKFIX)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LL_STACK</name><parameter_list>(<parameter><type><name>qi</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(qi-&gt;qfl_type == QFLT_LOCATION)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_QF_LIST</name><parameter_list>(<parameter><type><name>qfl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(qfl-&gt;qfl_type == QFLT_QUICKFIX)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LL_LIST</name><parameter_list>(<parameter><type><name>qfl</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(qfl-&gt;qfl_type == QFLT_LOCATION)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_LOC_LIST</name><parameter_list>(<parameter><type><name>wp</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(IS_LL_WINDOW(wp) ? wp-&gt;w_llist_ref : wp-&gt;w_llist)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FOR_ALL_QFL_ITEMS</name><parameter_list>(<parameter><type><name>qfl</name></type></parameter>, <parameter><type><name>qfp</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>for (i = 1, qfp = qfl-&gt;qf_start; !got_int &amp;&amp; i &lt;= qfl-&gt;qf_count &amp;&amp; qfp != NULL; ++i, qfp = qfp-&gt;qf_next)</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>qf_last_bufname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bufref_T</name></type> <name>qf_last_bufref</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_loc_list_changed</name> <init>=

<expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E926: Current location list was changed"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINE_MAXLEN</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<struct><specifier>static</specifier> struct <name>fmtpattern</name>

<block>{

<decl_stmt><decl><type><name>char_u</name></type> <name>convchar</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>

}</block> <decl><name><name>fmt_pat</name><index>[<expr><name>FMT_PATTERNS</name></expr>]</index></name> <init>=

<expr><block>{

<expr><block>{<expr><literal type="char">'f'</literal></expr>, <expr><literal type="string">".\\+"</literal></expr>}</block></expr>, 

<expr><block>{<expr><literal type="char">'n'</literal></expr>, <expr><literal type="string">"\\d\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'l'</literal></expr>, <expr><literal type="string">"\\d\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'c'</literal></expr>, <expr><literal type="string">"\\d\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'t'</literal></expr>, <expr><literal type="string">"."</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'m'</literal></expr>, <expr><literal type="string">".\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'r'</literal></expr>, <expr><literal type="string">".*"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'p'</literal></expr>, <expr><literal type="string">"[- .]*"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'v'</literal></expr>, <expr><literal type="string">"\\d\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'s'</literal></expr>, <expr><literal type="string">".\\+"</literal></expr>}</block></expr>,

<expr><block>{<expr><literal type="char">'o'</literal></expr>, <expr><literal type="string">".\\+"</literal></expr>}</block></expr>

}</block></expr></init></decl>;</struct>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>efmpat_to_regpat</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efmpat</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>regpat</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>efminfo</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>round</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>srcptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>efminfo</name><operator>-&gt;</operator><name>addr</name><index>[<expr><name>idx</name></expr>]</index></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E372: Too many %%%c in format string"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>efmpat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>&amp;&amp;</operator> <name>idx</name> <operator>&lt;</operator> <literal type="number">6</literal>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"DXOPQ"</literal></expr></argument>, <argument><expr><name><name>efminfo</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>idx</name> <operator>==</operator> <literal type="number">6</literal>

<operator>&amp;&amp;</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"OPQ"</literal></expr></argument>, <argument><expr><name><name>efminfo</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E373: Unexpected %%%c in format string"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>efmpat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>efminfo</name><operator>-&gt;</operator><name>addr</name><index>[<expr><name>idx</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>char_u</name><operator>)</operator><operator>++</operator><name>round</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">'('</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmpat</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>regpat</name></expr></argument>, <argument><expr><literal type="string">"\\%(\\a:\\)\\="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regpat</name> <operator>+=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmpat</name> <operator>==</operator> <literal type="char">'f'</literal> <operator>&amp;&amp;</operator> <name><name>efmpat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>efmpat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>efmpat</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>regpat</name></expr></argument>, <argument><expr><literal type="string">".\\{-1,}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regpat</name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>regpat</name></expr></argument>, <argument><expr><literal type="string">"\\f\\+"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>regpat</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>srcptr</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name><name>fmt_pat</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>pattern</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><operator>*</operator><name>regpat</name> <operator>=</operator> <operator>*</operator><name>srcptr</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>regpat</name></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">')'</literal></expr>;</expr_stmt>

<return>return <expr><name>regpat</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>scanf_fmt_to_regpat</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>pefmp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>regpat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efmp</name> <init>= <expr><operator>*</operator><name>pefmp</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'['</literal> <operator>||</operator> <operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>efmp</name><operator>)</operator> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>efmp</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>++</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>efmp</name> <operator>&lt;</operator> <name>efm</name> <operator>+</operator> <name>len</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>++</operator><name>efmp</name></expr>;</expr_stmt> 

<while>while <condition>(<expr><name>efmp</name> <operator>&lt;</operator> <name>efm</name> <operator>+</operator> <name>len</name>

<operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>++</operator><name>efmp</name><operator>)</operator> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>efmp</name> <operator>==</operator> <name>efm</name> <operator>+</operator> <name>len</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E374: Missing ] in format string"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt></block_content></block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>efmp</name> <operator>&lt;</operator> <name>efm</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <operator>*</operator><operator>++</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>regpat</name><operator>++</operator> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E375: Unsupported %%%c in format string"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pefmp</name> <operator>=</operator> <name>efmp</name></expr>;</expr_stmt>

<return>return <expr><name>regpat</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>efm_analyze_prefix</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efmp</name></decl></parameter>, <parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>efminfo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>efminfo</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <operator>*</operator><name>efmp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"DXAEWICZGOPQ"</literal></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>efminfo</name><operator>-&gt;</operator><name>prefix</name></name> <operator>=</operator> <operator>*</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E376: Invalid %%%c in format string prefix"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>efmp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>efm_to_regpat</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_ptr</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>regpat</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>round</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>regpat</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'^'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>round</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>efmp</name> <operator>=</operator> <name>efm</name></expr>;</init> <condition><expr><name>efmp</name> <operator>&lt;</operator> <name>efm</name> <operator>+</operator> <name>len</name></expr>;</condition> <incr><expr><operator>++</operator><name>efmp</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>efmp</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name>FMT_PATTERNS</name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>fmt_pat</name><index>[<expr><name>idx</name></expr>]</index></name><operator>.</operator><name>convchar</name> <operator>==</operator> <operator>*</operator><name>efmp</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <name>FMT_PATTERNS</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>efmpat_to_regpat</name><argument_list>(<argument><expr><name>efmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>fmt_ptr</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><name>round</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>round</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>efmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>scanf_fmt_to_regpat</name><argument_list>(<argument><expr><operator>&amp;</operator><name>efmp</name></expr></argument>, <argument><expr><name>efm</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"%\\.^$~["</literal></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'&gt;'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>conthere</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>efmp</name> <operator>==</operator> <name>efm</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name>efmp</name> <operator>=</operator> <call><name>efm_analyze_prefix</name><argument_list>(<argument><expr><name>efmp</name></expr></argument>, <argument><expr><name>fmt_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>efmp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E377: Invalid %%%c in format string"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmp</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name>efmp</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>efm</name> <operator>+</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">".*^$~["</literal></expr></argument>, <argument><expr><operator>*</operator><name>efmp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>efmp</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>efmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>free_efm_list</name><parameter_list>(<parameter><decl><type><name>efm_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>efm_first</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>efm_ptr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>efm_ptr</name> <operator>=</operator> <operator>*</operator><name>efm_first</name></expr>;</init> <condition><expr><name>efm_ptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>efm_ptr</name> <operator>=</operator> <operator>*</operator><name>efm_first</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>efm_first</name> <operator>=</operator> <name><name>efm_ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>efm_ptr</name><operator>-&gt;</operator><name>prog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>efm_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>fmt_start</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>efm_regpat_bufsz</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <operator>(</operator><name>FMT_PATTERNS</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>efm</name></expr></argument>)</argument_list></call> <operator>&lt;&lt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>FMT_PATTERNS</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr/>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>fmt_pat</name><index>[<expr><operator>--</operator><name>i</name></expr>]</index></name><operator>.</operator><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>sz</name> <operator>+=</operator> <literal type="number">12</literal></expr>;</expr_stmt> 

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>sz</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt> 

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>sz</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>efm_option_part_len</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>efm</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name><name>efm</name><index>[<expr><name>len</name></expr>]</index></name> <operator>!=</operator> <literal type="char">','</literal></expr>;</condition> <incr><expr><operator>++</operator><name>len</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>efm</name><index>[<expr><name>len</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>efm</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>len</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>efm_T</name> <modifier>*</modifier></type>

<name>parse_efm_option</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fmtstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sz</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>efm_regpat_bufsz</name><argument_list>(<argument><expr><name>efm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fmtstr</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>parse_efm_error</name>;</goto></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>efm</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fmt_ptr</name> <operator>=</operator> <call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>efm_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>parse_efm_error</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>fmt_first</name> <operator>=</operator> <name>fmt_ptr</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fmt_last</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>fmt_ptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>fmt_last</name> <operator>=</operator> <name>fmt_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>efm_option_part_len</name><argument_list>(<argument><expr><name>efm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>efm_to_regpat</name><argument_list>(<argument><expr><name>efm</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>fmt_ptr</name></expr></argument>, <argument><expr><name>fmtstr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>parse_efm_error</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>fmt_ptr</name><operator>-&gt;</operator><name>prog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>fmtstr</name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>parse_efm_error</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>efm</name> <operator>=</operator> <call><name>skip_to_option_part</name><argument_list>(<argument><expr><name>efm</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>fmt_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E378: 'errorformat' contains no pattern"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<goto>goto <name>parse_efm_end</name>;</goto>

<label><name>parse_efm_error</name>:</label>

<expr_stmt><expr><call><name>free_efm_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fmt_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>parse_efm_end</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fmtstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>fmt_first</name></expr>;</return>

</block_content>}</block></function>

<enum>enum <block>{

<decl><name>QF_FAIL</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,

<decl><name>QF_OK</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,

<decl><name>QF_END_OF_INPUT</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,

<decl><name>QF_NOMEM</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>,

<decl><name>QF_IGNORE_LINE</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,

<decl><name>QF_MULTISCAN</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>,

}</block>;</enum>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>linelen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>growbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>growbufsiz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p_str</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>p_li</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>buflnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnumlast</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vimconv_T</name></type> <name>vc</name></decl>;</decl_stmt>

}</block></struct></type> <name>qfstate_T</name>;</typedef>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_grow_linebuf</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newsz</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <ternary><condition><expr><name>newsz</name> <operator>&gt;</operator> <name>LINE_MAXLEN</name></expr> ?</condition><then> <expr><name>LINE_MAXLEN</name> <operator>-</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>newsz</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_next_str_line</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p_str</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>p_str</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_str</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>QF_END_OF_INPUT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>vim_strchr</name><argument_list>(<argument><expr><name>p_str</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>p</name> <operator>-</operator> <name>p_str</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <call><name>qf_grow_linebuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><name>p_str</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p_str</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>p_str</name></name> <operator>=</operator> <name>p_str</name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_next_list_line</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>p_li</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>p_li</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p_li</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>p_li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name>

<operator>||</operator> <name><name>p_li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p_li</name> <operator>=</operator> <name><name>p_li</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt></block_content></block></while> 

<if_stmt><if>if <condition>(<expr><name>p_li</name> <operator>==</operator> <name>NULL</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>p_li</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>QF_END_OF_INPUT</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>p_li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <call><name>qf_grow_linebuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><name><name>p_li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>p_li</name></name> <operator>=</operator> <name><name>p_li</name><operator>-&gt;</operator><name>li_next</name></name></expr>;</expr_stmt> 

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_next_buf_line</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>buflnum</name></name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>lnumlast</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_END_OF_INPUT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p_buf</name> <operator>=</operator> <call><name>ml_get_buf</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>buf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>buflnum</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>buflnum</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <call><name>qf_grow_linebuf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><name>p_buf</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_next_file_line</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>discard</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>growbuflen</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_END_OF_INPUT</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>discard</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>==</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>IObuff</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>=</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>growbuflen</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>+</operator> <name>growbuflen</name></expr></argument>,

<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>-</operator> <name>growbuflen</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>+</operator> <name>growbuflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>growbuflen</name> <operator>+=</operator> <name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name><operator>)</operator><index>[<expr><name>growbuflen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>==</operator> <name>LINE_MAXLEN</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>discard</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>=</operator> <ternary><condition><expr><literal type="number">2</literal> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>&lt;</operator> <name>LINE_MAXLEN</name></expr>

?</condition><then> <expr><literal type="number">2</literal> <operator>*</operator> <name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name></expr> </then><else>: <expr><name>LINE_MAXLEN</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block></for>

<while>while <condition>(<expr><name>discard</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal>

<operator>||</operator> <name><name>IObuff</name><index>[<expr><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>=</operator> <name>growbuflen</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>vc</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name> <operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name></decl>;</decl_stmt>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>string_convert</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>vc</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>&lt;</operator> <name>IOSIZE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>growbuf</name></name> <operator>=</operator> <name>line</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growbufsiz</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>&lt;</operator> <name>LINE_MAXLEN</name></expr>

?</condition><then> <expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr> </then><else>: <expr><name>LINE_MAXLEN</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_nextline</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>QF_FAIL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>fd</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tv</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_get_next_str_line</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_get_next_list_line</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_get_next_buf_line</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_get_next_file_line</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>linebuf</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_CRNL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>linebuf</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>remove_bom</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>namebuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>module</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>errmsg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errmsglen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>lnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>col</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name>use_viscol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>enr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>valid</name></decl>;</decl_stmt>

}</block></struct></type> <name>qffields_T</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_f</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>prefix</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <operator>*</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>expand_env</name><argument_list>(<argument><expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>, <argument><expr><name>CMDBUFFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"OPQ"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>mch_getperm</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_n</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>enr</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>atol</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_l</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>lnum</name></name> <operator>=</operator> <call><name>atol</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_c</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>atol</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_t</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <operator>*</operator><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>copy_nonerror_line</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linelen</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>linelen</name> <operator>&gt;=</operator> <name><name>fields</name><operator>-&gt;</operator><name>errmsglen</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>, <argument><expr><name>linelen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsglen</name></name> <operator>=</operator> <name>linelen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>, <argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_m</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>-</operator> <name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>fields</name><operator>-&gt;</operator><name>errmsglen</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>vim_realloc</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_NOMEM</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsglen</name></name> <operator>=</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>, <argument><expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_r</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_p</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>match_ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>match_ptr</name> <operator>=</operator> <name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr>;</init> <condition><expr><name>match_ptr</name> <operator>!=</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name></expr>;</condition>

<incr><expr><operator>++</operator><name>match_ptr</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>fields</name><operator>-&gt;</operator><name>col</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>match_ptr</name> <operator>==</operator> <name>TAB</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>+=</operator> <literal type="number">7</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>-=</operator> <name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>%</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>++</operator><name><name>fields</name><operator>-&gt;</operator><name>col</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>use_viscol</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_v</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>atol</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>use_viscol</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_s</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>-</operator> <name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>CMDBUFFSIZE</name> <operator>-</operator> <literal type="number">5</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>CMDBUFFSIZE</name> <operator>-</operator> <literal type="number">5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><literal type="string">"^\\V"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRNCAT</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>, <argument><expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'$'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_fmt_o</name><parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>rmp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>midx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>rmp</name><operator>-&gt;</operator><name>endp</name><index>[<expr><name>midx</name></expr>]</index></name> <operator>-</operator> <name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>CMDBUFFSIZE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>CMDBUFFSIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRNCAT</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>module</name></name></expr></argument>, <argument><expr><name><name>rmp</name><operator>-&gt;</operator><name>startp</name><index>[<expr><name>midx</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> (<modifier>*</modifier><name>qf_parse_fmt</name><index>[<expr><name>FMT_PATTERNS</name></expr>]</index>)<parameter_list>(<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type></decl></parameter>, <parameter><decl><type><name>int</name></type></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type></decl></parameter>)</parameter_list> <init>=

<expr><block>{

<expr><name>NULL</name></expr></block></expr></init><operator>,</operator>

qf_parse_fmt_n<operator>,</operator>

qf_parse_fmt_l<operator>,</operator>

qf_parse_fmt_c<operator>,</operator>

qf_parse_fmt_t<operator>,</operator>

qf_parse_fmt_m<operator>,</operator>

NULL<operator>,</operator>

qf_parse_fmt_p<operator>,</operator>

qf_parse_fmt_v<operator>,</operator>

qf_parse_fmt_s<operator>,</operator>

qf_parse_fmt_o</function_decl>

};

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_match</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linelen</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_ptr</name></decl></parameter>,

<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>regmatch</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_multiline</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_multiscan</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>prefix</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>midx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>idx</name> <operator>==</operator> <literal type="char">'C'</literal> <operator>||</operator> <name>idx</name> <operator>==</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>qf_multiline</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"EWI"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>FMT_PATTERNS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>QF_OK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>midx</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>fmt_ptr</name><operator>-&gt;</operator><name>addr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>midx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_fmt_f</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>midx</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>qf_multiscan</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>copy_nonerror_line</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>midx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_fmt_m</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>midx</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">6</literal> <operator>&amp;&amp;</operator> <name>midx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_fmt_r</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>midx</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>midx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <operator>(</operator><name><name>qf_parse_fmt</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator><operator>(</operator><name>regmatch</name><operator>,</operator> <name>midx</name><operator>,</operator> <name>fields</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_get_fields</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linelen</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_ptr</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_multiline</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_multiscan</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>QF_FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_multiscan</name> <operator>&amp;&amp;</operator>

<call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"OPQ"</literal></expr></argument>, <argument><expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>module</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>qf_multiscan</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>use_viscol</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>enr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>tail</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name><name>fmt_ptr</name><operator>-&gt;</operator><name>prog</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>vim_regexec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>linebuf</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>prog</name></name> <operator>=</operator> <name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_match</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>, <argument><expr><name>fmt_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>,

<argument><expr><name>fields</name></expr></argument>, <argument><expr><name>qf_multiline</name></expr></argument>, <argument><expr><name>qf_multiscan</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_dir_pfx</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>, <parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="char">'D'</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E379: Missing or empty directory name"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>=</operator>

<call><name>qf_push_dir</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="char">'X'</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>=</operator> <call><name>qf_pop_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_file_pfx</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>,

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>==</operator> <name>NUL</name> <operator>||</operator> <call><name>mch_getperm</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>&amp;&amp;</operator> <name>idx</name> <operator>==</operator> <literal type="char">'P'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name> <operator>=</operator>

<call><name>qf_push_dir</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_file_stack</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="char">'Q'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name> <operator>=</operator> <call><name>qf_pop_dir</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_file_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tail</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tail</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>STRMOVE</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><call><name>skipwhite</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiscan</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<return>return <expr><name>QF_MULTISCAN</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_line_nomatch</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linelen</name></decl></parameter>, <parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><call><name>copy_nonerror_line</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_multiline_pfx</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>,

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfprev</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_last</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qfprev</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator>

<operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_text</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><operator>(</operator><name>ptr</name> <operator>+=</operator> <name>len</name><operator>)</operator> <operator>=</operator> <literal type="char">'\n'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><operator>++</operator><name>ptr</name></expr></argument>, <argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_nr</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_nr</name></name> <operator>=</operator> <name><name>fields</name><operator>-&gt;</operator><name>enr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_isprintc</name><argument_list>(<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qfprev</name><operator>-&gt;</operator><name>qf_type</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>=</operator> <name><name>fields</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>qfprev</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>=</operator> <name><name>fields</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>qfprev</name><operator>-&gt;</operator><name>qf_col</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>=</operator> <name><name>fields</name><operator>-&gt;</operator><name>col</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_viscol</name></name> <operator>=</operator> <name><name>fields</name><operator>-&gt;</operator><name>use_viscol</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>qfprev</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfprev</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>=</operator> <call><name>qf_get_fnum</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>,

<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>||</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>!=</operator> <name>NULL</name></expr>

?</condition><then> <expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr>

</then><else>: <expr><ternary><condition><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fields</name><operator>-&gt;</operator><name>valid</name></name></expr>

?</condition><then> <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_IGNORE_LINE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_parse_line</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>linebuf</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linelen</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_first</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<label><name>restofline</name>:</label>

<if_stmt><if>if <condition>(<expr><name>fmt_start</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fmt_ptr</name> <operator>=</operator> <name>fmt_first</name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fmt_ptr</name> <operator>=</operator> <name>fmt_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name>fmt_start</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>fields</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<for>for <control>( <init>;</init> <condition><expr><name>fmt_ptr</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>fmt_ptr</name> <operator>=</operator> <name><name>fmt_ptr</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <name><name>fmt_ptr</name><operator>-&gt;</operator><name>prefix</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_get_fields</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>, <argument><expr><name>fmt_ptr</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>,

<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiscan</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_NOMEM</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiscan</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_ptr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>idx</name> <operator>==</operator> <literal type="char">'D'</literal> <operator>||</operator> <name>idx</name> <operator>==</operator> <literal type="char">'X'</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fmt_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_dir_pfx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_line_nomatch</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>, <argument><expr><name>linelen</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>fmt_ptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>conthere</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fmt_start</name> <operator>=</operator> <name>fmt_ptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"AEWI"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"CZ"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_multiline_pfx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>vim_strchr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"OPQ"</literal></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content> 

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_file_pfx</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>, <argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_MULTISCAN</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>restofline</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fmt_ptr</name><operator>-&gt;</operator><name>flags</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>QF_IGNORE_LINE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_stack_empty</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>qi</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_list_empty</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name>qfl</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_list_has_valid_entries</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_list_T</name> <modifier>*</modifier></type>

<name>qf_get_list</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_alloc_fields</name><parameter_list>(<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>pfields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>pfields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name>CMDBUFFSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aid_qf_namebuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfields</name><operator>-&gt;</operator><name>module</name></name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name>CMDBUFFSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aid_qf_module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfields</name><operator>-&gt;</operator><name>errmsglen</name></name> <operator>=</operator> <name>CMDBUFFSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfields</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name><name>pfields</name><operator>-&gt;</operator><name>errmsglen</name></name></expr></argument>, <argument><expr><name>aid_qf_errmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pfields</name><operator>-&gt;</operator><name>pattern</name></name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name>CMDBUFFSIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>aid_qf_pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pfields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pfields</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <name><name>pfields</name><operator>-&gt;</operator><name>pattern</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>pfields</name><operator>-&gt;</operator><name>module</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_free_fields</name><parameter_list>(<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>pfields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>pfields</name><operator>-&gt;</operator><name>namebuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>pfields</name><operator>-&gt;</operator><name>module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>pfields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>pfields</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setup_state</name><parameter_list>(

<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efile</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>lnumfirst</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>lnumlast</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>vc</name><operator>.</operator><name>vc_type</name></name> <operator>=</operator> <name>CONV_NONE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>enc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>enc</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>vc</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>p_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>efile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pstate</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>efile</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_openerrf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>efile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_str</name></name> <operator>=</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_li</name></name> <operator>=</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name><operator>-&gt;</operator><name>lv_first</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>tv</name></name> <operator>=</operator> <name>tv</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>buf</name></name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>buflnum</name></name> <operator>=</operator> <name>lnumfirst</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>lnumlast</name></name> <operator>=</operator> <name>lnumlast</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_cleanup_state</name><parameter_list>(<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>fd</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>growbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pstate</name><operator>-&gt;</operator><name>vc</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pstate</name><operator>-&gt;</operator><name>vc</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_init_process_nextline</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>efm_T</name> <modifier>*</modifier></type><name>fmt_first</name></decl></parameter>,

<parameter><decl><type><name>qfstate_T</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><name>qffields_T</name> <modifier>*</modifier></type><name>fields</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_get_nextline</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_parse_line</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linebuf</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>linelen</name></name></expr></argument>,

<argument><expr><name>fmt_first</name></expr></argument>, <argument><expr><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>QF_OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>status</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>qf_add_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>,

<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name> <operator>||</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>

?</condition><then> <expr><name><name>fields</name><operator>-&gt;</operator><name>namebuf</name></name></expr>

</then><else>: <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>fields</name><operator>-&gt;</operator><name>valid</name></name><operator>)</operator></expr>

?</condition><then> <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name></expr> </then><else>: <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>NULL</name></expr></else></ternary><operator>)</operator></expr></else></ternary></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>module</name></name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>lnum</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>col</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>use_viscol</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>pattern</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>enr</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,

<argument><expr><name><name>fields</name><operator>-&gt;</operator><name>valid</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_init_ext</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efile</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>errorformat</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>newlist</name></decl></parameter>, 

<parameter><decl><type><name>linenr_T</name></type> <name>lnumfirst</name></decl></parameter>, 

<parameter><decl><type><name>linenr_T</name></type> <name>lnumlast</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfstate_T</name></type> <name>state</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qffields_T</name></type> <name>fields</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>adding</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>efm_T</name> <modifier>*</modifier></type><name>fmt_first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efm</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type><name>last_efm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>qf_last_bufname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fields</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>qf_alloc_fields</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><call><name>qf_setup_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>efile</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,

<argument><expr><name>lnumfirst</name></expr></argument>, <argument><expr><name>lnumlast</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>qf_init_end</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newlist</name> <operator>||</operator> <name>qf_idx</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>adding</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>old_last</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_last</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>errorformat</name> <operator>==</operator> <name>p_efm</name> <operator>&amp;&amp;</operator> <name>tv</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>buf</name><operator>-&gt;</operator><name>b_p_efm</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>efm</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_p_efm</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>efm</name> <operator>=</operator> <name>errorformat</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>last_efm</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>(</operator><call><name>STRCMP</name><argument_list>(<argument><expr><name>last_efm</name></expr></argument>, <argument><expr><name>efm</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name>last_efm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_efm_list</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fmt_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fmt_first</name> <operator>=</operator> <call><name>parse_efm_option</name><argument_list>(<argument><expr><name>efm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_first</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>last_efm</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>efm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt_first</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<goto>goto <name>error2</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_init_process_nextline</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>fmt_first</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_NOMEM</name></expr>)</condition><block type="pseudo"><block_content> 

<goto>goto <name>qf_init_end</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_END_OF_INPUT</name></expr>)</condition><block type="pseudo"><block_content> 

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>QF_FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>error2</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>.</operator><name>fd</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>ferror</name><argument_list>(<argument><expr><name><name>state</name><operator>.</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt>

<goto>goto <name>qf_init_end</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_readerrf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>error2</name>:</label>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>adding</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>--</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>qf_init_end</name>:</label>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>old_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_cleanup_state</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_free_fields</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fields</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_init</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>efile</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>errorformat</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>newlist</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>ll_get_or_alloc_list</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>qf_init_ext</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><name>efile</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errorformat</name></expr></argument>,

<argument><expr><name>newlist</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>qf_title</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_store_title</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>title</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_cmdtitle</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name></type> <name><name>qftitle_str</name><index>[<expr><name>IOSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>qftitle_str</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">":%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>qftitle_str</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_list_T</name> <modifier>*</modifier></type>

<name>qf_get_curlist</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_new_list</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>&gt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><operator>--</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>==</operator> <name>LISTCOUNT</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LISTCOUNT</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name>LISTCOUNT</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>qf_list_T</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_store_title</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>qf_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qfl_type</name></name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qfl_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_id</name></name> <operator>=</operator> <operator>++</operator><name>last_qf_id</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>locstack_queue_delreq</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_delq_T</name> <modifier>*</modifier></type><name>q</name></decl>;</decl_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>qf_delq_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>qi</name></name> <operator>=</operator> <name>qi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>q</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>qf_delq_head</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_delq_head</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_stack_get_bufnr</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><name><name>ql_info</name><operator>.</operator><name>qf_bufnr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>wipe_qf_buffer</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>qfbuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>!=</operator> <name>INVALID_QFBUFNR</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qfbuf</name> <operator>=</operator> <call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfbuf</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>qfbuf</name><operator>-&gt;</operator><name>b_nwindows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>close_buffer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>qfbuf</name></expr></argument>, <argument><expr><name>DOBUF_WIPE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>=</operator> <name>INVALID_QFBUFNR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>ll_free_all</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>pqi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <operator>*</operator><name>pqi</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pqi</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>quickfix_busy</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>locstack_queue_delreq</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_refcount</name></name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_refcount</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>wipe_qf_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_free_all</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>incr_quickfix_busy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name>quickfix_busy</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>decr_quickfix_busy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>quickfix_busy</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<while>while <condition>(<expr><name>qf_delq_head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_delq_T</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>qf_delq_head</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>qf_delq_head</name> <operator>=</operator> <name><name>q</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>q</name><operator>-&gt;</operator><name>qi</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ABORT_ON_INTERNAL_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>quickfix_busy</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><literal type="string">"quickfix_busy has become negative"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EXITFREE</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><name>void</name></type>

<name>check_quickfix_busy</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>quickfix_busy</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><literal type="string">"quickfix_busy not zero on exit: %ld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>quickfix_busy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ABORT_ON_INTERNAL_ERROR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_add_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>module</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>bufnum</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>mesg</name></decl></parameter>, 

<parameter><decl><type><name>long</name></type> <name>lnum</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>col</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>vis_col</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>valid</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>lastp</name></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qfp</name> <operator>=</operator> <call><name>ALLOC_ONE</name><argument_list>(<argument><expr><name>qfline_T</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>QF_FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bufnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>buflist_findnr</name><argument_list>(<argument><expr><name>bufnum</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>=</operator> <name>bufnum</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_has_qf_entry</name></name> <operator>|=</operator>

<ternary><condition><expr><call><name>IS_QF_LIST</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BUF_HAS_QF_ENTRY</name></expr> </then><else>: <expr><name>BUF_HAS_LL_ENTRY</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>=</operator> <call><name>qf_get_fnum</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>mesg</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>=</operator> <name>col</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_viscol</name></name> <operator>=</operator> <name>vis_col</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pattern</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>pattern</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>module</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>module</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>QF_FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_nr</name></name> <operator>=</operator> <name>nr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>vim_isprintc</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name> <operator>=</operator> <name>valid</name></expr>;</expr_stmt>

<expr_stmt><expr><name>lastp</name> <operator>=</operator> <operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_last</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name> <operator>=</operator> <name>qfp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>qfp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>=</operator> <operator>*</operator><name>lastp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>lastp</name><operator>)</operator><operator>-&gt;</operator><name>qf_next</name></name> <operator>=</operator> <name>qfp</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_cleared</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>lastp</name> <operator>=</operator> <name>qfp</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>qfp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>QF_OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type>

<name>qf_alloc_stack</name><parameter_list>(<parameter><decl><type><name>qfltype_T</name></type> <name>qfltype</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>ALLOC_CLEAR_ONE</name><argument_list>(<argument><expr><name>qf_info_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qfl_type</name></name> <operator>=</operator> <name>qfltype</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>=</operator> <name>INVALID_QFBUFNR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qi</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type>

<name>ll_get_or_alloc_list</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>wp</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>=</operator> <call><name>qf_alloc_stack</name><argument_list>(<argument><expr><name>QFLT_LOCATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type>

<name>qf_cmd_get_stack</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>print_emsg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_loclist_cmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>print_emsg</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loclist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qi</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type>

<name>qf_cmd_get_or_alloc_stack</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>pwinp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_loclist_cmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>ll_get_or_alloc_list</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>pwinp</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qi</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>copy_loclist_entries</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>from_qfl</name></decl></parameter>, <parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>to_qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>from_qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>prevp</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>from_qfl</argument>, <argument>from_qfp</argument>, <argument>i</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_add_entry</name><argument_list>(<argument><expr><name>to_qfl</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_col</name></name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_viscol</name></name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_nr</name></name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>from_qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>QF_FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prevp</name> <operator>=</operator> <name><name>to_qfl</name><operator>-&gt;</operator><name>qf_last</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>prevp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>=</operator> <name><name>from_qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>prevp</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>=</operator> <name><name>from_qfp</name><operator>-&gt;</operator><name>qf_type</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>==</operator> <name>from_qfp</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>prevp</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>copy_loclist</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>from_qfl</name></decl></parameter>, <parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>to_qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qfl_type</name></name> <operator>=</operator> <name><name>from_qfl</name><operator>-&gt;</operator><name>qfl_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name><name>from_qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>=</operator> <call><name>alloc_tv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name></expr></argument>, <argument><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>from_qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>copy_loclist_entries</name><argument_list>(<argument><expr><name>from_qfl</name></expr></argument>, <argument><expr><name>to_qfl</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <name><name>from_qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_id</name></name> <operator>=</operator> <operator>++</operator><name>last_qf_id</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_changedtick</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>to_qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>to_qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>copy_loclist_stack</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>w_llist</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>to</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>=</operator> <call><name>qf_alloc_stack</name><argument_list>(<argument><expr><name>QFLT_LOCATION</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>w_llist</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>w_llist</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>copy_loclist</name><argument_list>(<argument><expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name><name>to</name><operator>-&gt;</operator><name>w_llist</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>to</name><operator>-&gt;</operator><name>w_llist</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_fnum</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>directory</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>bufname</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>fname</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>vms_remove_version</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BACKSLASH_IN_FILENAME</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>slash_adjust</name><argument_list>(<argument><expr><name>directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>slash_adjust</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>directory</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>vim_isAbsName</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>concat_fnames</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>mch_getperm</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>directory</name> <operator>=</operator> <call><name>qf_guess_filepath</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>directory</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>concat_fnames</name><argument_list>(<argument><expr><name>directory</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bufname</name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>bufname</name> <operator>=</operator> <name>fname</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_last_bufname</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>bufname</name></expr></argument>, <argument><expr><name>qf_last_bufname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qf_last_bufref</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name><name>qf_last_bufref</name><operator>.</operator><name>br_buf</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qf_last_bufname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buflist_new</name><argument_list>(<argument><expr><name>bufname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>BLN_NOOPT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bufname</name> <operator>==</operator> <name>ptr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_last_bufname</name> <operator>=</operator> <name>bufname</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_last_bufname</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>bufname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qf_last_bufref</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_has_qf_entry</name></name> <operator>=</operator>

<ternary><condition><expr><call><name>IS_QF_LIST</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>BUF_HAS_QF_ENTRY</name></expr> </then><else>: <expr><name>BUF_HAS_LL_ENTRY</name></expr></else></ternary></expr>;</expr_stmt>

<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_push_dir</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirbuf</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stackptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_file_stack</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_new</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_ptr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ds_new</name> <operator>=</operator> <call><name>ALLOC_ONE</name><argument_list>(<argument><expr>struct <name>dir_stack_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ds_new</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>ds_new</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <operator>*</operator><name>stackptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>stackptr</name> <operator>=</operator> <name>ds_new</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_isAbsName</name><argument_list>(<argument><expr><name>dirbuf</name></expr></argument>)</argument_list></call>

<operator>||</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <operator>(</operator><operator>*</operator><name>stackptr</name> <operator>&amp;&amp;</operator> <name>is_file_stack</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>dirbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>ds_new</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ds_new</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <call><name>concat_fnames</name><argument_list>(<argument><expr><name><name>ds_new</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>, <argument><expr><name>dirbuf</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mch_isdir</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TRUE</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ds_new</name> <operator>=</operator> <name><name>ds_new</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>ds_new</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ds_ptr</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name><name>next</name><operator>-&gt;</operator><name>next</name></name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ds_ptr</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ds_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>ds_new</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>dirbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name></expr>;</return></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>ds_ptr</name> <operator>=</operator> <operator>*</operator><name>stackptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>stackptr</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ds_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_pop_dir</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stackptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>stackptr</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ds_ptr</name> <operator>=</operator> <operator>*</operator><name>stackptr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>stackptr</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ds_ptr</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ds_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><operator>*</operator><name>stackptr</name></expr> ?</condition><then> <expr><name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>dirname</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_clean_dir_stack</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>stackptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_ptr</name></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>(</operator><name>ds_ptr</name> <operator>=</operator> <operator>*</operator><name>stackptr</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>stackptr</name> <operator>=</operator> <name><operator>(</operator><operator>*</operator><name>stackptr</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ds_ptr</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ds_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_guess_filepath</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>dir_stack_T</name></name> <modifier>*</modifier></type><name>ds_tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fullname</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ds_ptr</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>fullname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>ds_ptr</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fullname</name> <operator>=</operator> <call><name>concat_fnames</name><argument_list>(<argument><expr><name><name>ds_ptr</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fullname</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>mch_getperm</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>ds_ptr</name> <operator>=</operator> <name><name>ds_ptr</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name><operator>-&gt;</operator><name>next</name></name> <operator>!=</operator> <name>ds_ptr</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>ds_tmp</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>ds_tmp</name><operator>-&gt;</operator><name>dirname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>ds_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><ternary><condition><expr><name>ds_ptr</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>ds_ptr</name><operator>-&gt;</operator><name>dirname</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qflist_valid</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>int_u</name></type> <name>qf_id</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>qf_id</name> <operator>==</operator> <name>qf_id</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_qf_entry_present</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name>qfp</name> <operator>==</operator> <name>qf_ptr</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>get_next_valid_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>qf_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_qf_fnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>*</operator><name>qf_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_qf_fnum</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

<do>do

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>||</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><operator>!</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_valid</name></name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>dir</name> <operator>==</operator> <name>FORWARD_FILE</name> <operator>&amp;&amp;</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name>old_qf_fnum</name><operator>)</operator></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>qf_index</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<return>return <expr><name>qf_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>get_prev_valid_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>qf_index</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_qf_fnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <operator>*</operator><name>qf_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_qf_fnum</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

<do>do

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_prev</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>(</operator><operator>!</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_valid</name></name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name>dir</name> <operator>==</operator> <name>BACKWARD_FILE</name> <operator>&amp;&amp;</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name>old_qf_fnum</name><operator>)</operator></expr>)</condition>;</do>

<expr_stmt><expr><operator>*</operator><name>qf_index</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<return>return <expr><name>qf_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>get_nth_valid_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_qfidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>prev_qf_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>err</name> <init>= <expr><name>e_no_more_items</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>errornr</name><operator>--</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>prev_qf_ptr</name> <operator>=</operator> <name>qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_index</name> <operator>=</operator> <name>qf_idx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>FORWARD</name> <operator>||</operator> <name>dir</name> <operator>==</operator> <name>FORWARD_FILE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>get_next_valid_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qf_idx</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>get_prev_valid_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qf_idx</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name>prev_qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name>prev_index</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>err</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>new_qfidx</name> <operator>=</operator> <name>qf_idx</name></expr>;</expr_stmt>

<return>return <expr><name>qf_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>get_nth_entry</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_qfidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>errornr</name> <argument_list type="generic">&lt; <argument><expr><name>qf_idx</name> <operator>&amp;&amp;</operator> <name>qf_idx</name></expr></argument> &gt;</argument_list></name> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>--</operator><name>qf_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_prev</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name>errornr</name> <operator>&gt;</operator> <name>qf_idx</name> <operator>&amp;&amp;</operator> <name>qf_idx</name> <operator>&lt;</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>&amp;&amp;</operator>

<name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>qf_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><operator>*</operator><name>new_qfidx</name> <operator>=</operator> <name>qf_idx</name></expr>;</expr_stmt>

<return>return <expr><name>qf_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_get_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_qfidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qfidx</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>get_nth_valid_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qfidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>errornr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>get_nth_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qfidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>new_qfidx</name> <operator>=</operator> <name>qfidx</name></expr>;</expr_stmt>

<return>return <expr><name>qf_ptr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>win_T</name> <modifier>*</modifier></type>

<name>qf_find_help_win</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>wp</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>bt_help</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>wp</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>win_set_loclist</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>=</operator> <name>qi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>jump_to_help_window</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newwin</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>opened_window</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmdmod</name><operator>.</operator><name>tab</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <name>newwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>qf_find_help_win</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_nwindows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_enter</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>WSP_HELP</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmdmod</name><operator>.</operator><name>split</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>!=</operator> <name>Columns</name>

<operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>&lt;</operator> <literal type="number">80</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WSP_TOP</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>newwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WSP_NEWLOC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>win_split</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>opened_window</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_height</name></name> <operator>&lt;</operator> <name>p_hh</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_setheight</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>p_hh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>newwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_set_loclist</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p_im</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>restart_edit</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>win_T</name> <modifier>*</modifier></type>

<name>qf_find_win_with_loclist</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>ll</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>wp</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>ll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>bt_quickfix</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>wp</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>win_T</name> <modifier>*</modifier></type>

<name>qf_find_win_with_normal_buf</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>wp</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>bt_normal</name><argument_list>(<argument><expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>wp</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_goto_tabwin_with_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tp</argument>, <argument>wp</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_fnum</name></name> <operator>==</operator> <name>fnum</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>goto_tabpage_win</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_open_new_file_win</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>ll_ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>WSP_ABOVE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ll_ref</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WSP_NEWLOC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>win_split</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>p_swb</name> <operator>=</operator> <name>empty_option</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>swb_flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RESET_BINDING</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ll_ref</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_set_loclist</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>ll_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_goto_win_with_ll_file</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>use_win</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_fnum</name></decl></parameter>, <parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>ll_ref</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><name>use_win</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>win</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_fnum</name></name> <operator>==</operator> <name>qf_fnum</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<do>do

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>bt_normal</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>lastwin</name></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> 

</block_content>}</block> while <condition>(<expr><name>win</name> <operator>!=</operator> <name>curwin</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>win_goto</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>ll_ref</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_set_loclist</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>ll_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_goto_win_with_qfl_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>qf_fnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>altwin</name></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>altwin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_fnum</name></name> <operator>==</operator> <name>qf_fnum</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_prev</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>lastwin</name></expr>;</expr_stmt></block_content></block></if> 

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_prev</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>IS_QF_WINDOW</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>swb_flags</name> <operator>&amp;</operator> <name>SWB_USELAST</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>win_valid</name><argument_list>(<argument><expr><name>prevwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>prevwin</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>altwin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>altwin</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_prev</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_prev</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>altwin</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>win</name><operator>-&gt;</operator><name>w_p_pvw</name></name> <operator>&amp;&amp;</operator> <call><name>bt_normal</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>altwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>win_goto</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_jump_to_usable_window</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>qf_fnum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>newwin</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>opened_window</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>usable_wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>usable_win</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>ll_ref</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ll_ref</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ll_ref</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>usable_wp</name> <operator>=</operator> <call><name>qf_find_win_with_loclist</name><argument_list>(<argument><expr><name>ll_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>usable_wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>usable_win</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>usable_win</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><call><name>qf_find_win_with_normal_buf</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>usable_win</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>usable_win</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>swb_flags</name> <operator>&amp;</operator> <name>SWB_USETAB</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>usable_win</name> <operator>=</operator> <call><name>qf_goto_tabwin_with_file</name><argument_list>(<argument><expr><name>qf_fnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ONE_WINDOW</name> <operator>&amp;&amp;</operator> <call><name>bt_quickfix</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>!</operator><name>usable_win</name> <operator>||</operator> <name>newwin</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_open_new_file_win</name><argument_list>(<argument><expr><name>ll_ref</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>opened_window</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_llist_ref</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>qf_goto_win_with_ll_file</name><argument_list>(<argument><expr><name>usable_wp</name></expr></argument>, <argument><expr><name>qf_fnum</name></expr></argument>, <argument><expr><name>ll_ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>qf_goto_win_with_qfl_file</name><argument_list>(<argument><expr><name>qf_fnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_jump_edit_buffer</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>prev_winid</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>opened_window</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name> <init>= <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfltype_T</name></type> <name>qfl_type</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qfl_type</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_qf_curlist</name> <init>= <expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>save_qfid</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_id</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_abandon</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>no_write_message</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>do_ecmd</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">1</literal></expr></argument>,

<argument><expr><name>ECMD_HIDE</name> <operator>+</operator> <name>ECMD_SET_HELP</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>prev_winid</name> <operator>==</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_id</name></name></expr> ?</condition><then> <expr><name>curwin</name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>buflist_getfile</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>GETF_SETMARK</name> <operator>|</operator> <name>GETF_SWITCH</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qfl_type</name> <operator>==</operator> <name>QFLT_LOCATION</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><call><name>win_id2wp</name><argument_list>(<argument><expr><name>prev_winid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>!=</operator> <name>qi</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E924: Current window was closed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>opened_window</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<return>return <expr><name>NOTDONE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qfl_type</name> <operator>==</operator> <name>QFLT_QUICKFIX</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>qflist_valid</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E925: Current quickfix was changed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NOTDONE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>old_qf_curlist</name> <operator>!=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name>

<operator>||</operator> <operator>!</operator><call><name>is_qf_entry_present</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>qfl_type</name> <operator>==</operator> <name>QFLT_QUICKFIX</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E925: Current quickfix was changed"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loc_list_changed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>NOTDONE</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_jump_goto_line</name><parameter_list>(

<parameter><decl><type><name>linenr_T</name></type> <name>qf_lnum</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_col</name></decl></parameter>,

<parameter><decl><type><name>char_u</name></type> <name>qf_viscol</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_pattern</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_pattern</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>qf_lnum</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_col</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_viscol</name> <operator>==</operator> <name>TRUE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>coladvance</name><argument_list>(<argument><expr><name>qf_col</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <name>qf_col</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_set_curswant</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_cursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>beginline</name><argument_list>(<argument><expr><name>BL_WHITE</name> <operator>|</operator> <name>BL_FIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>pos_T</name></type> <name>save_cursor</name></decl>;</decl_stmt>

<expr_stmt><expr><name>save_cursor</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>do_search</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>, <argument><expr><name>qf_pattern</name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>SEARCH_KEEP</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name> <operator>=</operator> <name>save_cursor</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_jump_print_msg</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_index</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>old_curbuf</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>old_lnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>msg_scrolled</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>update_topline_redraw</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"(%d of %d)%s%s: "</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>qf_index</name></expr></argument>,

<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_count</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_cleared</name></name></expr> ?</condition><then> <expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" (line deleted)"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>qf_types</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_type</name></name></expr></argument>, <argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_nr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_fmt_text</name><argument_list>(<argument><expr><call><name>skipwhite</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>msg_scroll</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>==</operator> <name>old_curbuf</name> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>==</operator> <name>old_lnum</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name>msg_scrolled</name> <operator>&amp;&amp;</operator> <call><name>shortmess</name><argument_list>(<argument><expr><name>SHM_OVERALL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>msg_attr_keep</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msg_scroll</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_jump_open_window</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>newwin</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>opened_window</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>bt_help</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>cmdmod</name><operator>.</operator><name>tab</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>jump_to_help_window</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>newwin</name></expr></argument>, <argument><expr><name>opened_window</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bt_quickfix</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>opened_window</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NOTDONE</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_jump_to_usable_window</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr></argument>, <argument><expr><name>newwin</name></expr></argument>,

<argument><expr><name>opened_window</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_jump_to_buffer</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_index</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>prev_winid</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>opened_window</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>openfold</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>print_message</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>old_curbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>old_lnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>old_curbuf</name> <operator>=</operator> <name>curbuf</name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_lnum</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_jump_edit_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>, <argument><expr><name>prev_winid</name></expr></argument>,

<argument><expr><name>opened_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>retval</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>==</operator> <name>old_curbuf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>setpcmark</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_jump_goto_line</name><argument_list>(<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>, <argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_col</name></name></expr></argument>, <argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_viscol</name></name></expr></argument>,

<argument><expr><name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fdo_flags</name> <operator>&amp;</operator> <name>FDO_QUICKFIX</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>openfold</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>foldOpenCursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>print_message</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump_print_msg</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_index</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><name>old_curbuf</name></expr></argument>, <argument><expr><name>old_lnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_jump</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_jump_newwin</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_jump_newwin</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>errornr</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>newwin</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_qf_ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_qf_index</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>old_swb</name> <init>= <expr><name>p_swb</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>old_swb_flags</name> <init>= <expr><name>swb_flags</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_winid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opened_window</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>print_message</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_KeyTyped</name> <init>= <expr><name>KeyTyped</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <operator>&amp;</operator><name>ql_info</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_quickfix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_qf_ptr</name> <operator>=</operator> <name>qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_index</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>old_qf_index</name> <operator>=</operator> <name>qf_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>qf_get_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name>old_qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_index</name> <operator>=</operator> <name>old_qf_index</name></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <name>qf_index</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_win_pos_update</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>old_qf_index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>print_message</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>prev_winid</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_id</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_jump_open_window</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><name>newwin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opened_window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>failed</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>NOTDONE</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_jump_to_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_index</name></expr></argument>, <argument><expr><name>qf_ptr</name></expr></argument>, <argument><expr><name>forceit</name></expr></argument>, <argument><expr><name>prev_winid</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>opened_window</name></expr></argument>, <argument><expr><name>old_KeyTyped</name></expr></argument>, <argument><expr><name>print_message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>NOTDONE</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>!=</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>opened_window</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_close</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>qf_ptr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>qf_ptr</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<label><name>failed</name>:</label>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <name>old_qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_index</name> <operator>=</operator> <name>old_qf_index</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>theend</name>:</label>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <name>qf_index</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_swb</name> <operator>!=</operator> <name>old_swb</name> <operator>&amp;&amp;</operator> <name>p_swb</name> <operator>==</operator> <name>empty_option</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>p_swb</name> <operator>=</operator> <name>old_swb</name></expr>;</expr_stmt>

<expr_stmt><expr><name>swb_flags</name> <operator>=</operator> <name>old_swb_flags</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>qfFileAttr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>qfSepAttr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>qfLineAttr</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_list_entry</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cursel</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>filter_entry</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%2d %s"</literal></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>buf</name> <operator>=</operator> <call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_fname</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>gettail</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"%2d"</literal></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%2d %s"</literal></expr></argument>,

<argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>filter_entry</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>filter_entry</name> <operator>&amp;=</operator> <call><name>message_filtered</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_entry</name> <operator>&amp;&amp;</operator> <name>fname</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>filter_entry</name> <operator>&amp;=</operator> <call><name>message_filtered</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_entry</name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>filter_entry</name> <operator>&amp;=</operator> <call><name>message_filtered</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_entry</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>filter_entry</name> <operator>&amp;=</operator> <call><name>message_filtered</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_entry</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>msg_putchar</name><argument_list>(<argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_outtrans_attr</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><ternary><condition><expr><name>cursel</name></expr> ?</condition><then> <expr><call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_QFL</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>qfFileAttr</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><name>qfSepAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>IObuff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><literal type="string">"%ld col %d"</literal></expr></argument>,

<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name> <operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>qf_types</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_nr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>qfLineAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><name>qfSepAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_fmt_text</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts_attr</name><argument_list>(<argument><expr><literal type="string">":"</literal></expr></argument>, <argument><expr><name>qfSepAttr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_fmt_text</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>fname</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>

?</condition><then> <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></else></ternary></expr></argument>,

<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_prt_line</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_list</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx1</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx2</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>plus</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>all</name> <init>= <expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_quickfix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>arg</name></expr>;</expr_stmt>

<expr_stmt><expr><name>plus</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_list_range</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arg</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>idx2</name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>arg</name> <operator>!=</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_trailing</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>plus</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>idx2</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>idx1</name></expr>;</expr_stmt>

<expr_stmt><expr><name>idx1</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx1</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>idx1</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>-</operator><name>idx1</name> <operator>&gt;</operator> <name>i</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>idx1</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>idx2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>idx2</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>-</operator><name>idx2</name> <operator>&gt;</operator> <name>i</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>idx2</name> <operator>+</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>shorten_fnames</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qfFileAttr</name> <operator>=</operator> <call><name>syn_name2attr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"qfFileName"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfFileAttr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qfFileAttr</name> <operator>=</operator> <call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfSepAttr</name> <operator>=</operator> <call><name>syn_name2attr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"qfSeparator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfSepAttr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qfSepAttr</name> <operator>=</operator> <call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfLineAttr</name> <operator>=</operator> <call><name>syn_name2attr</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"qfLineNr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfLineAttr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qfLineAttr</name> <operator>=</operator> <call><name>HL_ATTR</name><argument_list>(<argument><expr><name>HLF_N</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>all</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name> <operator>||</operator> <name>all</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>idx1</name> <operator>&lt;=</operator> <name>i</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;=</operator> <name>idx2</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_entry</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>==</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>ui_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_fmt_text</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>text</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsize</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>text</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>bufsize</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><operator>++</operator><name>p</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>VIM_ISWHITE</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></while>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_msg</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>which</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lead</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><name>qf_title</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>which</name></expr>]</index></name><operator>.</operator><name>qf_count</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><name>IOSIZE</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"%serror list %d of %d; %d errors "</literal></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>lead</name></expr></argument>,

<argument><expr><name>which</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr></argument>,

<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>title</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">34</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="number">34</literal> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">34</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><name>title</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>trunc_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>Columns</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_age</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<while>while <condition>(<expr><name>count</name><operator>--</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_colder</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lolder</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E380: At bottom of quickfix stack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>&gt;=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E381: At top of quickfix stack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>qf_msg</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_history</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loclist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>&lt;=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_msg</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"No entries"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_msg</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr> ?</condition><then> <expr><literal type="string">"&gt; "</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_free_items</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfpnext</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stop</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>&amp;&amp;</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>qfpnext</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stop</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stop</name> <operator>=</operator> <operator>(</operator><name>qfp</name> <operator>==</operator> <name>qfpnext</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>stop</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name> <operator>=</operator> <name>qfpnext</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_last</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_clean_dir_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_dir_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_directory</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_clean_dir_stack</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qfl</name><operator>-&gt;</operator><name>qf_file_stack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_currfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiline</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiignore</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_multiscan</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_free</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free_items</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>VIM_CLEAR</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_tv</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_changedtick</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_mark_adjust</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>line1</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name></type> <name>line2</name></decl></parameter>,

<parameter><decl><type><name>long</name></type> <name>amount</name></decl></parameter>,

<parameter><decl><type><name>long</name></type> <name>amount_after</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_one</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_has_flag</name> <init>= <expr><ternary><condition><expr><name>wp</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>BUF_HAS_QF_ENTRY</name></expr> </then><else>: <expr><name>BUF_HAS_LL_ENTRY</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_has_qf_entry</name></name> <operator>&amp;</operator> <name>buf_has_flag</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>idx</name></expr></incr>)</control>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name> <init>= <expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>found_one</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;=</operator> <name>line1</name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&lt;=</operator> <name>line2</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>amount</name> <operator>==</operator> <name>MAXLNUM</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_cleared</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>amount_after</name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;</operator> <name>line2</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>+=</operator> <name>amount_after</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_one</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_has_qf_entry</name></name> <operator>&amp;=</operator> <operator>~</operator><name>buf_has_flag</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>qf_types</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">20</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>char_u</name></type> <name><name>cc</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'W'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" warning"</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'I'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" info"</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'E'</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>(</operator><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nr</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">" error"</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>c</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>cc</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cc</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cc</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>cc</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nr</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>p</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s %3d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p</name></expr></argument>, <argument><expr><name>nr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>qf_view_result</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>split</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bt_quickfix</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_quickfix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>split</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_jump_newwin</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator> <literal type="string">"clearjumps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>do_cmdline_cmd</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">".ll"</literal></expr> </then><else>: <expr><literal type="string">".cc"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cwindow</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call>

<operator>||</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name>

<operator>||</operator> <call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ex_cclose</name><argument_list>(<argument><expr><name>eap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>win</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ex_copen</name><argument_list>(<argument><expr><name>eap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cclose</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_close</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_set_title_var</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_internal_string_var</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"w:quickfix_title"</literal></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_goto_cwindow</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>resize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sz</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vertsplit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>win_goto</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>resize</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>vertsplit</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>!=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_width</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_setwidth</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>sz</name> <operator>!=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_height</name></name> <operator>&amp;&amp;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_height</name></name>

<operator>+</operator> <name><name>win</name><operator>-&gt;</operator><name>w_status_height</name></name> <operator>+</operator> <call><name>tabline_height</name><argument_list>()</argument_list></call> <operator>&lt;</operator> <name>cmdline_row</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_setheight</name><argument_list>(<argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_set_cwindow_options</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"swf"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"bt"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"quickfix"</literal></expr></argument>,

<argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"bh"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"hide"</literal></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>RESET_BINDING</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_DIFF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_p_diff</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"fdm"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"manual"</literal></expr></argument>,

<argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_open_new_cwindow</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>height</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>qf_buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>oldwin</name> <init>= <expr><name>curwin</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>prevtab</name> <init>= <expr><name>curtab</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qf_buf</name> <operator>=</operator> <call><name>qf_find_buf</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_QF_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>cmdmod</name><operator>.</operator><name>split</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_goto</name><argument_list>(<argument><expr><name>lastwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cmdmod</name><operator>.</operator><name>split</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <name>WSP_BELOW</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>WSP_NEWLOC</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>win_split</name><argument_list>(<argument><expr><name>height</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt> 

<expr_stmt><expr><call><name>RESET_BINDING</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_llist_ref</name></name> <operator>=</operator> <name>qi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_refcount</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>oldwin</name> <operator>!=</operator> <name>curwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>oldwin</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>qf_buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>do_ecmd</name><argument_list>(<argument><expr><name><name>qf_buf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ECMD_ONE</name></expr></argument>,

<argument><expr><name>ECMD_HIDE</name> <operator>+</operator> <name>ECMD_OLDBUF</name></expr></argument>, <argument><expr><name>oldwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>do_ecmd</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ECMD_ONE</name></expr></argument>, <argument><expr><name>ECMD_HIDE</name></expr></argument>, <argument><expr><name>oldwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>=</operator> <name><name>curbuf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bt_quickfix</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_set_cwindow_options</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>curtab</name> <operator>==</operator> <name>prevtab</name> <operator>&amp;&amp;</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_width</name></name> <operator>==</operator> <name>Columns</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_setheight</name><argument_list>(<argument><expr><name>height</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_p_wfh</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>win_valid</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>prevwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_copen</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lnum</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>height</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>height</name> <operator>=</operator> <name>QF_WINHEIGHT</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>reset_VIsual_and_resel</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_GUI</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>need_mouse_correct</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name><name>cmdmod</name><operator>.</operator><name>tab</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_goto_cwindow</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>height</name></expr></argument>,

<argument><expr><name><name>cmdmod</name><operator>.</operator><name>split</name></name> <operator>&amp;</operator> <name>WSP_VERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_open_new_cwindow</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>height</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_set_title_var</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_fill_buffer</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_cursor</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_topline</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_win_goto</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>, <parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>old_curwin</name> <init>= <expr><name>curwin</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>=</operator> <name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>col</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>coladd</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_curswant</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_topline</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>redraw_later</name><argument_list>(<argument><expr><name>VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_redr_status</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>old_curwin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curbuf</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cbottom</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_cursor</name><operator>.</operator><name>lnum</name></name> <operator>!=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_win_goto</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>linenr_T</name></type>

<name>qf_current_entry</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_index</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_win_pos_update</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>old_qf_index</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_index</name> <init>= <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_index</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name>qf_index</name> <operator>&lt;=</operator> <name><name>win</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name>

<operator>&amp;&amp;</operator> <name>old_qf_index</name> <operator>!=</operator> <name>qf_index</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>qf_index</name> <operator>&gt;</operator> <name>old_qf_index</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_redraw_top</name></name> <operator>=</operator> <name>old_qf_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_redraw_bot</name></name> <operator>=</operator> <name>qf_index</name></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_redraw_top</name></name> <operator>=</operator> <name>qf_index</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>win</name><operator>-&gt;</operator><name>w_redraw_bot</name></name> <operator>=</operator> <name>old_qf_index</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>qf_win_goto</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>qf_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>is_qf_win</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl></parameter>, <parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>bt_quickfix</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>IS_QF_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_llist_ref</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><call><name>IS_LL_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_llist_ref</name></name> <operator>==</operator> <name>qi</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>TRUE</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>win_T</name> <modifier>*</modifier></type>

<name>qf_find_win</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<macro><name>FOR_ALL_WINDOWS</name><argument_list>(<argument>win</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>is_qf_win</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>win</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type>

<name>qf_find_buf</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>!=</operator> <name>INVALID_QFBUFNR</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>qfbuf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qfbuf</name> <operator>=</operator> <call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfbuf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>qfbuf</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>=</operator> <name>INVALID_QFBUFNR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tp</argument>, <argument>win</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><call><name>is_qf_win</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>win</name><operator>-&gt;</operator><name>w_buffer</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_update_win_titlevar</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>curwin_save</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curwin_save</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>win</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_set_title_var</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curwin</name> <operator>=</operator> <name>curwin_save</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_update_buffer</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>aco_save_T</name></type> <name>aco</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>qf_find_buf</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>old_line_count</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>aucmd_prepbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_update_win_titlevar</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_fill_buffer</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>old_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><call><name>CHANGEDTICK</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>qf_win_pos_update</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>aucmd_restbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>old_line_count</name> <operator>&lt;</operator> <name><name>win</name><operator>-&gt;</operator><name>w_botline</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>redraw_buf_later</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_buf_add_line</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>linenr_T</name></type> <name>lnum</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>errbuf</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name>errbuf</name> <operator>=</operator> <call><name>buflist_findnr</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name><name>errbuf</name><operator>-&gt;</operator><name>b_fname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><call><name>gettail</name><argument_list>(<argument><expr><name><name>errbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>errbuf</name><operator>-&gt;</operator><name>b_sfname</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <call><name>mch_isFullName</name><argument_list>(<argument><expr><name><name>errbuf</name><operator>-&gt;</operator><name>b_sfname</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dirname</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>mch_dirname</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>shorten_buf_fname</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_strncpy</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name><name>errbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>IObuff</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'|'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>,

<argument><expr><literal type="string">" col %d"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>qf_types</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_nr</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_fmt_text</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>, <argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name>IOSIZE</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>IObuff</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">'|'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>IObuff</name><index>[<expr><name>len</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>qf_fmt_text</name><argument_list>(<argument><expr><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><call><name>skipwhite</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></else></ternary></expr></argument>,

<argument><expr><name>IObuff</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>IOSIZE</name> <operator>-</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ml_append_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>,

<argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_fill_buffer</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>lnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_KeyTyped</name> <init>= <expr><name>KeyTyped</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>curbuf</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>internal_error</name><argument_list>(<argument><expr><literal type="string">"qf_fill_buffer()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>(</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_flags</name></name> <operator>&amp;</operator> <name>ML_EMPTY</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ml_delete</name><argument_list>(<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qfl</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>dirname</name><index>[<expr><name>MAXPATHL</name></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>dirname</name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>old_last</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>old_last</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<while>while <condition>(<expr><name>lnum</name> <operator>&lt;</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_buf_add_line</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>ml_delete</name><argument_list>(<argument><expr><name>lnum</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>check_lnums</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>old_last</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name>curbuf_lock</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_option_value</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ft"</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"qf"</literal></expr></argument>, <argument><expr><name>OPT_LOCAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_ma</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>keep_filetype</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_BUFREADPOST</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"quickfix"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_BUFWINENTER</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"quickfix"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>keep_filetype</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name>curbuf_lock</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>redraw_curbuf_later</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>KeyTyped</name> <operator>=</operator> <name>old_KeyTyped</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_list_changed</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_changedtick</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_id2nr</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int_u</name></type> <name>qfid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>qf_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>qf_idx</name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>;</condition> <incr><expr><name>qf_idx</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>qf_idx</name></expr>]</index></name><operator>.</operator><name>qf_id</name> <operator>==</operator> <name>qfid</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>qf_idx</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

<return>return <expr><name>INVALID_QFIDX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_restore_list</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int_u</name></type> <name>save_qfid</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>curlist</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name> <operator>!=</operator> <name>save_qfid</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>curlist</name> <operator>=</operator> <call><name>qf_id2nr</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curlist</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name>curlist</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_jump_first</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int_u</name></type> <name>save_qfid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_restore_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>grep_internal</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>cmdidx</name> <operator>==</operator> <name>CMD_grep</name>

<operator>||</operator> <name>cmdidx</name> <operator>==</operator> <name>CMD_lgrep</name>

<operator>||</operator> <name>cmdidx</name> <operator>==</operator> <name>CMD_grepadd</name>

<operator>||</operator> <name>cmdidx</name> <operator>==</operator> <name>CMD_lgrepadd</name><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><literal type="string">"internal"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_gp</name></name> <operator>==</operator> <name>NUL</name></expr> ?</condition><then> <expr><name>p_gp</name></expr> </then><else>: <expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_gp</name></name></expr></else></ternary></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>make_get_auname</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>cmdidx</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_make</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"make"</literal></expr>;</return>

<case>case <expr><name>CMD_lmake</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lmake"</literal></expr>;</return>

<case>case <expr><name>CMD_grep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"grep"</literal></expr>;</return>

<case>case <expr><name>CMD_lgrep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgrep"</literal></expr>;</return>

<case>case <expr><name>CMD_grepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"grepadd"</literal></expr>;</return>

<case>case <expr><name>CMD_lgrepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgrepadd"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>get_mef_name</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>start</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>off</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>stat_T</name></type> <name>sb</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_mef</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>vim_tempname</name><argument_list>(<argument><expr><literal type="char">'e'</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_notmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>p_mef</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><operator>++</operator><name>p</name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>vim_strsave</name><argument_list>(<argument><expr><name>p_mef</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>start</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <call><name>mch_get_pid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>off</name> <operator>+=</operator> <literal type="number">19</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_mef</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>STRCPY</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>p_mef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name> <operator>+</operator> <operator>(</operator><name>p</name> <operator>-</operator> <name>p_mef</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%d%d"</literal></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mch_getperm</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<operator>&amp;&amp;</operator> <call><name>mch_lstat</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sb</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>make_get_fullcmd</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>makecmd</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_shq</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>makecmd</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sp</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>len</name> <operator>+=</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>p_sp</name></expr></argument>)</argument_list></call> <operator>+</operator> <operator>(</operator><name>unsigned</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>alloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>cmd</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p_shq</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>makecmd</name></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>p_shq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p_sp</name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>append_redir</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>p_sp</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>msg_col</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>msg_didout</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_puts</name><argument_list>(<argument><expr><literal type="string">":!"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>msg_outtrans</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>cmd</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_make</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>grep_internal</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>ex_vimgrep</name><argument_list>(<argument><expr><name>eap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>au_name</name> <operator>=</operator> <call><name>make_get_auname</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_menc</name></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_menc</name></name></expr> </then><else>: <expr><name>p_menc</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_loclist_cmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>autowrite_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>get_mef_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mch_remove</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>make_get_fullcmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>do_shell</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>p_sp</name> <operator>!=</operator> <name>NUL</name></expr> ?</condition><then> <expr><name>SHELL_DOOUT</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>AMIGA</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>char_avail</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>qf_init</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_make</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_lmake</name><operator>)</operator></expr> ?</condition><then> <expr><name>p_gefm</name></expr> </then><else>: <expr><name>p_efm</name></expr></else></ternary></expr></argument>,

<argument><expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_grepadd</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_lgrepadd</name><operator>)</operator></expr></argument>,

<argument><expr><call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>cleanup</name>;</goto></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name> <operator>&amp;&amp;</operator> <call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump_first</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<label><name>cleanup</name>:</label>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mch_remove</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_get_size</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_count</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_get_valid_size</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>sz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_fnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cdo</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_ldo</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>sz</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if> 

<if type="elseif">else if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name>prev_fnum</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>sz</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_fnum</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>sz</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_get_cur_idx</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_index</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>qf_get_cur_valid_idx</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>eidx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_fnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_has_valid_entries</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>&amp;&amp;</operator> <name>qfp</name><operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>qfp</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr></incr>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cfdo</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lfdo</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name>prev_fnum</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>eidx</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_fnum</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>eidx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><ternary><condition><expr><name>eidx</name></expr> ?</condition><then> <expr><name>eidx</name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_nth_valid_entry</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fdo</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>eidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>prev_fnum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_has_valid_entries</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>eidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>fdo</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name>prev_fnum</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>eidx</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_fnum</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>eidx</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eidx</name> <operator>==</operator> <name>n</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>i</name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cc</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errornr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<switch>switch <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_cc</name></expr>:</case> <case>case <expr><name>CMD_ll</name></expr>:</case>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_crewind</name></expr>:</case> <case>case <expr><name>CMD_lrewind</name></expr>:</case> <case>case <expr><name>CMD_cfirst</name></expr>:</case>

<case>case <expr><name>CMD_lfirst</name></expr>:</case>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <literal type="number">32767</literal></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cdo</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_ldo</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cfdo</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lfdo</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <call><name>qf_get_nth_valid_entry</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>line1</name></name></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cfdo</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lfdo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cnext</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errornr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_cdo</name> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_ldo</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_cfdo</name> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_lfdo</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_cnext</name></expr>:</case> <case>case <expr><name>CMD_lnext</name></expr>:</case> <case>case <expr><name>CMD_cdo</name></expr>:</case> <case>case <expr><name>CMD_ldo</name></expr>:</case>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>FORWARD</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_cprevious</name></expr>:</case> <case>case <expr><name>CMD_lprevious</name></expr>:</case> <case>case <expr><name>CMD_cNext</name></expr>:</case>

<case>case <expr><name>CMD_lNext</name></expr>:</case>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>BACKWARD</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_cnfile</name></expr>:</case> <case>case <expr><name>CMD_lnfile</name></expr>:</case> <case>case <expr><name>CMD_cfdo</name></expr>:</case> <case>case <expr><name>CMD_lfdo</name></expr>:</case>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>FORWARD_FILE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>CMD_cpfile</name></expr>:</case> <case>case <expr><name>CMD_lpfile</name></expr>:</case> <case>case <expr><name>CMD_cNfile</name></expr>:</case> <case>case <expr><name>CMD_lNfile</name></expr>:</case>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>BACKWARD_FILE</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>FORWARD</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_first_entry_in_buf</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bnr</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>idx</argument>)</argument_list></macro>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name>bnr</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>errornr</name> <operator>=</operator> <name>idx</name></expr>;</expr_stmt>

<return>return <expr><name>qfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_first_entry_on_line</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name><operator>-&gt;</operator><name>qf_fnum</name></name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>entry</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_last_entry_on_line</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><name>got_int</name> <operator>&amp;&amp;</operator>

<name><name>entry</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_fnum</name></name>

<operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>entry</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_entry_after_pos</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>||</operator>

<operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>&gt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>col</name></name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_entry_before_pos</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&lt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&lt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>||</operator>

<operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>&lt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>col</name></name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_entry_on_or_after_pos</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;=</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&gt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>||</operator>

<operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>&gt;=</operator> <name><name>pos</name><operator>-&gt;</operator><name>col</name></name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_entry_on_or_before_pos</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&lt;=</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name></expr>;</return></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>&lt;</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>||</operator>

<operator>(</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name> <operator>==</operator> <name><name>pos</name><operator>-&gt;</operator><name>lnum</name></name> <operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name> <operator>&lt;=</operator> <name><name>pos</name><operator>-&gt;</operator><name>col</name></name><operator>)</operator><operator>)</operator></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_entry_after_pos</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>bnr</name></decl></parameter>,

<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_entry_after_pos</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>qfp</name></expr>;</return></block_content></block></if></if_stmt>

<while>while <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name>bnr</name>

<operator>&amp;&amp;</operator> <call><name>qf_entry_on_or_before_pos</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name>bnr</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

<return>return <expr><name>qfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_entry_before_pos</name><parameter_list>(

<parameter><decl><type><name>int</name></type> <name>bnr</name></decl></parameter>,

<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>,

<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>==</operator> <name>bnr</name>

<operator>&amp;&amp;</operator> <call><name>qf_entry_before_pos</name><argument_list>(<argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>qf_entry_on_or_after_pos</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <call><name>qf_find_first_entry_on_line</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>qfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>qfline_T</name> <modifier>*</modifier></type>

<name>qf_find_closest_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>bnr</name></decl></parameter>,

<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>errornr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <call><name>qf_find_first_entry_in_buf</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>bnr</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qfp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>FORWARD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <call><name>qf_find_entry_after_pos</name><argument_list>(<argument><expr><name>bnr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>, <argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qfp</name> <operator>=</operator> <call><name>qf_find_entry_before_pos</name><argument_list>(<argument><expr><name>bnr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>, <argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>qfp</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_get_nth_below_entry</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>entry_arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>entry_arg</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>first_errornr</name> <init>= <expr><operator>*</operator><name>errornr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>qf_find_last_entry_on_line</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>qf_next</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_next</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>errornr</name> <operator>=</operator> <name>first_errornr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_get_nth_above_entry</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>errornr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name></name> <operator>==</operator> <name>NULL</name>

<operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name><operator>-&gt;</operator><name>qf_fnum</name></name> <operator>!=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>qf_prev</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><operator>*</operator><name>errornr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>linewise</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>qf_find_first_entry_on_line</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_find_nth_adj_entry</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>bnr</name></decl></parameter>,

<parameter><decl><type><name>pos_T</name> <modifier>*</modifier></type><name>pos</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>linewise</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>adj_entry</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errornr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>adj_entry</name> <operator>=</operator> <call><name>qf_find_closest_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>bnr</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>adj_entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <name>FORWARD</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_get_nth_below_entry</name><argument_list>(<argument><expr><name>adj_entry</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_get_nth_above_entry</name><argument_list>(<argument><expr><name>adj_entry</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>linewise</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errornr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>errornr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cbelow</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dir</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_has_flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>errornr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pos_T</name></type> <name>pos</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cabove</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cbelow</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cbefore</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cafter</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf_has_flag</name> <operator>=</operator> <name>BUF_HAS_QF_ENTRY</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>buf_has_flag</name> <operator>=</operator> <name>BUF_HAS_LL_ENTRY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_has_qf_entry</name></name> <operator>&amp;</operator> <name>buf_has_flag</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_quickfix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_has_valid_entries</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_quickfix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cbelow</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lbelow</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cafter</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lafter</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>FORWARD</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>dir</name> <operator>=</operator> <name>BACKWARD</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_cursor</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pos</name><operator>.</operator><name>col</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>errornr</name> <operator>=</operator> <call><name>qf_find_nth_adj_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pos</name></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>dir</name></expr></argument>,

<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cbelow</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lbelow</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cabove</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_labove</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>errornr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>errornr</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_no_more_items</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>cfile_get_auname</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>cmdidx</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_cfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cfile"</literal></expr>;</return>

<case>case <expr><name>CMD_cgetfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cgetfile"</literal></expr>;</return>

<case>case <expr><name>CMD_caddfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"caddfile"</literal></expr>;</return>

<case>case <expr><name>CMD_lfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lfile"</literal></expr>;</return>

<case>case <expr><name>CMD_lgetfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgetfile"</literal></expr>;</return>

<case>case <expr><name>CMD_laddfile</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"laddfile"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cfile</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>enc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>au_name</name> <operator>=</operator> <call><name>cfile_get_auname</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>enc</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>*</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_menc</name></name> <operator>!=</operator> <name>NUL</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_p_menc</name></name></expr> </then><else>: <expr><name>p_menc</name></expr></else></ternary></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_BROWSE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>cmdmod</name><operator>.</operator><name>browse</name></name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>browse_file</name> <init>= <expr><call><name>do_browse</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Error file"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><call><name>_</name><argument_list>(<argument><expr><name>BROWSE_FILTER_ALL_FILES</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>browse_file</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>set_string_option_direct</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ef"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>browse_file</name></expr></argument>, <argument><expr><name>OPT_FREE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>browse_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

if <condition>(<expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name> <operator>!=</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_string_option_direct</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"ef"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>OPT_FREE</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_loclist_cmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>qf_init</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>p_ef</name></expr></argument>, <argument><expr><name>p_efm</name></expr></argument>, <argument><expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_caddfile</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_laddfile</name><operator>)</operator></expr></argument>,

<argument><expr><call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cfile</name> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lfile</name><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump_first</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>vgr_get_auname</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>cmdidx</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_vimgrep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"vimgrep"</literal></expr>;</return>

<case>case <expr><name>CMD_lvimgrep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lvimgrep"</literal></expr>;</return>

<case>case <expr><name>CMD_vimgrepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"vimgrepadd"</literal></expr>;</return>

<case>case <expr><name>CMD_lvimgrepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lvimgrepadd"</literal></expr>;</return>

<case>case <expr><name>CMD_grep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"grep"</literal></expr>;</return>

<case>case <expr><name>CMD_lgrep</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgrep"</literal></expr>;</return>

<case>case <expr><name>CMD_grepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"grepadd"</literal></expr>;</return>

<case>case <expr><name>CMD_lgrepadd</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgrepadd"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vgr_init_regmatch</name><parameter_list>(<parameter><decl><type><name>regmmatch_T</name> <modifier>*</modifier></type><name>regmatch</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><name><name>regmatch</name><operator>-&gt;</operator><name>regprog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>last_search_pat</name><argument_list>()</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_noprevre</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>-&gt;</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><call><name>last_search_pat</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>RE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>regmatch</name><operator>-&gt;</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>RE_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>-&gt;</operator><name>rmm_ic</name></name> <operator>=</operator> <name>p_ic</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>-&gt;</operator><name>rmm_maxcol</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vgr_display_fname</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>msg_start</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>msg_strtrunc</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>msg_outtrans</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>msg_outtrans</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>msg_clr_eos</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>msg_didout</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>msg_nowait</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>msg_col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>out_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type>

<name>vgr_load_dummy_buf</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_now</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>save_mls</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_ei</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><name>save_ei</name> <operator>=</operator> <call><name>au_event_disable</name><argument_list>(<argument><expr><literal type="string">",Filetype"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>save_mls</name> <operator>=</operator> <name>p_mls</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p_mls</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>load_dummy_buffer</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>, <argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p_mls</name> <operator>=</operator> <name>save_mls</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>au_event_restore</name><argument_list>(<argument><expr><name>save_ei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vgr_qflist_valid</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int_u</name></type> <name>qfid</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>qfid</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_loc_list_changed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FALSE</name></expr>;</return>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_restore_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qfid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FALSE</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>TRUE</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vgr_match_buflines</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,

<parameter><decl><type><name>regmmatch_T</name> <modifier>*</modifier></type><name>regmatch</name></decl></parameter>,

<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>tomatch</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>duplicate_name</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>found_match</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>lnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>colnr_T</name></type> <name>col</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>lnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>lnum</name> <operator>&lt;=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tomatch</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><operator>++</operator><name>lnum</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>col</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>vim_regexec_multi</name><argument_list>(<argument><expr><name>regmatch</name></expr></argument>, <argument><expr><name>curwin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>,

<argument><expr><name>col</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_add_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, 

<argument><expr><name>fname</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>duplicate_name</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>buf</name><operator>-&gt;</operator><name>b_fnum</name></name></expr></else></ternary></expr></argument>,

<argument><expr><call><name>ml_get_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,

<argument><expr><name><name>regmatch</name><operator>-&gt;</operator><name>startpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lnum</name> <operator>+</operator> <name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>regmatch</name><operator>-&gt;</operator><name>startpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lnum</name> <operator>+</operator> <name>lnum</name></expr></argument>,

<argument><expr><name><name>regmatch</name><operator>-&gt;</operator><name>startpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>col</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, 

<argument><expr><name>NULL</name></expr></argument>, 

<argument><expr><literal type="number">0</literal></expr></argument>, 

<argument><expr><literal type="number">0</literal></expr></argument>, 

<argument><expr><name>TRUE</name></expr></argument> 

)</argument_list></call> <operator>==</operator> <name>QF_FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found_match</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>--</operator><operator>*</operator><name>tomatch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>VGR_GLOBAL</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal>

<operator>||</operator> <name><name>regmatch</name><operator>-&gt;</operator><name>endpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>lnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <name><name>regmatch</name><operator>-&gt;</operator><name>endpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>col</name>

<operator>+</operator> <operator>(</operator><name>col</name> <operator>==</operator> <name><name>regmatch</name><operator>-&gt;</operator><name>endpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>col</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>col</name> <operator>&gt;</operator> <operator>(</operator><name>colnr_T</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><call><name>ml_get_buf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>lnum</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>got_int</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>found_match</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>vgr_jump_to_match</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>forceit</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>redraw_for_dummy</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>first_match_buf</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>target_dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>curbuf</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>forceit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>curbuf</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>redraw_for_dummy</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>==</operator> <name>first_match_buf</name> <operator>&amp;&amp;</operator> <name>target_dir</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>exarg_T</name></type> <name>ea</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ea</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>target_dir</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <name>CMD_lcd</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ex_cd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct

<block>{

<decl_stmt><decl><type><name>long</name></type> <name>tomatch</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>spat</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>flags</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnames</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>fcount</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>regmmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl>;</decl_stmt> 

}</block></struct></type> <name>vgr_args_T</name>;</typedef>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vgr_process_args</name><parameter_list>(

<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>,

<parameter><decl><type><name>vgr_args_T</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>tomatch</name></name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name><name>args</name><operator>-&gt;</operator><name>tomatch</name></name> <operator>=</operator> <name>MAXLNUM</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skip_vimgrep_pat</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>spat</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invalpat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vgr_init_regmatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>regmatch</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>spat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>skipwhite</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <name>NUL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E683: File name missing or invalid pattern"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>get_arglist_exp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>fcount</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>args</name><operator>-&gt;</operator><name>fnames</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>args</name><operator>-&gt;</operator><name>fcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nomatch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>vgr_process_files</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>vgr_args_T</name> <modifier>*</modifier></type><name>cmd_args</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>redraw_for_dummy</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>first_match_buf</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>target_dir</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name> <init>= <expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>time_t</name></type> <name>seconds</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>duplicate_name</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>using_dummy</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_now</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found_match</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>aco_save_T</name></type> <name>aco</name></decl>;</decl_stmt>

<expr_stmt><expr><name>dirname_start</name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>aid_qf_dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dirname_now</name> <operator>=</operator> <call><name>alloc_id</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><name>aid_qf_dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dirname_start</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>dirname_now</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>mch_dirname</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>seconds</name> <operator>=</operator> <operator>(</operator><name>time_t</name><operator>)</operator><literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>fi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>fi</name> <argument_list type="generic">&lt; <argument><expr><name><name>cmd_args</name><operator>-&gt;</operator><name>fcount</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name> <operator>&amp;&amp;</operator> <name><name>cmd_args</name><operator>-&gt;</operator><name>tomatch</name></name></expr></argument> &gt;</argument_list></name> <literal type="number">0</literal></expr>;</condition>

<incr><expr><operator>++</operator><name>fi</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>shorten_fname1</name><argument_list>(<argument><expr><name><name>cmd_args</name><operator>-&gt;</operator><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>seconds</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>seconds</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vgr_display_fname</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buflist_findname_exp</name><argument_list>(<argument><expr><name><name>cmd_args</name><operator>-&gt;</operator><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_mfp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>duplicate_name</name> <operator>=</operator> <operator>(</operator><name>buf</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>using_dummy</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>redraw_for_dummy</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>vgr_load_dummy_buf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>, <argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>using_dummy</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>vgr_qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>, <argument><expr><name><name>cmd_args</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>got_int</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>smsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"Cannot open file \"%s\""</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>found_match</name> <operator>=</operator> <call><name>vgr_match_buflines</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>cmd_args</name><operator>-&gt;</operator><name>regmatch</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>cmd_args</name><operator>-&gt;</operator><name>tomatch</name></name></expr></argument>, <argument><expr><name>duplicate_name</name></expr></argument>, <argument><expr><name><name>cmd_args</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>using_dummy</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>found_match</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>first_match_buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>first_match_buf</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>duplicate_name</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>wipe_dummy_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>cmdmod</name><operator>.</operator><name>hide</name></name>

<operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_p_bh</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'u'</literal> 

<operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_p_bh</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'w'</literal> 

<operator>||</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_p_bh</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_match</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>wipe_dummy_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>buf</name> <operator>!=</operator> <operator>*</operator><name>first_match_buf</name>

<operator>||</operator> <operator>(</operator><name><name>cmd_args</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>VGR_NOJUMP</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>unload_dummy_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BF_DUMMY</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>b_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BF_DUMMY</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <operator>*</operator><name>first_match_buf</name>

<operator>&amp;&amp;</operator> <operator>*</operator><name>target_dir</name> <operator>==</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>, <argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>target_dir</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>aucmd_prepbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_SYN_HL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_FILETYPE</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_p_ft</name></name></expr></argument>,

<argument><expr><name><name>buf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>do_modelines</name><argument_list>(<argument><expr><name>OPT_NOWIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>aucmd_restbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_vimgrep</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>vgr_args_T</name></type> <name>args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>redraw_for_dummy</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>first_match_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>target_dir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<expr_stmt><expr><name>au_name</name> <operator>=</operator> <call><name>vgr_get_auname</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_or_alloc_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vgr_process_args</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<goto>goto <name>theend</name>;</goto></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_grepadd</name> <operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_lgrepadd</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_vimgrepadd</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_lvimgrepadd</name><operator>)</operator>

<operator>||</operator> <call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>vgr_process_files</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redraw_for_dummy</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>first_match_buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>target_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>fcount</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>fnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>fcount</name></name></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>fnames</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call>

<operator>||</operator> <call><name>qf_restore_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>theend</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>args</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>VGR_NOJUMP</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vgr_jump_to_match</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>redraw_for_dummy</name></expr></argument>,

<argument><expr><name>first_match_buf</name></expr></argument>, <argument><expr><name>target_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nomatch2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>args</name><operator>.</operator><name>spat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>redraw_for_dummy</name></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_FOLDING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>foldUpdateAll</name><argument_list>(<argument><expr><name>curwin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>redraw_later</name><argument_list>(<argument><expr><name>NOT_VALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<label><name>theend</name>:</label>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>target_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>args</name><operator>.</operator><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>restore_start_dir</name><parameter_list>(<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_now</name> <init>= <expr><call><name>alloc</name><argument_list>(<argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>dirname_now</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>mch_dirname</name><argument_list>(<argument><expr><name>dirname_now</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STRCMP</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>, <argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>exarg_T</name></type> <name>ea</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>vim_memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ea</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>arg</name></name> <operator>=</operator> <name>dirname_start</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ea</name><operator>.</operator><name>cmdidx</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>curwin</name><operator>-&gt;</operator><name>w_localdir</name></name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><name>CMD_cd</name></expr> </then><else>: <expr><name>CMD_lcd</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ex_cd</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ea</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>dirname_now</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>buf_T</name> <modifier>*</modifier></type>

<name>load_dummy_buffer</name><parameter_list>(

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>, 

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>resulting_dir</name></decl></parameter>)</parameter_list> 

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>newbuf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bufref_T</name></type> <name>newbufref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bufref_T</name></type> <name>newbuf_to_wipe</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>failed</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>aco_save_T</name></type> <name>aco</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>readfile_result</name></decl>;</decl_stmt>

<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <call><name>buflist_new</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>BLN_DUMMY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>newbuf</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newbufref</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>buf_copy_options</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>BCO_ENTER</name> <operator>|</operator> <name>BCO_NOHELP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ml_open</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>++</operator><name><name>newbuf</name><operator>-&gt;</operator><name>b_locked</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>aucmd_prepbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>setfname</name><argument_list>(<argument><expr><name>curbuf</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>check_need_swap</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_flags</name></name> <operator>&amp;=</operator> <operator>~</operator><name>BF_DUMMY</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>newbuf_to_wipe</name><operator>.</operator><name>br_buf</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>readfile_result</name> <operator>=</operator> <call><name>readfile</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><name>MAXLNUM</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>READ_NEW</name> <operator>|</operator> <name>READ_DUMMY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>--</operator><name><name>newbuf</name><operator>-&gt;</operator><name>b_locked</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>readfile_result</name> <operator>==</operator> <name>OK</name>

<operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>curbuf</name><operator>-&gt;</operator><name>b_flags</name></name> <operator>&amp;</operator> <name>BF_NEW</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>failed</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>!=</operator> <name>newbuf</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>set_bufref</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newbuf_to_wipe</name></expr></argument>, <argument><expr><name>newbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>newbuf</name> <operator>=</operator> <name>curbuf</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>aucmd_restbuf</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aco</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>newbuf_to_wipe</name><operator>.</operator><name>br_buf</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newbuf_to_wipe</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>wipe_buffer</name><argument_list>(<argument><expr><name><name>newbuf_to_wipe</name><operator>.</operator><name>br_buf</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>newbuf</name><operator>-&gt;</operator><name>b_flags</name></name> <operator>|=</operator> <name>BF_DUMMY</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>mch_dirname</name><argument_list>(<argument><expr><name>resulting_dir</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>restore_start_dir</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bufref_valid</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newbufref</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>failed</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>wipe_dummy_buffer</name><argument_list>(<argument><expr><name>newbuf</name></expr></argument>, <argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>newbuf</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>wipe_dummy_buffer</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<while>while <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_nwindows</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>did_one</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>firstwin</name><operator>-&gt;</operator><name>w_next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<for>for <control>(<init><expr><name>wp</name> <operator>=</operator> <name>firstwin</name></expr>;</init> <condition><expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>wp</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_next</name></name></expr></incr>)</control><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name><name>wp</name><operator>-&gt;</operator><name>w_buffer</name></name> <operator>==</operator> <name>buf</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>win_close</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>did_one</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt></block_content></block></for></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_one</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>!=</operator> <name>buf</name> <operator>&amp;&amp;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_nwindows</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> 

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<decl_stmt><decl><type><name>cleanup_T</name></type> <name>cs</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>enter_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>wipe_buffer</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>

<expr_stmt><expr><call><name>leave_cleanup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>restore_start_dir</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>unload_dummy_buffer</name><parameter_list>(<parameter><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname_start</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>!=</operator> <name>buf</name></expr>)</condition> 

<block>{<block_content>

<expr_stmt><expr><call><name>close_buffer</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>DOBUF_UNLOAD</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>restore_start_dir</name><argument_list>(<argument><expr><name>dirname_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_qfline_items</name><parameter_list>(<parameter><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bufnum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>dict</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name></type> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name>bufnum</name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_fnum</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bufnum</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>buflist_findnr</name><argument_list>(<argument><expr><name>bufnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>bufnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>dict</name> <operator>=</operator> <call><name>dict_alloc</name><argument_list>()</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>list_append_dict</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>qfp</name><operator>-&gt;</operator><name>qf_type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"bufnr"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name>bufnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"lnum"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_lnum</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"col"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_col</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"vcol"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_viscol</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"nr"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_nr</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"module"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_module</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"pattern"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_pattern</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"text"</literal></expr></argument>, <argument><expr><name><name>qfp</name><operator>-&gt;</operator><name>qf_text</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name>

<operator>||</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><literal type="string">"valid"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator><name><name>qfp</name><operator>-&gt;</operator><name>qf_valid</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>get_errorlist</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi_arg</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>, <parameter><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><name>qi_arg</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qfp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <operator>&amp;</operator><name>ql_info</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>==</operator> <name>INVALID_QFIDX</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>&gt;=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<macro><name>FOR_ALL_QFL_ITEMS</name><argument_list>(<argument>qfl</argument>, <argument>qfp</argument>, <argument>i</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>get_qfline_items</name><argument_list>(<argument><expr><name>qfp</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<enum>enum <block>{

<decl><name>QF_GETLIST_NONE</name> <init>= <expr><literal type="number">0x0</literal></expr></init></decl>,

<decl><name>QF_GETLIST_TITLE</name> <init>= <expr><literal type="number">0x1</literal></expr></init></decl>,

<decl><name>QF_GETLIST_ITEMS</name> <init>= <expr><literal type="number">0x2</literal></expr></init></decl>,

<decl><name>QF_GETLIST_NR</name> <init>= <expr><literal type="number">0x4</literal></expr></init></decl>,

<decl><name>QF_GETLIST_WINID</name> <init>= <expr><literal type="number">0x8</literal></expr></init></decl>,

<decl><name>QF_GETLIST_CONTEXT</name> <init>= <expr><literal type="number">0x10</literal></expr></init></decl>,

<decl><name>QF_GETLIST_ID</name> <init>= <expr><literal type="number">0x20</literal></expr></init></decl>,

<decl><name>QF_GETLIST_IDX</name> <init>= <expr><literal type="number">0x40</literal></expr></init></decl>,

<decl><name>QF_GETLIST_SIZE</name> <init>= <expr><literal type="number">0x80</literal></expr></init></decl>,

<decl><name>QF_GETLIST_TICK</name> <init>= <expr><literal type="number">0x100</literal></expr></init></decl>,

<decl><name>QF_GETLIST_FILEWINID</name> <init>= <expr><literal type="number">0x200</literal></expr></init></decl>,

<decl><name>QF_GETLIST_QFBUFNR</name> <init>= <expr><literal type="number">0x400</literal></expr></init></decl>,

<decl><name>QF_GETLIST_ALL</name> <init>= <expr><literal type="number">0x7FF</literal></expr></init></decl>,

}</block>;</enum>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_list_from_lines</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>errorformat</name> <init>= <expr><name>p_efm</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>efm_di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name> <operator>&amp;&amp;</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>efm_di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"efm"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name> <operator>||</operator>

<name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errorformat</name> <operator>=</operator> <name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>l</name> <operator>=</operator> <call><name>list_alloc</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>qf_alloc_stack</name><argument_list>(<argument><expr><name>QFLT_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>qf_init_ext</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>errorformat</name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_errorlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>dict_add_list</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"items"</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_winid</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name><name>win</name><operator>-&gt;</operator><name>w_id</name></name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_qfbufnr</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"qfbufnr"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><operator>(</operator><name>qi</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>qi</name><operator>-&gt;</operator><name>qf_bufnr</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_keys2flags</name><parameter_list>(<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loclist</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>QF_GETLIST_NONE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"all"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_ALL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>loclist</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>&amp;=</operator> <operator>~</operator> <name>QF_GETLIST_FILEWINID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"title"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_TITLE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"nr"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_NR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"winid"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_WINID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_CONTEXT</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"id"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_ID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"items"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_ITEMS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"idx"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_IDX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"size"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_SIZE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"changedtick"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_TICK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>loclist</name> <operator>&amp;&amp;</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"filewinid"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_FILEWINID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"qfbufnr"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>QF_GETLIST_QFBUFNR</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>flags</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_qfidx</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"nr"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>qf_idx</name> <operator>&gt;=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name>INVALID_QFIDX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name>

<operator>&amp;&amp;</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name>INVALID_QFIDX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"id"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <call><name>qf_id2nr</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name>INVALID_QFIDX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qf_idx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_defaults</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>locstack</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_TITLE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_ITEMS</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>list_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_list</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"items"</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_NR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"nr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_WINID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"winid"</literal></expr></argument>, <argument><expr><call><name>qf_winid</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_CONTEXT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_ID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_IDX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_TICK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"changedtick"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>locstack</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_FILEWINID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"filewinid"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_QFBUFNR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_qfbufnr</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_title</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>dict_add_string</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_filewinid</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>winid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>ll_wp</name> <init>= <expr><call><name>qf_find_win_with_loclist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ll_wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>winid</name> <operator>=</operator> <name><name>ll_wp</name><operator>-&gt;</operator><name>w_id</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"filewinid"</literal></expr></argument>, <argument><expr><name>winid</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_items</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>list_alloc</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_errorlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>dict_add_list</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"items"</literal></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_ctx</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>di</name> <operator>=</operator> <call><name>dictitem_alloc</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>di</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>dictitem_free</name><argument_list>(<argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <name>FAIL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_string</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_getprop_idx</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>curidx</name> <init>= <expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>curidx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>curidx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_get_properties</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>retdict</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name> <init>= <expr><name>INVALID_QFIDX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>QF_GETLIST_NONE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lines"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>qf_get_list_from_lines</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><name>di</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>GET_LOC_LIST</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flags</name> <operator>=</operator> <call><name>qf_getprop_keys2flags</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>wp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <call><name>qf_getprop_qfidx</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>what</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>qf_idx</name> <operator>==</operator> <name>INVALID_QFIDX</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><call><name>qf_getprop_defaults</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_TITLE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_title</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_NR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"nr"</literal></expr></argument>, <argument><expr><name>qf_idx</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_WINID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"winid"</literal></expr></argument>, <argument><expr><call><name>qf_winid</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_ITEMS</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_items</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_CONTEXT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_ctx</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_ID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_IDX</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_idx</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_SIZE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_TICK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>dict_add_number</name><argument_list>(<argument><expr><name>retdict</name></expr></argument>, <argument><expr><literal type="string">"changedtick"</literal></expr></argument>, <argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_changedtick</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>wp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_FILEWINID</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_filewinid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>status</name> <operator>==</operator> <name>OK</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>QF_GETLIST_QFBUFNR</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_getprop_qfbufnr</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>retdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_add_entry_from_dict</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>d</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>first_entry</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valid_entry</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>did_bufnr_emsg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>filename</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>module</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pattern</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>text</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bufnum</name></decl>, <decl><type ref="prev"/><name>valid</name></decl>, <decl><type ref="prev"/><name>status</name></decl>, <decl><type ref="prev"/><name>col</name></decl>, <decl><type ref="prev"/><name>vcol</name></decl>, <decl><type ref="prev"/><name>nr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>lnum</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>first_entry</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>did_bufnr_emsg</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"filename"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>module</name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"module"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bufnum</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"bufnr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lnum"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"col"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vcol</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"vcol"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>nr</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"nr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pattern</name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"pattern"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>text</name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"text"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>text</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>text</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filename</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>bufnum</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>lnum</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pattern</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bufnum</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>buflist_findnr</name><argument_list>(<argument><expr><name>bufnum</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>did_bufnr_emsg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>did_bufnr_emsg</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E92: Buffer %d not found"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bufnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bufnum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>dict_find</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"valid"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>dict_get_number</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"valid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>qf_add_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, 

<argument><expr><name>filename</name></expr></argument>,

<argument><expr><name>module</name></expr></argument>,

<argument><expr><name>bufnum</name></expr></argument>,

<argument><expr><name>text</name></expr></argument>,

<argument><expr><name>lnum</name></expr></argument>,

<argument><expr><name>col</name></expr></argument>,

<argument><expr><name>vcol</name></expr></argument>, 

<argument><expr><name>pattern</name></expr></argument>, 

<argument><expr><name>nr</name></expr></argument>,

<argument><expr><ternary><condition><expr><name>type</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NUL</name></expr> </then><else>: <expr><operator>*</operator><name>type</name></expr></else></ternary></expr></argument>,

<argument><expr><name>valid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>valid</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>valid_entry</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_add_entries</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>,

<parameter><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name> <init>= <expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>listitem_T</name> <modifier>*</modifier></type><name>li</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>old_last</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>valid_entry</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>qf_idx</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>old_last</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_last</name></name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free_items</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_store_title</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>FOR_ALL_LIST_ITEMS</name><argument_list>(<argument>list</argument>, <argument>li</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_DICT</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt> 

<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>li</name><operator>-&gt;</operator><name>li_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_add_entry_from_dict</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>li</name> <operator>==</operator> <name><name>list</name><operator>-&gt;</operator><name>lv_first</name></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>valid_entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>QF_FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<break>break;</break></block_content></block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>valid_entry</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>action</name> <operator>!=</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>action</name> <operator>!=</operator> <literal type="char">'a'</literal> <operator>||</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>old_last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_get_qfidx</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newlist</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name> <init>= <expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"nr"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_NUMBER</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>action</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name>action</name> <operator>==</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>qf_idx</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>newlist</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <ternary><condition><expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>qf_idx</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>qf_idx</name> <operator>&gt;=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>INVALID_QFIDX</name></expr>;</return></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>action</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>*</operator><name>newlist</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt></block_content></block></if></if_stmt> 

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name>

<operator>&amp;&amp;</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><name>newlist</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>INVALID_QFIDX</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<return>return <expr><name>INVALID_QFIDX</name></expr>;</return></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>newlist</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"id"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_NUMBER</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>INVALID_QFIDX</name></expr>;</return></block_content></block></if></if_stmt>

<return>return <expr><call><name>qf_id2nr</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_number</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qf_idx</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_title</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name> <init>= <expr><call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_title</name></name> <operator>=</operator> <call><name>dict_get_string</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"title"</literal></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>==</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_update_win_titlevar</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_items</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title_save</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>title_save</name> <operator>=</operator> <call><name>vim_strsave</name><argument_list>(<argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>qf_idx</name></expr>]</index></name><operator>.</operator><name>qf_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_add_entries</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>,

<argument><expr><name>title_save</name></expr></argument>, <argument><expr><ternary><condition><expr><name>action</name> <operator>==</operator> <literal type="char">' '</literal></expr> ?</condition><then> <expr><literal type="char">'a'</literal></expr> </then><else>: <expr><name>action</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>title_save</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_items_from_lines</name><parameter_list>(

<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>qf_idx</name></decl></parameter>,

<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>,

<parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>errorformat</name> <init>= <expr><name>p_efm</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>efm_di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>efm_di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"efm"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name> <operator>||</operator>

<name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>errorformat</name> <operator>=</operator> <name><name>efm_di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name> <operator>||</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_free_items</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>qf_idx</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_init_ext</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>errorformat</name></expr></argument>,

<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>OK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_context</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free_tv</name><argument_list>(<argument><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ctx</name> <operator>=</operator> <call><name>alloc_tv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>copy_tv</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ctx</name></name> <operator>=</operator> <name>ctx</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_setprop_curidx</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>denote</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>old_qfidx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qfline_T</name> <modifier>*</modifier></type><name>qf_ptr</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name>

<operator>&amp;&amp;</operator> <name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRCMP</name><argument_list>(<argument><expr><name><name>di</name><operator>-&gt;</operator><name>di_tv</name><operator>.</operator><name>vval</name><operator>.</operator><name>v_string</name></name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newidx</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>newidx</name> <operator>=</operator> <call><name>tv_get_number_chk</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>di</name><operator>-&gt;</operator><name>di_tv</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>denote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>denote</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newidx</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newidx</name> <operator>&gt;</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newidx</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>old_qfidx</name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_ptr</name> <operator>=</operator> <call><name>get_nth_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>newidx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name>qf_ptr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <name>newidx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name> <operator>==</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_id</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_win_pos_update</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>old_qfidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>qf_set_properties</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>dictitem_T</name> <modifier>*</modifier></type><name>di</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>FAIL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>qf_idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>newlist</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>newlist</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <call><name>qf_setprop_get_qfidx</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qf_idx</name> <operator>==</operator> <name>INVALID_QFIDX</name></expr>)</condition><block type="pseudo"><block_content> 

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>newlist</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <name>qf_idx</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_idx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"title"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_setprop_title</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"items"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_setprop_items</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>di</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lines"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_setprop_items_from_lines</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qf_idx</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>di</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"context"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_setprop_context</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>di</name> <operator>=</operator> <call><name>dict_find</name><argument_list>(<argument><expr><name>what</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"idx"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_setprop_curidx</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>di</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>qf_free_stack</name><parameter_list>(<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>qfwin</name> <init>= <expr><call><name>qf_find_win</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>llwin</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>qfwin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>&lt;</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_free</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>llwin</name> <operator>=</operator> <call><name>qf_find_win_with_loclist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>llwin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>llwin</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>qf_free_all</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_listcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>qfwin</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>new_ll</name> <init>= <expr><call><name>qf_alloc_stack</name><argument_list>(<argument><expr><name>QFLT_LOCATION</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new_ll</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>new_ll</name><operator>-&gt;</operator><name>qf_bufnr</name></name> <operator>=</operator> <name><name>qfwin</name><operator>-&gt;</operator><name>w_buffer</name><operator>-&gt;</operator><name>b_fnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>qfwin</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfwin</name><operator>-&gt;</operator><name>w_llist_ref</name></name> <operator>=</operator> <name>new_ll</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>qfwin</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>win_set_loclist</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>new_ll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>set_errorlist</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>,

<parameter><decl><type><name>list_T</name> <modifier>*</modifier></type><name>list</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>action</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>title</name></decl></parameter>,

<parameter><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>what</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><name>OK</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>ll_get_or_alloc_list</name><argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>FAIL</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>action</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>qf_free_stack</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>what</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_set_properties</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>what</name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>qf_add_entries</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><name>list</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>mark_quickfix_ctx</name><parameter_list>(<parameter><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>copyID</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>abort</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>ctx</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>LISTCOUNT</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>abort</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>

<block>{<block_content>

<expr_stmt><expr><name>ctx</name> <operator>=</operator> <name><name>qi</name><operator>-&gt;</operator><name>qf_lists</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>qf_ctx</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_NUMBER</name>

<operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_STRING</name> <operator>&amp;&amp;</operator> <name><name>ctx</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_FLOAT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>abort</name> <operator>=</operator> <call><name>set_ref_in_item</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>copyID</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>abort</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>set_ref_in_quickfix</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>copyID</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>abort</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>tabpage_T</name> <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<expr_stmt><expr><name>abort</name> <operator>=</operator> <call><name>mark_quickfix_ctx</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ql_info</name></expr></argument>, <argument><expr><name>copyID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>abort</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>abort</name></expr>;</return></block_content></block></if></if_stmt>

<macro><name>FOR_ALL_TAB_WINDOWS</name><argument_list>(<argument>tp</argument>, <argument>win</argument>)</argument_list></macro>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>win</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>abort</name> <operator>=</operator> <call><name>mark_quickfix_ctx</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_llist</name></name></expr></argument>, <argument><expr><name>copyID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>abort</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>abort</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_LL_WINDOW</name><argument_list>(<argument><expr><name>win</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>win</name><operator>-&gt;</operator><name>w_llist_ref</name><operator>-&gt;</operator><name>qf_refcount</name></name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>abort</name> <operator>=</operator> <call><name>mark_quickfix_ctx</name><argument_list>(<argument><expr><name><name>win</name><operator>-&gt;</operator><name>w_llist_ref</name></name></expr></argument>, <argument><expr><name>copyID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>abort</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>abort</name></expr>;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>abort</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>cbuffer_get_auname</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>cmdidx</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_cbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cbuffer"</literal></expr>;</return>

<case>case <expr><name>CMD_cgetbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cgetbuffer"</literal></expr>;</return>

<case>case <expr><name>CMD_caddbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"caddbuffer"</literal></expr>;</return>

<case>case <expr><name>CMD_lbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lbuffer"</literal></expr>;</return>

<case>case <expr><name>CMD_lgetbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgetbuffer"</literal></expr>;</return>

<case>case <expr><name>CMD_laddbuffer</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"laddbuffer"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>cbuffer_process_args</name><parameter_list>(

<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>,

<parameter><decl><type><name>buf_T</name> <modifier>*</modifier><modifier>*</modifier></type><name>bufp</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name> <modifier>*</modifier></type><name>line1</name></decl></parameter>,

<parameter><decl><type><name>linenr_T</name> <modifier>*</modifier></type><name>line2</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <name>curbuf</name></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><operator>*</operator><call><name>skipwhite</name><argument_list>(<argument><expr><call><name>skipdigits</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buflist_findnr</name><argument_list>(<argument><expr><call><name>atoi</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>buf</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invarg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_mfp</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E681: Buffer is not loaded"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>addr_count</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>eap</name><operator>-&gt;</operator><name>line1</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>=</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>line1</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>line1</name></name> <operator>&gt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name> <operator>&gt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>b_ml</name><operator>.</operator><name>ml_line_count</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invrange</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>FAIL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>line1</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line1</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>line2</name> <operator>=</operator> <name><name>eap</name><operator>-&gt;</operator><name>line2</name></name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>bufp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<return>return <expr><name>OK</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cbuffer</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>qf_title</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>line1</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linenr_T</name></type> <name>line2</name></decl>;</decl_stmt>

<expr_stmt><expr><name>au_name</name> <operator>=</operator> <call><name>cbuffer_get_auname</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_or_alloc_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>cbuffer_process_args</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>line2</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>FAIL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>qf_title</name> <operator>=</operator> <call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><operator>-&gt;</operator><name>b_sfname</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>vim_snprintf</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><literal type="string">"%s (%s)"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>qf_title</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>buf</name><operator>-&gt;</operator><name>b_sfname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qf_title</name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>qf_init_ext</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>p_efm</name></expr></argument>,

<argument><expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_caddbuffer</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_laddbuffer</name><operator>)</operator></expr></argument>,

<argument><expr><name>line1</name></expr></argument>, <argument><expr><name>line2</name></expr></argument>,

<argument><expr><name>qf_title</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>buf_T</name> <modifier>*</modifier></type><name>curbuf_old</name> <init>= <expr><name>curbuf</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>, <argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>,

<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>curbuf</name> <operator>!=</operator> <name>curbuf_old</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cbuffer</name> <operator>||</operator>

<name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lbuffer</name><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump_first</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<function><type><specifier>static</specifier> <name>char_u</name> <modifier>*</modifier></type>

<name>cexpr_get_auname</name><parameter_list>(<parameter><decl><type><name>cmdidx_T</name></type> <name>cmdidx</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<switch>switch <condition>(<expr><name>cmdidx</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_cexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cexpr"</literal></expr>;</return>

<case>case <expr><name>CMD_cgetexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"cgetexpr"</literal></expr>;</return>

<case>case <expr><name>CMD_caddexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"caddexpr"</literal></expr>;</return>

<case>case <expr><name>CMD_lexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lexpr"</literal></expr>;</return>

<case>case <expr><name>CMD_lgetexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lgetexpr"</literal></expr>;</return>

<case>case <expr><name>CMD_laddexpr</name></expr>:</case> <return>return <expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"laddexpr"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_cexpr</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>tv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int_u</name></type> <name>save_qfid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>au_name</name> <operator>=</operator> <call><name>cexpr_get_auname</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>qf_cmd_get_or_alloc_stack</name><argument_list>(<argument><expr><name>eap</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>tv</name> <operator>=</operator> <call><name>eval_expr</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>eap</name><operator>-&gt;</operator><name>nextcmd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tv</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name> <operator>&amp;&amp;</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_string</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator>

<operator>||</operator> <operator>(</operator><name><name>tv</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_LIST</name> <operator>&amp;&amp;</operator> <name><name>tv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>qf_init_ext</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name><name>qi</name><operator>-&gt;</operator><name>qf_curlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tv</name></expr></argument>, <argument><expr><name>p_efm</name></expr></argument>,

<argument><expr><operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_caddexpr</name>

<operator>&amp;&amp;</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>!=</operator> <name>CMD_laddexpr</name><operator>)</operator></expr></argument>,

<argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>linenr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>,

<argument><expr><call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>qf_stack_empty</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>save_qfid</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>qf_id</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_cexpr</name>

<operator>||</operator> <name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lexpr</name><operator>)</operator>

<operator>&amp;&amp;</operator> <call><name>qflist_valid</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump_first</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>save_qfid</name></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>forceit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"E777: String or List expected"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<label><name>cleanup</name>:</label>

<expr_stmt><expr><call><name>free_tv</name><argument_list>(<argument><expr><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>qf_info_T</name> <modifier>*</modifier></type>

<name>hgr_get_ll</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>new_ll</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>bt_help</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <name>curwin</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>qf_find_help_win</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>wp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content> 

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <name><name>wp</name><operator>-&gt;</operator><name>w_llist</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qi</name> <operator>=</operator> <call><name>qf_alloc_stack</name><argument_list>(<argument><expr><name>QFLT_LOCATION</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>new_ll</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>qi</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>hgr_search_file</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>fname</name></decl></parameter>,

<parameter><decl><type><name>vimconv_T</name> <modifier>*</modifier></type><name>p_vc</name></decl></parameter>,

<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>p_regmatch</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name></type> <name>lnum</name></decl>;</decl_stmt>

<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>mch_fopen</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>fname</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<expr_stmt><expr><name>lnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>vim_fgets</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>IOSIZE</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>line</name> <init>= <expr><name>IObuff</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p_vc</name><operator>-&gt;</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name>

<operator>&amp;&amp;</operator> <call><name>has_non_ascii</name><argument_list>(<argument><expr><name>IObuff</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <call><name>string_convert</name><argument_list>(<argument><expr><name>p_vc</name></expr></argument>, <argument><expr><name>IObuff</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>line</name> <operator>=</operator> <name>IObuff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>vim_regexec</name><argument_list>(<argument><expr><name>p_regmatch</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><operator>(</operator><name>colnr_T</name><operator>)</operator><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><call><name>STRLEN</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>l</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>line</name><index>[<expr><name>l</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>line</name><index>[<expr><operator>--</operator><name>l</name></expr>]</index></name> <operator>=</operator> <name>NUL</name></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><call><name>qf_add_entry</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>, 

<argument><expr><name>fname</name></expr></argument>,

<argument><expr><name>NULL</name></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name>line</name></expr></argument>,

<argument><expr><name>lnum</name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>p_regmatch</name><operator>-&gt;</operator><name>startp</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>line</name><operator>)</operator>

<operator>+</operator> <literal type="number">1</literal></expr></argument>, 

<argument><expr><name>FALSE</name></expr></argument>, 

<argument><expr><name>NULL</name></expr></argument>, 

<argument><expr><literal type="number">0</literal></expr></argument>, 

<argument><expr><literal type="number">1</literal></expr></argument>, 

<argument><expr><name>TRUE</name></expr></argument> 

)</argument_list></call> <operator>==</operator> <name>QF_FAIL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>got_int</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>IObuff</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>line</name> <operator>!=</operator> <name>IObuff</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>vim_free</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>lnum</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>line_breakcheck</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>hgr_search_files_in_dir</name><parameter_list>(

<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>,

<parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>dirname</name></decl></parameter>,

<parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>p_regmatch</name></decl></parameter>,

<parameter><decl><type><name>vimconv_T</name> <modifier>*</modifier></type><name>p_vc</name></decl></parameter>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>fcount</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier><modifier>*</modifier></type><name>fnames</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fi</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>add_pathsep</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>STRCAT</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><literal type="string">"doc/*.\\(txt\\|??x\\)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>gen_expand_wildcards</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dirname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fcount</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>fnames</name></expr></argument>, <argument><expr><name>EW_FILE</name><operator>|</operator><name>EW_SILENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name>

<operator>&amp;&amp;</operator> <name>fcount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<for>for <control>(<init><expr><name>fi</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>fi</name> <operator>&lt;</operator> <name>fcount</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>;</condition> <incr><expr><operator>++</operator><name>fi</name></expr></incr>)</control>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name>lang</name> <operator>!=</operator> <name>NULL</name>

<operator>&amp;&amp;</operator> <call><name>STRNICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><name><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name>

<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><call><name>STRNICMP</name><argument_list>(<argument><expr><name>lang</name></expr></argument>, <argument><expr><literal type="string">"en"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>

<operator>&amp;&amp;</operator> <call><name>STRNICMP</name><argument_list>(<argument><expr><literal type="string">"txt"</literal></expr></argument>, <argument><expr><name><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name>

<operator>+</operator> <call><name>STRLEN</name><argument_list>(<argument><expr><name><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>

<continue>continue;</continue></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>hgr_search_file</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name><name>fnames</name><index>[<expr><name>fi</name></expr>]</index></name></expr></argument>, <argument><expr><name>p_vc</name></expr></argument>, <argument><expr><name>p_regmatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>FreeWild</name><argument_list>(<argument><expr><name>fcount</name></expr></argument>, <argument><expr><name>fnames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>hgr_search_in_rtp</name><parameter_list>(<parameter><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl></parameter>, <parameter><decl><type><name>regmatch_T</name> <modifier>*</modifier></type><name>p_regmatch</name></decl></parameter>, <parameter><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>vimconv_T</name></type> <name>vc</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>vc</name><operator>.</operator><name>vc_type</name></name> <operator>=</operator> <name>CONV_NONE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>enc_utf8</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vc</name></expr></argument>, <argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"utf-8"</literal></expr></argument>, <argument><expr><name>p_enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>p_rtp</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <name>NUL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>got_int</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>copy_option_part</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>MAXPATHL</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hgr_search_files_in_dir</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><name>NameBuff</name></expr></argument>, <argument><expr><name>p_regmatch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vc</name></expr></argument>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
, <argument><expr><name>lang</name></expr></argument>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>vc</name><operator>.</operator><name>vc_type</name></name> <operator>!=</operator> <name>CONV_NONE</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>convert_setup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>ex_helpgrep</name><parameter_list>(<parameter><decl><type><name>exarg_T</name> <modifier>*</modifier></type><name>eap</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>regmatch_T</name></type> <name>regmatch</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>save_cpo</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>qf_info_T</name> <modifier>*</modifier></type><name>qi</name> <init>= <expr><operator>&amp;</operator><name>ql_info</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>new_qi</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>au_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>lang</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>CMD_helpgrep</name></expr>:</case> <expr_stmt><expr><name>au_name</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"helpgrep"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><name>CMD_lhelpgrep</name></expr>:</case> <expr_stmt><expr><name>au_name</name> <operator>=</operator> <operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><literal type="string">"lhelpgrep"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPRE</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><call><name>aborting</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_loclist_cmd</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>qi</name> <operator>=</operator> <call><name>hgr_get_ll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>new_qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>qi</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>save_cpo</name> <operator>=</operator> <name>p_cpo</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p_cpo</name> <operator>=</operator> <name>empty_option</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>incr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_MULTI_LANG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>lang</name> <operator>=</operator> <call><name>check_help_lang</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>=</operator> <call><name>vim_regcomp</name><argument_list>(<argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>, <argument><expr><name>RE_MAGIC</name> <operator>+</operator> <name>RE_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regmatch</name><operator>.</operator><name>rm_ic</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>qf_list_T</name> <modifier>*</modifier></type><name>qfl</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>qf_new_list</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><call><name>qf_cmdtitle</name><argument_list>(<argument><expr><operator>*</operator><name><name>eap</name><operator>-&gt;</operator><name>cmdlinep</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>qfl</name> <operator>=</operator> <call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hgr_search_in_rtp</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regmatch</name></expr></argument>, <argument><expr><name>lang</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>vim_regfree</name><argument_list>(<argument><expr><name><name>regmatch</name><operator>.</operator><name>regprog</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_nonevalid</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_ptr</name></name> <operator>=</operator> <name><name>qfl</name><operator>-&gt;</operator><name>qf_start</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>qfl</name><operator>-&gt;</operator><name>qf_index</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_list_changed</name><argument_list>(<argument><expr><name>qfl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>qf_update_buffer</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>p_cpo</name> <operator>==</operator> <name>empty_option</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>p_cpo</name> <operator>=</operator> <name>save_cpo</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>free_string_option</name><argument_list>(<argument><expr><name>save_cpo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>au_name</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>apply_autocmds</name><argument_list>(<argument><expr><name>EVENT_QUICKFIXCMDPOST</name></expr></argument>, <argument><expr><name>au_name</name></expr></argument>,

<argument><expr><name><name>curbuf</name><operator>-&gt;</operator><name>b_fname</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>curbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_qi</name> <operator>&amp;&amp;</operator> <call><name>IS_LL_STACK</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>qf_find_buf</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>qf_list_empty</name><argument_list>(<argument><expr><call><name>qf_get_curlist</name><argument_list>(<argument><expr><name>qi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_jump</name><argument_list>(<argument><expr><name>qi</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_nomatch2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>eap</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<expr_stmt><expr><call><name>decr_quickfix_busy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>eap</name><operator>-&gt;</operator><name>cmdidx</name></name> <operator>==</operator> <name>CMD_lhelpgrep</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bt_help</name><argument_list>(<argument><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_buffer</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>curwin</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>qi</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>new_qi</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>ll_free_all</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>curwin</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>curwin</name><operator>-&gt;</operator><name>w_llist</name></name> <operator>=</operator> <name>qi</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_EVAL</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>PROTO</name></expr></argument>)</argument_list></call></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>void</name></type>

<name>get_qf_loc_list</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>is_qf</name></decl></parameter>, <parameter><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>what_arg</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>what_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rettv_list_alloc</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>is_qf</name> <operator>||</operator> <name>wp</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>get_errorlist</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>rettv_dict_alloc</name><argument_list>(<argument><expr><name>rettv</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<if_stmt><if>if <condition>(<expr><name>is_qf</name> <operator>||</operator> <operator>(</operator><name>wp</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>what_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name><name>what_arg</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>qf_get_properties</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_dictreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type>

<name>f_getloclist</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>wp</name></decl>;</decl_stmt>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>find_win_by_nr_or_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_qf_loc_list</name><argument_list>(<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>wp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_getqflist</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>argvars</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>rettv</name></type> <name>UNUSED</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>get_qf_loc_list</name><argument_list>(<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>set_qf_ll_list</name><parameter_list>(

<parameter><decl><type><name>win_T</name> <modifier>*</modifier><name>wp</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>list_arg</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>action_arg</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier><name>what_arg</name></type> <name>UNUSED</name></decl></parameter>,

<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>e_invact</name> <init>= <expr><call><name>N_</name><argument_list>(<argument><expr><literal type="string">"E927: Invalid action: '%s'"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char_u</name> <modifier>*</modifier></type><name>act</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>action</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>recursive</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>FEAT_QUICKFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><name><name>list_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_LIST</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_listreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<if type="elseif">else if <condition>(<expr><name>recursive</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_au_recursive</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<decl_stmt><decl><type><name>list_T</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><name><name>list_arg</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_list</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>dict_T</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>valid_dict</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>action_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_STRING</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>act</name> <operator>=</operator> <call><name>tv_get_string_chk</name><argument_list>(<argument><expr><name>action_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>act</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<return>return;</return></block_content></block></if></if_stmt> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>act</name> <operator>==</operator> <literal type="char">'a'</literal> <operator>||</operator> <operator>*</operator><name>act</name> <operator>==</operator> <literal type="char">'r'</literal> <operator>||</operator> <operator>*</operator><name>act</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>act</name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<name><name>act</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <name>NUL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>action</name> <operator>=</operator> <operator>*</operator><name>act</name></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>semsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_invact</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>act</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name><name>action_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>action</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if>

<else>else<block type="pseudo"><block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_stringreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>action_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name>

<operator>&amp;&amp;</operator> <name><name>what_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>!=</operator> <name>VAR_UNKNOWN</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>what_arg</name><operator>-&gt;</operator><name>v_type</name></name> <operator>==</operator> <name>VAR_DICT</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <name><name>what_arg</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_dict</name></name></expr>;</expr_stmt></block_content></block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>emsg</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr><name>e_dictreq</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>valid_dict</name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>++</operator><name>recursive</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>action</name> <operator>&amp;&amp;</operator> <name>valid_dict</name> <operator>&amp;&amp;</operator> <call><name>set_errorlist</name><argument_list>(<argument><expr><name>wp</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>action</name></expr></argument>,

<argument><expr><operator>(</operator><name>char_u</name> <operator>*</operator><operator>)</operator><operator>(</operator><ternary><condition><expr><name>wp</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><literal type="string">":setqflist()"</literal></expr> </then><else>: <expr><literal type="string">":setloclist()"</literal></expr></else></ternary><operator>)</operator></expr></argument>,

<argument><expr><name>d</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>OK</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><operator>--</operator><name>recursive</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_setloclist</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>win_T</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rettv</name><operator>-&gt;</operator><name>vval</name><operator>.</operator><name>v_number</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>win</name> <operator>=</operator> <call><name>find_win_by_nr_or_id</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>win</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>set_qf_ll_list</name><argument_list>(<argument><expr><name>win</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>f_setqflist</name><parameter_list>(<parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>argvars</name></decl></parameter>, <parameter><decl><type><name>typval_T</name> <modifier>*</modifier></type><name>rettv</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>set_qf_ll_list</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>argvars</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><name>rettv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
