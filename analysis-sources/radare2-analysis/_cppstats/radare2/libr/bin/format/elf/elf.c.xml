<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\bin\format\elf\elf.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"elf.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>IFDBG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IFDBG</name></cpp:undef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DO_THE_DBG</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFDBG</name></cpp:macro> <cpp:value>if (DO_THE_DBG)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IFINT</name></cpp:macro> <cpp:value>if (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIPS_PLT_OFFSET</name></cpp:macro> <cpp:value>108</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RISCV_PLT_OFFSET</name></cpp:macro> <cpp:value>40</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_PAGE_MASK</name></cpp:macro> <cpp:value>0xFFFFFFFFFFFFF000LL</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_PAGE_SIZE</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ELF_NO_RELRO</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ELF_PART_RELRO</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ELF_FULL_RELRO</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bprintf</name></cpp:macro> <cpp:value>if(bin-&gt;verbose) R_LOG_WARN</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REL_RELA_SZ</name></cpp:macro> <cpp:value>(sizeof (Elf_(Rel)) &gt; sizeof (Elf_(Rela))? sizeof (Elf_(Rel)): sizeof (Elf_(Rela)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ8</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_read_ble8((x) + (i)); (i) += 1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_read_ble16((x) + (i), bin-&gt;endian); (i) += 2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_read_ble32((x) + (i), bin-&gt;endian); (i) += 4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_read_ble64((x) + (i), bin-&gt;endian); (i) += 8</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READWORD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ64 (x, i)</cpp:value></cpp:define>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READWORD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>READ32 (x, i)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BREAD8</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_buf_read_ble8_at(x, i); (i) += 1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BREAD16</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_buf_read_ble16_at(x, i, bin-&gt;endian); (i) += 2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BREAD32</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_buf_read_ble32_at(x, i, bin-&gt;endian); (i) += 4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BREAD64</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>i</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_buf_read_ble64_at(x, i, bin-&gt;endian); (i) += 8</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>UTX_MUL</name><parameter_list>(<parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>UT64_MUL</name> <argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>UTX_MUL</name><parameter_list>(<parameter><decl><type><name>ut64</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>r2</name> <init>= <expr><operator>*</operator><name>r</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>r2</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <name>r2</name></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GROWTH_FACTOR</name></cpp:macro> <cpp:value>(1.5)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>round_up</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((a) + (4) - (1)) / (4)) * (4))</cpp:value></cpp:define>

<enum>enum <block>{

<decl><name>X86</name></decl>,

<decl><name>X86_64</name></decl>,

<decl><name>ARM</name></decl>,

<decl><name>AARCH64</name></decl>,

<decl><name>RCE</name></decl>,

<decl><name>ARCH_LEN</name></decl>

}</block>;</enum>

<typedef>typedef <type><struct>struct <name>reginfo</name> <block>{

<decl_stmt><decl><type><name>ut32</name></type> <name>regsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>regdelta</name></decl>;</decl_stmt>

}</block></struct></type> <name>reginfo_t</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>reginfo_t</name></type> <name><name>reginf</name><index>[<expr><name>ARCH_LEN</name></expr>]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><literal type="number">160</literal></expr>, <expr><literal type="number">0x5c</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="number">216</literal></expr>, <expr><literal type="number">0x84</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="number">72</literal></expr>, <expr><literal type="number">0x5c</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="number">272</literal></expr>, <expr><literal type="number">0x84</literal></expr> }</block></expr>,

<expr><block>{ <expr><literal type="number">272</literal></expr>, <expr><literal type="number">0x84</literal></expr> }</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>__strnlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>IS_PRINTABLE</name> <argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>--</operator><name>len</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>str</name><operator>)</operator> <operator>==</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>l</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_bin_etrel</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_REL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__is_valid_ident</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name></name></expr></argument>, <argument><expr><name>ELFMAG</name></expr></argument>, <argument><expr><name>SELFMAG</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name></name></expr></argument>, <argument><expr><name>CGCMAG</name></expr></argument>, <argument><expr><name>SCGCMAG</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>init_ehdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>e_ident</name><index>[<expr><name>EI_NIDENT</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>ehdr</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Ehdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>e_ident</name></expr></argument>, <argument><expr><name>EI_NIDENT</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (magic)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_type.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_type { ET_NONE=0, ET_REL=1,"</literal>

<literal type="string">" ET_EXEC=2, ET_DYN=3, ET_CORE=4, ET_LOOS=0xfe00, ET_HIOS=0xfeff,"</literal>

<literal type="string">" ET_LOPROC=0xff00, ET_HIPROC=0xffff };"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_machine.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_machine {EM_NONE=0, EM_M32=1,"</literal>

<literal type="string">" EM_SPARC=2, EM_386=3, EM_68K=4, EM_88K=5, EM_IAMCU=6, EM_860=7, EM_MIPS=8,"</literal>

<literal type="string">" EM_S370=9, EM_MIPS_RS3_LE=10, EM_RS6000=11, EM_PARISC=15, EM_nCUBE=16,"</literal>

<literal type="string">" EM_VPP500=17, EM_SPARC32PLUS=18, EM_960=19, EM_PPC=20, EM_PPC64=21, EM_S390=22,"</literal>

<literal type="string">" EM_SPU=23, EM_V800=36, EM_FR20=37, EM_RH32=38, EM_RCE=39, EM_ARM=40,"</literal>

<literal type="string">" EM_ALPHA=41, EM_SH=42, EM_SPARCV9=43, EM_TRICORE=44, EM_ARC=45, EM_H8_300=46,"</literal>

<literal type="string">" EM_H8_300H=47, EM_H8S=48, EM_H8_500=49, EM_IA_64=50, EM_MIPS_X=51,"</literal>

<literal type="string">" EM_COLDFIRE=52, EM_68HC12=53, EM_MMA=54, EM_PCP=55, EM_NCPU=56, EM_NDR1=57,"</literal>

<literal type="string">" EM_STARCORE=58, EM_ME16=59, EM_ST100=60, EM_TINYJ=61, EM_X86_64=62, EM_PDSP=63,"</literal>

<literal type="string">" EM_PDP10=64, EM_PDP11=65, EM_FX66=66, EM_ST9PLUS=67, EM_ST7=68, EM_68HC16=69,"</literal>

<literal type="string">" EM_68HC11=70, EM_68HC08=71, EM_68HC05=72, EM_SVX=73, EM_ST19=74, EM_VAX=75,"</literal>

<literal type="string">" EM_CRIS=76, EM_JAVELIN=77, EM_FIREPATH=78, EM_ZSP=79, EM_MMIX=80, EM_HUANY=81,"</literal>

<literal type="string">" EM_PRISM=82, EM_AVR=83, EM_FR30=84, EM_D10V=85, EM_D30V=86, EM_V850=87,"</literal>

<literal type="string">" EM_M32R=88, EM_MN10300=89, EM_MN10200=90, EM_PJ=91, EM_OPENRISC=92,"</literal>

<literal type="string">" EM_ARC_COMPACT=93, EM_XTENSA=94, EM_VIDEOCORE=95, EM_TMM_GPP=96, EM_NS32K=97,"</literal>

<literal type="string">" EM_TPC=98, EM_SNP1K=99, EM_ST200=100, EM_IP2K=101, EM_MAX=102, EM_CR=103,"</literal>

<literal type="string">" EM_F2MC16=104, EM_MSP430=105, EM_BLACKFIN=106, EM_SE_C33=107, EM_SEP=108,"</literal>

<literal type="string">" EM_ARCA=109, EM_UNICORE=110, EM_EXCESS=111, EM_DXP=112, EM_ALTERA_NIOS2=113,"</literal>

<literal type="string">" EM_CRX=114, EM_XGATE=115, EM_C166=116, EM_M16C=117, EM_DSPIC30F=118, EM_CE=119,"</literal>

<literal type="string">" EM_M32C=120, EM_TSK3000=131, EM_RS08=132, EM_SHARC=133, EM_ECOG2=134,"</literal>

<literal type="string">" EM_SCORE7=135, EM_DSP24=136, EM_VIDEOCORE3=137, EM_LATTICEMICO32=138,"</literal>

<literal type="string">" EM_SE_C17=139, EM_TI_C6000=140, EM_TI_C2000=141, EM_TI_C5500=142,"</literal>

<literal type="string">" EM_TI_ARP32=143, EM_TI_PRU=144,"</literal>

<literal type="string">" EM_MMDSP_PLUS=160, EM_CYPRESS_M8C=161, EM_R32C=162, EM_TRIMEDIA=163,"</literal>

<literal type="string">" EM_HEXAGON=164, EM_8051=165, EM_STXP7X=166, EM_NDS32=167,"</literal>

<literal type="string">" EM_ECOG1X=168, EM_MAXQ30=169, EM_XIMO16=170, EM_MANIK=171, EM_CRAYNV2=172,"</literal>

<literal type="string">" EM_RX=173, EM_METAG=174, EM_MCST_ELBRUS=175, EM_ECOG16=176, EM_CR16=177,"</literal>

<literal type="string">" EM_ETPU=178, EM_SLE9X=179, EM_L10M=180, EM_K10M=181, EM_AARCH64=183,"</literal>

<literal type="string">" EM_AVR32=185, EM_STM8=186, EM_TILE64=187, EM_TILEPRO=188, EM_CUDA=190,"</literal>

<literal type="string">" EM_TILEGX=191, EM_CLOUDSHIELD=192, EM_COREA_1ST=193, EM_COREA_2ND=194,"</literal>

<literal type="string">" EM_ARC_COMPACT2=195, EM_OPEN8=196, EM_RL78=197, EM_VIDEOCORE5=198,"</literal>

<literal type="string">" EM_78KOR=199, EM_56800EX=200, EM_BA1=201, EM_BA2=202, EM_XCORE=203,"</literal>

<literal type="string">" EM_MCHP_PIC=204, EM_INTEL205=205, EM_INTEL206=206, EM_INTEL207=207,"</literal>

<literal type="string">" EM_INTEL208=208, EM_INTEL209=209, EM_KM32=210, EM_KMX32=211, EM_KMX16=212,"</literal>

<literal type="string">" EM_KMX8=213, EM_KVARC=214, EM_CDP=215, EM_COGE=216, EM_COOL=217, EM_NORC=218,"</literal>

<literal type="string">" EM_CSR_KALIMBA=219, EM_AMDGPU=224, EM_RISCV=243, EM_LANAI=244, EM_BPF=247,"</literal>

<literal type="string">" EM_CSKY=252}"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_class.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_class {ELFCLASSNONE=0, ELFCLASS32=1, ELFCLASS64=2};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_data.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_data {ELFDATANONE=0, ELFDATA2LSB=1, ELFDATA2MSB=2};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_hdr_version.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_hdr_version {EV_NONE=0, EV_CURRENT=1};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_obj_version.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_obj_version {EV_NONE=0, EV_CURRENT=1};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.offset"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.size"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Ehdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_ident.format"</literal></expr></argument>, <argument><expr><literal type="string">"[4]z[1]E[1]E[1]E.::"</literal>

<literal type="string">" magic (elf_class)class (elf_data)data (elf_hdr_version)version"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.format"</literal></expr></argument>, <argument><expr><literal type="string">"?[2]E[2]E[4]Eqqqxwwwwww"</literal>

<literal type="string">" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version"</literal>

<literal type="string">" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.format"</literal></expr></argument>, <argument><expr><literal type="string">"?[2]E[2]E[4]Exxxxwwwwww"</literal>

<literal type="string">" (elf_ident)ident (elf_type)type (elf_machine)machine (elf_obj_version)version"</literal>

<literal type="string">" entry phoff shoff flags ehsize phentsize phnum shentsize shnum shstrndx"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>endian</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2MSB</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Ehdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ehdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ehdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (ehdr)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name></name></expr></argument>, <argument><expr><name>ehdr</name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>__is_valid_ident</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_version</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ehsize</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phentsize</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shentsize</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>ehdr</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>read_phdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>linux_kernel_hack</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>phdr_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_elf64</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>is_elf64</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>phdr</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>phdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (phdr)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_PHDR</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>phdr_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_elf64</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_flags</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_vaddr</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_paddr</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_filesz</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_memsz</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_elf64</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_flags</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_align</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>phdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>linux_kernel_hack</name> <operator>&amp;&amp;</operator> <name>phdr_found</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>load_addr</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_baddr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>load_addr</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>read_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_phdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>phdr_size</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>phdr_size</name></expr></argument>, <argument><expr><operator>(</operator><name>ut32</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>phdr_size</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>phdr_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>phdr_size</name> <operator>&gt;</operator> <operator>(</operator><name>ut32</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name> <operator>+</operator> <name>phdr_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc (phdr)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>linux_kern_hack</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>_128K</name> <init>= <expr><literal type="number">1024</literal> <operator>*</operator> <literal type="number">128</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <name>_128K</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_X86_64</name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_386</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>linux_kern_hack</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>read_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>linux_kern_hack</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_phdr.offset"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_phdr.size"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_p_type.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_p_type {PT_NULL=0,PT_LOAD=1,PT_DYNAMIC=2,"</literal>

<literal type="string">"PT_INTERP=3,PT_NOTE=4,PT_SHLIB=5,PT_PHDR=6,PT_LOOS=0x60000000,"</literal>

<literal type="string">"PT_HIOS=0x6fffffff,PT_LOPROC=0x70000000,PT_HIPROC=0x7fffffff};"</literal></expr></argument>,

<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_p_flags.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_p_flags {PF_None=0,PF_Exec=1,"</literal>

<literal type="string">"PF_Write=2,PF_Write_Exec=3,PF_Read=4,PF_Read_Exec=5,PF_Read_Write=6,"</literal>

<literal type="string">"PF_Read_Write_Exec=7};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_phdr.format"</literal></expr></argument>, <argument><expr><literal type="string">"[4]E[4]Eqqqqqq (elf_p_type)type (elf_p_flags)flags"</literal>

<literal type="string">" offset vaddr paddr filesz memsz align"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_phdr.format"</literal></expr></argument>, <argument><expr><literal type="string">"[4]Exxxxx[4]Ex (elf_p_type)type offset vaddr paddr"</literal>

<literal type="string">" filesz memsz (elf_p_flags)flags align"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_shdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>shdr_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>shdr</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>shdr_size</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shdr_size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shdr_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>+</operator> <name>shdr_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc (shdr)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shdr.offset"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shdr.size"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_s_type.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_s_type {SHT_NULL=0,SHT_PROGBITS=1,"</literal>

<literal type="string">"SHT_SYMTAB=2,SHT_STRTAB=3,SHT_RELA=4,SHT_HASH=5,SHT_DYNAMIC=6,SHT_NOTE=7,"</literal>

<literal type="string">"SHT_NOBITS=8,SHT_REL=9,SHT_SHLIB=10,SHT_DYNSYM=11,SHT_LOOS=0x60000000,"</literal>

<literal type="string">"SHT_HIOS=0x6fffffff,SHT_LOPROC=0x70000000,SHT_HIPROC=0x7fffffff};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name> <operator>+</operator> <name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>shdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (shdr) at 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_flags</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_addr</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_link</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_info</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_addralign</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_entsize</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>shdr</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_s_flags_64.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_s_flags_64 {SF64_None=0,SF64_Exec=1,"</literal>

<literal type="string">"SF64_Alloc=2,SF64_Alloc_Exec=3,SF64_Write=4,SF64_Write_Exec=5,"</literal>

<literal type="string">"SF64_Write_Alloc=6,SF64_Write_Alloc_Exec=7};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shdr.format"</literal></expr></argument>, <argument><expr><literal type="string">"x[4]E[8]Eqqqxxqq name (elf_s_type)type"</literal>

<literal type="string">" (elf_s_flags_64)flags addr offset size link info addralign entsize"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_s_flags_32.cparse"</literal></expr></argument>, <argument><expr><literal type="string">"enum elf_s_flags_32 {SF32_None=0,SF32_Exec=1,"</literal>

<literal type="string">"SF32_Alloc=2,SF32_Alloc_Exec=3,SF32_Write=4,SF32_Write_Exec=5,"</literal>

<literal type="string">"SF32_Write_Alloc=6,SF32_Write_Alloc_Exec=7};"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shdr.format"</literal></expr></argument>, <argument><expr><literal type="string">"x[4]E[4]Exxxxxxx name (elf_s_type)type"</literal>

<literal type="string">" (elf_s_flags_32)flags addr offset size link info addralign entsize"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_shidx_valid</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><macro><name>Elf_</name><argument_list>(<argument>Half</argument>)</argument_list></macro> <name>value</name></expr></argument>)</argument_list> <block>{<block_content>

<return>return <expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>value</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name>SHN_LORESERVE</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>SHN_HIRESERVE</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_strtab</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Half</argument>)</argument_list></macro> <expr_stmt><expr><name>shstrndx</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shstrndx</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shstrndx</name> <operator>!=</operator> <name>SHN_UNDEF</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_shidx_valid</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>shstrndx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>shstrndx</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>&gt;</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>shstrndx</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_section</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>shstrndx</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr></argument>,

<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (shstrtab) at 0x%"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shstrtab.offset"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_shstrtab.size"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<expr_stmt><expr><specifier>static</specifier> <call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><macro><name>get_dynamic_segment</name><argument_list>(<argument>ELFOBJ *bin</argument>)</argument_list></macro> <block>{

<expr><name>int</name> <name>i</name></expr>;

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_DYNAMIC</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_filesz</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

<expr_stmt/></block_content></block></if></if_stmt></block_content></block></if></if_stmt></block_content></block></for>}</block></expr></expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

}

}

<return>return <expr><name>NULL</name></expr>;</return>

}

static <decl_stmt><decl><type><name>void</name></type> <name>init_dynamic_section_sdb</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><macro><name>Elf_</name><argument_list>(<argument>Addr</argument>)</argument_list></macro> <name>strtabaddr</name></expr></argument>, <argument><expr><name>size_t</name> <name>strsize</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_has_relro</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>r</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ELF_FULL_RELRO</name></expr>:</case>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf.relro"</literal></expr></argument>, <argument><expr><literal type="string">"full"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>R_ELF_PART_RELRO</name></expr>:</case>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf.relro"</literal></expr></argument>, <argument><expr><literal type="string">"partial"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf.relro"</literal></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_strtab.offset"</literal></expr></argument>, <argument><expr><name>strtabaddr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_strtab.size"</literal></expr></argument>, <argument><expr><name>strsize</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>compute_dyn_entries</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>dyn_phdr</name></expr></argument>, <argument><expr><name>ut64</name> <name>dyn_size</name></expr></argument>)</argument_list> <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Dyn</argument>)</argument_list></macro> <expr_stmt><expr><name>d</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>res</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>res</name> <operator>&lt;</operator> <operator>(</operator><name>dyn_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</condition> <incr><expr><name>res</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>sdyn</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>dyn_phdr</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>+</operator> <name>res</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sdyn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>d_tag</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>sdyn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>d</name><operator>.</operator><name>d_tag</name></name> <operator>==</operator> <name>DT_NULL</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>int</name></type> <name>init_dynamic_section</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call> <operator>*</operator><name>dyn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>strtabaddr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>relentry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>strsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>sdyn</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dyn_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>loaded_offset</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>dyn_phdr</name> <operator>=</operator> <call><name>get_dynamic_segment</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dyn_phdr</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dyn_size</name> <operator>=</operator> <name><name>dyn_phdr</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>entries</name> <init>= <expr><call><name>compute_dyn_entries</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>dyn_phdr</name></expr></argument>, <argument><expr><name>dyn_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entries</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dyn</name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dyn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UTX_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>dyn_size</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>loaded_offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>dyn_phdr</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>loaded_offset</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dyn_size</name> <operator>||</operator> <name>loaded_offset</name> <operator>+</operator> <name>dyn_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>loaded_offset</name> <operator>+</operator> <name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sdyn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Dyn</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (dyn)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>sdyn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>sdyn</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DT_STRTAB</name></expr>:</case>

<expr_stmt><expr><name>strtabaddr</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_STRSZ</name></expr>:</case>

<expr_stmt><expr><name>strsize</name> <operator>=</operator> <name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_PLTREL</name></expr>:</case>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>=</operator> <name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_RELAENT</name></expr>:</case>

<expr_stmt><expr><name>relentry</name> <operator>=</operator> <name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>&gt;=</operator> <name>DT_VERSYM</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>&lt;=</operator> <name>DT_VERNEEDNUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>=</operator> <name><name>dyn</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>=</operator> <ternary><condition><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <name>relentry</name></expr>?</condition><then> <expr><name>DT_RELA</name></expr></then><else>: <expr><name>DT_REL</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>strtabaddr</name> <operator>==</operator> <name>UT64_MAX</name> <operator>||</operator> <name>strtabaddr</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>strsize</name> <operator>&gt;</operator> <name>ST32_MAX</name> <operator>||</operator> <operator>!</operator><name>strsize</name> <operator>||</operator> <name>strsize</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>strtabaddr</name> <operator>+</operator> <name>strsize</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strtabaddr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"DT_STRTAB not found or invalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>strsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strtab</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>strtabaddr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><name>strtab</name></expr></argument>, <argument><expr><name>strsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name> <operator>=</operator> <name>dyn</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name> <operator>=</operator> <name>entries</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>=</operator> <name>strtab</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name> <operator>=</operator> <name>strsize</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_dynamic_section_sdb</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>strtabaddr</name></expr></argument>, <argument><expr><name>strsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dyn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSection</name><modifier>*</modifier></type> <name>get_section_by_name</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_ver_flags</name><parameter_list>(<parameter><decl><type><name>ut32</name></type> <name>flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buff</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>buff</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flags</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="string">"none"</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>VER_FLG_BASE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"BASE "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>VER_FLG_WEAK</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>VER_FLG_BASE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"| "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"WEAK "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>~</operator><operator>(</operator><name>VER_FLG_BASE</name> <operator>|</operator> <name>VER_FLG_WEAK</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"| &lt;unknown&gt;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>buff</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>store_versioninfo_gnu_versym</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>shdr</name></expr></argument>, <argument><expr><name>int</name> <name>sz</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>num_entries</name> <init>= <expr><name>sz</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Versym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sdb</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name>DT_VERSYM</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>link_shdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr>]</index></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>num_entries</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">2</literal> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>edata</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut16</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><name>ut16</name> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>num_entries</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name>DT_VERSYM</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>link_section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"section_name"</literal></expr></argument>, <argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"num_entries"</literal></expr></argument>, <argument><expr><name>num_entries</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link_section_name"</literal></expr></argument>, <argument><expr><name>link_section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>num_entries</name></expr>;</init> <condition><expr><name>i</name><operator>--</operator></expr>;</condition><incr/>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>r_read_ble16</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><index>[<expr><name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut16</name></expr></argument>)</argument_list></sizeof></expr>]</index></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp_val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_entries</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>check_def</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>j</name> <operator>&lt;</operator> <literal type="number">4</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>i</name> <operator>+</operator> <name>j</name><operator>)</operator> <operator>&lt;</operator> <name>num_entries</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"entry%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"0 (*local*)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="string">"1 (*global*)"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_val</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%x "</literal></expr></argument>, <argument><expr><name><name>data</name><index>[<expr><name>i</name><operator>+</operator><name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>check_def</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name>DT_VERNEED</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>)</condition> <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Verneed</argument>)</argument_list></macro> <expr_stmt><expr><name>vn</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>svn</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verneed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name>DT_VERNEED</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Vernaux</argument>)</argument_list></macro> <expr_stmt><expr><name>vna</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>svna</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Vernaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>a_off</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>vn</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>svn</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>svn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read Verneed for Versym\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vn</name><operator>.</operator><name>vn_version</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svn</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vn</name><operator>.</operator><name>vn_cnt</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svn</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vn</name><operator>.</operator><name>vn_file</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svn</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vn</name><operator>.</operator><name>vn_aux</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svn</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vn</name><operator>.</operator><name>vn_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svn</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a_off</name> <operator>=</operator> <name>offset</name> <operator>+</operator> <name><name>vn</name><operator>.</operator><name>vn_aux</name></name></expr>;</expr_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>a_off</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>a_off</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>vna</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>a_off</name></expr></argument>, <argument><expr><name>svna</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>svna</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read Vernaux for Versym\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vna</name><operator>.</operator><name>vna_hash</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svna</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vna</name><operator>.</operator><name>vna_flags</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svna</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vna</name><operator>.</operator><name>vna_other</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svna</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vna</name><operator>.</operator><name>vna_name</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svna</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vna</name><operator>.</operator><name>vna_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svna</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a_off</name> <operator>+=</operator> <name><name>vna</name><operator>.</operator><name>vna_next</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name><name>vna</name><operator>.</operator><name>vna_other</name></name> <operator>!=</operator> <name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>vna</name><operator>.</operator><name>vna_next</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name><name>vna</name><operator>.</operator><name>vna_other</name></name> <operator>==</operator> <name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>vna</name><operator>.</operator><name>vna_name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s(%s)"</literal></expr></argument>, <argument><expr><name>tmp_val</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>+</operator> <name><name>vna</name><operator>.</operator><name>vna_name</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>check_def</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>vn</name><operator>.</operator><name>vn_next</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name><name>vn</name><operator>.</operator><name>vn_next</name></name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>vinfoaddr</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>version_info</name><index>[<expr><call><name>DT_VERSIONTAGIDX</name> <argument_list>(<argument><expr><name>DT_VERDEF</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>check_def</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0x8001</literal> <operator>&amp;&amp;</operator> <name>vinfoaddr</name></expr>)</condition> <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Verdef</argument>)</argument_list></macro> <expr_stmt><expr><name>vd</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>svd</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>vinfoaddr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>vd</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>svd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>svd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read Verdef for Versym\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_version</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_flags</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_ndx</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_cnt</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_hash</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_aux</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vd</name><operator>.</operator><name>vd_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svd</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name><name>vd</name><operator>.</operator><name>vd_next</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name><name>vd</name><operator>.</operator><name>vd_ndx</name></name> <operator>!=</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>vd</name><operator>.</operator><name>vd_next</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

<if_stmt><if>if <condition>(<expr><name><name>vd</name><operator>.</operator><name>vd_ndx</name></name> <operator>==</operator> <operator>(</operator><name><name>data</name><index>[<expr><name>i</name> <operator>+</operator> <name>j</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0x7FFF</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Verdaux</argument>)</argument_list></macro> <expr_stmt><expr><name>vda</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>svda</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off_vda</name> <init>= <expr><name>offset</name> <operator>-</operator> <name><name>vd</name><operator>.</operator><name>vd_next</name></name> <operator>+</operator> <name><name>vd</name><operator>.</operator><name>vd_aux</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off_vda</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>off_vda</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>vda</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off_vda</name></expr></argument>, <argument><expr><name>svda</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>svda</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read Verdaux for Versym\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vda</name><operator>.</operator><name>vda_name</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svda</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vda</name><operator>.</operator><name>vda_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>svda</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>vda</name><operator>.</operator><name>vda_name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>+</operator> <name><name>vda</name><operator>.</operator><name>vda_name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s(%s%-*s)"</literal></expr></argument>, <argument><expr><name>tmp_val</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><literal type="number">12</literal> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,<argument><expr><literal type="string">")"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>tmp_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>sdb</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>store_versioninfo_gnu_verdef</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>shdr</name></expr></argument>, <argument><expr><name>int</name> <name>sz</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>dfs</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>cnt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>link_shdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr>]</index></name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>R_BIN_ELF64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call> <operator>*</operator><name>defs</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>defs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate memory (Check Elf_(Verdef))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>link_shdr</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>link_section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sdb</name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>defs</name> <operator>+</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"section_name"</literal></expr></argument>, <argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"entries"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link_section_name"</literal></expr></argument>, <argument><expr><name>link_section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb_verdef</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vstart</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>defs</name><operator>)</operator> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>vstart_off</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call> <operator>*</operator><name>verdef</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call><operator>*</operator><operator>)</operator><name>vstart</name></expr>;</expr_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Verdaux</argument>)</argument_list></macro> <expr_stmt><expr><name>aux</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>isum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vstart</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>verdef</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>dfs</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdef</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_version</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_flags</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_ndx</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_cnt</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_hash</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_aux</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>dfs</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>vdaux</name> <init>= <expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_aux</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vdaux</name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <name>vstart_off</name> <operator>&lt;</operator> <name>vdaux</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vstart</name> <operator>+=</operator> <name>vdaux</name></expr>;</expr_stmt>

<expr_stmt><expr><name>vstart_off</name> <operator>+=</operator> <name>vdaux</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vstart</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>vstart_off</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aux</name><operator>.</operator><name>vda_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isum</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>verdef</name><operator>-&gt;</operator><name>vd_aux</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"vd_version"</literal></expr></argument>, <argument><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_version</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"vd_ndx"</literal></expr></argument>, <argument><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_ndx</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"vd_cnt"</literal></expr></argument>, <argument><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"vda_name"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name><index>[<expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><literal type="string">"flags"</literal></expr></argument>, <argument><expr><call><name>get_ver_flags</name> <argument_list>(<argument><expr><name><name>verdef</name><operator>-&gt;</operator><name>vd_flags</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>verdef</name><operator>-&gt;</operator><name>vd_cnt</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb_parent</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <name>vstart_off</name> <operator>&lt;</operator> <name><name>aux</name><operator>.</operator><name>vda_next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>isum</name> <operator>+=</operator> <name><name>aux</name><operator>.</operator><name>vda_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vstart</name> <operator>+=</operator> <name><name>aux</name><operator>.</operator><name>vda_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vstart_off</name> <operator>+=</operator> <name><name>aux</name><operator>.</operator><name>vda_next</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vstart</name> <operator>&gt;</operator> <name>end</name> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verdaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>vstart_off</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aux</name><operator>.</operator><name>vda_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>isum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>, <argument><expr><literal type="string">"parent"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_parent</name></expr></argument>, <argument><expr><literal type="string">"vda_name"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name><index>[<expr><name><name>aux</name><operator>.</operator><name>vda_name</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"parent%d"</literal></expr></argument>, <argument><expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"verdef%u"</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>verdef</name><operator>-&gt;</operator><name>vd_next</name></name> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>-</operator> <name>i</name> <operator>&lt;</operator> <name><name>verdef</name><operator>-&gt;</operator><name>vd_next</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_verdef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>out_error</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>st32</name><operator>)</operator><name><name>verdef</name><operator>-&gt;</operator><name>vd_next</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid vd_next in the ELF version\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>verdef</name><operator>-&gt;</operator><name>vd_next</name></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>defs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>sdb</name></expr>;</return>

<label><name>out_error</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>defs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>store_versioninfo_gnu_verneed</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>shdr</name></expr></argument>, <argument><expr><name>int</name> <name>sz</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>end</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>need</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>link_shdr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link_section_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb_vernaux</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb_version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cnt</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>R_BIN_ELF64</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name>SIZE_MAX</name></expr>)</condition> <block>{<block_content>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sdb</name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sdb</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>link_shdr</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>link_section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>link_shdr</name><operator>-&gt;</operator><name>sh_name</name></name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>need</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut8</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate memory for Elf_(Verneed)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>need</name> <operator>+</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"section_name"</literal></expr></argument>, <argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"num_entries"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_info</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link"</literal></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><literal type="string">"link_section_name"</literal></expr></argument>, <argument><expr><name>link_section_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&lt;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>, <argument><expr><name>need</name></expr></argument>, <argument><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>cnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>cnt</name> <operator>&lt;</operator> <name><name>shdr</name><operator>-&gt;</operator><name>sh_info</name></name></expr>;</condition> <incr><expr><name>cnt</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>isum</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>vstart</name> <init>= <expr><name>need</name> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Verneed</argument>)</argument_list></macro> <expr_stmt><expr><name>vvn</name> <operator>=</operator> <block>{ <expr><literal type="number">0</literal></expr> }</block></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>vstart</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verneed</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name>end</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Verneed</name></expr></argument>)</argument_list></call> <operator>*</operator><name>entry</name> <operator>=</operator> <operator>&amp;</operator><name>vvn</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sdb_version</name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sdb_version</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vvn</name><operator>.</operator><name>vn_version</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vvn</name><operator>.</operator><name>vn_cnt</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vvn</name><operator>.</operator><name>vn_file</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vvn</name><operator>.</operator><name>vn_aux</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vvn</name><operator>.</operator><name>vn_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><literal type="string">"vn_version"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>vn_version</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>vn_file</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>vn_file</name></name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><literal type="string">"file_name"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><literal type="string">"cnt"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>st32</name></type> <name>vnaux</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>vn_aux</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vnaux</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vstart</name> <operator>+=</operator> <name>vnaux</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>vn_cnt</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>vn_cnt</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>isum</name> <operator>=</operator> <name>i</name> <operator>+</operator> <name><name>entry</name><operator>-&gt;</operator><name>vn_aux</name></name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>vn_cnt</name> <operator>&amp;&amp;</operator> <name>vstart</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Vernaux</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>end</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Vernaux</name></expr></argument>)</argument_list></call> <operator>*</operator><name>aux</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Vernaux</argument>)</argument_list></macro> <expr_stmt><expr><name>vaux</name> <operator>=</operator> <block>{<expr><literal type="number">0</literal></expr>}</block></expr>;</expr_stmt>

<expr_stmt><expr><name>aux</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Vernaux</name></expr></argument>)</argument_list></call><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>vaux</name></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vaux</name><operator>.</operator><name>vna_hash</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vaux</name><operator>.</operator><name>vna_flags</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vaux</name><operator>.</operator><name>vna_other</name></name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vaux</name><operator>.</operator><name>vna_name</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>vaux</name><operator>.</operator><name>vna_next</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>vstart</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aux</name><operator>-&gt;</operator><name>vna_name</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<expr_stmt><expr><name>sdb_vernaux</name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sdb_vernaux</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_vernaux</name></expr></argument>, <argument><expr><literal type="string">"idx"</literal></expr></argument>, <argument><expr><name>isum</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aux</name><operator>-&gt;</operator><name>vna_name</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>aux</name><operator>-&gt;</operator><name>vna_name</name></name> <operator>+</operator> <literal type="number">8</literal> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>name</name> <index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name><index>[<expr><name><name>aux</name><operator>-&gt;</operator><name>vna_name</name></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>name</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_vernaux</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_vernaux</name></expr></argument>, <argument><expr><literal type="string">"flags"</literal></expr></argument>, <argument><expr><call><name>get_ver_flags</name> <argument_list>(<argument><expr><name><name>aux</name><operator>-&gt;</operator><name>vna_flags</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name>sdb_vernaux</name></expr></argument>, <argument><expr><literal type="string">"version"</literal></expr></argument>, <argument><expr><name><name>aux</name><operator>-&gt;</operator><name>vna_other</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isum</name> <operator>+=</operator> <name><name>aux</name><operator>-&gt;</operator><name>vna_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vstart</name> <operator>+=</operator> <name><name>aux</name><operator>-&gt;</operator><name>vna_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"vernaux%d"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb_vernaux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"vernaux%d"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d,%s"</literal></expr></argument>, <argument><expr><name>isum</name></expr></argument>, <argument><expr><call><name>get_ver_flags</name> <argument_list>(<argument><expr><name><name>aux</name><operator>-&gt;</operator><name>vna_flags</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>entry</name><operator>-&gt;</operator><name>vn_next</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid vn_next\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name><name>entry</name><operator>-&gt;</operator><name>vn_next</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"version%d"</literal></expr></argument>, <argument><expr><name>cnt</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>vn_next</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>sdb</name></expr>;</return>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>need</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_vernaux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<function><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>store_versioninfo</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb_versioninfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_verdef</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_verneed</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num_versym</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sdb_versioninfo</name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <operator>(</operator><name>i</name><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>left</name> <init>= <expr><name>size</name> <operator>-</operator> <operator>(</operator><name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>SHT_GNU_verdef</name></expr>:</case>

<expr_stmt><expr><name>sdb</name> <operator>=</operator> <call><name>store_versioninfo_gnu_verdef</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"verdef%d"</literal></expr></argument>, <argument><expr><name>num_verdef</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb_versioninfo</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SHT_GNU_verneed</name></expr>:</case>

<expr_stmt><expr><name>sdb</name> <operator>=</operator> <call><name>store_versioninfo_gnu_verneed</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"verneed%d"</literal></expr></argument>, <argument><expr><name>num_verneed</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb_versioninfo</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>SHT_GNU_versym</name></expr>:</case>

<expr_stmt><expr><name>sdb</name> <operator>=</operator> <call><name>store_versioninfo_gnu_versym</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"versym%d"</literal></expr></argument>, <argument><expr><name>num_versym</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name>sdb_versioninfo</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>sdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<return>return <expr><name>sdb_versioninfo</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>init_dynstr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_STRTAB</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".dynstr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name><argument_list>(<argument><expr><literal type="string">"Cannot allocate memory for dynamic strings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>dynstr_size</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>elf_init</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_ehdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize program headers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>!=</operator> <name>ET_CORE</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_shdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize section headers\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_strtab</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize strings table\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_dynstr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize dynamic strings\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_baddr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>init_dynamic_section</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_is_static</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize dynamic section\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_sections</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>boffset</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_boffset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_ns_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"versioninfo"</literal></expr></argument>, <argument><expr><call><name>store_versioninfo</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_section_offset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>section</name><operator>-&gt;</operator><name>offset</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_section_addr</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>section</name></expr>?</condition><then> <expr><name><name>section</name><operator>-&gt;</operator><name>rva</name></name></expr></then><else>: <expr><name>UT64_MAX</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_section_addr_end</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>section</name></expr>?</condition><then> <expr><name><name>section</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name><name>section</name><operator>-&gt;</operator><name>size</name></name></expr></then><else>: <expr><name>UT64_MAX</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_OFFSET</name></cpp:macro> <cpp:value>(rel-&gt;is_rela? rel-&gt;r.rela.r_offset: rel-&gt;r.rel.r_offset)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_INFO</name></cpp:macro> <cpp:value>(rel-&gt;is_rela? rel-&gt;r.rela.r_info: rel-&gt;r.rel.r_info)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_SYM</name></cpp:macro> <cpp:value>(ELF_R_SYM (REL_INFO))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REL_TYPE</name></cpp:macro> <cpp:value>(ELF_R_TYPE (REL_INFO))</cpp:value></cpp:define>

<struct>struct <name>ht_rel_t</name> <block>{

<union>union <block>{

<macro><name>Elf_</name><argument_list>(<argument>Rel</argument>)</argument_list></macro> <expr_stmt><expr><name>rel</name></expr>;</expr_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Rela</argument>)</argument_list></macro> <expr_stmt><expr><name>rela</name></expr>;</expr_stmt>

}</block> <decl><name>r</name></decl>;</union>

<decl_stmt><decl><type><name>bool</name></type> <name>is_rela</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>RBinElfSection</name> <modifier>*</modifier></type><name>get_rel_sec</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>sects</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>rel_sec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><name>rel_sec</name> <operator>&amp;&amp;</operator> <name><name>sects</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rel_sec</name> <operator>=</operator> <call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>sects</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>rel_sec</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>read_rel</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rel</name></expr></argument>)</argument_list></call> <operator>*</operator><name>rel</name></expr></argument>, <argument><expr><name>ut8</name> <operator>*</operator><name>rl</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>read_rela</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call> <operator>*</operator><name>rela</name></expr></argument>, <argument><expr><name>ut8</name> <operator>*</operator><name>rl</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>rela</name><operator>-&gt;</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>-&gt;</operator><name>r_info</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>-&gt;</operator><name>r_addend</name></name> <operator>=</operator> <call><name>READWORD</name> <argument_list>(<argument><expr><name>rl</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>read_ht_rel</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>rl</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>ht_rel_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>==</operator> <name>DT_RELA</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>is_rela</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>read_rela</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>r</name><operator>.</operator><name>rela</name></name></expr></argument>, <argument><expr><name>rl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>read_rel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>r</name><operator>.</operator><name>rel</name></name></expr></argument>, <argument><expr><name>rl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>rel</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rel_cache_free</name><parameter_list>(<parameter><decl><type><name>HtUPKv</name> <modifier>*</modifier></type><name>kv</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>kv</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HtUP</name> <modifier>*</modifier></type><name>rel_cache_new</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>rl</name><index>[<expr><name>MAX_REL_RELA_SZ</name></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>rel_sec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>tsize</name></decl>, <decl><type ref="prev"/><name>nrel</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>rel_sect</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">".rel.plt"</literal></expr>, <expr><literal type="string">".rela.plt"</literal></expr>, <expr><literal type="string">".rel.dyn"</literal></expr>, <expr><literal type="string">".rela.dyn"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>rela_sect</name><index>[]</index></name> <init>= <expr><block>{ <expr><literal type="string">".rela.plt"</literal></expr>, <expr><literal type="string">".rel.plt"</literal></expr>, <expr><literal type="string">".rela.dyn"</literal></expr>, <expr><literal type="string">".rel.dyn"</literal></expr>, <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>rel_cache</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>==</operator> <name>DT_REL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rel_sec</name> <operator>=</operator> <call><name>get_rel_sec</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel_sect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>==</operator> <name>DT_RELA</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rel_sec</name> <operator>=</operator> <call><name>get_rel_sec</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rela_sect</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel_sec</name> <operator>||</operator> <name><name>rel_sec</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nrel</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><name><name>rel_sec</name><operator>-&gt;</operator><name>size</name></name> <operator>/</operator> <operator>(</operator><name>int</name><operator>)</operator><name>tsize</name><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nrel</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>htsize</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>nrel</name></expr></argument>, <argument><expr><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rel_cache</name> <operator>=</operator> <call><name>ht_up_new_size</name> <argument_list>(<argument><expr><name>htsize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rel_cache_free</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>rel_sec</name><operator>-&gt;</operator><name>size</name></name> <operator>&amp;&amp;</operator> <name>k</name> <operator>&lt;</operator> <name>nrel</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <name>tsize</name></expr><operator>,</operator> <expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>rel_sec</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>j</name></expr></argument>, <argument><expr><name>rl</name></expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <name>tsize</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>read_ht_rel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rl</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>out</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ht_up_insert</name> <argument_list>(<argument><expr><name>rel_cache</name></expr></argument>, <argument><expr><name>REL_SYM</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>rel_cache</name></expr>;</return>

<label><name>out</name>:</label>

<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>rel_cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_dyn_entry</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dyn_entry</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>==</operator> <name>dyn_entry</name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DT_REL</name></expr>:</case>

<case>case <expr><name>DT_RELA</name></expr>:</case>

<case>case <expr><name>DT_PLTGOT</name></expr>:</case>

<case>case <expr><name>DT_JMPREL</name></expr>:</case>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr>;</return>

<case>case <expr><name>DT_RELSZ</name></expr>:</case>

<case>case <expr><name>DT_RELASZ</name></expr>:</case>

<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_got_addr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>ret</name> <init>= <expr><call><name>get_dyn_entry</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>DT_PLTGOT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_addr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".got"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_addr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".got.plt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_ppc</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nrel</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plt_section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>plt_section</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>endian</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>base</name> <init>= <expr><call><name>r_read_be32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base</name> <operator>-=</operator> <operator>(</operator><name>nrel</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>+=</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>base</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>base</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>base</name> <operator>-=</operator> <operator>(</operator><name>nrel</name> <operator>*</operator> <literal type="number">12</literal><operator>)</operator> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>+=</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>base</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_sparc</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plt_section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_addr</name> <init>= <expr><name><name>plt_section</name><operator>-&gt;</operator><name>rva</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>REL_TYPE</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_SPARC_JMP_SLOT</name></expr>:</case>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_addr</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>plt_addr</name></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown sparc reloc type %d\n"</literal></expr></argument>, <argument><expr><name>REL_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_arm</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plt_section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT32_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_addr</name> <init>= <expr><name><name>plt_section</name><operator>-&gt;</operator><name>rva</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>REL_TYPE</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ARM_JUMP_SLOT</name></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">20</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_addr</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>plt_addr</name></expr>;</return>

</block_content>}</block>

<case>case <expr><name>R_AARCH64_JUMP_SLOT</name></expr>:</case>

<return>return <expr><name>plt_addr</name> <operator>+</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">16</literal> <operator>+</operator> <literal type="number">32</literal></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported relocation type for imports %d\n"</literal></expr></argument>, <argument><expr><name>REL_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_x86</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_addr</name></decl>, <decl><type ref="prev"/><name>plt_sym_addr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>pltsec_section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".plt.sec"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>got_addr</name> <init>= <expr><call><name>get_got_addr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>got_addr</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>got_offset</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>got_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>got_offset</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>of</name> <init>= <expr><name>REL_OFFSET</name> <operator>-</operator> <name>got_addr</name> <operator>+</operator> <name>got_offset</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>REL_TYPE</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<case>case <expr><name>R_386_GLOB_DAT</name></expr>:</case>

<case>case <expr><name>R_386_JMP_SLOT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>of</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>of</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;=</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>of</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plt_sym_addr</name> <operator>=</operator> <ternary><condition><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal></expr>

?</condition><then> <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_read_le64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>plt_sym_addr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".plt.got"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_has_relro</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>R_ELF_PART_RELRO</name> <operator>||</operator> <operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plt_addr</name> <operator>=</operator> <name><name>s</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>of</name> <operator>=</operator> <name>of</name> <operator>+</operator> <name>got_addr</name> <operator>-</operator> <name>got_offset</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name>plt_addr</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">4</literal> <operator>&lt;</operator> <name><name>s</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>plt_addr</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plt_sym_addr</name> <operator>=</operator> <ternary><condition><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Addr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>==</operator> <literal type="number">4</literal></expr>

?</condition><then> <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_read_le64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plt_addr</name> <operator>+</operator> <literal type="number">6</literal> <operator>+</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>plt_sym_addr</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>of</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>plt_addr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_sym_addr</name> <operator>==</operator> <name>of</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>plt_addr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>plt_sym_addr</name></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_sym_offset</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>plt_sym_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_sym_offset</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>plt_sym_offset</name> <operator>-</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0xff</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>pltsec_section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>pltsec_section</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">16</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>plt_sym_addr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>plt_sym_addr</name> <operator>-</operator> <literal type="number">6</literal></expr>;</return>

</block_content>}</block></else></if_stmt>

<default>default:</default>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported relocation type for imports %d\n"</literal></expr></argument>, <argument><expr><name>REL_TYPE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>of</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_riscv</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".rela.plt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_addr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>r_mem_mem_aligned</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><literal type="string">"\x3c\x0f\x00"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>base</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name>RISCV_PLT_OFFSET</name></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<return>return <expr><name>plt_addr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_section</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sizeOfProcedureLinkageTable</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sizeOfPltEntry</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>plt_section</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name>sizeOfProcedureLinkageTable</name> <operator>+</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name>sizeOfPltEntry</name><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported relocs type %"</literal> <name>PFMT64u</name> <literal type="string">" for arch %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>REL_TYPE</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr_mips</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".rela.plt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>plt_addr</name> <init>= <expr><name><name>s</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>r_mem_mem_aligned</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><literal type="string">"\x3c\x0f\x00"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>base</name> <operator>-</operator> <name>buf</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name>MIPS_PLT_OFFSET</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt> 

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>plt_addr</name> <operator>+=</operator> <name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<return>return <expr><name>plt_addr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>plt_section</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sizeOfProcedureLinkageTable</name> <init>= <expr><literal type="number">32</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>sizeOfPltEntry</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>plt_section</name><operator>-&gt;</operator><name>rva</name></name> <operator>+</operator> <name>sizeOfProcedureLinkageTable</name> <operator>+</operator> <operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>k</name></name> <operator>*</operator> <name>sizeOfPltEntry</name><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported relocs type %"</literal> <name>PFMT64u</name> <literal type="string">" for arch %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name>REL_TYPE</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>get_import_addr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>nrel</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name> <operator>=</operator> <call><name>rel_cache_new</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ht_rel_t</name></name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><call><name>ht_up_find</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name></expr></argument>, <argument><expr><name>sym</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rel</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>plt_section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".plt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nrel</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name><operator>-&gt;</operator><name>count</name></name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EM_PPC</name></expr>:</case>

<case>case <expr><name>EM_PPC64</name></expr>:</case>

<return>return <expr><call><name>get_import_addr_ppc</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>, <argument><expr><name>nrel</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SPARC</name></expr>:</case>

<case>case <expr><name>EM_SPARCV9</name></expr>:</case>

<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case>

<return>return <expr><call><name>get_import_addr_sparc</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RISCV</name></expr>:</case>

<return>return <expr><call><name>get_import_addr_riscv</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARM</name></expr>:</case>

<case>case <expr><name>EM_AARCH64</name></expr>:</case>

<return>return <expr><call><name>get_import_addr_arm</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_386</name></expr>:</case>

<case>case <expr><name>EM_X86_64</name></expr>:</case>

<return>return <expr><call><name>get_import_addr_x86</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MIPS</name></expr>:</case> 

<return>return <expr><call><name>get_import_addr_mips</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>plt_section</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unsupported relocs type %"</literal> <name>PFMT64u</name> <literal type="string">" for arch %d\n"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>ut64</name><operator>)</operator> <name>REL_TYPE</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name> <name>Elf_</name></type>(<name>r_bin_elf_has_nx</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_GNU_STACK</name></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><operator>!</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_flags</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>Elf_</name></type>(<name>r_bin_elf_has_relro</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveBindNow</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveGnuRelro</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DT_BIND_NOW</name></expr>:</case>

<expr_stmt><expr><name>haveBindNow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_FLAGS</name></expr>:</case>

<for>for <control>(<init><expr><name>i</name><operator>++</operator></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>dTag</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dTag</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>dTag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DT_FLAGS_1</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name> <operator>&amp;</operator> <name>DF_1_NOW</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>haveBindNow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></switch>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_GNU_RELRO</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>haveGnuRelro</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>haveGnuRelro</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>haveBindNow</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>R_ELF_FULL_RELRO</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>R_ELF_PART_RELRO</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>R_ELF_NO_RELRO</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_baddr</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>base</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_LOAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_vaddr</name> <operator>&amp;</operator> <name>ELF_PAGE_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>tmp</name> <operator>-</operator> <operator>(</operator><name>tmp</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ELF_PAGE_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&lt;</operator> <name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0x08000000</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>base</name> <operator>==</operator> <name>UT64_MAX</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name>base</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_boffset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>tmp</name></decl>, <decl><type ref="prev"/><name>base</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_LOAD</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>&amp;</operator> <name>ELF_PAGE_MASK</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>tmp</name> <operator>-</operator> <operator>(</operator><name>tmp</name> <operator>%</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>ELF_PAGE_SIZE</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&lt;</operator> <name>base</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>base</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><ternary><condition><expr><name>base</name> <operator>==</operator> <name>UT64_MAX</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name>base</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_init_offset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_entry_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <name>entry</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>entry</name> <operator>+</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (init_offset)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x68</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_fini_offset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_entry_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <name>entry</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>entry</name> <operator>+</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (get_fini)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name> <operator>==</operator> <literal type="number">0x68</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>memmove</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isExecutable</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ET_EXEC</name></expr>:</case> <return>return <expr><name>true</name></expr>;</return>

<case>case <expr><name>ET_DYN</name></expr>:</case> <return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_entry_offset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>entry</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isExecutable</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_offset</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".init.text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>entry</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_offset</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".text"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>entry</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_offset</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".init"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>getmainsymbol</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>r_bin_elf_symbol_t</name></name> <modifier>*</modifier></type><name>symbol</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>symbol</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>symbol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>symbol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"main"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>symbol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_get_main_offset</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_entry_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <name>entry</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <operator>(</operator><name>entry</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (main)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0x18</literal><operator>+</operator><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x58</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0x2f</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x00</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>entry_vaddr</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>main_addr</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">0x30</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>main_addr</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name>entry_vaddr</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>main_addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\xf0\x00\x0b\x4f\xf0\x00\x0e\x02\xbc\x6a\x46"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0x28</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\xf0\x00\x0b\x4f\xf0\x00\x0e\x5d\xf8\x04\x1b"</literal></expr></argument>, <argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <literal type="number">0x30</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>pa</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>delta</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pa</name> <operator>&lt;</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>pa</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x00\xb0\xa0\xe3\x00\xe0\xa0\xe3"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">0x34</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x24\xc0\x9f\xe5\x00\xb0\xa0\xe3"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">0x30</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <operator>~</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x21\x00\xe0\x03\x01\x00\x11\x04"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>got_offset</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>got_offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".got"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator>

<operator>(</operator><name>got_offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_section_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".got.plt"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>gp</name> <init>= <expr><name>got_offset</name> <operator>+</operator> <literal type="number">0x7ff0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">4</literal></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>instr</name> <init>= <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>instr</name> <operator>&amp;</operator> <literal type="number">0xffff0000</literal><operator>)</operator> <operator>==</operator> <literal type="number">0x8f840000</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>short</name></type> <name>delta</name> <init>= <expr><name>instr</name> <operator>&amp;</operator> <literal type="number">0x0000ffff</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>gp</name> <operator>+</operator> <name>delta</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xe8</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"\x50\xe8\x00\x00\x00\x00\xb8\x01\x00\x00\x00\x53"</literal></expr></argument>, <argument><expr><literal type="number">12</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>SIZEOF_CALL</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>rel_addr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>entry</name> <operator>+</operator> <name>SIZEOF_CALL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>rel_addr</name></expr>;</expr_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0x00</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x48</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0x1e</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x8d</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0x11</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xe8</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name> <modifier>*</modifier></type><name>pmain</name> <init>= <expr><operator>(</operator><name>ut32</name><operator>*</operator><operator>)</operator><operator>(</operator><name>buf</name> <operator>+</operator> <literal type="number">0x30</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>vmain</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>*</operator><name>pmain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>ventry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vmain</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal> <operator>==</operator> <name>ventry</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>ut64</name><operator>)</operator><name>vmain</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0x1d</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x48</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">0x1e</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x8b</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x31\xed\x49\x89"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>maddr</name></decl>, <decl><type ref="prev"/><name>baddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>n32s</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>maddr</name> <operator>=</operator> <name>entry</name> <operator>+</operator> <literal type="number">0x24</literal> <operator>+</operator> <call><name>r_read_le32</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">0x20</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>maddr</name></expr></argument>, <argument><expr><name>n32s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (maddr) 2\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maddr</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>n32s</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>baddr</name> <operator>=</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_entry</name></name> <operator>&gt;&gt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>baddr</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_baddr</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maddr</name> <operator>+=</operator> <name>baddr</name></expr>;</expr_stmt>

<return>return <expr><name>maddr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\x49\x89\xd9"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">156</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xe8</literal></expr>)</condition> <block>{<block_content> 

<return>return <expr><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">157</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>entry</name> <operator>+</operator> <literal type="number">156</literal> <operator>+</operator> <literal type="number">5</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>buf</name><operator>+</operator><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="string">"\x48\xc7\xc7"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">29</literal> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">23</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\x68'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>buf</name><index>[<expr><literal type="number">23</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>int</name></type> <name>bo</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xf3</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x0f</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x1e</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0xfa</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bo</name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>bo</name></expr>]</index></name> <operator>==</operator> <literal type="number">0x48</literal> <operator>&amp;&amp;</operator> <name><name>buf</name><index>[<expr><name>bo</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x8d</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>bo</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st32</name></type> <name>maindelta</name> <init>= <expr><operator>(</operator><name>st32</name><operator>)</operator><call><name>r_read_le32</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>vmain</name> <init>= <expr><operator>(</operator><name>ut64</name><operator>)</operator><operator>(</operator><name>entry</name> <operator>+</operator> <name>bo</name> <operator>+</operator> <name>maindelta</name><operator>)</operator> <operator>+</operator> <literal type="number">7</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>ventry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vmain</name><operator>&gt;&gt;</operator><literal type="number">16</literal> <operator>==</operator> <name>ventry</name><operator>&gt;&gt;</operator><literal type="number">16</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name>ut64</name><operator>)</operator><name>vmain</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>m</name> <init>= <expr><call><name>getmainsymbol</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>m</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name> <name>Elf_</name></type>(<name>r_bin_elf_get_stripped</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_SYMTAB</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_intrp</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_INTERP</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sz</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_filesz</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.intrp_addr"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.intrp_size"</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sz</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>sz</name></expr></argument> &gt;</argument_list></name> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (main)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name></expr></argument>, <argument><expr><literal type="string">"elf_header.intrp"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>str</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>bool</name> <name>Elf_</name></type>(<name>r_bin_elf_is_static</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_INTERP</name> <operator>||</operator>

<name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_DYNAMIC</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_data_encoding</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ELFDATANONE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFDATA2LSB</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"2's complement, little endian"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFDATA2MSB</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"2's complement, big endian"</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default> <return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"&lt;unknown: %x&gt;"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name> <name>Elf_</name></type>(<name>r_bin_elf_has_va</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_arch</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EM_ARC</name></expr>:</case>

<case>case <expr><name>EM_ARC_A5</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"arc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_AVR</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"avr"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CRIS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"cris"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68K</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"m68k"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MIPS</name></expr>:</case>

<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case>

<case>case <expr><name>EM_MIPS_X</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"mips"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MCST_ELBRUS</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"elbrus"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TRICORE</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"tricore"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RCE</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"mcore"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARM</name></expr>:</case>

<case>case <expr><name>EM_AARCH64</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_HEXAGON</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"hexagon"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_BLACKFIN</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"blackfin"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SPARC</name></expr>:</case>

<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case>

<case>case <expr><name>EM_SPARCV9</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"sparc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PPC</name></expr>:</case>

<case>case <expr><name>EM_PPC64</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ppc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PARISC</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"hppa"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PROPELLER</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"propeller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MICROBLAZE</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"microblaze.gnu"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RISCV</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"riscv"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VAX</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"vax"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_XTENSA</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"xtensa"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_LANAI</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"lanai"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VIDEOCORE3</name></expr>:</case>

<case>case <expr><name>EM_VIDEOCORE4</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"vc4"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MSP430</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"msp430"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SH</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"sh"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_V850</name></expr>:</case>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"v850"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_IA_64</name></expr>:</case>

<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"ia64"</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"x86"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_machine_name</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EM_NONE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"No machine"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_M32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"AT&amp;T WE 32100"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SPARC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"SUN SPARC"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_386</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel 80386"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68K</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola m68k family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_88K</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola m88k family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_860</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel 80860"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MIPS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"MIPS R3000"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_S370</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"IBM System/370"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MIPS_RS3_LE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"MIPS R3000 little-endian"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PARISC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"HPPA"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VPP500</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Fujitsu VPP500"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SPARC32PLUS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Sun's \"v8plus\""</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_960</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel 80960"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PPC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"PowerPC"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PPC64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"PowerPC 64-bit"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_S390</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"IBM S390"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_V800</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NEC V800 series"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FR20</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Fujitsu FR20"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RH32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"TRW RH-32"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RCE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola RCE"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARM</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ARM"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_BLACKFIN</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Analog Devices Blackfin"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FAKE_ALPHA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Digital Alpha"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SH</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Hitachi SH"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SPARCV9</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"SPARC v9 64-bit"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TRICORE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Siemens Tricore"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Argonaut RISC Core"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_H8_300</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Hitachi H8/300"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_H8_300H</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Hitachi H8/300H"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_H8S</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Hitachi H8S"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_H8_500</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Hitachi H8/500"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_IA_64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel Merced"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MIPS_X</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Stanford MIPS-X"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_COLDFIRE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola Coldfire"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68HC12</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola M68HC12"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MMA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Fujitsu MMA Multimedia Accelerator"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PCP</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Siemens PCP"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_NCPU</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Sony nCPU embeeded RISC"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_NDR1</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Denso NDR1 microprocessor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_STARCORE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola Start*Core processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ME16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Toyota ME16 processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ST100</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroelectronic ST100 processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TINYJ</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Advanced Logic Corp. Tinyj emb.fam"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_X86_64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"AMD x86-64 architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_LANAI</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"32bit LANAI architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PDSP</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Sony DSP Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PDP10</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Digital Equipment Corp. PDP-10"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PDP11</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Digital Equipment Corp. PDP-11"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FX66</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Siemens FX66 microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ST9PLUS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroelectronics ST9+ 8/16 mc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ST7</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STmicroelectronics ST7 8 bit mc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68HC16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola MC68HC16 microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68HC11</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola MC68HC11 microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68HC08</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola MC68HC08 microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_68HC05</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Motorola MC68HC05 microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SVX</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Silicon Graphics SVx"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ST19</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroelectronics ST19 8 bit mc"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VAX</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Digital VAX"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CRIS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Axis Communications 32-bit embedded processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_JAVELIN</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Infineon Technologies 32-bit embedded processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FIREPATH</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Element 14 64-bit DSP Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ZSP</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"LSI Logic 16-bit DSP Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MMIX</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Donald Knuth's educational 64-bit processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_HUANY</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Harvard University machine-independent object files"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PRISM</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"SiTera Prism"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_AVR</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Atmel AVR 8-bit microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FR30</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Fujitsu FR30"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_D10V</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Mitsubishi D10V"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_D30V</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Mitsubishi D30V"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_V850</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NEC v850"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_M32R</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Mitsubishi M32R"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MN10300</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Matsushita MN10300"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MN10200</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Matsushita MN10200"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PJ</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"picoJava"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_OPENRISC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"OpenRISC 32-bit embedded processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARC_A5</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ARC Cores Tangent-A5"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_XTENSA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Tensilica Xtensa Architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_AARCH64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ARM aarch64"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_PROPELLER</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Parallax Propeller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MICROBLAZE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Xilinx MicroBlaze"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RISCV</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"RISC V"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VIDEOCORE3</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"VideoCore III"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VIDEOCORE4</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"VideoCore IV"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_LATTICEMICO32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"RISC processor for Lattice FPGA architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SE_C17</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Seiko Epson C17 family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TI_C6000</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"The Texas Instruments TMS320C6000 DSP family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TI_C2000</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"The Texas Instruments TMS320C2000 DSP family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TI_C5500</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"The Texas Instruments TMS320C55x DSP family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TI_ARP32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Texas Instruments Application Specific RISC Processor, 32bit fetch"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TI_PRU</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Texas Instruments Programmable Realtime Unit"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MMDSP_PLUS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroelectronics 64bit VLIW Data Signal Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CYPRESS_M8C</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Cypress M8C microprocessor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_R32C</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Renesas R32C series microprocessors"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TRIMEDIA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NXP Semiconductors TriMedia architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_QDSP6</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"QUALCOMM DSP6 Processor"</literal></expr></argument>)</argument_list></call></expr>;</return> 

<case>case <expr><name>EM_8051</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel 8051 and variants"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_STXP7X</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroelectronics STxP7x family of configurable and extensible RISC processors"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_NDS32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Andes Technology compact code size embedded RISC processor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ECOG1</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Cyan Technology eCOG1X family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MAXQ30</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Dallas Semiconductor MAXQ30 Core Micro-controllers"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_XIMO16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"New Japan Radio (NJR) 16-bit DSP Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MANIK</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"M2000 Reconfigurable RISC Microprocessor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CRAYNV2</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Cray Inc. NV2 vector architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RX</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Renesas RX family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_METAG</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Imagination Technologies META processor architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MCST_ELBRUS</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"MCST Elbrus general purpose hardware architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ECOG16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Cyan Technology eCOG16 family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CR16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"National Semiconductor CompactRISC CR16 16-bit microprocessor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ETPU</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Freescale Extended Time Processing Unit"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_SLE9X</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Infineon Technologies SLE9X core"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_L10M</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel L10M"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_K10M</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Intel K10M"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_AVR32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Atmel Corporation 32-bit microprocessor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_STM8</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"STMicroeletronics STM8 8-bit microcontroller"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TILE64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Tilera TILE64 multicore architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TILEPRO</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Tilera TILEPro multicore architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CUDA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NVIDIA CUDA architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_TILEGX</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Tilera TILE-Gx multicore architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CLOUDSHIELD</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"CloudShield architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_COREA_1ST</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KIPO-KAIST Core-A 1st generation processor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_COREA_2ND</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KIPO-KAIST Core-A 2nd generation processor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_ARC_COMPACT2</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Synopsys ARCompact V2"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_OPEN8</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Open8 8-bit RISC soft processor core"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_RL78</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Renesas RL78 family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VIDEOCORE5</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Broadcom VideoCore V processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_78KOR</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Renesas 78KOR family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_BA1</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Beyond BA1 CPU architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_BA2</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Beyond BA2 CPU architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_XCORE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"XMOS xCORE processor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MCHP_PIC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Microchip 8-bit PIC(r) family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_INTEL205</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Reserved by Intel"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_INTEL206</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Reserved by Intel"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_INTEL207</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Reserved by Intel"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_INTEL208</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Reserved by Intel"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_INTEL209</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Reserved by Intel"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_KM32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KM211 KM32 32-bit processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_KMX32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KM211 KMX32 32-bit processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_KMX16</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KM211 KMX16 16-bit processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_KMX8</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KM211 KMX8 8-bit processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_KVARC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"KM211 KVARC processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CDP</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Paneve CDP architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_COGE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Cognitive Smart Memory Processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_COOL</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Bluechip Systems CoolEngine"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_NORC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Nanoradio Optimized RISC"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_CSR_KALIMBA</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"CSR Kalimba architecture family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_Z80</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Zilog Z80"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_VISIUM</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Controls and Data Services VISIUMcore processor"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_FT32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"FTDI Chip FT32 high performance 32-bit RISC architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_MOXIE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"Moxie processor family"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>EM_AMDGPU</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"AMD GPU architecture"</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default> <return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"&lt;unknown&gt;: 0x%x"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_file_type</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>e_type</name> <init>= <expr><operator>(</operator><name>ut32</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name></expr></init></decl>;</decl_stmt> 

<switch>switch <condition>(<expr><name>e_type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ET_NONE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NONE (None)"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ET_REL</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"REL (Relocatable file)"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ET_EXEC</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"EXEC (Executable file)"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ET_DYN</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"DYN (Shared object file)"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ET_CORE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"CORE (Core file)"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_type</name> <operator>&gt;=</operator> <name>ET_LOPROC</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>e_type</name> <operator>&lt;=</operator> <name>ET_HIPROC</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"Processor Specific: %x"</literal></expr></argument>, <argument><expr><name>e_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>e_type</name> <operator>&gt;=</operator> <name>ET_LOOS</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>e_type</name> <operator>&lt;=</operator> <name>ET_HIOS</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"OS Specific: %x"</literal></expr></argument>, <argument><expr><name>e_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"&lt;unknown&gt;: %x"</literal></expr></argument>, <argument><expr><name>e_type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_elf_class</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ELFCLASSNONE</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"none"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFCLASS32</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ELF32"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFCLASS64</name></expr>:</case> <return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"ELF64"</literal></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default> <return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"&lt;unknown: %x&gt;"</literal></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>int</name> <name>Elf_</name></type>(<name>r_bin_elf_get_bits</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ARC_A5</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">16</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_MIPS</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut32</name></type> <name>mipsType</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_flags</name></name> <operator>&amp;</operator> <name>EF_MIPS_ARCH</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>==</operator> <name>ET_EXEC</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>haveInterp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>==</operator> <name>PT_INTERP</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>haveInterp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>haveInterp</name> <operator>&amp;&amp;</operator> <name>mipsType</name> <operator>==</operator> <name>EF_MIPS_ARCH_3</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">64</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>mipsType</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EF_MIPS_ARCH_1</name></expr>:</case>

<case>case <expr><name>EF_MIPS_ARCH_2</name></expr>:</case>

<case>case <expr><name>EF_MIPS_ARCH_3</name></expr>:</case>

<case>case <expr><name>EF_MIPS_ARCH_4</name></expr>:</case>

<case>case <expr><name>EF_MIPS_ARCH_5</name></expr>:</case>

<case>case <expr><name>EF_MIPS_ARCH_32</name></expr>:</case>

<return>return <expr><literal type="number">32</literal></expr>;</return>

<case>case <expr><name>EF_MIPS_ARCH_64</name></expr>:</case>

<return>return <expr><literal type="number">64</literal></expr>;</return>

<case>case <expr><name>EF_MIPS_ARCH_32R2</name></expr>:</case>

<return>return <expr><literal type="number">32</literal></expr>;</return>

<case>case <expr><name>EF_MIPS_ARCH_64R2</name></expr>:</case>

<return>return <expr><literal type="number">64</literal></expr>;</return>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><literal type="number">32</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ARM</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_type</name></name> <operator>!=</operator> <name>ET_EXEC</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>r_bin_elf_symbol_t</name></name> <modifier>*</modifier></type><name>symbol</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>symbol</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>symbol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>paddr</name> <init>= <expr><name><name>symbol</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>paddr</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">16</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>entry</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_entry_offset</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">16</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ELFCLASS32</name></expr>:</case> <return>return <expr><literal type="number">32</literal></expr>;</return>

<case>case <expr><name>ELFCLASS64</name></expr>:</case> <return>return <expr><literal type="number">64</literal></expr>;</return>

<case>case <expr><name>ELFCLASSNONE</name></expr>:</case>

<default>default:</default> <return>return <expr><literal type="number">32</literal></expr>;</return> 

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>noodle</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>tmp</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">64</literal></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_mem_mem</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>int</name></type> <name>needle</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>len</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">4096</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>r_mem_mem</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>,

<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>s</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_osabi_name</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>num</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>section_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>ELFOSABI_LINUX</name></expr>:</case> <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"linux"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFOSABI_SOLARIS</name></expr>:</case> <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"solaris"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFOSABI_FREEBSD</name></expr>:</case> <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"freebsd"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>ELFOSABI_HPUX</name></expr>:</case> <return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">"hpux"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_NOTE</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>section_name</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".note.openbsd.ident"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"openbsd"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".note.minix.ident"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"minix"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".note.netbsd.ident"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"netbsd"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><literal type="string">".note.android.ident"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"android"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>needle</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">"freebsd"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"freebsd"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>noodle</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">"BEOS:APP_VERSION"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"beos"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>needle</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">"GNU"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"linux"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"linux"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut8</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_grab_regstate</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>num</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_type</name> <operator>!=</operator> <name>PT_NOTE</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_bits</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>elf_nhdr_size</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>bits</name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Nhdr</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>elf_nhdr</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>elf_nhdr_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>regs_found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><name>regs_found</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>n_descsz</name></decl>, <decl><type ref="prev"/><name>n_namesz</name></decl>, <decl><type ref="prev"/><name>n_type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>elf_nhdr</name></expr></argument>, <argument><expr><name>elf_nhdr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>elf_nhdr_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read NOTES hdr from CORE file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_nhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n_descsz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_namesz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_namesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_type</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n_descsz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_namesz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_namesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_type</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_type</name> <operator>==</operator> <name>NT_PRSTATUS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regs_found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_nhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>elf_nhdr_size</name> <operator>+</operator> <name>n_descsz</name> <operator>+</operator> <name>n_namesz</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<decl_stmt><decl><type><name>int</name></type> <name>regdelta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>regsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EM_AARCH64</name></expr>:</case>

<expr_stmt><expr><name>regsize</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>AARCH64</name></expr>]</index></name><operator>.</operator><name>regsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>regdelta</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>AARCH64</name></expr>]</index></name><operator>.</operator><name>regdelta</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EM_ARM</name></expr>:</case>

<expr_stmt><expr><name>regsize</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>ARM</name></expr>]</index></name><operator>.</operator><name>regsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>regdelta</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>ARM</name></expr>]</index></name><operator>.</operator><name>regdelta</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EM_386</name></expr>:</case>

<expr_stmt><expr><name>regsize</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>X86</name></expr>]</index></name><operator>.</operator><name>regsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>regdelta</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>X86</name></expr>]</index></name><operator>.</operator><name>regdelta</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>EM_X86_64</name></expr>:</case>

<expr_stmt><expr><name>regsize</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>X86_64</name></expr>]</index></name><operator>.</operator><name>regsize</name></expr>;</expr_stmt>

<expr_stmt><expr><name>regdelta</name> <operator>=</operator> <name><name>reginf</name><index>[<expr><name>X86_64</name></expr>]</index></name><operator>.</operator><name>regdelta</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>regsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>+</operator> <name>offset</name> <operator>+</operator> <name>regdelta</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>regsize</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>regsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read register state from CORE file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>regsize</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find NOTE section\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>int</name> <name>Elf_</name></type>(<name>r_bin_elf_is_big_endian</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>==</operator> <name>ELFDATA2MSB</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_rpath</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name><operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>==</operator> <name>DT_RPATH</name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>==</operator> <name>DT_RUNPATH</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"malloc (rpath)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>sectionIsInvalid</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>sect</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name><name>sect</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>sect</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>get_relocs_num</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>size</name></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUMENTRIES_ROUNDUP</name><parameter_list>(<parameter><type><name>sectionsize</name></type></parameter>, <parameter><type><name>entrysize</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((sectionsize)+(entrysize)-1)/(entrysize))</cpp:value></cpp:define>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <ternary><condition><expr><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>==</operator> <name>DT_REL</name></expr> ?</condition><then> <expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>sectionIsInvalid</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".rela."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">".rela."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>NUMENTRIES_ROUNDUP</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".rel."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">".rel."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>+=</operator> <call><name>NUMENTRIES_ROUNDUP</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>ret</name></expr>;</return>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUMENTRIES_ROUNDUP</name></cpp:undef>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>read_reloc</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>RBinElfReloc</name> <modifier>*</modifier></type><name>r</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_rela</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>offset</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name> <argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>offset</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof> <operator>&lt;</operator> <name>offset</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>!=</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>is_rela</name> <operator>==</operator> <name>DT_RELA</name></expr>)</condition> <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Rela</argument>)</argument_list></macro> <expr_stmt><expr><name>rela</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_addend</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rela</name><operator>.</operator><name>r_addend</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>=</operator> <name>is_rela</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>rela</name><operator>.</operator><name>r_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>ELF_R_TYPE</name> <argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>sym</name></name> <operator>=</operator> <call><name>ELF_R_SYM</name> <argument_list>(<argument><expr><name><name>rela</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>addend</name></name> <operator>=</operator> <name><name>rela</name><operator>.</operator><name>r_addend</name></name></expr>;</expr_stmt>

<return>return <expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rela</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<macro><name>Elf_</name><argument_list>(<argument>Rel</argument>)</argument_list></macro> <expr_stmt><expr><name>rel</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_offset</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>rel</name><operator>.</operator><name>r_info</name></name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>is_rela</name></name> <operator>=</operator> <name>is_rela</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>rel</name><operator>.</operator><name>r_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>ELF_R_TYPE</name> <argument_list>(<argument><expr><name><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>sym</name></name> <operator>=</operator> <call><name>ELF_R_SYM</name> <argument_list>(<argument><expr><name><name>rel</name><operator>.</operator><name>r_info</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>r</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><name>RBinElfReloc</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_relocs</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>, <decl><type ref="prev"/><name>rel</name></decl>, <decl><type ref="prev"/><name>rela</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfReloc</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>reloc_num</name> <init>= <expr><call><name>get_relocs_num</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reloc_num</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>reloc_num</name></name> <operator>=</operator> <name>reloc_num</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>RBinElfReloc</name><operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name>size_t</name><operator>)</operator><name>reloc_num</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfReloc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>rel</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>&amp;&amp;</operator> <name>rel</name> <operator>&lt;</operator> <name>reloc_num</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>is_rela</name> <init>= <expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".rela."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">".rela."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_rel</name> <init>= <expr><literal type="number">0</literal> <operator>==</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">".rel."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">".rel."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_rela</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_rel</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</condition> <incr><expr><name>j</name> <operator>+=</operator> <name>res</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>&gt;=</operator> <name>reloc_num</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Internal error: ELF relocation buffer too small,"</literal>

<literal type="string">"please file a bug report."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rela</name> <operator>=</operator> <ternary><condition><expr><name>is_rela</name></expr>?</condition><then> <expr><name>DT_RELA</name></expr> </then><else>: <expr><name>DT_REL</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>rela</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>is_rela</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>read_reloc</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name></expr></argument>, <argument><expr><name>rela</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>+</operator> <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>j</name> <operator>+</operator> <name>res</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"malformed file, relocation entry #%u is partially beyond the end of section %u.\n"</literal></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>+</operator> <name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>rva</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>rel</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rel</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>reloc_num</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RBinElfLib</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_libs</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfLib</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>||</operator> <operator>*</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name><operator>+</operator><literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>d_tag</name> <operator>==</operator> <name>DT_NEEDED</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfLib</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>k</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfLib</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"realloc (libs)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>RBinElfLib</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>k</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfLib</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>r</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"realloc (libs)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>r</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_section_from_phdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>ret</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>i</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>sz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>sz</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><call><name>R_ARRAY_SIZE</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><operator>*</operator><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>i</name> <operator>=</operator> <operator>*</operator><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSection</name> <modifier>*</modifier></type><name>get_sections_from_phdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num_sections</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>reldyn</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>relava</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pltgotva</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>relva</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>reldynsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>relasz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>pltgotsz</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>DT_REL</name></expr>:</case>

<expr_stmt><expr><name>reldyn</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_sections</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_RELA</name></expr>:</case>

<expr_stmt><expr><name>relva</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_sections</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_RELSZ</name></expr>:</case>

<expr_stmt><expr><name>reldynsz</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_RELASZ</name></expr>:</case>

<expr_stmt><expr><name>relasz</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_PLTGOT</name></expr>:</case>

<expr_stmt><expr><name>pltgotva</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_sections</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_PLTRELSZ</name></expr>:</case>

<expr_stmt><expr><name>pltgotsz</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>DT_JMPREL</name></expr>:</case>

<expr_stmt><expr><name>relava</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>num_sections</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> <break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>num_sections</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RBinElfSection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_section_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">".rel.dyn"</literal></expr></argument>, <argument><expr><name>reldyn</name></expr></argument>, <argument><expr><name>reldynsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_section_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">".rela.plt"</literal></expr></argument>, <argument><expr><name>relava</name></expr></argument>, <argument><expr><name>pltgotsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_section_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">".rel.plt"</literal></expr></argument>, <argument><expr><name>relva</name></expr></argument>, <argument><expr><name>relasz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_section_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><literal type="string">".got.plt"</literal></expr></argument>, <argument><expr><name>pltgotva</name></expr></argument>, <argument><expr><name>pltgotsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RBinElfSection</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_sections</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>unknown_s</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>invalid_s</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nidx</name></decl>, <decl><type ref="prev"/><name>unknown_c</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>invalid_c</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>get_sections_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSection</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>align</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_addralign</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>flags</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_flags</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>link</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_link</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>info</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_info</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>rva</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_addr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>SHNAME</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>SHSIZE</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nidx</name> <operator>=</operator> <name>SHNAME</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nidx</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_section</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name> <operator>||</operator> <name>nidx</name></expr></argument> &gt;</argument_list></name> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>invalid_s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>invalid_s</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"invalid%d"</literal></expr></argument>, <argument><expr><name>invalid_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>invalid_s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>invalid_c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>SHNAME</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>SHNAME</name> <operator>&lt;</operator> <name>SHSIZE</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name>SHNAME</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>unknown_s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>unknown_s</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"unknown%d"</literal></expr></argument>, <argument><expr><name>unknown_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>unknown_s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>unknown_c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_special_arm_symbol</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>)</argument_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'$'</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<return>return <expr><operator>(</operator><name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator> <operator>&amp;&amp;</operator>

<call><name>ELF_ST_TYPE</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STT_NOTYPE</name> <operator>&amp;&amp;</operator>

<call><name>ELF_ST_BIND</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STB_LOCAL</name> <operator>&amp;&amp;</operator>

<call><name>ELF_ST_VISIBILITY</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STV_DEFAULT</name></expr>;</return>

<default>default:</default>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_special_symbol</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>, <argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>name</name></expr></argument>)</argument_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>EM_ARM</name></expr>:</case>

<case>case <expr><name>EM_AARCH64</name></expr>:</case>

<return>return <expr><call><name>is_special_arm_symbol</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bind2str</name><argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>)</argument_list> <block>{<block_content>

<switch>switch <condition>(<expr><call><name>ELF_ST_BIND</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>STB_LOCAL</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_LOCAL_STR</name></expr>;</return>

<case>case <expr><name>STB_GLOBAL</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_GLOBAL_STR</name></expr>;</return>

<case>case <expr><name>STB_WEAK</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_WEAK_STR</name></expr>;</return>

<case>case <expr><name>STB_NUM</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_NUM_STR</name></expr>;</return>

<case>case <expr><name>STB_LOOS</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_LOOS_STR</name></expr>;</return>

<case>case <expr><name>STB_HIOS</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_HIOS_STR</name></expr>;</return>

<case>case <expr><name>STB_LOPROC</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_LOPROC_STR</name></expr>;</return>

<case>case <expr><name>STB_HIPROC</name></expr>:</case> <return>return <expr><name>R_BIN_BIND_HIPROC_STR</name></expr>;</return>

<default>default:</default> <return>return <expr><name>R_BIN_BIND_UNKNOWN_STR</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type2str</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr>struct <name>r_bin_elf_symbol_t</name> <operator>*</operator><name>ret</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>)</argument_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>bin</name> <operator>&amp;&amp;</operator> <name>ret</name> <operator>&amp;&amp;</operator> <call><name>is_special_symbol</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>, <argument><expr><name><name>ret</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>R_BIN_TYPE_SPECIAL_SYM_STR</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><call><name>ELF_ST_TYPE</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<case>case <expr><name>STT_NOTYPE</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_NOTYPE_STR</name></expr>;</return>

<case>case <expr><name>STT_OBJECT</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_OBJECT_STR</name></expr>;</return>

<case>case <expr><name>STT_FUNC</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_FUNC_STR</name></expr>;</return>

<case>case <expr><name>STT_SECTION</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_SECTION_STR</name></expr>;</return>

<case>case <expr><name>STT_FILE</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_FILE_STR</name></expr>;</return>

<case>case <expr><name>STT_COMMON</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_COMMON_STR</name></expr>;</return>

<case>case <expr><name>STT_TLS</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_TLS_STR</name></expr>;</return>

<case>case <expr><name>STT_NUM</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_NUM_STR</name></expr>;</return>

<case>case <expr><name>STT_LOOS</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_LOOS_STR</name></expr>;</return>

<case>case <expr><name>STT_HIOS</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_HIOS_STR</name></expr>;</return>

<case>case <expr><name>STT_LOPROC</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_LOPROC_STR</name></expr>;</return>

<case>case <expr><name>STT_HIPROC</name></expr>:</case> <return>return <expr><name>R_BIN_TYPE_HIPROC_STR</name></expr>;</return>

<default>default:</default> <return>return <expr><name>R_BIN_TYPE_UNKNOWN_STR</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>fill_symbol_bind_and_type</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr>struct <name>r_bin_elf_symbol_t</name> <operator>*</operator><name>ret</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>)</argument_list> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>bind</name></name> <operator>=</operator> <call><name>bind2str</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>type2str</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>RBinElfSymbol</name><modifier>*</modifier></type> <name>get_symbols_from_phdr</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Addr</argument>)</argument_list></macro> <expr_stmt><expr><name>addr_sym_table</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>s</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>tsize</name></decl>, <decl><type ref="prev"/><name>nsym</name></decl>, <decl><type ref="prev"/><name>ret_ctr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>toffset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>tmp_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>sym_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_entries</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>d_tag</name></expr>)</condition> <block>{<block_content>

<case>case <expr><operator>(</operator><name>DT_SYMTAB</name><operator>)</operator></expr>:</case>

<expr_stmt><expr><name>addr_sym_table</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><operator>(</operator><name>DT_SYMENT</name><operator>)</operator></expr>:</case>

<expr_stmt><expr><name>sym_size</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name><name>d_un</name><operator>.</operator><name>d_val</name></name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr_sym_table</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sym_size</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>addr_sym_table</name><operator>)</operator> <operator>/</operator> <name>sym_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>nsym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name> <argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_sym_table</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator> <name>addr_sym_table</name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nsym</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>capacity1</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>capacity2</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call><operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>capacity1</name></expr></argument>, <argument><expr><name>sym_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>RBinElfSymbol</name> <operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>capacity2</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>r_bin_elf_symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sym</name> <operator>||</operator> <operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>ret_ctr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nsym</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>capacity1</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call><operator>*</operator> <name>temp_sym</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call><operator>*</operator><operator>)</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><operator>(</operator><name>capacity1</name> <operator>*</operator> <name>GROWTH_FACTOR</name><operator>)</operator> <operator>*</operator> <name>sym_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_sym</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>temp_sym</name></expr>;</expr_stmt>

<expr_stmt><expr><name>capacity1</name> <operator>*=</operator> <name>GROWTH_FACTOR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_ctr</name> <operator>&gt;=</operator> <name>capacity2</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>temp_ret</name> <init>= <expr><call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><name>capacity2</name> <operator>*</operator> <name>GROWTH_FACTOR</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr>struct <name>r_bin_elf_symbol_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_ret</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>temp_ret</name></expr>;</expr_stmt>

<expr_stmt><expr><name>capacity2</name> <operator>*=</operator> <name>GROWTH_FACTOR</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>addr_sym_table</name> <operator>+</operator> <name>i</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name> <argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name> <argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_info</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_other</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_value</name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_size</name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_value</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_size</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_info</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_other</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>bool</name></type> <name>is_sht_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_vaddr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name> <operator>&amp;&amp;</operator> <name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>==</operator> <name>SHT_NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>toffset</name> <operator>=</operator> <call><name>get_import_addr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block>{<block_content>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_ALL_SYMBOLS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator> <name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_sht_null</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>==</operator> <name>SHT_NULL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>bind2str</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_BIN_BIND_UNKNOWN_STR</name></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>type2str</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>R_BIN_TYPE_UNKNOWN_STR</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>toffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_offset</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp_offset</name> <operator>=</operator> <name>toffset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_vaddr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp_offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>+</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>tmp_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rest</name> <init>= <expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>st_name</name> <init>= <expr><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>st_name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>st_name</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>st_name</name> <operator>&gt;=</operator> <name>maxsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><call><name>__strnlen</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name> <operator>+</operator> <name>st_name</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>strtab</name><index>[<expr><name>st_name</name></expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>ordinal</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>in_shdr</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_symbol_bind_and_type</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>is_sht_null</name> <operator>=</operator> <name>is_sht_null</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>is_vaddr</name> <operator>=</operator> <name>is_vaddr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_ctr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<label><name>done</name>:</label>

<block>{<block_content>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <ternary><condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><name>i</name></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>temp_sym</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><call><name>realloc</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>, <argument><expr><operator>(</operator><name>nsym</name> <operator>*</operator> <name>GROWTH_FACTOR</name><operator>)</operator> <operator>*</operator> <name>sym_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_sym</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sym</name> <operator>=</operator> <name>temp_sym</name></expr>;</expr_stmt>

</block_content>}</block>

<block>{<block_content>

<expr_stmt><expr><name>ret_ctr</name> <operator>=</operator> <ternary><condition><expr><name>ret_ctr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><name>ret_ctr</name></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><operator>(</operator><name>RBinElfSymbol</name> <operator>*</operator><operator>)</operator><call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>ret_ctr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <name>ret_ctr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_ctr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <operator>(</operator><name>RBinImport</name> <operator>*</operator> <operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>ret_ctr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinImport</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_ALL_SYMBOLS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name> <operator>&amp;&amp;</operator> <name>ret_ctr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name> <operator>=</operator> <name>ret_ctr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret_ctr</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name> <operator>=</operator> <operator>(</operator><name>RBinSymbol</name> <operator>*</operator> <operator>*</operator><operator>)</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>ret_ctr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinSymbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_phdr_symbols</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name> <operator>=</operator> <call><name>get_symbols_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>R_BIN_ELF_ALL_SYMBOLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_phdr_imports</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name> <operator>=</operator> <call><name>get_symbols_from_phdr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>R_BIN_ELF_IMPORT_SYMBOLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier><name>Elf_</name></type>(<name>get_phdr_symbols</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>type</name> <operator>!=</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name><operator>)</operator></expr>

?</condition><then> <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_phdr_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_phdr_imports</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <name>Elf_</name></type>(<name>fix_symbols</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nsym</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier><modifier>*</modifier></type><name>sym</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><operator>*</operator><name>sym</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>phdr_symbols</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>get_phdr_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>phd_offset_map</name> <init>= <expr><call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUP</name> <modifier>*</modifier></type><name>phd_ordinal_map</name> <init>= <expr><call><name>ht_up_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>phdr_symbols</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>d</name> <init>= <expr><name>ret</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>d</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ht_up_insert</name> <argument_list>(<argument><expr><name>phd_offset_map</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_up_insert</name> <argument_list>(<argument><expr><name>phd_ordinal_map</name></expr></argument>, <argument><expr><name><name>d</name><operator>-&gt;</operator><name>ordinal</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>phdr_symbols</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ht_up_find</name> <argument_list>(<argument><expr><name>phd_offset_map</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>ht_up_find</name> <argument_list>(<argument><expr><name>phd_ordinal_map</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>ordinal</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>in_shdr</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>p</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>d</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"$"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name><name>d</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>phdr_symbols</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>in_shdr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>RBinElfSymbol</name><operator>*</operator><operator>)</operator><call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>nsym</name> <operator>+</operator> <name>count</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>nsym</name><operator>--</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>phdr_symbols</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>in_shdr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><operator>++</operator><name>nsym</name></expr>]</index></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>sym</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>nsym</name></expr>;</expr_stmt>

<label><name>done</name>:</label>

<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>phd_offset_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name>phd_ordinal_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_section_local_sym</name><argument_list>(<argument><expr><name>ELFOBJ</name> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name></expr></argument>)</argument_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><operator>-&gt;</operator><name>st_name</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ELF_ST_TYPE</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STT_SECTION</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ELF_ST_BIND</name> <argument_list>(<argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_info</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STB_LOCAL</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_shidx_valid</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>Elf_</name><argument_list>(<argument>Word</argument>)</argument_list></macro> <expr_stmt><expr><name>sh_name</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>sym</name><operator>-&gt;</operator><name>st_shndx</name></name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr>;</expr_stmt>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name> <operator>&amp;&amp;</operator> <name>sh_name</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>sh_name</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shstrtab_size</name></name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>setsymord</name><parameter_list>(<parameter><decl><type><name>ELFOBJ</name><modifier>*</modifier></type> <name>eobj</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>ord</name></decl></parameter>, <parameter><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>eobj</name><operator>-&gt;</operator><name>symbols_by_ord</name></name> <operator>||</operator> <name>ord</name> <operator>&gt;=</operator> <name><name>eobj</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_bin_symbol_free</name> <argument_list>(<argument><expr><name><name>eobj</name><operator>-&gt;</operator><name>symbols_by_ord</name><index>[<expr><name>ord</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>eobj</name><operator>-&gt;</operator><name>symbols_by_ord</name><index>[<expr><name>ord</name></expr>]</index></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>void</name></type> <name>_set_arm_thumb_bits</name><argument_list>(<argument><expr>struct <call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>, <argument><expr><name>RBinSymbol</name> <operator>*</operator><operator>*</operator><name>sym</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bin_bits</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_bits</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><operator>*</operator><name>sym</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>&gt;=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>ptr</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'a'</literal></expr> :</case> 

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>vaddr</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<break>break;</break>

<default>default:</default>

<goto>goto <name>arm_symbol</name>;</goto>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<label><name>arm_symbol</name>:</label>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <name>bin_bits</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>bin_bits</name> <operator>!=</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>vaddr</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bits</name></name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier><name>Elf_</name></type><argument_list>(<argument><expr><name>_r_bin_elf_convert_symbol</name></expr></argument>)</argument_list><argument_list>(<argument><expr>struct <call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_obj_t</name></expr></argument>)</argument_list></call> <operator>*</operator><name>bin</name></expr></argument>,

<argument><expr>struct <name>r_bin_elf_symbol_t</name> <operator>*</operator><name>symbol</name></expr></argument>,

<argument><expr><specifier>const</specifier> <name>char</name> <operator>*</operator><name>namefmt</name></expr></argument>)</argument_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>paddr</name></decl>, <decl><type ref="prev"/><name>vaddr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>symbol</name><operator>-&gt;</operator><name>is_vaddr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>paddr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>vaddr</name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>paddr</name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vaddr</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_p2v_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>paddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinSymbol</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <ternary><condition><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><name>namefmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>symbol</name><operator>-&gt;</operator><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>forwarder</name></name> <operator>=</operator> <literal type="string">"NONE"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>bind</name></name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>bind</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>type</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>is_imported</name></name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>is_imported</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>paddr</name></name> <operator>=</operator> <name>paddr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>vaddr</name></name> <operator>=</operator> <name>vaddr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ptr</name><operator>-&gt;</operator><name>ordinal</name></name> <operator>=</operator> <name><name>symbol</name><operator>-&gt;</operator><name>ordinal</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_machine</name></name> <operator>==</operator> <name>EM_ARM</name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>ptr</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>_set_arm_thumb_bits</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ptr</name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><specifier>static</specifier> <name>ut32</name></type> <name>hashRBinElfSymbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>obj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier></type><name>symbol</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>RBinElfSymbol</name> <operator>*</operator><operator>)</operator><name>obj</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hash</name> <init>= <expr><call><name>sdb_hash</name> <argument_list>(<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>hash</name> <operator>^=</operator> <call><name>sdb_hash</name> <argument_list>(<argument><expr><name><name>symbol</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>^=</operator> <operator>(</operator><name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>hash</name> <operator>^=</operator> <operator>(</operator><name><name>symbol</name><operator>-&gt;</operator><name>offset</name></name> <operator>&amp;</operator> <literal type="number">0xffffffff</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>hash</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_RBinElfSymbol</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RBinElfSymbol</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name><name>b</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>result</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RBinElfSymbol</name><modifier>*</modifier> <name>Elf_</name></type>(<name>_r_bin_elf_get_symbols_imports</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>shdr_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tsize</name></decl>, <decl><type ref="prev"/><name>nsym</name></decl>, <decl><type ref="prev"/><name>ret_ctr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>r</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>toffset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>import_ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSymbol</name> <modifier>*</modifier></type><name>import_sym_ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>ret_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>prev_ret_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>import_ret_ctr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>strtab_section</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><name>sym</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>s</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr>]</index></name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>strtab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtPP</name> <modifier>*</modifier></type><name>symbol_map</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtPPOptions</name></type> <name>symbol_map_options</name> <init>= <expr><block>{

<expr><operator>.</operator><name>cmp</name> <operator>=</operator> <operator>(</operator><name>HtPPListComparator</name><operator>)</operator><name>cmp_RBinElfSymbol</name></expr>,

<expr><operator>.</operator><name>hashfn</name> <operator>=</operator> <name>hashRBinElfSymbol</name></expr>,

<expr><operator>.</operator><name>dupkey</name> <operator>=</operator> <name>NULL</name></expr>,

<expr><operator>.</operator><name>calcsizeK</name> <operator>=</operator> <name>NULL</name></expr>,

<expr><operator>.</operator><name>calcsizeV</name> <operator>=</operator> <name>NULL</name></expr>,

<expr><operator>.</operator><name>freefn</name> <operator>=</operator> <name>NULL</name></expr>,

<expr><operator>.</operator><name>elem_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>HtPPKv</name></expr></argument>)</argument_list></sizeof></expr>,

}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name> <operator>||</operator> <operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>||</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name> <operator>==</operator> <literal type="number">0xffff</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>get_phdr_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>shdr_size</name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>shdr_size</name> <operator>+</operator> <literal type="number">8</literal> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>R_BIN_ELF_SYMTAB_SYMBOLS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_SYMTAB</name><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>(</operator><name>type</name> <operator>&amp;</operator> <name>R_BIN_ELF_DYNSYM_SYMBOLS</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_type</name> <operator>==</operator> <name>SHT_DYNSYM</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_link</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_link</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Shdr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator> <operator>&gt;=</operator> <name>shdr_size</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>strtab_section</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_link</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name>ST32_MAX</name> <operator>||</operator> <name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name><operator>+</operator><literal type="number">8</literal> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"size (syms strtab)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>strtab</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>strtab</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">8</literal> <operator>+</operator> <name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"malloc (syms strtab)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>strtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>||</operator>

<name><name>strtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name> <operator>+</operator> <name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>strtab_section</name><operator>-&gt;</operator><name>sh_offset</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>strtab</name></expr></argument>, <argument><expr><name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (syms strtab)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>newsize</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>newsize</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>newsize</name></expr></argument> &gt;</argument_list></name> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"invalid shdr %d size\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nsym</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>sh_begin</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>sh_end</name> <init>= <expr><name>sh_begin</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_size</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sh_begin</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>sh_end</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>st64</name></type> <name>newshsize</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <name>sh_begin</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>newshsize</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>sym</name> <operator>=</operator> <operator>(</operator><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call> <operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><name>nsym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"calloc (syms)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>UT32_MUL</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>size</name></expr></argument>, <argument><expr><name>nsym</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>size</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>size</name></expr></argument> &gt;</argument_list></name> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>nsym</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>sh_offset</name> <operator>+</operator> <name>j</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Sym</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"read (sym)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>R_BIN_ELF64</name></expr></cpp:if>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_info</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_other</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_value</name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_size</name> <operator>=</operator> <call><name>READ64</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_value</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_size</name> <operator>=</operator> <call><name>READ32</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_info</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_other</name> <operator>=</operator> <call><name>READ8</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>sym</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>=</operator> <call><name>READ16</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></for>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>realloc</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>ret_size</name> <operator>+</operator> <name>nsym</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d symbols\n"</literal></expr></argument>, <argument><expr><name>nsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>ret</name> <operator>+</operator> <name>ret_size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nsym</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev_ret_size</name> <operator>=</operator> <name>ret_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_size</name> <operator>+=</operator> <name>nsym</name></expr>;</expr_stmt>

<expr_stmt><expr><name>symbol_map</name> <operator>=</operator> <call><name>ht_pp_new_opt</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>symbol_map_options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>prev_ret_size</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ht_pp_insert</name> <argument_list>(<argument><expr><name>symbol_map</name></expr></argument>, <argument><expr><name>ret</name> <operator>+</operator> <name>k</name></expr></argument>, <argument><expr><name>ret</name> <operator>+</operator> <name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>nsym</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>is_sht_null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_vaddr</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_imported</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>toffset</name> <operator>=</operator> <call><name>get_import_addr</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>is_imported</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>==</operator> <name>STN_UNDEF</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>tsize</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>toffset</name> <operator>=</operator> <operator>(</operator><name>ut64</name><operator>)</operator><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_value</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_sht_null</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>==</operator> <name>SHT_NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_shndx</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shnum</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_value</name> <operator>+</operator> <name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_shndx</name></expr>]</index></name><operator>.</operator><name>sh_offset</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_v2p_new</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>toffset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name>toffset</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_vaddr</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>tsize</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_name</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"index out of strtab range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>st_name</name> <init>= <expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_name</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxsize</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><call><name>r_buf_size</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>strtab_section</name><operator>-&gt;</operator><name>sh_size</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_section_local_sym</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shname</name> <init>= <expr><operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name><index>[<expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name><index>[<expr><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>st_shndx</name></expr>]</index></name><operator>.</operator><name>sh_name</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_ncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>shname</name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>st_name</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>st_name</name> <operator>&gt;=</operator> <name>maxsize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_str_ncpy</name><argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>strtab</name><index>[<expr><name>st_name</name></expr>]</index></name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <call><name>type2str</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>ht_pp_find</name> <argument_list>(<argument><expr><name>symbol_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>ret</name> <operator>+</operator> <name>ret_ctr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>ordinal</name> <operator>=</operator> <name>k</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name><name>name</name><index>[<expr><name>ELF_STRING_LENGTH</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fill_symbol_bind_and_type</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sym</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>is_sht_null</name> <operator>=</operator> <name>is_sht_null</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>is_vaddr</name> <operator>=</operator> <name>is_vaddr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>is_imported</name> <operator>=</operator> <name>is_imported</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ret_ctr</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name> <operator>&amp;&amp;</operator> <name>is_imported</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>import_ret_ctr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>symbol_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>symbol_map</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>get_phdr_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>ret_ctr</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinElfSymbol</name> <modifier>*</modifier></type><name>aux</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>fix_symbols</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>ret_ctr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nsym</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aux</name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>aux</name><operator>-&gt;</operator><name>last</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>aux</name><operator>-&gt;</operator><name>ordinal</name></name> <operator>&gt;</operator> <name>max</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>aux</name><operator>-&gt;</operator><name>ordinal</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aux</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name>nsym</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>R_BIN_ELF_IMPORT_SYMBOLS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name> <operator>=</operator> <name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name> <operator>=</operator> <operator>(</operator><name>RBinImport</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinImport</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name> <operator>=</operator> <name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name> <operator>=</operator> <operator>(</operator><name>RBinSymbol</name><operator>*</operator><operator>*</operator><operator>)</operator><call><name>calloc</name> <argument_list>(<argument><expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>nsym</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinSymbol</name><operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>import_ret</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><name>import_ret_ctr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>import_ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>bprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d symbols\n"</literal></expr></argument>, <argument><expr><name>nsym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>import_ret_ctr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name><name>ret</name><index>[<expr><operator>++</operator><name>i</name></expr>]</index></name><operator>.</operator><name>last</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>import_sym_ptr</name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>_r_bin_elf_convert_symbol</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>setsymord</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name><name>import_sym_ptr</name><operator>-&gt;</operator><name>ordinal</name></name></expr></argument>, <argument><expr><name>import_sym_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>is_imported</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>import_ret</name><index>[<expr><name>import_ret_ctr</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfSymbol</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>import_ret_ctr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>import_ret</name><index>[<expr><name>import_ret_ctr</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>import_ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sym</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>strtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_pp_free</name> <argument_list>(<argument><expr><name>symbol_map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RBinElfSymbol</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_symbols</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_symbols</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>g_symbols</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>_r_bin_elf_get_symbols_imports</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>R_BIN_ELF_ALL_SYMBOLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>g_symbols</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RBinElfSymbol</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_imports</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>g_imports</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>g_imports</name></name> <operator>=</operator> <call><call><name>Elf_</name><argument_list>(<argument><expr><name>_r_bin_elf_get_symbols_imports</name></expr></argument>)</argument_list></call> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>R_BIN_ELF_IMPORT_SYMBOLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>g_imports</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>RBinElfField</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_get_fields</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfField</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>ret</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name> <operator>+</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>RBinElfField</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"ehdr"</literal></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"shoff"</literal></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_shoff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"phoff"</literal></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phoff</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name>ELF_STRING_LENGTH</name></expr></argument>, <argument><expr><literal type="string">"phdr_%i"</literal></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>p_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>ret</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>last</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name> <name>Elf_</name></type>(<name>r_bin_elf_free</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name><modifier>*</modifier></type> <name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bin</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shdr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>strtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dyn_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>shstrtab</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>dynstr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>imports_by_ord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name></expr>)</condition> <block>{<block_content>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord_size</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_bin_symbol_free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>symbols_by_ord</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_symbols</name></name> <operator>!=</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_symbols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bin</name><operator>-&gt;</operator><name>g_imports</name></name> <operator>!=</operator> <name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr_imports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_sections</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_symbols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>g_imports</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_up_free</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>rel_cache</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>ELFOBJ</name><modifier>*</modifier> <name>Elf_</name></type>(<name>r_bin_elf_new_buf</name>)<parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>ELFOBJ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bin</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>kv</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>r_buf_size</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <name>verbose</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <call><name>r_buf_ref</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>elf_init</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<function_decl><type><name>Elf_</name></type>(<name>r_bin_elf_free</name>) <parameter_list>(<parameter><decl><type><name>bin</name></type></decl></parameter>)</parameter_list>;</function_decl>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>bin</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>is_in_pphdr</name><argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>p</name></expr></argument>, <argument><expr><name>ut64</name> <name>addr</name></expr></argument>)</argument_list> <block>{<block_content>

<return>return <expr><name>addr</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>is_in_vphdr</name><argument_list>(<argument><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>p</name></expr></argument>, <argument><expr><name>ut64</name> <name>addr</name></expr></argument>)</argument_list> <block>{<block_content>

<return>return <expr><name>addr</name> <operator>&gt;=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>+</operator> <name><name>p</name><operator>-&gt;</operator><name>p_filesz</name></name></expr>;</return>

</block_content>}</block></decl></decl_stmt>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_p2v</name>) <parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>paddr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name> <operator>+</operator> <name>paddr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>paddr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_LOAD</name> <operator>&amp;&amp;</operator> <call><name>is_in_pphdr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>paddr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>+</operator> <name>paddr</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>paddr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_v2p</name>) <parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>vaddr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>vaddr</name> <operator>-</operator> <name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>vaddr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_LOAD</name> <operator>&amp;&amp;</operator> <call><name>is_in_vphdr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>vaddr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>+</operator> <name>vaddr</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>vaddr</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_p2v_new</name>) <parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>paddr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name> <operator>+</operator> <name>paddr</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_LOAD</name> <operator>&amp;&amp;</operator> <call><name>is_in_pphdr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>paddr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name> <operator>+</operator> <name>paddr</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>ut64</name> <name>Elf_</name></type>(<name>r_bin_elf_v2p_new</name>) <parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>vaddr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_bin_etrel</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>vaddr</name> <operator>-</operator> <name><name>bin</name><operator>-&gt;</operator><name>baddr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_LOAD</name> <operator>&amp;&amp;</operator> <call><name>is_in_vphdr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>vaddr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name> <operator>+</operator> <name>vaddr</name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>UT64_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>get_nt_file_maps</name> <parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>core_maps</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut16</name></type> <name>ph_num</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut16</name></type> <name>ph</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ph</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ph</name> <operator>&lt;</operator> <name>ph_num</name></expr>;</condition> <incr><expr><name>ph</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>ph</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_NOTE</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>bits</name> <init>= <expr><call><call><name>Elf_</name><argument_list>(<argument><expr><name>r_bin_elf_get_bits</name></expr></argument>)</argument_list></call><argument_list>(<argument><expr><name>bin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>elf_nhdr_size</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>bits</name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf64_Nhdr</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>Elf32_Nhdr</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size_of</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>bits</name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr> ?</condition><then> <expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr> </then><else>: <expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>elf_nhdr</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>elf_nhdr_size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>n_descsz</name></decl>, <decl><type ref="prev"/><name>n_namesz</name></decl>, <decl><type ref="prev"/><name>n_type</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>,

<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>ph</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>+</operator> <name>offset</name></expr></argument>,

<argument><expr><name>elf_nhdr</name></expr></argument>, <argument><expr><name>elf_nhdr_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>elf_nhdr_size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot read more NOTES header from CORE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_nhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n_descsz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_namesz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_namesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Elf64_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_type</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n_descsz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_descsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_namesz</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_namesz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n_type</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Elf32_Nhdr</name> <operator>*</operator><operator>)</operator><name>elf_nhdr</name><operator>)</operator><operator>-&gt;</operator><name>n_type</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_type</name> <operator>==</operator> <name>NT_FILE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>elf_nhdr_size</name> <operator>+</operator> <name>n_namesz</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_nhdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>elf_nhdr_size</name> <operator>+</operator> <name>n_descsz</name> <operator>+</operator> <name>n_namesz</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<decl_stmt><decl><type><name>ut64</name></type> <name>i</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>ph</name></expr>]</index></name><operator>.</operator><name>p_offset</name> <operator>+</operator> <name>offset</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>n_maps</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n_maps</name> <operator>=</operator> <call><name>BREAD64</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BREAD64</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>n_maps</name> <operator>=</operator> <call><name>BREAD32</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>BREAD32</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>jump</name> <init>= <expr><operator>(</operator><operator>(</operator><name>size_of</name> <operator>*</operator> <literal type="number">3</literal><operator>)</operator> <operator>*</operator> <name>n_maps</name><operator>)</operator> <operator>+</operator> <name>i</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len_str</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>n_maps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">512</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bits</name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>BREAD64</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>BREAD32</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ffbreak\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>jump</name> <operator>+</operator> <name>len_str</name></expr></argument>,

<argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>str</name><index>[<expr><sizeof>sizeof<argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof> <operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinMap</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core_maps</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>len_str</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>n_maps</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <operator>(</operator><name>size_of</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>

<label><name>fail</name>:</label>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_bin_elf_map_free</name> <parameter_list>(<parameter><decl><type><name>RBinMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>RList</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_get_maps</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut16</name></type> <name>ph</name></decl>, <decl><type ref="prev"/><name>ph_num</name> <init>= <expr><name><name>bin</name><operator>-&gt;</operator><name>ehdr</name><operator>.</operator><name>e_phnum</name></name></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>maps</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>r_bin_elf_map_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>ph</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>ph</name> <operator>&lt;</operator> <name>ph_num</name></expr>;</condition> <incr><expr><name>ph</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>Elf_</name><argument_list>(<argument><expr><name>Phdr</name></expr></argument>)</argument_list></call> <operator>*</operator><name>p</name> <operator>=</operator> <operator>&amp;</operator><name><name>bin</name><operator>-&gt;</operator><name>phdr</name><index>[<expr><name>ph</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>p_type</name></name> <operator>==</operator> <name>PT_LOAD</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RBinMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>map</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_vaddr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_memsz</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>perms</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_flags</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>p_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>maps</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>maps</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_nt_file_maps</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><name>maps</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Could not retrieve the names of all maps from NT_FILE\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>maps</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier><name>Elf_</name></type>(<name>r_bin_elf_compiler</name>)<parameter_list>(<parameter><decl><type><name>ELFOBJ</name> <modifier>*</modifier></type><name>bin</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RBinElfSection</name> <modifier>*</modifier></type><name>section</name> <init>= <expr><call><name>get_section_by_name</name> <argument_list>(<argument><expr><name>bin</name></expr></argument>, <argument><expr><literal type="string">".comment"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>section</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>section</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>sz</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>section</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><literal type="number">128</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sz</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>sz</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_buf_read_at</name> <argument_list>(<argument><expr><name><name>bin</name><operator>-&gt;</operator><name>b</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><name>buf</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buflen</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nullbyte</name> <init>= <expr><name>buf</name> <operator>+</operator> <name>buflen</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>!=</operator> <name>sz</name> <operator>&amp;&amp;</operator> <name><name>nullbyte</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>buflen</name> <operator>&lt;</operator> <name>sz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>nullbyte</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>sz</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function></block_content></block></decl></decl_stmt></block_content></block></decl></decl_stmt>

</unit>
