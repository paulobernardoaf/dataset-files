<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\anal\var.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cons.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_list.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DB</name></cpp:macro> <cpp:value>a-&gt;sdb_fcns</cpp:value></cpp:define>

<struct>struct <name>VarType</name> <block>{

<decl_stmt><decl><type><name>bool</name></type> <name>isarg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>regname</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SDB_VARTYPE_FMT</name></cpp:macro> <cpp:value>"bzdzz"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXISTS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (key, sizeof (key) - 1, x, ##__VA_ARGS__), sdb_exists (DB, key)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETKEY</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (key, sizeof (key) - 1, x, ##__VA_ARGS__);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETKEY2</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (key2, sizeof (key) - 1, x, ##__VA_ARGS__);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SETVAL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>snprintf (val, sizeof (val) - 1, x, ##__VA_ARGS__);</cpp:value></cpp:define>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_var_display</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"type:%s doesn't exist\n"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>usePxr</name> <init>= <expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"int"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_VAR_KIND_REG</name></expr>:</case>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>usePxr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pxr $w @r:%s\n"</literal></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pf r (%s)\n"</literal></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"register not found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_BPV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>usePxr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pxr $w @%s+0x%x\n"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pf %s @%s+0x%x\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>usePxr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pxr $w @%s-0x%x\n"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pf %s @%s-0x%x\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>, <argument><expr><operator>-</operator><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_SPV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>usePxr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pxr $w @%s+0x%x\n"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"pf %s @ %s+0x%x\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>__int_type_from_size</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>size</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case> <return>return <expr><literal type="string">"int8_t"</literal></expr>;</return>

<case>case <expr><literal type="number">2</literal></expr>:</case> <return>return <expr><literal type="string">"int16_t"</literal></expr>;</return>

<case>case <expr><literal type="number">4</literal></expr>:</case> <return>return <expr><literal type="string">"int32_t"</literal></expr>;</return>

<case>case <expr><literal type="number">8</literal></expr>:</case> <return>return <expr><literal type="string">"int64_t"</literal></expr>;</return>

<default>default:</default> <return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_var_rebase</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>diff</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>a</name> <operator>&amp;&amp;</operator> <name>fcn</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>var_list</name> <init>= <expr><call><name>r_anal_var_all_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>var_list</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>var_list</argument>, <argument>it</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_access</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.access"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>access</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>var_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_anal_var_delete</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>regname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>!=</operator> <name><name>reg</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>var_access</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.access"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>var_access</name></expr></argument>, <argument><expr><name>access</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>var_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_var_add</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isarg</name></decl></parameter>, <parameter><decl><type><name>R_NONNULL</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>a</name> <operator>&amp;&amp;</operator> <name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kind</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>R_ANAL_VAR_KIND_BPV</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>__int_type_from_size</name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>__int_type_from_size</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>bits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"int32_t"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_VAR_KIND_BPV</name></expr>:</case> 

<case>case <expr><name>R_ANAL_VAR_KIND_SPV</name></expr>:</case> 

<case>case <expr><name>R_ANAL_VAR_KIND_REG</name></expr>:</case> 

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid var kind '%c'\n"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register wasn't found at the given delta\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d,%s,%d,%s,%s"</literal></expr></argument>, <argument><expr><name>isarg</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>reg</name></expr>?</condition><then> <expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sign</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="string">"_"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%d.%s%d"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shortvar</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.%s%d"</literal></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>fcn_key</name></expr></argument>, <argument><expr><name>shortvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_key</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sign</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_val</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%c,%d"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>name_key</name></expr></argument>, <argument><expr><name>name_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_global</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%c.%s,%d,%s"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_global</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_retype</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,

<parameter><decl><type><name>bool</name></type> <name>isarg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>R_ANAL_VAR_KIND_BPV</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"int"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>delta</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_VAR_KIND_REG</name></expr>:</case>

<case>case <expr><name>R_ANAL_VAR_KIND_BPV</name></expr>:</case>

<case>case <expr><name>R_ANAL_VAR_KIND_SPV</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid var kind '%c'\n"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>reg</name> <operator>=</operator> <call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register wasn't found at the given delta\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d,%s,%d,%s,%s"</literal></expr></argument>, <argument><expr><name>isarg</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>reg</name></expr> ?</condition><then> <expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sign</name> <init>= <expr><ternary><condition><expr><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr></then><else>: <expr><literal type="string">"_"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%d.%s%d"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shortvar</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.%s%d"</literal></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_val</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%c,%d"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>fcn_key</name></expr></argument>, <argument><expr><name>shortvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_key</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>name_key</name></expr></argument>, <argument><expr><name>name_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_kind</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_kind</name> <operator>&amp;&amp;</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type_kind</name></expr></argument>, <argument><expr><literal type="string">"struct"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>field_n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_key</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>type_kind</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>field_n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>field</name> <operator>=</operator> <call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_key</name></expr></argument>, <argument><expr><name>field_n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>field_n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field_key</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>type_key</name></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field_type</name> <init>= <expr><call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>field_offset</name> <init>= <expr><call><name>sdb_array_get_num</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>field_offset</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_var_delete</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name> <operator>+</operator> <name>field_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_global</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_global</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_delete_all</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>kind</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>v</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_delete</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_delete</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>r_anal_var_get</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>av</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sign</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="string">"_"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcn_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>var_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%d.%s%d"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shortvar</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d.%s%d"</literal></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_remove</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>fcn_key</name></expr></argument>, <argument><expr><name>shortvar</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>name_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sign</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_global</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%c.%s,%d,%s"</literal></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_remove</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_global</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_access_clear</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_var_delete_byname</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>var</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_var_delete</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalVar</name> <modifier>*</modifier></type><name>r_anal_var_get_byname</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_value</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>name_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_value</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name_value</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>comma</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>comma</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comma</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_anal_var_get</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>*</operator><name>name_value</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAnalVar</name> <modifier>*</modifier></type><name>r_anal_var_get</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>VarType</name></name></type> <name>vt</name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sign</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="string">"_"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varkey</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%d.%s%d"</literal></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vardef</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>varkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vardef</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sign</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_fmt_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_fmt_tobin</name> <argument_list>(<argument><expr><name>vardef</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>av</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_fmt_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>scope</name></name> <operator>=</operator> <name>scope</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>isarg</name></name> <operator>=</operator> <name><name>vt</name><operator>.</operator><name>isarg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name><name>vt</name><operator>.</operator><name>name</name></name></expr> ?</condition><then> <expr><name><name>vt</name><operator>.</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"unkown_var"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>vt</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name><name>vt</name><operator>.</operator><name>type</name></name></expr> ?</condition><then> <expr><name><name>vt</name><operator>.</operator><name>type</name></name></expr> </then><else>: <expr><literal type="string">"unkown_type"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>regname</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><ternary><condition><expr><name><name>vt</name><operator>.</operator><name>regname</name></name></expr> ?</condition><then> <expr><name><name>vt</name><operator>.</operator><name>regname</name></name></expr> </then><else>: <expr><literal type="string">"unkown_regname"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_fmt_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>av</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_var_free</name><parameter_list>(<parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>av</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>av</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>regname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>ut64</name></type> <name>r_anal_var_addr</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>ret</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>R_ANAL_VAR_KIND_BPV</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>v1</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>R_ANAL_VAR_KIND_SPV</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>regname</name> <operator>=</operator> <call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call> <operator>+</operator> <name><name>v1</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ANAL_VAR_SDB_KIND</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ANAL_VAR_SDB_TYPE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ANAL_VAR_SDB_SIZE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>R_ANAL_VAR_SDB_NAME</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define> 

<function><type><name>R_API</name> <name>bool</name></type> <name>r_anal_var_check_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>isdigit</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strcspn</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"., =/"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_rename</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>new_name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>verbose</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_var_check_name</name> <argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>v1</name> <init>= <expr><call><name>r_anal_var_get_byname</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>v1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_free</name> <argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>verbose</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"variable or arg with name `%s` already exist\n"</literal></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>scope</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sign</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_val</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_val</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name_val</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>comma</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comma</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_owned</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>name_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <operator>-</operator><name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="string">"_"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%d.%s%d"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_array_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SDB_NAME</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>stored_name</name> <init>= <expr><call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SDB_NAME</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stored_name</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>old_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>old_name</name> <operator>=</operator> <name>stored_name</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>stored_name</name></expr></argument>, <argument><expr><name>old_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_array_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SDB_NAME</name></expr></argument>, <argument><expr><name>new_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>r_anal_var_link</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inst_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"inst.0x%"</literal> <name>PFMT64x</name> <literal type="string">".lvar"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal> <name>PFMT64x</name> <literal type="string">",%c,0x%x,0x%x"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>scope</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>inst_key</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_access</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>var_addr</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xs_type</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>xs_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_global</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>xs_type_str</name> <init>= <expr><ternary><condition><expr><name>xs_type</name></expr>?</condition><then> <expr><literal type="string">"writes"</literal></expr></then><else>: <expr><literal type="string">"reads"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_local</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.access"</literal></expr></argument>,

<argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_local</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name><literal type="string">".%d"</literal></expr></argument>, <argument><expr><name>xs_addr</name> <operator>-</operator> <name>var_addr</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>var_local</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.%s"</literal></expr></argument>,

<argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>xs_type_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>inst_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"inst.0x%"</literal><name>PFMT64x</name> <literal type="string">".vars"</literal></expr></argument>, <argument><expr><name>xs_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>var_def</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name> <literal type="string">",%c,0x%x,0x%x"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>,

<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>inst_key</name></expr></argument>, <argument><expr><name>var_def</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>sdb_array_add_num</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_local</name></expr></argument>, <argument><expr><name>xs_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_add</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"a,"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>var_global</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>xs_type_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>sdb_array_add_num</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>var_global</name></expr></argument>, <argument><expr><name>xs_addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_var_access_clear</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>var_addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>key2</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>scope</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.%s"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="string">"writes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETKEY2</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.%s"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="string">"reads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%d.access"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><name>scope</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><literal type="string">"writes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETKEY2</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>var_addr</name></expr></argument>, <argument><expr><literal type="string">"reads"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_fcn_var_del_bydelta</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>fna</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>scope</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>delta</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>idx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>key</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>val</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name> <literal type="string">".%c"</literal></expr></argument>, <argument><expr><name>fna</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>sdb_itoa</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>sdb_array_indexof</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_array_delete</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>SETKEY</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%08"</literal><name>PFMT64x</name> <literal type="string">".%c.%d"</literal></expr></argument>, <argument><expr><name>fna</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_unset</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_anal_var_count</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name><name>count</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>count</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>count</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>count</name><index>[<expr><name>type</name></expr>]</index></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>var_add_structure_fields_to_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>av</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base_name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>a</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_kind</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_kind</name> <operator>&amp;&amp;</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type_kind</name></expr></argument>, <argument><expr><literal type="string">"struct"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field_name</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>new_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>field_n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_key</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>type_kind</name></expr></argument>, <argument><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>field_n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>field_name</name> <operator>=</operator> <call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_key</name></expr></argument>, <argument><expr><name>field_n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>field_n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field_key</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>type_key</name></expr></argument>, <argument><expr><name>field_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field_type</name> <init>= <expr><call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>field_offset</name> <init>= <expr><call><name>sdb_array_get_num</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_key</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>field_count</name> <init>= <expr><call><name>sdb_array_get_num</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_key</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>field_size</name> <init>= <expr><call><name>r_type_get_bitsize</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>field_type</name></expr></argument>)</argument_list></call> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>field_count</name></expr>?</condition><then> <expr><name>field_count</name></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>new_name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>( <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>field_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>field_offset</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>new_name</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>fav</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fav</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>new_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>delta</name> <operator>+</operator> <name>field_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name><name>av</name><operator>-&gt;</operator><name>kind</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>new_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>regname</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>regname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>field_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fav</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>field_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>fav</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>field_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type_key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_varname</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pfx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>delta</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s_%xh"</literal></expr></argument>, <argument><expr><name>pfx</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>v_delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%d.%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name_value</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>sdb_fcns</name></name></expr></argument>, <argument><expr><name>name_key</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name_value</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name_value</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>comma</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>comma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v_delta</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comma</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v_delta</name> <operator>==</operator> <name>delta</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>varname</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s_%xh_%d"</literal></expr></argument>, <argument><expr><name>pfx</name></expr></argument>, <argument><expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>varname</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_regname</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>value</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ri</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>ri</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">32</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_reg_32_to_64</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>value</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>name</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>extract_arg</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sign</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>type</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>st64</name></type> <name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>op_esil</name> <init>= <expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op_esil</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esil_buf</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>op_esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>esil_buf</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr_end</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>esil_buf</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">",%s,%s"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>sign</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr_end</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esil_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr_end</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>ptr_end</name></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>(</operator><name><name>addr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'0'</literal> <operator>||</operator> <name><name>addr</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'x'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>addr</name> <operator>&gt;=</operator> <name>esil_buf</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>addr</name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>dst</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_BP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rn</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>reg</name></expr> ?</condition><then> <expr><name><name>op</name><operator>-&gt;</operator><name>dst</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rn</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>bp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><name>sp</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>rn</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>verbose</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Analysis didn't fill op-&gt;stackop for instruction that alters stack at 0x%"</literal><name>PFMT64x</name><literal type="string">".\n"</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>addr</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_PUSH</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_POP</name>

<operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RET</name> <operator>&amp;&amp;</operator> <call><name>r_str_isnumber</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>st64</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>==</operator> <name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>imm</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>==</operator> <name>R_ANAL_STACK_SET</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>==</operator> <name>R_ANAL_STACK_GET</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>%</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>st64</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rw</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>direction</name></name> <operator>==</operator> <name>R_ANAL_OP_DIR_WRITE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>sign</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isarg</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>bp_frame</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>ptr</name> <operator>&gt;=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>type</name> <operator>!=</operator> <literal type="char">'s'</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pfx</name> <init>= <expr><ternary><condition><expr><name>isarg</name></expr> ?</condition><then> <expr><name>ARGPREFIX</name></expr> </then><else>: <expr><name>VARPREFIX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>bp_off</name> <init>= <expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bp_off</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>get_varname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>, <argument><expr><name>bp_off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp_off</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><name>isarg</name></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bp_off</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>rw</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>get_varname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>VARPREFIX</name></expr></argument>, <argument><expr><operator>-</operator><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><name>ptr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><name>ptr</name></expr></argument>, <argument><expr><operator>-</operator><name>ptr</name></expr></argument>, <argument><expr><name>rw</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esil_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_reg_in_src</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_used_like_arg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opsreg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opdreg</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STR_EQUAL</name><parameter_list>(<parameter><type><name>s1</name></type></parameter>, <parameter><type><name>s2</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(s1 &amp;&amp; s2 &amp;&amp; !strcmp (s1, s2))</cpp:value></cpp:define>

<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>dst</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalValue</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_POP</name></expr>:</case>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>R_ANAL_OP_TYPE_MOV</name></expr>:</case>

<return>return <expr><operator>(</operator><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>dst</name><operator>-&gt;</operator><name>memref</name></name><operator>)</operator></expr>;</return>

<case>case <expr><name>R_ANAL_OP_TYPE_CMOV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>R_ANAL_OP_TYPE_LEA</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_LOAD</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><name>R_ANAL_OP_TYPE_XOR</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opsreg</name></expr></argument>, <argument><expr><name>opdreg</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>src</name><operator>-&gt;</operator><name>memref</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>dst</name><operator>-&gt;</operator><name>memref</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_ADD</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_SUB</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><operator>(</operator><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_reg_in_src</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>opsreg0</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>get_regname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>opsreg1</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>get_regname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>opsreg2</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>get_regname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>opsreg0</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>opsreg1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>opsreg2</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_extract_rarg</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>reg_set</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>count</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>op</name> <operator>&amp;&amp;</operator> <name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opsreg</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>get_regname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>src</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opdreg</name> <init>= <expr><ternary><condition><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name></expr> ?</condition><then> <expr><call><name>get_regname</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>dst</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_LOG_DEBUG</name> <argument_list>(<argument><expr><literal type="string">"No calling convention for function '%s' to extract register arguments\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr><call><name>r_anal_cc_max_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>max_count</name> <operator>||</operator> <operator>(</operator><operator>*</operator><name>count</name> <operator>&gt;=</operator> <name>max_count</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name>tmp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>argc</name> <operator>=</operator> <call><name>r_type_func_args_count</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max_count</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>r_anal_cc_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>is_used_like_an_arg</name> <init>= <expr><call><name>is_used_like_arg</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>opsreg</name></expr></argument>, <argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>is_used_like_an_arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ri</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>i</name> <operator>&lt;</operator> <name>argc</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>fname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_type_func_args_type</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vname</name> <operator>=</operator> <call><name>r_type_func_args_name</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"arg%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>vname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><name>type</name></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_link</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_META_TYPE_VARTYPE</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>regname</name></expr></argument>, <argument><expr><name>opdreg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>selfreg</name> <init>= <expr><call><name>r_anal_cc_self</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>selfreg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>is_used_like_an_arg</name> <init>= <expr><call><name>is_used_like_arg</name> <argument_list>(<argument><expr><name>selfreg</name></expr></argument>, <argument><expr><name>opsreg</name></expr></argument>, <argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name>is_used_like_an_arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"self"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>selfreg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ri</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_link</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_META_TYPE_VARTYPE</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_reg_in_src</name> <argument_list>(<argument><expr><name>selfreg</name></expr></argument>, <argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>selfreg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>errorreg</name> <init>= <expr><call><name>r_anal_cc_error</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>errorreg</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>STR_EQUAL</name> <argument_list>(<argument><expr><name>opdreg</name></expr></argument>, <argument><expr><name>errorreg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>ri</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>errorreg</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ri</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>ri</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_add</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_var_link</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_var_access</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>R_META_TYPE_VARTYPE</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>vname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><operator>*</operator><name>count</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>reg_set</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_extract_vars</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>anal</name> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>BP</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>SP</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>extract_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>BP</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>extract_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>BP</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>extract_arg</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>SP</name></expr></argument>, <argument><expr><literal type="string">"+"</literal></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_SPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>var_generate_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>dynamicVars</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>r_anal_var_free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>kind</name> <operator>=</operator> <name>R_ANAL_VAR_KIND_BPV</name></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>varlist</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"fcn.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>varlist</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>varlist</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>next</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>varlist</name></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>word</name> <init>= <expr><call><name>sdb_anext</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_nlen</name> <argument_list>(<argument><expr><name>word</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>vardef</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>DB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(

<argument><expr><literal type="string">"var.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%s"</literal></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>word</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>word</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>word</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vardef</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>VarType</name></name></type> <name>vt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_fmt_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_fmt_tobin</name> <argument_list>(<argument><expr><name>vardef</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalVar</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>av</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>varlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>vt</name><operator>.</operator><name>name</name></name> <operator>||</operator> <operator>!</operator><name><name>vt</name><operator>.</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning null var in fcn.0x%"</literal><name>PFMT64x</name> <literal type="string">".%c.%s\n"</literal></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>kind</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>vt</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>isarg</name></name> <operator>=</operator> <name><name>vt</name><operator>.</operator><name>isarg</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>regname</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>vt</name><operator>.</operator><name>regname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>vt</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>vt</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>av</name><operator>-&gt;</operator><name>isarg</name></name> <operator>&amp;&amp;</operator> <name>kind</name> <operator>==</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>vt</name><operator>.</operator><name>regname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>arg_max</name> <init>= <expr><ternary><condition><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr> ?</condition><then> <expr><call><name>r_anal_cc_max_arg</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>arg_max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reg_arg</name> <init>= <expr><call><name>r_anal_cc_arg</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg_arg</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>reg_arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>!=</operator> <name><name>reg</name><operator>-&gt;</operator><name>index</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>reg</name><operator>-&gt;</operator><name>index</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>argnum</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>argnum</name></name> <operator>=</operator> <name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dynamicVars</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>var_add_structure_fields_to_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>av</name></expr></argument>, <argument><expr><name><name>vt</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_fmt_free</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>vt</name></expr></argument>, <argument><expr><name>SDB_VARTYPE_FMT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find var definition for '%s'\n"</literal></expr></argument>, <argument><expr><name>word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>next</name></expr>)</condition>;</do>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>varlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name> <modifier>*</modifier></type><name>r_anal_var_all_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_ARG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>reg_vars</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>bpv_vars</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>spv_vars</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_SPV</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>reg_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>bpv_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_join</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>spv_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>reg_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>bpv_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>spv_vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name> <modifier>*</modifier></type><name>r_anal_var_list</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>var_generate_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name> <modifier>*</modifier></type><name>r_anal_var_list_dynamic</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>var_generate_list</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>var_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&amp;&amp;</operator> <name>b</name><operator>)</operator></expr>?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>delta</name></name></expr></then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>regvar_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RAnalVar</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list><block>{<block_content>

<return>return <expr><ternary><condition><expr><operator>(</operator><name>a</name> <operator>&amp;&amp;</operator> <name>b</name><operator>)</operator></expr>?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>argnum</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>argnum</name></name></expr></then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_var_list_show</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>kind</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name> <operator>&amp;&amp;</operator> <name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>var_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>kind</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>kind</name> <operator>==</operator> <name>R_ANAL_VAR_KIND_REG</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"afv%c %s %s %s @ 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"afv%c %d %s %s @ 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>kind</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_VAR_KIND_BPV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument> ,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"kind"</literal></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><operator>(</operator><name>st64</name><operator>)</operator><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument> ,<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"kind"</literal></expr></argument>, <argument><expr><literal type="string">"var"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><operator>(</operator><name>st64</name><operator>)</operator><operator>-</operator><call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_REG</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"kind"</literal></expr></argument>, <argument><expr><literal type="string">"reg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_SPV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"kind"</literal></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"kind"</literal></expr></argument>, <argument><expr><literal type="string">"var"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ref"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"base"</literal></expr></argument>, <argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><operator>(</operator><name>st64</name><operator>)</operator><operator>(</operator><operator>-</operator><call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_VAR_KIND_BPV</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"arg %s %s @ %s+0x%x\n"</literal></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"var %s %s @ %s-0x%x\n"</literal></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_BP</name></expr>]</index></name></expr></argument>,

<argument><expr><operator>-</operator><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_REG</name></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>i</name> <init>= <expr><call><name>r_reg_index_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Register not found"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"arg %s %s @ %s\n"</literal></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>i</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><name>R_ANAL_VAR_KIND_SPV</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><name><name>fcn</name><operator>-&gt;</operator><name>maxstack</name></name> <operator>+</operator> <name><name>var</name><operator>-&gt;</operator><name>delta</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"var %s %s @ %s+0x%x\n"</literal></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>,

<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>cb_printf</name></name> <argument_list>(<argument><expr><literal type="string">"arg %s %s @ %s+0x%x\n"</literal></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>R_REG_NAME_SP</name></expr>]</index></name></expr></argument>,

<argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></switch>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_fcn_vars_cache_init</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalFcnVarsCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>bvars</name></name> <operator>=</operator> <call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_BPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>rvars</name></name> <operator>=</operator> <call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_REG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cache</name><operator>-&gt;</operator><name>svars</name></name> <operator>=</operator> <call><name>r_anal_var_list</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>R_ANAL_VAR_KIND_SPV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>bvars</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>var_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>rvars</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>regvar_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>svars</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>var_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_anal_fcn_vars_cache_fini</name><parameter_list>(<parameter><decl><type><name>RAnalFcnVarsCache</name> <modifier>*</modifier></type><name>cache</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>bvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>rvars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>svars</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>char</name> <modifier>*</modifier></type><name>r_anal_fcn_format_sig</name><parameter_list>(<parameter><decl><type><name>R_NONNULL</name> <name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>R_NONNULL</name> <name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <name>char</name> <modifier>*</modifier></type><name>fcn_name</name></decl></parameter>,

<parameter><decl><type><name>R_NULLABLE</name> <name>RAnalFcnVarsCache</name> <modifier>*</modifier></type><name>reuse_cache</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_name_pre</name></decl></parameter>, <parameter><decl><type><name>R_NULLABLE</name> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_name_post</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFcnVarsCache</name> <modifier>*</modifier></type><name>cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn_name</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn_name</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RStrBuf</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_strbuf_new</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_fcn_name</name> <init>= <expr><call><name>r_type_func_guess</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_fcn_name</name> <operator>&amp;&amp;</operator> <call><name>r_type_func_exist</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_type</name> <init>= <expr><call><name>r_type_func_ret</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_type</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><literal type="string">" "</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fcn_type</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>fcn_type</name><index>[<expr><call><name>strlen</name> <argument_list>(<argument><expr><name>fcn_type</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sp</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>fcn_type</name></expr></argument>, <argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_name_pre</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fcn_name_pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn_name_post</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fcn_name_post</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>type_fcn_name</name> <operator>&amp;&amp;</operator> <call><name>r_type_func_exist</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>argc</name> <init>= <expr><call><name>r_type_func_args_count</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>comma</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>argc</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_type_func_args_type</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_type_func_args_name</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name> <operator>||</operator> <operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing type for %s\n"</literal></expr></argument>, <argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name>argc</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tc</name> <init>= <expr><ternary><condition><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>type</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>?</condition><then> <expr><literal type="string">""</literal></expr></then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>comma</name></expr>?</condition><then> <expr><literal type="string">", "</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cache</name> <operator>=</operator> <name>reuse_cache</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cache</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAnalFcnVarsCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type_fcn_name</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_init</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cache</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>comma</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>arg_bp</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>tmp_len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache-&gt;rvars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"self"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_slice</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>r_strbuf_length</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>tmp_len</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>type</name><index>[<expr><name>tmp_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache-&gt;bvars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>delta</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>rvars</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>comma</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg_bp</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>tmp_len</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>type</name><index>[<expr><name>tmp_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator><literal type="char">'*'</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><literal type="string">", "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>maybe_comma</name> <init>= <expr><literal type="string">", "</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>cache-&gt;svars</argument>, <argument>iter</argument>, <argument>var</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>maybe_comma</name> <operator>||</operator> <operator>(</operator><operator>(</operator><name>arg_bp</name> <operator>||</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name><name>cache</name><operator>-&gt;</operator><name>rvars</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <name>comma</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>RAnalVar</name> <operator>*</operator><operator>)</operator><name><name>iter</name><operator>-&gt;</operator><name>n</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>isarg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>maybe_comma</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>maybe_comma</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_strbuf_appendf</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%s%s%s"</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>type</name></name></expr></argument>,

<argument><expr><ternary><condition><expr><name>tmp_len</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>type</name><index>[<expr><name>tmp_len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator><literal type="char">'*'</literal></expr> ?</condition><then> <expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>maybe_comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_strbuf_append</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">");"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>type_fcn_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>reuse_cache</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_vars_cache_fini</name> <argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>r_strbuf_drain</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

</unit>
