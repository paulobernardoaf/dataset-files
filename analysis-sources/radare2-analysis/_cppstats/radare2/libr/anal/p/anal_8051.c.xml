<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\anal\p\anal_8051.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_types.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_lib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_asm.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;8051_ops.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../asm/arch/8051/8051_disas.c"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>map_code</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>map_idata</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>map_sfr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>map_xdata</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>map_pdata</name></decl>;</decl_stmt>

}</block></struct></type> <name>i8051_cpu_model</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>i8051_cpu_model</name></type> <name><name>cpu_models</name><index>[]</index></name> <init>= <expr><block>{

<expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"8051-generic"</literal></expr>,

<expr><operator>.</operator><name>map_code</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>map_idata</name> <operator>=</operator> <literal type="number">0x10000000</literal></expr>,

<expr><operator>.</operator><name>map_sfr</name> <operator>=</operator> <literal type="number">0x10000180</literal></expr>,

<expr><operator>.</operator><name>map_xdata</name> <operator>=</operator> <literal type="number">0x20000000</literal></expr>,

<expr><operator>.</operator><name>map_pdata</name> <operator>=</operator> <literal type="number">0x00000000</literal></expr>

}</block></expr>,

<expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"8051-shared-code-xdata"</literal></expr>,

<expr><operator>.</operator><name>map_code</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>map_idata</name> <operator>=</operator> <literal type="number">0x10000000</literal></expr>,

<expr><operator>.</operator><name>map_sfr</name> <operator>=</operator> <literal type="number">0x10000180</literal></expr>,

<expr><operator>.</operator><name>map_xdata</name> <operator>=</operator> <literal type="number">0x00000000</literal></expr>,

<expr><operator>.</operator><name>map_pdata</name> <operator>=</operator> <literal type="number">0x00000000</literal></expr>

}</block></expr>,

<expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <name>NULL</name></expr> 

}</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>i8051_is_init</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>i8051_cpu_model</name> <modifier>*</modifier></type><name>cpu_curr_model</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>i8051_reg_write</name> <parameter_list>(<parameter><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>num</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut32</name></type> <name>i8051_reg_read</name> <parameter_list>(<parameter><decl><type><name>RReg</name> <modifier>*</modifier></type><name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><name>R_REG_TYPE_GPR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name>reg</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>desc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>

}</block></struct></type> <name>i8051_map_entry</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>I8051_IDATA</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>I8051_SFR</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>I8051_XDATA</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>i8051_map_entry</name></type> <name><name>mem_map</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{

<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>UT32_MAX</name></expr>, <expr><literal type="string">"idata"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>UT32_MAX</name></expr>, <expr><literal type="string">"sfr"</literal></expr> }</block></expr>,

<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>UT32_MAX</name></expr>, <expr><literal type="string">"xdata"</literal></expr> }</block></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>map_cpu_memory</name> <parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>entry</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RIODesc</name> <modifier>*</modifier></type><name>desc</name> <init>= <expr><name><name>mem_map</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><name>desc</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>&amp;&amp;</operator> <call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>fd_get_name</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <name>addr</name> <operator>!=</operator> <name><name>mem_map</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>fd_remap</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mstr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"malloc://%d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>open_at</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name>mstr</name></expr></argument>, <argument><expr><name>R_PERM_RW</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>desc</name> <operator>&amp;&amp;</operator> <call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>fd_get_name</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>maps</name> <init>= <expr><call><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>fd_get_map</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>desc</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>current_map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>maps</argument>, <argument>iter</argument>, <argument>current_map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmdstr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"omni %d %s"</literal></expr></argument>, <argument><expr><name><name>current_map</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name><name>mem_map</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>cmd</name></name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>core</name></name></expr></argument>, <argument><expr><name>cmdstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmdstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>maps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>mem_map</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><name>desc</name> <operator>=</operator> <name>desc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mem_map</name><index>[<expr><name>entry</name></expr>]</index></name><operator>.</operator><name>addr</name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_cpu_model</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>addr_idata</name></decl>, <decl><type ref="prev"/><name>addr_sfr</name></decl>, <decl><type ref="prev"/><name>addr_xdata</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpu</name> <init>= <expr><name><name>anal</name><operator>-&gt;</operator><name>cpu</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cpu</name> <operator>||</operator> <operator>!</operator><name><name>cpu</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cpu</name> <operator>=</operator> <name><name>cpu_models</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>name</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>force</name> <operator>||</operator> <operator>!</operator><name>cpu_curr_model</name> <operator>||</operator> <call><name>r_str_casecmp</name> <argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><name><name>cpu_curr_model</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name> <operator>&amp;&amp;</operator> <call><name>r_str_casecmp</name> <argument_list>(<argument><expr><name>cpu</name></expr></argument>, <argument><expr><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cpu_curr_model</name> <operator>=</operator> <operator>&amp;</operator><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>addr_idata</name> <operator>=</operator> <name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>map_idata</name></expr>;</expr_stmt>

<expr_stmt><expr><name>addr_sfr</name> <operator>=</operator> <name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>map_sfr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>addr_xdata</name> <operator>=</operator> <name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>map_xdata</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>i8051_reg_write</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_code"</literal></expr></argument>, <argument><expr><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>map_code</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>i8051_reg_write</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_idata"</literal></expr></argument>, <argument><expr><name>addr_idata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>i8051_reg_write</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_sfr"</literal></expr></argument>, <argument><expr><name>addr_sfr</name> <operator>-</operator> <literal type="number">0x80</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>i8051_reg_write</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_xdata"</literal></expr></argument>, <argument><expr><name>addr_xdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>i8051_reg_write</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_pdata"</literal></expr></argument>, <argument><expr><name><name>cpu_models</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>map_pdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr_idata</name> <operator>=</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_idata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addr_sfr</name> <operator>=</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_sfr"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">0x80</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>addr_xdata</name> <operator>=</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_xdata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>anal</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>fd_get_name</name></name> <operator>&amp;&amp;</operator> <name><name>anal</name><operator>-&gt;</operator><name>coreb</name><operator>.</operator><name>cmd</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>map_cpu_memory</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>I8051_IDATA</name></expr></argument>, <argument><expr><name>addr_idata</name></expr></argument>, <argument><expr><literal type="number">0x100</literal></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>map_cpu_memory</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>I8051_SFR</name></expr></argument>, <argument><expr><name>addr_sfr</name></expr></argument>, <argument><expr><literal type="number">0x80</literal></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>map_cpu_memory</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>I8051_XDATA</name></expr></argument>, <argument><expr><name>addr_xdata</name></expr></argument>, <argument><expr><literal type="number">0x10000</literal></expr></argument>, <argument><expr><name>force</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>ut8</name></type> <name><name>bitindex</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="number">0x20</literal></expr>, <expr><literal type="number">0x21</literal></expr>, <expr><literal type="number">0x22</literal></expr>, <expr><literal type="number">0x23</literal></expr>, <expr><literal type="number">0x24</literal></expr>, <expr><literal type="number">0x25</literal></expr>, <expr><literal type="number">0x26</literal></expr>, <expr><literal type="number">0x27</literal></expr>, 

<expr><literal type="number">0x28</literal></expr>, <expr><literal type="number">0x29</literal></expr>, <expr><literal type="number">0x2A</literal></expr>, <expr><literal type="number">0x2B</literal></expr>, <expr><literal type="number">0x2C</literal></expr>, <expr><literal type="number">0x2D</literal></expr>, <expr><literal type="number">0x2E</literal></expr>, <expr><literal type="number">0x2F</literal></expr>, 

<expr><literal type="number">0x80</literal></expr>, <expr><literal type="number">0x88</literal></expr>, <expr><literal type="number">0x90</literal></expr>, <expr><literal type="number">0x98</literal></expr>, <expr><literal type="number">0xA0</literal></expr>, <expr><literal type="number">0xA8</literal></expr>, <expr><literal type="number">0xB0</literal></expr>, <expr><literal type="number">0xB8</literal></expr>, 

<expr><literal type="number">0xC0</literal></expr>, <expr><literal type="number">0xC8</literal></expr>, <expr><literal type="number">0xD0</literal></expr>, <expr><literal type="number">0xD8</literal></expr>, <expr><literal type="number">0xE0</literal></expr>, <expr><literal type="number">0xE8</literal></expr>, <expr><literal type="number">0xF0</literal></expr>, <expr><literal type="number">0xF8</literal></expr> 

}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

typedef struct {

const char *name;

ut8 offset; 

ut8 resetvalue; 

ut8 num_bytes; 

ut8 banked : 1;

ut8 isdptr : 1;

} RI8051Reg;

static RI8051Reg registers[] = {

{"a", 0xE0, 0x00, 1, 0},

{"b", 0xF0, 0x00, 1, 0},

{"dph", 0x83, 0x00, 1, 0},

{"dpl", 0x82, 0x00, 1, 0},

{"dptr", 0x82, 0x00, 2, 0, 1},

{"ie", 0xA8, 0x00, 1, 0},

{"ip", 0xB8, 0x00, 1, 0},

{"p0", 0x80, 0xFF, 1, 0},

{"p1", 0x90, 0xFF, 1, 0},

{"p2", 0xA0, 0xFF, 1, 0},

{"p3", 0xB0, 0xFF, 1, 0},

{"pcon", 0x87, 0x00, 1, 0},

{"psw", 0xD0, 0x00, 1, 0},

{"r0", 0x00, 0x00, 1, 1},

{"r1", 0x01, 0x00, 1, 1},

{"r2", 0x02, 0x00, 1, 1},

{"r3", 0x03, 0x00, 1, 1},

{"r4", 0x04, 0x00, 1, 1},

{"r5", 0x05, 0x00, 1, 1},

{"r6", 0x06, 0x00, 1, 1},

{"r7", 0x07, 0x00, 1, 1},

{"sbuf", 0x99, 0x00, 1, 0},

{"scon", 0x98, 0x00, 1, 0},

{"sp", 0x81, 0x07, 1, 0},

{"tcon", 0x88, 0x00, 1, 0},

{"th0", 0x8C, 0x00, 1, 0},

{"th1", 0x8D, 0x00, 1, 0},

{"tl0", 0x8A, 0x00, 1, 0},

{"tl1", 0x8B, 0x00, 1, 0},

{"tmod", 0x89, 0x00, 1, 0}

};

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>e</name><parameter_list>(<parameter><type><name>frag</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_strbuf_append(&amp;op-&gt;esil, frag)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ef</name><parameter_list>(<parameter><type><name>frag</name></type></parameter>, <parameter><type><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_strbuf_appendf(&amp;op-&gt;esil, frag, __VA_ARGS__)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_c</name></cpp:macro> <cpp:value>"7,$c,c,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_b</name></cpp:macro> <cpp:value>"8,$b,c,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_ac</name></cpp:macro> <cpp:value>"3,$c,ac,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_ab</name></cpp:macro> <cpp:value>"3,$b,ac,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_ov</name></cpp:macro> <cpp:value>"6,$c,ov,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_ob</name></cpp:macro> <cpp:value>"7,$b,6,$b,^,ov,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>flag_p</name></cpp:macro> <cpp:value>"0xff,a,&amp;=,$p,!,p,:=,"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_a</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_bit</name></cpp:macro> <cpp:value>bitindex[buf[1]&gt;&gt;3]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_c</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_dir1</name></cpp:macro> <cpp:value>buf[1]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_dir2</name></cpp:macro> <cpp:value>buf[2]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_dp</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_dpx</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_imm1</name></cpp:macro> <cpp:value>buf[1]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_imm2</name></cpp:macro> <cpp:value>buf[2]</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_imm16</name></cpp:macro> <cpp:value>op-&gt;val</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_ri</name></cpp:macro> <cpp:value>(1 &amp; buf[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_rix</name></cpp:macro> <cpp:value>(1 &amp; buf[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_rn</name></cpp:macro> <cpp:value>(7 &amp; buf[0])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_sp2</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ev_sp1</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_a</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_dir1</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,%d,+,[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_sfr,%d,+,[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_bit</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>exr_dir1</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_dpx</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_xdata,dptr,+,[1],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_imm1</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"%d,"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_imm2</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"%d,"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_imm16</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut16</name></type> <name>val</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"%d,"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_ri</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,r%d,+,[1],"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_rix</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"8,0xff,_pdata,&amp;,&lt;&lt;,_xdata,+,r%d,+,[1],"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_rn</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"r%d,"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_sp1</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_idata,sp,+,[1],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,-=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exr_sp2</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,-=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_idata,sp,+,[2],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,-=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_a</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_c</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"c,=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_dir1</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,%d,+,=[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_sfr,%d,+,=[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_dir2</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>exw_dir1</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_bit</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>exw_dir1</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_dp</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"dptr,=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_dpx</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_xdata,dptr,+,=[1],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_ri</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,r%d,+,=[1],"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_rix</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"8,0xff,_pdata,&amp;,&lt;&lt;,_xdata,+,r%d,+,=[1],"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_rn</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"r%d,=,"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_sp1</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,+=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_idata,sp,+,=[1],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exw_sp2</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,+=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"_idata,sp,+,=[2],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,sp,+=,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_a</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"a,%s=,"</literal></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_c</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"c,%s=,"</literal></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_dp</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>dummy</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"dptr,%s=,"</literal></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_dir1</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,%d,+,%s=[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_sfr,%d,+,%s=[1],"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_bit</name> <parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>exi_dir1</name> <argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_ri</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"_idata,r%d,+,%s=[1],"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>exi_rn</name><parameter_list>(<parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>reg</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operation</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>ef</name> <argument_list>(<argument><expr><literal type="string">"r%d,%s=,"</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name>operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xr</name><parameter_list>(<parameter><type><name>subject</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>exr_##subject (op, ev_##subject)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xw</name><parameter_list>(<parameter><type><name>subject</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>exw_##subject (op, ev_##subject)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xi</name><parameter_list>(<parameter><type><name>subject</name></type></parameter>, <parameter><type><name>operation</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>exi_##subject (op, ev_##subject, operation)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_set</name></cpp:macro> <cpp:value>ef ("%d,1,&lt;&lt;,", buf[1] &amp; 7)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_mask</name></cpp:macro> <cpp:value>bit_set; e ("255,^,")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_r</name></cpp:macro> <cpp:value>ef ("%d,", buf[1] &amp; 7); xr (bit); e ("&gt;&gt;,1,&amp;,")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bit_c</name></cpp:macro> <cpp:value>ef ("%d,c,&lt;&lt;,", buf[1] &amp; 7);</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>jmp</name></cpp:macro> <cpp:value>ef ("%d,pc,=", op-&gt;jump)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>cjmp</name></cpp:macro> <cpp:value>e ("?{,"); jmp; e (",}")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>call</name></cpp:macro> <cpp:value>ef ("%d,", op-&gt;fail); xw (sp2); jmp</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alu_op</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xr (val); e ("a," aluop "=," flags)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alu_op_c</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>e ("c,"); xr (val); e ("+,a," aluop "=," flags)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>alu_op_d</name><parameter_list>(<parameter><type><name>val</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>xr (val); xi (dir1, aluop)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>template_alu4_c</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case base + 0x4: alu_op_c (imm1, aluop, flags); break; case base + 0x5: alu_op_c (dir1, aluop, flags); break; case base + 0x6: case base + 0x7: alu_op_c (ri, aluop, flags); break; case base + 0x8: case base + 0x9: case base + 0xA: case base + 0xB: case base + 0xC: case base + 0xD: case base + 0xE: case base + 0xF: alu_op_c (rn, aluop, flags); break;</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>template_alu2</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case base + 0x2: alu_op_d (a, aluop); break; case base + 0x3: alu_op_d (imm2, aluop); break;</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>template_alu4</name><parameter_list>(<parameter><type><name>base</name></type></parameter>, <parameter><type><name>aluop</name></type></parameter>, <parameter><type><name>flags</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case base + 0x4: alu_op (imm1, aluop, flags); break; case base + 0x5: alu_op (dir1, aluop, flags); break; case base + 0x6: case base + 0x7: alu_op (ri, aluop, flags); break; case base + 0x8: case base + 0x9: case base + 0xA: case base + 0xB: case base + 0xC: case base + 0xD: case base + 0xE: case base + 0xF: alu_op (rn, aluop, flags); break;</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>analop_esil</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_strbuf_init</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_strbuf_set</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>op</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0x00</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x10</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"?{,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>bit_mask</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>bit</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>jmp</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">",}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x20</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x30</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x40</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"c,1,&amp;,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x50</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"c,1,&amp;,!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x60</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,0,==,$z,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x70</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,0,==,$z,!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x11</literal></expr>:</case> <case>case <expr><literal type="number">0x31</literal></expr>:</case> <case>case <expr><literal type="number">0x51</literal></expr>:</case> <case>case <expr><literal type="number">0x71</literal></expr>:</case>

<case>case <expr><literal type="number">0x91</literal></expr>:</case> <case>case <expr><literal type="number">0xB1</literal></expr>:</case> <case>case <expr><literal type="number">0xD1</literal></expr>:</case> <case>case <expr><literal type="number">0xF1</literal></expr>:</case> 

<case>case <expr><literal type="number">0x12</literal></expr>:</case> 

<expr_stmt><expr><name>call</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x01</literal></expr>:</case> <case>case <expr><literal type="number">0x21</literal></expr>:</case> <case>case <expr><literal type="number">0x41</literal></expr>:</case> <case>case <expr><literal type="number">0x61</literal></expr>:</case>

<case>case <expr><literal type="number">0x81</literal></expr>:</case> <case>case <expr><literal type="number">0xA1</literal></expr>:</case> <case>case <expr><literal type="number">0xC1</literal></expr>:</case> <case>case <expr><literal type="number">0xE1</literal></expr>:</case> 

<case>case <expr><literal type="number">0x02</literal></expr>:</case> 

<case>case <expr><literal type="number">0x80</literal></expr>:</case> 

<expr_stmt><expr><name>jmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x22</literal></expr>:</case> 

<case>case <expr><literal type="number">0x32</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>sp2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"pc,="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x03</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,a,0x101,*,&gt;&gt;,a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x04</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x05</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x06</literal></expr>:</case> <case>case <expr><literal type="number">0x07</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x08</literal></expr>:</case> <case>case <expr><literal type="number">0x09</literal></expr>:</case> <case>case <expr><literal type="number">0x0A</literal></expr>:</case> <case>case <expr><literal type="number">0x0B</literal></expr>:</case>

<case>case <expr><literal type="number">0x0C</literal></expr>:</case> <case>case <expr><literal type="number">0x0D</literal></expr>:</case> <case>case <expr><literal type="number">0x0E</literal></expr>:</case> <case>case <expr><literal type="number">0x0F</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x13</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"7,c,&lt;&lt;,1,a,&amp;,c,=,0x7f,1,a,&gt;&gt;,&amp;,+,a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x14</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x15</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x16</literal></expr>:</case> <case>case <expr><literal type="number">0x17</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x18</literal></expr>:</case> <case>case <expr><literal type="number">0x19</literal></expr>:</case> <case>case <expr><literal type="number">0x1A</literal></expr>:</case> <case>case <expr><literal type="number">0x1B</literal></expr>:</case>

<case>case <expr><literal type="number">0x1C</literal></expr>:</case> <case>case <expr><literal type="number">0x1D</literal></expr>:</case> <case>case <expr><literal type="number">0x1E</literal></expr>:</case> <case>case <expr><literal type="number">0x1F</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x23</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"7,a,0x101,*,&gt;&gt;,a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<macro><name>template_alu4</name> <argument_list>(<argument><literal type="number">0x20</literal></argument>, <argument><literal type="string">"+"</literal></argument>, <argument>flag_c flag_ac flag_ov flag_p</argument>)</argument_list></macro> 

<case>case <expr><literal type="number">0x33</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"c,1,&amp;,a,a,+=,7,$c,c,:=,a,+=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<macro><name>template_alu4_c</name> <argument_list>(<argument><literal type="number">0x30</literal></argument>, <argument><literal type="string">"+"</literal></argument>, <argument>flag_c flag_ac flag_ov flag_p</argument>)</argument_list></macro> 

<macro><name>template_alu2</name> <argument_list>(<argument><literal type="number">0x40</literal></argument>, <argument><literal type="string">"|"</literal></argument>)</argument_list></macro> 

<macro><name>template_alu4</name> <argument_list>(<argument><literal type="number">0x40</literal></argument>, <argument><literal type="string">"|"</literal></argument>, <argument>flag_p</argument>)</argument_list></macro> 

<macro><name>template_alu2</name> <argument_list>(<argument><literal type="number">0x50</literal></argument>, <argument><literal type="string">"&amp;"</literal></argument>)</argument_list></macro> 

<macro><name>template_alu4</name> <argument_list>(<argument><literal type="number">0x50</literal></argument>, <argument><literal type="string">"&amp;"</literal></argument>, <argument>flag_p</argument>)</argument_list></macro> 

<macro><name>template_alu2</name> <argument_list>(<argument><literal type="number">0x60</literal></argument>, <argument><literal type="string">"^"</literal></argument>)</argument_list></macro> 

<macro><name>template_alu4</name> <argument_list>(<argument><literal type="number">0x60</literal></argument>, <argument><literal type="string">"^"</literal></argument>, <argument>flag_p</argument>)</argument_list></macro> 

<case>case <expr><literal type="number">0x72</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x73</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"dptr,a,+,pc,="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x74</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x75</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x76</literal></expr>:</case> <case>case <expr><literal type="number">0x77</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x78</literal></expr>:</case> <case>case <expr><literal type="number">0x79</literal></expr>:</case> <case>case <expr><literal type="number">0x7A</literal></expr>:</case> <case>case <expr><literal type="number">0x7B</literal></expr>:</case>

<case>case <expr><literal type="number">0x7C</literal></expr>:</case> <case>case <expr><literal type="number">0x7D</literal></expr>:</case> <case>case <expr><literal type="number">0x7E</literal></expr>:</case> <case>case <expr><literal type="number">0x7F</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x82</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x83</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,pc,--,+,[1],a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x84</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"b,0,==,$z,ov,:=,b,a,%,b,a,/=,b,=,0,c,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x85</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x86</literal></expr>:</case> <case>case <expr><literal type="number">0x87</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x88</literal></expr>:</case> <case>case <expr><literal type="number">0x89</literal></expr>:</case> <case>case <expr><literal type="number">0x8A</literal></expr>:</case> <case>case <expr><literal type="number">0x8B</literal></expr>:</case>

<case>case <expr><literal type="number">0x8C</literal></expr>:</case> <case>case <expr><literal type="number">0x8D</literal></expr>:</case> <case>case <expr><literal type="number">0x8E</literal></expr>:</case> <case>case <expr><literal type="number">0x8F</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x90</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x92</literal></expr>:</case> 

<expr_stmt><expr><name>bit_c</name></expr>;</expr_stmt> <expr_stmt><expr><name>bit_mask</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"&amp;,|,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name><argument_list>(<argument><expr><name>bit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0x93</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,dptr,+,[1],a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<macro><name>template_alu4_c</name> <argument_list>(<argument><literal type="number">0x90</literal></argument>, <argument><literal type="string">"-"</literal></argument>, <argument>flag_b flag_ab flag_ob flag_p</argument>)</argument_list></macro> 

<case>case <expr><literal type="number">0xA0</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA2</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA3</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>dp</name></expr></argument>, <argument><expr><literal type="string">"++"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA4</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"8,a,b,*,DUP,a,=,&gt;&gt;,DUP,b,=,0,==,$z,!,ov,:=,0,c,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA5</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,trap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA6</literal></expr>:</case> <case>case <expr><literal type="number">0xA7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xA8</literal></expr>:</case> <case>case <expr><literal type="number">0xA9</literal></expr>:</case> <case>case <expr><literal type="number">0xAA</literal></expr>:</case> <case>case <expr><literal type="number">0xAB</literal></expr>:</case>

<case>case <expr><literal type="number">0xAC</literal></expr>:</case> <case>case <expr><literal type="number">0xAD</literal></expr>:</case> <case>case <expr><literal type="number">0xAE</literal></expr>:</case> <case>case <expr><literal type="number">0xAF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB0</literal></expr>:</case> 

<expr_stmt><expr><name>bit_r</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB2</literal></expr>:</case> 

<expr_stmt><expr><name>bit_set</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>bit</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB3</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB4</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"==,$z,!,"</literal> <name>flag_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB5</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"==,$z,!,"</literal> <name>flag_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB6</literal></expr>:</case> <case>case <expr><literal type="number">0xB7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"==,$z,!,"</literal> <name>flag_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xB8</literal></expr>:</case> <case>case <expr><literal type="number">0xB9</literal></expr>:</case> <case>case <expr><literal type="number">0xBA</literal></expr>:</case> <case>case <expr><literal type="number">0xBB</literal></expr>:</case>

<case>case <expr><literal type="number">0xBC</literal></expr>:</case> <case>case <expr><literal type="number">0xBD</literal></expr>:</case> <case>case <expr><literal type="number">0xBE</literal></expr>:</case> <case>case <expr><literal type="number">0xBF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>imm1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"==,$z,!,"</literal> <name>flag_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC0</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>sp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC2</literal></expr>:</case> 

<expr_stmt><expr><name>bit_mask</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>bit</name></expr></argument>, <argument><expr><literal type="string">"&amp;"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC3</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC4</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0xff,4,a,0x101,*,&gt;&gt;,&amp;,a,=,"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC5</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,+,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC6</literal></expr>:</case> <case>case <expr><literal type="number">0xC7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,+,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xC8</literal></expr>:</case> <case>case <expr><literal type="number">0xC9</literal></expr>:</case> <case>case <expr><literal type="number">0xCA</literal></expr>:</case> <case>case <expr><literal type="number">0xCB</literal></expr>:</case>

<case>case <expr><literal type="number">0xCC</literal></expr>:</case> <case>case <expr><literal type="number">0xCD</literal></expr>:</case> <case>case <expr><literal type="number">0xCE</literal></expr>:</case> <case>case <expr><literal type="number">0xCF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,+,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD0</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>sp1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD2</literal></expr>:</case> 

<expr_stmt><expr><name>bit_set</name></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>bit</name></expr></argument>, <argument><expr><literal type="string">"|"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD3</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"1,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD4</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"a,0x0f,&amp;,9,==,4,$b,ac,|,?{,6,a,+=,7,$c,c,|,c,:=,},a,0xf0,&amp;,0x90,==,8,$b,c,|,?{,0x60,a,+=,7,$c,c,|,c,:=,},"</literal> <name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD5</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,==,$z,!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD6</literal></expr>:</case>

<case>case <expr><literal type="number">0xD7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0xf0,&amp;,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0x0f,&amp;,|,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0xf0,&amp;,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0x0f,&amp;,|,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xD8</literal></expr>:</case> <case>case <expr><literal type="number">0xD9</literal></expr>:</case> <case>case <expr><literal type="number">0xDA</literal></expr>:</case> <case>case <expr><literal type="number">0xDB</literal></expr>:</case>

<case>case <expr><literal type="number">0xDC</literal></expr>:</case> <case>case <expr><literal type="number">0xDD</literal></expr>:</case> <case>case <expr><literal type="number">0xDE</literal></expr>:</case> <case>case <expr><literal type="number">0xDF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>, <argument><expr><literal type="string">"--"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,==,$z,!,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>cjmp</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE0</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dpx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE2</literal></expr>:</case> <case>case <expr><literal type="number">0xE3</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE4</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"0,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE5</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE6</literal></expr>:</case> <case>case <expr><literal type="number">0xE7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xE8</literal></expr>:</case> <case>case <expr><literal type="number">0xE9</literal></expr>:</case> <case>case <expr><literal type="number">0xEA</literal></expr>:</case> <case>case <expr><literal type="number">0xEB</literal></expr>:</case>

<case>case <expr><literal type="number">0xEC</literal></expr>:</case> <case>case <expr><literal type="number">0xED</literal></expr>:</case> <case>case <expr><literal type="number">0xEE</literal></expr>:</case> <case>case <expr><literal type="number">0xEF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF0</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dpx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF2</literal></expr>:</case> <case>case <expr><literal type="number">0xF3</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>rix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF4</literal></expr>:</case> 

<expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><literal type="string">"255,"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xi</name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="string">"^"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>e</name> <argument_list>(<argument><expr><name>flag_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF5</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>dir1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF6</literal></expr>:</case> <case>case <expr><literal type="number">0xF7</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>ri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0xF8</literal></expr>:</case> <case>case <expr><literal type="number">0xF9</literal></expr>:</case> <case>case <expr><literal type="number">0xFA</literal></expr>:</case> <case>case <expr><literal type="number">0xFB</literal></expr>:</case>

<case>case <expr><literal type="number">0xFC</literal></expr>:</case> <case>case <expr><literal type="number">0xFD</literal></expr>:</case> <case>case <expr><literal type="number">0xFE</literal></expr>:</case> <case>case <expr><literal type="number">0xFF</literal></expr>:</case> 

<expr_stmt><expr><call><name>xr</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><call><name>xw</name> <argument_list>(<argument><expr><name>rn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>RAnalEsilCallbacks</name></type> <name>ocbs</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static int i8051_hook_reg_read(RAnalEsil *, const char *, ut64 *, int *);

static int i8051_reg_compare(const void *name, const void *reg) {

return strcmp ((const char*)name, ((RI8051Reg*)reg)-&gt;name);

}

static RI8051Reg *i8051_reg_find(const char *name) {

return (RI8051Reg *) bsearch (

name, registers,

sizeof (registers) / sizeof (registers[0]),

sizeof (registers[0]),

i8051_reg_compare);

}

static int i8051_reg_get_offset(RAnalEsil *esil, RI8051Reg *ri) {

ut8 offset = ri-&gt;offset;

if (ri-&gt;banked) {

ut64 psw = 0LL;

i8051_hook_reg_read (esil, "psw", &amp;psw, NULL);

offset += psw &amp; 0x18;

}

return offset;

}

static int i8051_hook_reg_read(RAnalEsil *esil, const char *name, ut64 *res, int *size) {

int ret = 0;

ut64 val = 0LL;

RI8051Reg *ri;

RAnalEsilCallbacks cbs = esil-&gt;cb;

if ((ri = i8051_reg_find (name))) {

ut8 offset = i8051_reg_get_offset(esil, ri);

ret = r_anal_esil_mem_read (esil, IRAM_BASE + offset, (ut8*)res, ri-&gt;num_bytes);

}

esil-&gt;cb = ocbs;

if (!ret &amp;&amp; ocbs.hook_reg_read) {

ret = ocbs.hook_reg_read (esil, name, res, NULL);

}

if (!ret &amp;&amp; ocbs.reg_read) {

ret = ocbs.reg_read (esil, name, &amp;val, NULL);

}

esil-&gt;cb = cbs;

return ret;

}

static int i8051_hook_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {

int ret = 0;

RI8051Reg *ri;

RAnalEsilCallbacks cbs = esil-&gt;cb;

if ((ri = i8051_reg_find (name))) {

ut8 offset = i8051_reg_get_offset(esil, ri);

ret = r_anal_esil_mem_write (esil, IRAM_BASE + offset, (ut8*)val, ri-&gt;num_bytes);

}

esil-&gt;cb = ocbs;

if (!ret &amp;&amp; ocbs.hook_reg_write) {

ret = ocbs.hook_reg_write (esil, name, val);

}

esil-&gt;cb = cbs;

return ret;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>esil_i8051_init</name> <parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>user</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ocbs</name> <operator>=</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i8051_is_init</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>esil_i8051_fini</name> <parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i8051_is_init</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>ocbs</name><operator>.</operator><name>user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i8051_is_init</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>set_reg_profile</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>=

<expr><literal type="string">"=PC pc\n"</literal>

<literal type="string">"=SP sp\n"</literal>

<literal type="string">"gpr r0 .8 0 0\n"</literal>

<literal type="string">"gpr r1 .8 1 0\n"</literal>

<literal type="string">"gpr r2 .8 2 0\n"</literal>

<literal type="string">"gpr r3 .8 3 0\n"</literal>

<literal type="string">"gpr r4 .8 4 0\n"</literal>

<literal type="string">"gpr r5 .8 5 0\n"</literal>

<literal type="string">"gpr r6 .8 6 0\n"</literal>

<literal type="string">"gpr r7 .8 7 0\n"</literal>

<literal type="string">"gpr a .8 8 0\n"</literal>

<literal type="string">"gpr b .8 9 0\n"</literal>

<literal type="string">"gpr dptr .16 10 0\n"</literal>

<literal type="string">"gpr dpl .8 10 0\n"</literal>

<literal type="string">"gpr dph .8 11 0\n"</literal>

<literal type="string">"gpr psw .8 12 0\n"</literal>

<literal type="string">"gpr p .1 .96 0\n"</literal>

<literal type="string">"gpr ov .1 .98 0\n"</literal>

<literal type="string">"gpr ac .1 .102 0\n"</literal>

<literal type="string">"gpr c .1 .103 0\n"</literal>

<literal type="string">"gpr sp .8 13 0\n"</literal>

<literal type="string">"gpr pc .16 15 0\n"</literal>

<literal type="string">"gpr _code .32 20 0\n"</literal>

<literal type="string">"gpr _idata .32 24 0\n"</literal>

<literal type="string">"gpr _sfr .32 28 0\n"</literal>

<literal type="string">"gpr _xdata .32 32 0\n"</literal>

<literal type="string">"gpr _pdata .32 36 0\n"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>retval</name> <init>= <expr><call><name>r_reg_set_profile_string</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>retval</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_cpu_model</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut32</name></type> <name>map_direct_addr</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>&lt;</operator> <literal type="number">0x80</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>addr</name> <operator>+</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_idata"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>addr</name> <operator>+</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_sfr"</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>i8051_op</name><parameter_list>(<parameter><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>RAnalOpMask</name></type> <name>mask</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>set_cpu_model</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>string</name> <operator>&amp;&amp;</operator> <name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>op</name> <operator>!=</operator> <operator>(</operator><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;</operator> <operator>~</operator><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>mask</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name>arg1</name> <init>= <expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arg1</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name>arg2</name> <init>= <expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>arg2</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>delay</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cycles</name></name> <operator>=</operator> <name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>failcycles</name></name> <operator>=</operator> <name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cycles</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>nopcode</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>family</name></name> <operator>=</operator> <name>R_ANAL_OP_FAMILY_CPU</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>instr</name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <name>R_ANAL_COND_AL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>OP_CJNE</name></expr>:</case>

<case>case <expr><name>OP_DJNZ</name></expr>:</case>

<case>case <expr><name>OP_JB</name></expr>:</case>

<case>case <expr><name>OP_JBC</name></expr>:</case>

<case>case <expr><name>OP_JNZ</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <name>R_ANAL_COND_NE</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>OP_JNB</name></expr>:</case>

<case>case <expr><name>OP_JZ</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <name>R_ANAL_COND_EQ</name></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>OP_JC</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <name>R_ANAL_COND_HS</name></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>OP_JNC</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>cond</name></name> <operator>=</operator> <name>R_ANAL_COND_LO</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>instr</name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>eob</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>OP_CJNE</name></expr>:</case>

<case>case <expr><name>OP_DJNZ</name></expr>:</case>

<case>case <expr><name>OP_JB</name></expr>:</case>

<case>case <expr><name>OP_JBC</name></expr>:</case>

<case>case <expr><name>OP_JC</name></expr>:</case>

<case>case <expr><name>OP_JMP</name></expr>:</case>

<case>case <expr><name>OP_JNB</name></expr>:</case>

<case>case <expr><name>OP_JNC</name></expr>:</case>

<case>case <expr><name>OP_JNZ</name></expr>:</case>

<case>case <expr><name>OP_JZ</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>eob</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>arg1</name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<break>break;</break> <case>case <expr><name>A_DIRECT</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>map_direct_addr</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>A_BIT</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>map_direct_addr</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><call><name>arg_bit</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>A_IMMEDIATE</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>A_IMM16</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>*</operator> <literal type="number">256</literal> <operator>+</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>+</operator> <call><name>i8051_reg_read</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"_xdata"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></switch>

<switch>switch <condition>(<expr><name>arg2</name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<break>break;</break> <case>case <expr><name>A_DIRECT</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_RI</name> <operator>||</operator> <name>arg1</name> <operator>==</operator> <name>A_RN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>map_direct_addr</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>arg1</name> <operator>!=</operator> <name>A_DIRECT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>map_direct_addr</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break> <case>case <expr><name>A_BIT</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>arg_bit</name> <argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>arg1</name> <operator>==</operator> <name>A_RI</name> <operator>||</operator> <name>arg1</name> <operator>==</operator> <name>A_RN</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <call><name>map_direct_addr</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>A_IMMEDIATE</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>val</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>arg1</name> <operator>==</operator> <name>A_RI</name> <operator>||</operator> <name>arg1</name> <operator>==</operator> <name>A_RN</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr> </then><else>: <expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></switch>

<switch>switch<condition>(<expr><name><name>_8051_ops</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>instr</name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<break>break;</break> <case>case <expr><name>OP_PUSH</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>=</operator> <name>R_ANAL_STACK_INC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>OP_POP</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>=</operator> <name>R_ANAL_STACK_INC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>OP_RET</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>=</operator> <name>R_ANAL_STACK_INC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <operator>-</operator><literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break> <case>case <expr><name>OP_CALL</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>=</operator> <name>R_ANAL_STACK_INC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_ADDR11</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <call><name>arg_addr11</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_ADDR16</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <literal type="number">0x100</literal> <operator>*</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break> <case>case <expr><name>OP_JMP</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_ADDR11</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <call><name>arg_addr11</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_ADDR16</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <literal type="number">0x100</literal> <operator>*</operator> <name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>arg1</name> <operator>==</operator> <name>A_OFFSET</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <call><name>arg_offset</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>OP_CJNE</name></expr>:</case>

<case>case <expr><name>OP_DJNZ</name></expr>:</case>

<case>case <expr><name>OP_JC</name></expr>:</case>

<case>case <expr><name>OP_JNC</name></expr>:</case>

<case>case <expr><name>OP_JZ</name></expr>:</case>

<case>case <expr><name>OP_JNZ</name></expr>:</case>

<case>case <expr><name>OP_JB</name></expr>:</case>

<case>case <expr><name>OP_JBC</name></expr>:</case>

<case>case <expr><name>OP_JNB</name></expr>:</case>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>jump</name></name> <operator>=</operator> <call><name>arg_offset</name> <argument_list>(<argument><expr><name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>fail</name></name> <operator>=</operator> <name>addr</name> <operator>+</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>op</name><operator>-&gt;</operator><name>ptr</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>op</name><operator>-&gt;</operator><name>refptr</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>refptr</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>R_ANAL_OP_MASK_ESIL</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>copy</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>len</name> <operator>&gt;=</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><name>len</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>analop_esil</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>olen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>mnemonic</name></name> <operator>=</operator> <call><name>r_8051_disas</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>olen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>olen</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mask</name> <operator>&amp;</operator> <name>R_ANAL_OP_MASK_HINT</name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if></if_stmt>

<return>return <expr><name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><name>RAnalPlugin</name></type> <name>r_anal_plugin_8051</name> <init>= <expr><block>{

<expr><operator>.</operator><name>name</name> <operator>=</operator> <literal type="string">"8051"</literal></expr>,

<expr><operator>.</operator><name>arch</name> <operator>=</operator> <literal type="string">"8051"</literal></expr>,

<expr><operator>.</operator><name>esil</name> <operator>=</operator> <name>true</name></expr>,

<expr><operator>.</operator><name>bits</name> <operator>=</operator> <literal type="number">8</literal><operator>|</operator><literal type="number">16</literal></expr>,

<expr><operator>.</operator><name>desc</name> <operator>=</operator> <literal type="string">"8051 CPU code analysis plugin"</literal></expr>,

<expr><operator>.</operator><name>license</name> <operator>=</operator> <literal type="string">"LGPL3"</literal></expr>,

<expr><operator>.</operator><name>op</name> <operator>=</operator> <operator>&amp;</operator><name>i8051_op</name></expr>,

<expr><operator>.</operator><name>set_reg_profile</name> <operator>=</operator> <operator>&amp;</operator><name>set_reg_profile</name></expr>,

<expr><operator>.</operator><name>esil_init</name> <operator>=</operator> <name>esil_i8051_init</name></expr>,

<expr><operator>.</operator><name>esil_fini</name> <operator>=</operator> <name>esil_i8051_fini</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>R2_PLUGIN_INCORE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>R_API</name> <name>RLibStruct</name></type> <name>radare_plugin</name> <init>= <expr><block>{

<expr><operator>.</operator><name>type</name> <operator>=</operator> <name>R_LIB_TYPE_ANAL</name></expr>,

<expr><operator>.</operator><name>data</name> <operator>=</operator> <operator>&amp;</operator><name>r_anal_plugin_8051</name></expr>,

<expr><operator>.</operator><name>version</name> <operator>=</operator> <name>R2_VERSION</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
