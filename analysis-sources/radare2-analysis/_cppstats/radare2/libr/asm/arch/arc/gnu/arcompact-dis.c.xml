<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\asm\arch\arc\gnu\arcompact-dis.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ansidecl.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"disas-asm.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arc.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arc-ext.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arc-dis.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"arcompact-dis.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"elf-bfd.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_types.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bfd_vma</name></type> <name>bfd_getm32</name> <parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>int</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>bfd_vma</name></type> <name>bfd_getm32_ac</name> <argument_list>(<argument><expr><name>unsigned</name> <name>int</name></expr></argument>)</argument_list> <name>ATTRIBUTE_UNUSED</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dbg</name></cpp:macro> <cpp:value>(0)</cpp:value></cpp:define>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_NELEM</name></cpp:undef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_NELEM</name><parameter_list>(<parameter><type><name>ary</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sizeof(ary) / sizeof((ary)[0]))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIT</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((word) &amp; (1 &lt;&lt; (n)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BITS</name><parameter_list>(<parameter><type><name>word</name></type></parameter>,<parameter><type><name>s</name></type></parameter>,<parameter><type><name>e</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((word) &lt;&lt; (sizeof(word)*8-1 - (e))) &gt;&gt; ((s)+(sizeof(word)*8-1 - (e))))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPCODE</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 27, 31))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDA</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 0, 5))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDb</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 24, 26))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDB</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 12, 14))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 6, 11))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OPCODE_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 11, 15))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDA_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 0, 2))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDB_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 8, 10))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDC_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 5, 7))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDU_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS ((word), 0, 4))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDS_AC</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS (((signed int) (word)), 0, 8))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDD</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(BITS (((signed int) (word)), 16, 23))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDD9</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((BITS(((signed int)(word)),15,15) &lt;&lt; 8) | (BITS((word),16,23)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDS</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((BITS(((signed int)(word)),0,5) &lt;&lt; 6) | (BITS((word),6,11)))</cpp:value></cpp:define> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDS9</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((BITS(((signed int)(word)),15,15) &lt;&lt; 7) | (BITS((word),17,23))) &lt;&lt; 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELDS9_FLAG</name><parameter_list>(<parameter><type><name>word</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((BITS(((signed int)(word)),0,5) &lt;&lt; 6) | (BITS((word),6,11))) )</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PUT_NEXT_WORD_IN</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if (is_limm==1 &amp;&amp; !NEXT_WORD(1)) mwerror(state, "Illegal limm reference in last instruction!\n"); if (info-&gt;endian == BFD_ENDIAN_LITTLE) { (a) = ((state-&gt;words[1] &amp; 0xff00) | (state-&gt;words[1] &amp; 0xff)) &lt;&lt; 16; (a) |= ((state-&gt;words[1] &amp; 0xff0000) | (state-&gt;words[1] &amp; 0xff000000)) &gt;&gt; 16; } else { (a) = state-&gt;words[1]; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_NULLIFY</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do{ state-&gt;nullifyMode = BITS(state-&gt;words[0],5,5); }while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_COND_NULLIFY</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do { state-&gt;nullifyMode = BITS(state-&gt;words[0],5,5); cond = BITS(state-&gt;words[0],0,4); }while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FLAG_COND_NULLIFY</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>do{ if (is_shimm == 0) { flag = BIT(state-&gt;words[0],15); state-&gt;nullifyMode = BITS(state-&gt;words[0],5,5); cond = BITS(state-&gt;words[0],0,4); } }while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FLAG_COND</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ if (is_shimm == 0) { flag = BIT(state-&gt;words[0],15); cond = BITS(state-&gt;words[0],0,4); } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FLAG</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ flag = BIT(state-&gt;words[0],15); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_COND</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ if (is_shimm == 0) { cond = BITS(state-&gt;words[0],0,4); } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FIELD</name><parameter_list>(<parameter><type><name>field</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>{ if ((field) == 62) { is_limm++; field##isReg = 0; PUT_NEXT_WORD_IN(field); } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FIELD_A</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldA = FIELDA(state-&gt;words[0]); if (fieldA == 62) { fieldAisReg = 0; fieldA = 0; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_B</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldB = (FIELDB(state-&gt;words[0]) &lt;&lt; 3);fieldB |= FIELDb(state-&gt;words[0]); if (fieldB == 62) { fieldBisReg = 0; fieldB = 0; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_C</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = FIELDC(state-&gt;words[0]); if (fieldC == 62) { fieldCisReg = 0; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_U8</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = BITS(state-&gt;words[0],15,16);fieldC = fieldC &lt;&lt;6; fieldC |= FIELDC(state-&gt;words[0]); fieldCisReg = 0; }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FIELD_B</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldB = (FIELDB(state-&gt;words[0]) &lt;&lt; 3);fieldB |= FIELDb(state-&gt;words[0]); CHECK_FIELD(fieldB); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FIELD_C</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = FIELDC(state-&gt;words[0]); CHECK_FIELD(fieldC); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_C_S</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC_S = (FIELDC_S(state-&gt;words[0]) &lt;&lt; 3); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_B_S</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldB_S = (FIELDB_S(state-&gt;words[0]) &lt;&lt; 3); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_FIELD_H_AC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = ((FIELDA_AC(state-&gt;words[0])) &lt;&lt; 3); fieldC |= FIELDC_AC(state-&gt;words[0]); CHECK_FIELD(fieldC); }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_H_AC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = ((FIELDA_AC(state-&gt;words[0])) &lt;&lt; 3); fieldC |= FIELDC_AC(state-&gt;words[0]); if (fieldC &gt; 60) { fieldCisReg = 0; fieldC = 0; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_C_AC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldC = FIELDC_AC(state-&gt;words[0]); if (fieldC &gt; 3) { fieldC += 8; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_B_AC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldB = FIELDB_AC(state-&gt;words[0]); if (fieldB &gt; 3) { fieldB += 8; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIELD_A_AC</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{ fieldA = FIELDA_AC(state-&gt;words[0]); if (fieldA &gt; 3) { fieldA += 8; } }</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SMALL</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((field##x) &lt; 256) &amp;&amp; ((field##x) &gt; -257))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_REG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(field##x##isReg)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SIMD_128_REG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(usesSimdReg##x == 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SIMD_16_REG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(usesSimdReg##x == 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_SIMD_DATA_REG</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(usesSimdReg##x == 3)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_LB_Rx_RB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,"[","]","","")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_x_COMMA_LB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,"",", [","",",[")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_COMMA_x_RB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,", ","]",", ","]")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_x_RB</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,"","]","","]")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_COMMA_x</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,", ","",", ","")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_x_COMMA</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,"",", ","",", ")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_x</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>WRITE_FORMAT(x,"","","","")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>cb1</name></type></parameter>,<parameter><type><name>ca1</name></type></parameter>,<parameter><type><name>cb</name></type></parameter>,<parameter><type><name>ca</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>strcat(formatString, (IS_SIMD_128_REG(x) ? cb1"%S"ca1: IS_SIMD_16_REG(x) ? cb1"%I"ca1: IS_SIMD_DATA_REG(x)? cb1"%D"ca1: IS_REG(x) ? cb1"%r"ca1: usesAuxReg ? cb"%a"ca : IS_SMALL(x) ? cb"%d"ca : cb"%h"ca))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_LB</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>strcat(formatString, "[")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_FORMAT_RB</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>strcat(formatString, "]")</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_COMMENT</name><parameter_list>(<parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(state-&gt;comm[state-&gt;commNum++] = (str))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_NOP_COMMENT</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>if (!fieldAisReg &amp;&amp; !flag) WRITE_COMMENT("nop");</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_WORD</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(offset += 4, state-&gt;words[x])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEXT_WORD_AC</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(offset += 2, state-&gt;words[x])</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>add_target</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(state-&gt;targets[state-&gt;tcnt++] = (x))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>short</name> <name>int</name></type> <name>enable_simd</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>short</name> <name>int</name></type> <name>enable_insn_stream</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>core_reg_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>coreRegName</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name><name>state</name><operator>-&gt;</operator><name>coreRegName</name></name>) <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>_this</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>aux_reg_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>auxRegName</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name><name>state</name><operator>-&gt;</operator><name>auxRegName</name></name>) <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>_this</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>cond_code_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>condCodeName</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name><name>state</name><operator>-&gt;</operator><name>condCodeName</name></name>) <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>_this</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>instruction_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op1</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>op2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>instName</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call>(<modifier>*</modifier><name><name>state</name><operator>-&gt;</operator><name>instName</name></name>) <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>_this</name></name></expr></argument>, <argument><expr><name>op1</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>mwerror</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>msg</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>err</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>state</name><operator>-&gt;</operator><name>err</name></name>) <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>_this</name></name></expr></argument>, <argument><expr><operator>(</operator><name>msg</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>post_address</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>addr</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>id</name><index>[<expr><literal type="number">3</literal><operator>*</operator><call><name>_NELEM</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>addresses</name></name></expr></argument>)</argument_list></call></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>acnt</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <call><name>_NELEM</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>addresses</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>addresses</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name><name>state</name><operator>-&gt;</operator><name>acnt</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <name>i</name><operator>*</operator><literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>id</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'@'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>id</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'0'</literal><operator>+</operator><name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>id</name><index>[<expr><name>j</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>id</name><operator>+</operator><name>j</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="string">""</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>my_sprintf</name> <parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type><name>format</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>leading_zero</name></decl>, <decl><type ref="prev"/><name><name>regMap</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>bp</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>bp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regMap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>regMap</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <goto>goto <name>DOCOMM</name>;</goto> 

<default>default:</default>

<expr_stmt><expr><operator>*</operator><name>bp</name><operator>++</operator> <operator>=</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'%'</literal></expr>:</case>

<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>leading_zero</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<label><name>RETRY</name>:</label><empty_stmt>;</empty_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>p</name><operator>++</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<case>case <expr><literal type="char">'3'</literal></expr>:</case>

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<case>case <expr><literal type="char">'5'</literal></expr>:</case>

<case>case <expr><literal type="char">'6'</literal></expr>:</case>

<case>case <expr><literal type="char">'7'</literal></expr>:</case>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<case>case <expr><literal type="char">'9'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>leading_zero</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name>size</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="char">'0'</literal></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<goto>goto <name>RETRY</name>;</goto>

</block_content>}</block>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inc_bp</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>bp = bp+strlen(bp)</cpp:value></cpp:define>

<case>case <expr><literal type="char">'h'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>unsigned</name></type> <name>u</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CDT_DEBUG</name></cpp:macro></cpp:define>

<if_stmt><if>if <condition>(<expr><name>u</name> <operator>&gt;</operator> <literal type="number">65536</literal></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>CDT_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>bp</name></expr></argument>,<argument><expr><literal type="string">"0x%x_%04x"</literal></expr></argument>,<argument><expr><name>u</name> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><name>u</name> <operator>&amp;</operator> <literal type="number">0xffff</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>bp</name></expr></argument>,<argument><expr><literal type="string">"0x%08x"</literal></expr></argument>,<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"0x%x"</literal></expr></argument>, <argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'X'</literal></expr>:</case> <case>case <expr><literal type="char">'x'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>leading_zero</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%0*x"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%*x"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%x"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%*d"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REG2NAME</name><parameter_list>(<parameter><type><name>num</name></type></parameter>, <parameter><type><name>name</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>case num: sprintf(bp,""name); regMap[((num)&lt;32)?0:1] |= 1&lt;&lt;((num)-(((num)&lt;32)?0:32)); break;</cpp:value></cpp:define>

<switch>switch <condition>(<expr><name>val</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">26</literal></expr></argument>, <argument><expr><literal type="string">"gp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">27</literal></expr></argument>, <argument><expr><literal type="string">"fp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">28</literal></expr></argument>, <argument><expr><literal type="string">"sp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">29</literal></expr></argument>, <argument><expr><literal type="string">"ilink1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">30</literal></expr></argument>, <argument><expr><literal type="string">"ilink2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><literal type="string">"blink"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">60</literal></expr></argument>, <argument><expr><literal type="string">"lp_count"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>REG2NAME</name><argument_list>(<argument><expr><literal type="number">63</literal></expr></argument>, <argument><expr><literal type="string">"pcl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<default>default:</default>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>core_reg_name</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ext</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"r%d"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block><break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>arc_aux_reg_name</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ext</name></decl>;</decl_stmt>

<expr_stmt><expr><name>ext</name> <operator>=</operator> <call><name>aux_reg_name</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ext</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>ext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"%h"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>bp</name></expr></argument>,<argument><expr><literal type="string">"%s"</literal></expr></argument>,<argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>char</name><operator>*</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>inc_bp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

va_arg(ap,char*);

inc_bp();

break;

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:elif> 

<expr_stmt><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><specifier>extern</specifier> <name>void</name></type> <name>abort</name> <argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list></decl>;</decl_stmt>

<expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<case>case <expr><literal type="char">'S'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"vr%d"</literal></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>inc_bp</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'I'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"i%d"</literal></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>inc_bp</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'D'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>val</name> <init>= <expr><call><name>va_arg</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>,<argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>, <argument><expr><literal type="string">"dr%d"</literal></expr></argument>,<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>inc_bp</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,<argument><expr><literal type="string">"?? format %c\n"</literal></expr></argument>,<argument><expr><name><name>p</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></switch>

</block_content>}</block></while>

<label><name>DOCOMM</name>:</label>

<expr_stmt><expr><operator>*</operator><name>bp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>va_end</name> <argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>condName</name><index>[]</index></name> <init>=

<expr><block>{

<expr><literal type="string">""</literal></expr> , <expr><literal type="string">"z"</literal></expr> , <expr><literal type="string">"nz"</literal></expr> , <expr><literal type="string">"p"</literal></expr> , <expr><literal type="string">"n"</literal></expr> , <expr><literal type="string">"c"</literal></expr> , <expr><literal type="string">"nc"</literal></expr> , <expr><literal type="string">"v"</literal></expr> ,

<expr><literal type="string">"nv"</literal></expr> , <expr><literal type="string">"gt"</literal></expr> , <expr><literal type="string">"ge"</literal></expr> , <expr><literal type="string">"lt"</literal></expr> , <expr><literal type="string">"le"</literal></expr> , <expr><literal type="string">"hi"</literal></expr> , <expr><literal type="string">"ls"</literal></expr> , <expr><literal type="string">"pnz"</literal></expr>,

<expr><literal type="string">"ss"</literal></expr> , <expr><literal type="string">"sc"</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>write_instr_name_</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instrName</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>cond</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>condCodeIsPartOfName</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>flag</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>signExtend</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>addrWriteBack</name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>directMem</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><name>instrName</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cond</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>condlim</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>condCodeIsPartOfName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>condlim</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cond</name> <operator>&lt;</operator> <name>condlim</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <name><name>condName</name><index>[<expr><name>cond</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <call><name>cond_code_name</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>cond</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cc</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".d"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>signExtend</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>addrWriteBack</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".ab"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".as"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>directMem</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrBuffer</name></name></expr></argument>, <argument><expr><literal type="string">".di"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>write_instr_name</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>{write_instr_name_(state, instrName,cond, condCodeIsPartOfName, flag, signExtend, addrWriteBack, directMem); formatString[0] = '\0'; }</cpp:value></cpp:define>

<enum>enum

<block>{

<decl><name>op_BC</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><name>op_BLC</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><name>op_LD</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>, <decl><name>op_ST</name> <init>= <expr><literal type="number">3</literal></expr></init></decl>, <decl><name>op_MAJOR_4</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>,

<decl><name>op_MAJOR_5</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>, <decl><name>op_MAJOR_6</name> <init>= <expr><literal type="number">6</literal></expr></init></decl>, <decl><name>op_SIMD</name><init>=<expr><literal type="number">9</literal></expr></init></decl>, <decl><name>op_LD_ADD</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>, <decl><name>op_ADD_SUB_SHIFT</name> <init>= <expr><literal type="number">13</literal></expr></init></decl>,

<decl><name>op_ADD_MOV_CMP</name> <init>= <expr><literal type="number">14</literal></expr></init></decl>, <decl><name>op_S</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>, <decl><name>op_LD_S</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>, <decl><name>op_LDB_S</name> <init>= <expr><literal type="number">17</literal></expr></init></decl>,

<decl><name>op_LDW_S</name> <init>= <expr><literal type="number">18</literal></expr></init></decl>, <decl><name>op_LDWX_S</name> <init>= <expr><literal type="number">19</literal></expr></init></decl>, <decl><name>op_ST_S</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>, <decl><name>op_STB_S</name> <init>= <expr><literal type="number">21</literal></expr></init></decl>,

<decl><name>op_STW_S</name> <init>= <expr><literal type="number">22</literal></expr></init></decl>, <decl><name>op_Su5</name> <init>= <expr><literal type="number">23</literal></expr></init></decl>, <decl><name>op_SP</name> <init>= <expr><literal type="number">24</literal></expr></init></decl>, <decl><name>op_GP</name> <init>= <expr><literal type="number">25</literal></expr></init></decl>, <decl><name>op_Pcl</name> <init>= <expr><literal type="number">26</literal></expr></init></decl>,

<decl><name>op_MOV_S</name> <init>= <expr><literal type="number">27</literal></expr></init></decl>, <decl><name>op_ADD_CMP</name> <init>= <expr><literal type="number">28</literal></expr></init></decl>, <decl><name>op_BR_S</name> <init>= <expr><literal type="number">29</literal></expr></init></decl>, <decl><name>op_B_S</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>, <decl><name>op_BL_S</name> <init>= <expr><literal type="number">31</literal></expr></init></decl>

}</block>;</enum>

<decl_stmt><decl><type><specifier>extern</specifier> <name>disassemble_info</name></type> <name>tm_print_insn_info</name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bfd_vma</name></type>

<name>bfd_getm32</name> <parameter_list>(<parameter><decl><type><name>data</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>data</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>value</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff0000</literal><operator>)</operator> <operator>|</operator> <operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff000000</literal><operator>)</operator><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bfd_vma</name></type>

<name>bfd_getm32_ac</name> <parameter_list>(<parameter><decl><type><name>data</name></type></decl></parameter>)</parameter_list>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>data</name></decl>;</decl_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>value</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>value</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">8</literal> <operator>|</operator> <operator>(</operator><name>data</name> <operator>&amp;</operator> <literal type="number">0xff00</literal><operator>)</operator> <operator>&gt;&gt;</operator> <literal type="number">8</literal><operator>)</operator></expr>;</expr_stmt>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>sign_extend</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bits</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>BIT</name> <argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>(</operator><name>bits</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>value</name> <operator>|=</operator> <operator>(</operator><literal type="number">0xffffffff</literal> <operator>&lt;&lt;</operator> <name>bits</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>value</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>

<name>dsmOneArcInst</name> <parameter_list>(<parameter><decl><type><name>bfd_vma</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>arcDisState</name></name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>disassemble_info</name> <modifier>*</modifier></type> <name>info</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>subopcode</name></decl>, <decl><type ref="prev"/><name>mul</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>condCodeIsPartOfName</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>decodingClass</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>instrName</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fieldAisReg</name><init>=<expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>fieldBisReg</name><init>=<expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>fieldCisReg</name><init>=<expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fieldA</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>fieldB</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>fieldC</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flag</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>cond</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_shimm</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>is_limm</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>signExtend</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>addrWriteBack</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>directMem</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_linked</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>offset</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>usesAuxReg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>usesSimdRegA</name><init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>usesSimdRegB</name><init>=<expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>usesSimdRegC</name><init>=<expr><literal type="number">0</literal></expr></init></decl>,<decl><type ref="prev"/><name>simd_scale_u8</name><init>=<expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><operator>!</operator><name>E_ARC_MACH_A4</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>formatString</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_when_no_jump</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_mem_load</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>no_reg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg2</name></name> <operator>=</operator> <name>no_reg</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sourceType</name></name> <operator>=</operator> <name>ARC_UNDEFINED</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>instructionLen</name></name> <operator>==</operator> <literal type="number">4</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getm32</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>instructionLen</name></name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NEXT_WORD</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>=</operator> <call><name>OPCODE</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>NEXT_WORD_AC</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>=</operator> <call><name>OPCODE_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>mul</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>condCodeIsPartOfName</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>commNum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tcnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>acnt</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>noflow</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>op_BC</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"b"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">13</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>condCodeIsPartOfName</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_BLC</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">9</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bl"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">13</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>condCodeIsPartOfName</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"breq"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brne"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brlt"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brge"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brlo"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brhs"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">14</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bbit0"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">15</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bbit1"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (0[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (0[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_LD</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">6</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (0[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_ST</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">7</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">1</literal></expr></argument>,<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"st"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"stb"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"stw"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_MAJOR_4</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>,<argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"adc"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sbc"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"and"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"or"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bic"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"xor"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"max"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"min"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case>

<block>{<block_content>

<if_stmt><if>if<condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0x264a7000</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"nop"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mov"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">11</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"tst"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"cmp"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rcmp"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">14</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rsub"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">15</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bset"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bclr"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">17</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"btst"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">18</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bxor"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">19</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bmsk"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">20</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add1"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">21</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add2"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">22</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add3"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">23</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub1"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">24</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub2"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">25</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub3"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">30</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mpyw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">31</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mpyuw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">32</literal></expr>:</case>

<case>case <expr><literal type="number">33</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"j"</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">34</literal></expr>:</case>

<case>case <expr><literal type="number">35</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"jl"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>condCodeIsPartOfName</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">40</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lp"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">11</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>condCodeIsPartOfName</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">41</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"flag"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">42</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lr"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">43</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sr"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">47</literal></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> 

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lsr"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ror"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rrc"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sexb"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sexw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"extb"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"extw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"abs"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"not"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">11</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rlc"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ex"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt>

<break>break;</break> 

<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"llock"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">17</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"scond"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">34</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">63</literal></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">24</literal></expr></argument>,<argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sleep"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr> :</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>mach</name></name><operator>)</operator> <operator>==</operator> <name>ARC_MACH_ARC7</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"trap0"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"swi"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sync"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rtie"</literal></expr> ;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brk"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name><operator>=</operator><name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">17</literal></expr></argument>,<argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">24</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">25</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">26</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_load_len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (0[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>op_MAJOR_5</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>,<argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lsr"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ror"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mul64"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>mul</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mulu64"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>mul</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"adds"</literal></expr> ;</expr_stmt><break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"subs"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"divaw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">0xA</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asls"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">0xB</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asrs"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">0x28</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"addsdw"</literal></expr>;</expr_stmt><break>break;</break>

<case>case <expr><literal type="number">0x29</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"subsdw"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">47</literal></expr>:</case>

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"swap"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"norm"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sat16"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rnd16"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"abssw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"abss"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"negsw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"negs"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"normw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"swape"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator><name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_MAJOR_6</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">44</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">26</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"rtsc"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_SIMD</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>enable_simd</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">68</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld32"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name><operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name><operator>=</operator><literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">72</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld64"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">74</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld64w"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">70</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld32wl"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">66</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld32wh"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">76</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld128"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">78</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vld128r"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">38</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"SIMD"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">71</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_0"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">81</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_1"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">67</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_2"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">75</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_3"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">83</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_4"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">89</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_5"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">91</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_6"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">93</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst16_7"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">69</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst32_0"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">82</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst32_2"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">86</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst32_4"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">88</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst32_6"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">73</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst64"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr> ;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">77</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst128"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">37</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>simd_scale_u8</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">79</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vst128r"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">38</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"SIMD"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">80</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmvw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">84</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmvzw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">90</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmovw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">94</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmovzw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">85</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmvaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">95</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmovaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vaddw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vaddaw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbaddw"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">11</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsubw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsubaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbsubw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmulw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmulaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbmulw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbmulaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmulfw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmulfaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbmulfw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">15</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsummw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbrsubw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">23</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr7w"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr7aw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vaddsuw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vabsw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsignw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vupbw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vexch1"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vexch2"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vexch4"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vupsbw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdirun"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdorun"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdiwr"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">11</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdowr"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdird"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdord"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">63</literal></expr>:</case>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vrec"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vrecrun"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vrun"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vendrec"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vabsaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vupbaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vupsbaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">40</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">16</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">48</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrwi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrrwi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">59</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrsrwi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">18</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmaxw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmaxaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbmaxw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">19</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vminw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vminaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbminw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">14</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdifw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vdifaw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmrb"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">24</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vand"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vandaw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">25</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vor"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">26</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vxor"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vxoraw"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">27</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbic"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vbicaw"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vavb"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vavrb"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">28</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"veqw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">29</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vnew"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">30</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vlew"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">31</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vltw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">49</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrpwbi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vasrrpwbi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsr8"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsr8aw"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">37</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>sub_subopcode</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>sub_subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsr8i"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vsr8awi"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">41</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">20</literal></expr>:</case>

<case>case <expr><literal type="number">21</literal></expr>:</case>

<case>case <expr><literal type="number">22</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>short</name></type> <name>subopcode2</name> <init>= <expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>, <argument><expr><literal type="number">18</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>subopcode2</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr1w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr2w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr3w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr4w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr5w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr6w"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr1aw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr2aw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr3aw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr4aw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr5aw"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">11</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vmr6aw"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<block>{<block_content>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">19</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">15</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vh264ft"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">14</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vh264f"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vvc1ft"</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vvc1f"</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">42</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">92</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vd6tapf"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">39</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">55</literal></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"vinti"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">43</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesSimdRegA</name> <operator>=</operator> <name>usesSimdRegB</name> <operator>=</operator> <name>usesSimdRegC</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"SIMD"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"???_SIMD"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>op_LD_ADD</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">15</literal></expr>;</expr_stmt> 

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_ADD_SUB_SHIFT</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">16</literal></expr>;</expr_stmt> 

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_ADD_MOV_CMP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">17</literal></expr>;</expr_stmt> 

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mov_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"cmp_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">18</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_S</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt> 

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">27</literal></expr>;</expr_stmt>

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"j_s"</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">2</literal></expr> :</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"jl_s"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_when_no_jump</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr> :</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"j_s.d"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="number">3</literal></expr> :</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"jl_s.d"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_always</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">6</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub_s.ne"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">35</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr> :</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt>

<switch>switch<condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"nop_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"unimp_s"</literal></expr>;</expr_stmt><break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"jeq_s [blink]"</literal></expr>;</expr_stmt>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"jne_s [blink]"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"j_s [blink]"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_when_no_jump</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"j_s.d [blink]"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_always</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"and_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"or_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bic_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr> :</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"xor_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">11</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"tst_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mul64_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>mul</name> <operator>=</operator><literal type="number">1</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sexb_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">14</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sexw_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">15</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"extb_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">16</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"extw_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">17</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"abs_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">18</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"not_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">19</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"neg_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">20</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add1_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">21</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add2_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">22</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add3_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">24</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">25</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lsr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">26</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">27</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">28</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">29</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lsr_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">30</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"trap_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">33</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">31</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brk_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_LD_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_LDB_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_LDW_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_LDWX_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw_s.x"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_ST_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"st_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_STB_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"stb_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_STW_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"stw_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_Su5</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">23</literal></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asl_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"lsr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"asr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bset_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bclr_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bmsk_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"btst_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_SP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">19</literal></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"st_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"stb_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"sub_s"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"pop_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"push_s"</literal></expr>;</expr_stmt> <expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"??? (2[3])"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_GP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">20</literal></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldb_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ldw_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_Pcl</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ld_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">29</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_MOV_S</name></expr>:</case>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"mov_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">30</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_ADD_CMP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">21</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"cmp_s"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"add_s"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>op_BR_S</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"brne_s"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"breq_s"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_B_S</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"b_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"beq_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bne_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bgt_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bge_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"blt_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"ble_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bhi_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bhs_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"blo_s"</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bls_s"</literal></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><name>op_BL_S</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">24</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"bl_s"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>isBranch</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name><operator>=</operator><name>invalid_instr</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>==</operator> <name>invalid_instr</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_SIMD</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>enable_simd</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <call><name>instruction_name</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name></expr></argument>,

<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>instructionLen</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name>flags</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>AC_SYNTAX_3OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">22</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_2OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">14</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_1OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">36</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_NOP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>mwerror</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"Invalid syntax class\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<switch>switch <condition>(<expr><name>flags</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>AC_SYNTAX_3OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_2OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_1OP</name></expr>:</case>

<expr_stmt><expr><name>decodingClass</name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_NOP</name></expr>:</case>

<break>break;</break>

<case>case <expr><name>AC_SYNTAX_SIMD</name></expr>:</case>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>mwerror</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"Invalid syntax class\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instrName</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name><operator>=</operator><name>invalid_instr</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <name>fieldBisReg</name> <operator>=</operator> <name>fieldCisReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>cond</name> <operator>=</operator> <name>is_shimm</name> <operator>=</operator> <name>is_limm</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <name>BR_exec_when_no_jump</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>signExtend</name> <operator>=</operator> <name>addrWriteBack</name> <operator>=</operator> <name>directMem</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>usesAuxReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>decodingClass</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>subopcode</name></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_limm</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldBisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_limm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <name>fieldA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_limm</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <name>fieldA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>fieldC</name> <operator>==</operator> <literal type="number">62</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>CHECK_FLAG_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_limm</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldBisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CHECK_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mul</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CHECK_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>flag</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldC</name> <operator>==</operator> <literal type="number">29</literal> <operator>||</operator> <name>fieldC</name> <operator>==</operator> <literal type="number">31</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>CHECK_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>nullifyMode</name></name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldCisReg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name>is_linked</name></expr> ?</condition><then> <expr><name>direct_call</name></expr> </then><else>: <expr><name>direct_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name>is_linked</name></expr> ?</condition><then> <expr><name>indirect_call</name></expr> </then><else>: <expr><name>indirect_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>register_for_indirect_jump</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>,

<argument><expr><ternary><condition><expr><call><name>IS_REG</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>?</condition><then><expr><literal type="string">"[%r]"</literal></expr></then><else>:<expr><literal type="string">"%s"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>IS_REG</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>,

<argument><expr><call><name>post_address</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>FIELDA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">62</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"prefetch"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_limm</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dbg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"5:b reg %d %d c reg %d %d \n"</literal></expr></argument>,

<argument><expr><name>fieldBisReg</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldCisReg</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldBisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg2</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_mem_load</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>directMem</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (fieldBisReg &amp;&amp; (fieldB != 62))

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>addrWriteBack</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>signExtend</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_REG</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">"%*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_LB</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldBisReg</name> <operator>||</operator> <name>fieldB</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">6</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if<condition>(<expr><call><name>FIELDA</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">62</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>instrName</name> <operator>=</operator> <literal type="string">"prefetch"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDD9</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dbg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"6:b reg %d %d c 0x%x \n"</literal></expr></argument>,

<argument><expr><name>fieldBisReg</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_mem_load</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldBisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>directMem</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">11</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldBisReg</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>fieldB</name> <operator>!=</operator> <literal type="number">62</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addrWriteBack</name> <operator>=</operator> <call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>signExtend</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_REG</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name> <argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strcat</name> <argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">"%*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_LB</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldBisReg</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_RB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">7</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>source_operand</name><operator>.</operator><name>registerNum</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>sourceType</name></name> <operator>=</operator> <ternary><condition><expr><name>fieldCisReg</name></expr> ?</condition><then> <expr><name>ARC_REGISTER</name></expr> </then><else>: <expr><name>ARC_LIMM</name></expr></else></ternary></expr> ;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>FIELDD9</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>fieldAisReg</name><operator>=</operator><literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dbg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"7:b reg %d %x off %x\n"</literal></expr></argument>,

<argument><expr><name>fieldBisReg</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>=</operator> <name>fieldA</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldBisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_offset</name></name> <operator>+=</operator> <name>fieldB</name></expr><operator>,</operator> <expr><name><name>state</name><operator>-&gt;</operator><name>_ea_present</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>directMem</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>addrWriteBack</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldA</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_RB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">8</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>is_limm</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>usesAuxReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_RB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">9</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_limm</name> <operator>||</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <name>fieldA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>FIELDS9</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_NULLIFY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name></expr> ?</condition><then> <expr><name>direct_call</name></expr> </then><else>: <expr><name>direct_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><call><name>post_address</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">10</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>usesAuxReg</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_RB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">11</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldC</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name></expr> ?</condition><then> <expr><name>direct_call</name></expr> </then><else>: <expr><name>direct_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><call><name>post_address</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">12</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>subopcode</name> <operator>=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <operator>(</operator><operator>(</operator><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>subopcode</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FLAG_COND</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FLAG</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BC</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>|=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>,<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldA</name> <operator>&lt;&lt;</operator> <literal type="number">9</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>|=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">18</literal></expr></argument>,<argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldA</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldA</name> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>|=</operator> <call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">17</literal></expr></argument>,<argument><expr><literal type="number">26</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldA</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BC</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator> <operator>||</operator>

<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>sign_extend</name> <argument_list>(<argument><expr><name>fieldA</name></expr></argument>, <argument><expr><literal type="number">25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>sign_extend</name> <argument_list>(<argument><expr><name>fieldA</name></expr></argument>, <argument><expr><literal type="number">21</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3</literal><operator>)</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_NULLIFY</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else

if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name> <operator>&amp;&amp;</operator> <call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BC</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>BIT</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_NULLIFY</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>CHECK_COND_NULLIFY</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BLC</name></expr> 

?</condition><then> <expr><name>direct_call</name></expr>

</then><else>: <expr><name>direct_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><call><name>post_address</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">14</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mul</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldAisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name> <argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mul</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">15</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_A_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">16</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>FIELDA_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">17</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_H_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">18</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_H_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_H_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">3</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">19</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>FIELD_B_AC</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldB</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <literal type="number">28</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <operator>(</operator><call><name>FIELDU_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">4</literal></expr>:</case>

<case>case <expr><literal type="number">5</literal></expr>:</case>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">20</literal></expr>:</case>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <literal type="number">26</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDS_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="number">3</literal></expr>:</case>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldC</name> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldC</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">21</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_Su5</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">22</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">23</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDU_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">24</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BL_S</name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>sign_extend</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>, <argument><expr><literal type="number">13</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<if type="elseif">else if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">9</literal></expr></argument>,<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">3</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>sign_extend</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <call><name>sign_extend</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name> <operator>==</operator> <name>op_BL_S</name></expr> 

?</condition><then> <expr><name>direct_call</name></expr>

</then><else>: <expr><name>direct_jump</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><call><name>post_address</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">25</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">6</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>sign_extend</name> <argument_list>(<argument><expr><name>fieldC</name></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>&amp;</operator> <operator>~</operator><literal type="number">0x3</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <name>fieldAisReg</name> <operator>=</operator> <name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>add_target</name><argument_list>(<argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>flow</name></name> <operator>=</operator> <name>direct_jump</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>, <argument><expr><literal type="string">",%s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><call><name>post_address</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">26</literal></expr>:</case>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">27</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>,<argument><expr><literal type="string">"[%r]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">28</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_C_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>_opcode</name></name></expr>)</condition>

<block>{<block_content>

<case>case <expr><name>op_LD_S</name></expr> :</case>

<case>case <expr><name>op_ST_S</name></expr> :</case>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>FIELDU_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_LDB_S</name></expr> :</case>

<case>case <expr><name>op_STB_S</name></expr> :</case>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>FIELDU_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>op_LDW_S</name></expr> :</case>

<case>case <expr><name>op_LDWX_S</name></expr> :</case>

<case>case <expr><name>op_STW_S</name></expr> :</case>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>FIELDU_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_RB</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">29</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <literal type="number">63</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldA</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldAisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">30</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <operator>(</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">31</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">17</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <literal type="number">31</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">32</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>BITS</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">22</literal></expr></argument>,<argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fieldC</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name> <argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name> <argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">33</literal></expr>:</case>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <call><name>FIELDC_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <call><name>FIELDB_AC</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>fieldBisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>,<argument><expr><literal type="string">"%d"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>,<argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>,<argument><expr><name>formatString</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>fieldB</name> <operator>&lt;&lt;</operator> <literal type="number">3</literal><operator>)</operator> <operator>|</operator> <name>fieldC</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">34</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>directMem</name> <operator>=</operator> <call><name>BIT</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,<argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">22</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fieldCisReg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>ea_reg1</name></name> <operator>=</operator> <name>fieldC</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">35</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>formatString</name></expr></argument>,<argument><expr><literal type="string">"%r,%r,%r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">36</literal></expr>:</case>

<expr_stmt><expr><call><name>FIELD_B_AC</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">44</literal></expr>:</case>

<expr_stmt><expr><name>fieldB</name> <operator>=</operator> <name>fieldBisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>,

<argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">37</literal></expr>:</case>

<case>case <expr><literal type="number">39</literal></expr>:</case>

<case>case <expr><literal type="number">41</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>decodingClass</name> <operator>==</operator> <literal type="number">41</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><call><name>FIELD_U8</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>simd_scale_u8</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldC</name> <operator>=</operator> <name>fieldC</name> <operator>&lt;&lt;</operator> <name>simd_scale_u8</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><ternary><condition><expr><name>decodingClass</name> <operator>==</operator> <literal type="number">37</literal></expr> ?</condition><then> <expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr> </then><else>:

<expr><call><name>WRITE_FORMAT_x_COMMA</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><ternary><condition><expr><name>decodingClass</name> <operator>==</operator> <literal type="number">37</literal></expr> ?</condition><then> <expr><call><name>WRITE_FORMAT_x_RB</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></then><else>:

<expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>,<argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">38</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_COMMA_LB</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x_RB</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_NOP_COMMENT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>,<argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">40</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">42</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_A</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>CHECK_FIELD_B</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>A</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>B</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_COMMA_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldA</name></expr></argument>, <argument><expr><name>fieldB</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">43</literal></expr>:</case>

<expr_stmt><expr><call><name>CHECK_FIELD_C</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>BITS</name> <argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><literal type="number">23</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">55</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fieldCisReg</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>write_instr_name</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>WRITE_FORMAT_x</name><argument_list>(<argument><expr><name>C</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>my_sprintf</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>operandBuffer</name></name></expr></argument>, <argument><expr><name>formatString</name></expr></argument>, <argument><expr><name>fieldC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>mwerror</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="string">"Bad decoding class in ARC disassembler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>_cond</name></name> <operator>=</operator> <name>cond</name></expr>;</expr_stmt>

<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>instructionLen</name></name> <operator>=</operator> <name>offset</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>_coreRegName</name>

<parameter_list>(

<parameter><decl><type><name>void</name> <modifier>*</modifier><name>_this</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter> 

)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>arcExtMap_coreRegName</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>_auxRegName</name>

<parameter_list>( <parameter><decl><type><name>void</name> <modifier>*</modifier><name>_this</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter> 

)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>arcExtMap_auxRegName</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>_condCodeName</name>

<parameter_list>(

<parameter><decl><type><name>void</name> <modifier>*</modifier><name>_this</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter> 

)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>arcExtMap_condCodeName</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>

<name>_instName</name>

<parameter_list>(

<parameter><decl><type><name>void</name> <modifier>*</modifier><name>_this</name></type> <name>ATTRIBUTE_UNUSED</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>op1</name></decl></parameter>, 

<parameter><decl><type><name>int</name></type> <name>op2</name></decl></parameter>, 

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>flags</name></decl></parameter> 

)</parameter_list>

<block>{<block_content>

<return>return <expr><call><name>arcExtMap_instName</name><argument_list>(<argument><expr><name>op1</name></expr></argument>, <argument><expr><name>op2</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>

<name>parse_disassembler_options</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>options</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt> 

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>options</name></expr>;</init> <condition><expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr/>)</control>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>CONST_STRNEQ</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"simd"</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>enable_simd</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>CONST_STRNEQ</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"insn-stream"</literal></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name>enable_insn_stream</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><name>int</name></type>

<name>ARCompact_decodeInstr</name> <parameter_list>(<parameter><decl><type><name>bfd_vma</name></type> <name>address</name></decl></parameter>, 

<parameter><decl><type><name>disassemble_info</name><modifier>*</modifier></type> <name>info</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bfd_byte</name></type> <name><name>buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>arcDisState</name></name></type> <name>s</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>stream</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>stream</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>fprintf_ftype</name></type> <name>func</name> <init>= <expr><name><name>info</name><operator>-&gt;</operator><name>fprintf_func</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lowbyte</name></decl>, <decl><type ref="prev"/><name>highbyte</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>disassembler_options</name></name></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>parse_disassembler_options</name> <argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>disassembler_options</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>disassembler_options</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>lowbyte</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>highbyte</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcDisState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>memory_error_func</name></name>) <argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0x38</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x48</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>buffer</name><index>[<expr><name>highbyte</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>memory_error_func</name></name>) <argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>_this</name></name> <operator>=</operator> <operator>&amp;</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>coreRegName</name></name> <operator>=</operator> <name>_coreRegName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>auxRegName</name></name> <operator>=</operator> <name>_auxRegName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>condCodeName</name></name> <operator>=</operator> <name>_condCodeName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instName</name></name> <operator>=</operator> <name>_instName</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>dsmOneArcInst</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>instr</name> <init>= <expr><name><name>s</name><operator>.</operator><name>instrBuffer</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>operand</name> <init>= <expr><name><name>s</name><operator>.</operator><name>operandBuffer</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>space</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>instr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>enable_insn_stream</name></expr>)</condition>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" %04x "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">"%08x "</literal></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>space</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>operand</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>space</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>operand</name> <operator>=</operator> <name>space</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><name>instr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>__TRANSLATION_REQUIRED</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>

<block>{<block_content>

<decl_stmt><decl><type><name>bfd_vma</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmpBuffer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>operand</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'@'</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>operand</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tmpBuffer</name> <operator>=</operator> <call><name>strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,<argument><expr><literal type="string">"@"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tmpBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>tmpBuffer</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>s</name><operator>.</operator><name>addresses</name><index>[<expr><name><name>operand</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="char">'0'</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>print_address_func</name></name>) <argument_list>(<argument><expr><operator>(</operator><name>bfd_vma</name><operator>)</operator> <name>addr</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name>func</name>) <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>operand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>bytes_per_line</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

<return>return <expr><name>bytes</name></expr>;</return> 

</block_content>}</block></function>

<function><type><name><name>struct</name> <name>arcDisState</name></name></type>

<name>arcAnalyzeInstr</name>

<parameter_list>(

<parameter><decl><type><name>bfd_vma</name></type> <name>address</name></decl></parameter>, 

<parameter><decl><type><name>disassemble_info</name><modifier>*</modifier></type> <name>info</name></decl></parameter>

)</parameter_list>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>status</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bfd_byte</name></type> <name><name>buffer</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>arcDisState</name></name></type> <name>s</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lowbyte</name></decl>, <decl><type ref="prev"/><name>highbyte</name></decl>;</decl_stmt>

<expr_stmt><expr><name>lowbyte</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>highbyte</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>arcDisState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>memory_error_func</name></name>) <argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>address</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>&gt;</operator> <literal type="number">0x38</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&amp;</operator> <literal type="number">0xf8</literal><operator>)</operator> <operator>!=</operator> <literal type="number">0x48</literal><operator>)</operator></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name><name>buffer</name><index>[<expr><name>lowbyte</name></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal><operator>)</operator> <operator>|</operator> <name><name>buffer</name><index>[<expr><name>highbyte</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if>

<else>else

<block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>buffer</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>status</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>

<block>{<block_content>

<expr_stmt><expr><call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>memory_error_func</name></name>) <argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>address</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instructionLen</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>status</name> <operator>=</operator> <call>(<modifier>*</modifier><name><name>info</name><operator>-&gt;</operator><name>read_memory_func</name></name>) <argument_list>(<argument><expr><name>address</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>endian</name></name> <operator>==</operator> <name>BFD_ENDIAN_LITTLE</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getl32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>words</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>bfd_getb32</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>_this</name></name> <operator>=</operator> <operator>&amp;</operator><name>s</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>coreRegName</name></name> <operator>=</operator> <name>_coreRegName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>auxRegName</name></name> <operator>=</operator> <name>_auxRegName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>condCodeName</name></name> <operator>=</operator> <name>_condCodeName</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>s</name><operator>.</operator><name>instName</name></name> <operator>=</operator> <name>_instName</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>dsmOneArcInst</name><argument_list>(<argument><expr><name>address</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>info</name><operator>-&gt;</operator><name>bytes_per_line</name></name> <operator>=</operator> <name>bytes</name></expr>;</expr_stmt>

<return>return <expr><name>s</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type>

<name>arc_print_disassembler_options</name> <parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>stream</name></decl></parameter>)</parameter_list>

<block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">"\n\

ARC-specific disassembler options:\n\

use with the -M switch, with options separated by commas\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" insn-stream Show the instruction byte stream from most\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" significant byte to least significant byte (excluding LIMM).\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" This option is useful for viewing the actual encoding of instructions.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><literal type="string">" simd Enable SIMD instructions disassembly.\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

</unit>
