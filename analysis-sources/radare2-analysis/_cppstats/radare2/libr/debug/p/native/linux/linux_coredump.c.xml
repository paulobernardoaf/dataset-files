<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\debug\p\native\linux\linux_coredump.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_debug.h&gt;</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>DEBUGGER</name></expr></cpp:if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name> <operator>||</operator> <name>__i386__</name> <operator>||</operator> <name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/uio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/ptrace.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;asm/ptrace.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"linux_coredump.h"</cpp:file></cpp:include>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<typedef>typedef <type><name>Elf64_auxv_t</name></type> <name>elf_auxv_t</name>;</typedef>

<typedef>typedef <type><name>Elf64_Ehdr</name></type> <name>elf_hdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf64_Phdr</name></type> <name>elf_phdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf64_Shdr</name></type> <name>elf_shdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf64_Nhdr</name></type> <name>elf_nhdr_t</name>;</typedef>

<typedef>typedef <type><name>ut32</name></type> <name>elf_offset_t</name>;</typedef>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__arm__</name></expr></cpp:elif>

<typedef>typedef <type><name>Elf32_auxv_t</name></type> <name>elf_auxv_t</name>;</typedef>

<typedef>typedef <type><name>Elf32_Ehdr</name></type> <name>elf_hdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf32_Phdr</name></type> <name>elf_phdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf32_Shdr</name></type> <name>elf_shdr_t</name>;</typedef>

<typedef>typedef <type><name>Elf32_Nhdr</name></type> <name>elf_nhdr_t</name>;</typedef>

<typedef>typedef <type><name>ut64</name></type> <name>elf_offset_t</name>;</typedef>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fmt_addr</name></cpp:macro> <cpp:value>"%08lx-%08lx"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ELF_HDR_SIZE</name></cpp:macro> <cpp:value>sizeof(elf_hdr_t)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>round_up</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((((a) + (4) - (1)) / (4)) * (4))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>sizeof_round_up</name><parameter_list>(<parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>round_up(sizeof(b))</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <name>map_file_t</name></type> <name>mapping_file</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>note_info_t</name></type> <name><name>note_info</name><index>[<expr><name>NT_LENGHT_T</name></expr>]</index></name></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_a_kernel_mapping</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><operator>(</operator><name>name</name>

<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[vdso]"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[vsyscall]"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[vvar]"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[heap]"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[vectors]"</literal></expr></argument>)</argument_list></call>

<operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"[stack"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"[stack"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>prpsinfo_get_psargs</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>paux</name><index>[<expr><name>ELF_PRARGSZ</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>bytes_left</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>r_mem_dup</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buffer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <name>bytes_left</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>+</operator> <name>bytes_left</name> <operator>&lt;</operator> <name>ELF_PRARGSZ</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>paux</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>paux</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>paux</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>bytes_left</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prpsinfo_t</name> <modifier>*</modifier></type><name>linux_get_prpsinfo</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>proc_per_process_t</name> <modifier>*</modifier></type><name>proc_data</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prog_states</name> <init>= <expr><literal type="string">"RSDTZW"</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>basename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pfname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ppsargs</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>prpsinfo_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>pid_t</name></type> <name>mypid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>prpsinfo_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Couldn't allocate memory for prpsinfo_t\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_pid</name></name> <operator>=</operator> <name>mypid</name> <operator>=</operator> <name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/cmdline"</literal></expr></argument>, <argument><expr><name>mypid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buffer</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buffer</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"buffer NULL\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>pfname</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pfname</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>basename</name> <operator>=</operator> <call><name>r_file_basename</name> <argument_list>(<argument><expr><name>pfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_fname</name></name></expr></argument>, <argument><expr><name>basename</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_fname</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_fname</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_fname</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>ppsargs</name> <operator>=</operator> <call><name>prpsinfo_get_psargs</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ppsargs</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_psargs</name></name></expr></argument>, <argument><expr><name>ppsargs</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_psargs</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_psargs</name><index>[<expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_psargs</name></name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ppsargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sname</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>s_name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_zomb</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>pr_sname</name></name> <operator>==</operator> <literal type="char">'Z'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_state</name></name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>prog_states</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sname</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>prog_states</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_ppid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>ppid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_pgrp</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>pgrp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>sid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_flag</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>flag</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_nice</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>nice</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_uid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>uid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_gid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>gid</name></name></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

<label><name>error</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pfname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ppsargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>proc_per_thread_t</name> <modifier>*</modifier></type><name>get_proc_thread_content</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_p_sigpend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp_p_sighold</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_sigpend</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_sighold</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>file</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/task/%d/stat"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>proc_per_thread_t</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>proc_per_thread_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>no_str</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name> <name>unsigned</name> <name>int</name></type> <name>no_lui</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>no_num</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name>no_char</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>no_ui</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%d %s %c %d %d %d %d %d %u %lu %lu %lu %lu"</literal>

<literal type="string">"%"</literal><name>PFMT64x</name><literal type="string">" %"</literal><name>PFMT64x</name><literal type="string">" %ld %lu"</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><name>no_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_char</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_ui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>utime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>stime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>cutime</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>t</name><operator>-&gt;</operator><name>cstime</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/task/%d/status"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>temp_p_sigpend</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"SigPnd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>temp_p_sighold</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"SigBlk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>temp_p_sigpend</name> <operator>||</operator> <operator>!</operator><name>temp_p_sighold</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_sigpend</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name>p_sigpend</name> <operator>=</operator> <name>temp_p_sigpend</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_sigpend</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name><name>p_sigpend</name><index>[<expr><name>temp_p_sigpend</name> <operator>-</operator> <name>p_sigpend</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_sighold</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name>p_sighold</name> <operator>=</operator> <name>temp_p_sighold</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_sighold</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name><name>p_sighold</name><index>[<expr><name>temp_p_sighold</name> <operator>-</operator> <name>p_sighold</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>sigpend</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>p_sigpend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>t</name><operator>-&gt;</operator><name>sighold</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>p_sighold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>t</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>prstatus_t</name> <modifier>*</modifier></type><name>linux_get_prstatus</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>proc_content_t</name> <modifier>*</modifier></type><name>proc_data</name></decl></parameter>, <parameter><decl><type><name>short</name> <name>int</name></type> <name>signr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>elf_gregset_t</name></type> <name>regs</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>prstatus_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name></name> <operator>=</operator> <call><name>get_proc_thread_content</name> <argument_list>(<argument><expr><name>pid</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>prstatus_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_cursig</name></name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>pr_info</name><operator>.</operator><name>si_signo</name></name> <operator>=</operator> <name>signr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_pid</name></name> <operator>=</operator> <name>tid</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_ppid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>ppid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_pgrp</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>pgrp</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sid</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>sid</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sigpend</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>sigpend</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_sighold</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>sighold</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_utime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>utime</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_utime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>utime</name></name> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_stime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>stime</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_stime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>stime</name></name> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_cutime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>cutime</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_cutime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>cutime</name></name> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_cstime</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>cstime</name></name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>pr_cstime</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <operator>(</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name><operator>-&gt;</operator><name>cstime</name></name> <operator>%</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETREGS</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"PTRACE_GETREGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>pr_reg</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>regs</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>regs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>elf_fpregset_t</name> <modifier>*</modifier></type><name>linux_get_fp_regset</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>elf_fpregset_t</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>elf_fpregset_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETFPREGS</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"PTRACE_GETFPREGS"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>siginfo_t</name> <modifier>*</modifier></type><name>linux_get_siginfo</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>siginfo_t</name> <modifier>*</modifier></type><name>siginfo</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>siginfo_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>siginfo</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETSIGINFO</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>r_ptrace_data_t</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><name>siginfo</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <operator>!</operator><name><name>siginfo</name><operator>-&gt;</operator><name>si_signo</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"PTRACE_GETSIGINFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>siginfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>siginfo</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_map_deleted_part</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>deleted_str</name><index>[]</index></name> <init>= <expr><literal type="string">"(deleted)"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len_name</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len_suffx</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>deleted_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>name</name> <operator>+</operator> <name>len_name</name> <operator>-</operator> <name>len_suffx</name></expr></argument>, <argument><expr><name>deleted_str</name></expr></argument>, <argument><expr><name>len_suffx</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>getAnonymousValue</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>keyw</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keyw</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>keyw</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>keyw</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keyw</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>keyw</name> <operator>&amp;&amp;</operator> <call><name>isspace</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>keyw</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>keyw</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><operator>*</operator><name>keyw</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>keyw</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>isAnonymousKeyword</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pp</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pp</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>keyw</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="string">"Anonymous:"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>keyw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>keyw</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><literal type="string">"AnonHugePages:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>keyw</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>has_map_anonymous_content</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff_smaps</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>start_addr</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>end_addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>extern_tok</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>keyw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>identity</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><name>fmt_addr</name></expr></argument>, <argument><expr><name>start_addr</name></expr></argument>, <argument><expr><name>end_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_anonymous</name></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>pp</name></expr> ;</condition> <incr><expr><name>pp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>keyw</name> <operator>=</operator> <call><name>isAnonymousKeyword</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_anonymous</name> <operator>=</operator> <call><name>getAnonymousValue</name> <argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>is_anonymous</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_this_map</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buff_smaps</name></decl></parameter>, <parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>filter_flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ppp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>extern_tok</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flags_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>identity</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><name>fmt_addr</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>aux</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name>vmflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>perms</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>perms</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>identity</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><name>perms</name> <operator>&amp;</operator> <name>R_PERM_R</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>perms</name> <operator>&amp;</operator> <name>R_PERM_W</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aux</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>aux</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>aux</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>pp</name></expr> ;</condition> <incr><expr><name>pp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ppp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init>;</init> <condition><expr><name>ppp</name></expr> ;</condition> <incr><expr><name>ppp</name> <operator>=</operator> <call><name>strtok_r</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>extern_tok</name></expr></argument>)</argument_list></call></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags_str</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>ppp</name></expr></argument>, <argument><expr><literal type="string">"VmFlags:"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>file_backed</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_FILE_PRIV</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_FILE_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flags_str</name> <operator>||</operator> <operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>kernel_mapping</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>perms</name> <operator>&amp;</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>shared</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_ANON_PRIV</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>anonymous</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_PRIV</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>anonymous</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>perms</name> <operator>&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>shared</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_ANON_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>flags_str</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>flags_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>flags_str</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><operator>*</operator><name>flags_str</name><operator>++</operator> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name>flags_str</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>flags_str</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"sh"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vmflags</name> <operator>|=</operator> <name>SH_FLAG</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"io"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vmflags</name> <operator>|=</operator> <name>IO_FLAG</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"ht"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vmflags</name> <operator>|=</operator> <name>HT_FLAG</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"dd"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vmflags</name> <operator>|=</operator> <name>DD_FLAG</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>vmflags</name> <operator>&amp;</operator> <name>SH_FLAG</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vmflags</name> <operator>|=</operator> <name>PV_FLAG</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>vmflags</name> <operator>&amp;</operator> <name>DD_FLAG</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>vmflags</name> <operator>&amp;</operator> <name>IO_FLAG</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>kernel_mapping</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vmflags</name> <operator>&amp;</operator> <name>HT_FLAG</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_PRIV</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>anonymous</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vmflags</name> <operator>&amp;</operator> <name>SH_FLAG</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_ANON_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_SHR</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vmflags</name> <operator>&amp;</operator> <name>PV_FLAG</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_ANON_PRIV</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>anonymous</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>filter_flags</name> <operator>&amp;</operator> <name>MAP_HUG_PRIV</name><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>anonymous</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<label><name>fail</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>identity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>clean_maps</name><parameter_list>(<parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>h</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>aux</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>h</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>aux</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>aux</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>linux_map_entry_t</name> <modifier>*</modifier></type><name>linux_get_mapped_files</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>ut8</name></type> <name>filter_flags</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>me_head</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>me_tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>is_anonymous</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>is_deleted</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buff_maps</name><init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>buff_smaps</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size_file</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/smaps"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff_smaps</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff_smaps</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/maps"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff_maps</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size_file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff_maps</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>pmentry</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>linux_map_entry_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pmentry</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>error</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>start_addr</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>end_addr</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <ternary><condition><expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"unk"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"unk"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>

?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>perms</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>shared</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>shared</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>kernel_mapping</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <call><name>is_a_kernel_mapping</name> <argument_list>(<argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>anonymous</name></name> <operator>=</operator> <name><name>pmentry</name><operator>-&gt;</operator><name>kernel_mapping</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>is_anonymous</name> <operator>=</operator> <call><name>has_map_anonymous_content</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>, <argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>, <argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_anonymous</name> <operator>&amp;&amp;</operator> <name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_anonymous</name> <operator>=</operator> <name>is_deleted</name> <operator>=</operator> <call><name>has_map_deleted_part</name> <argument_list>(<argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>anonymous</name></name> <operator>=</operator> <name>is_anonymous</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>pmentry</name><operator>-&gt;</operator><name>kernel_mapping</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_deleted</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>file_backed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>pmentry</name><operator>-&gt;</operator><name>dumpeable</name></name> <operator>=</operator> <call><name>dump_this_map</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>, <argument><expr><name>pmentry</name></expr></argument>, <argument><expr><name>filter_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><name>fmt_addr</name><literal type="string">" - anonymous: %d, kernel_mapping: %d, file_backed: %d, dumpeable: %d\n"</literal></expr></argument>,

<argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>, <argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>,

<argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>anonymous</name></name></expr></argument>, <argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>kernel_mapping</name></name></expr></argument>,

<argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>file_backed</name></name></expr></argument>, <argument><expr><name><name>pmentry</name><operator>-&gt;</operator><name>dumpeable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>pmentry</name><operator>-&gt;</operator><name>file_backed</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>pmentry</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>mapping_file</name><operator>.</operator><name>size</name></name> <operator>+=</operator> <name>SIZE_NT_FILE_DESCSZ</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>mapping_file</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ADD_MAP_NODE</name> <argument_list>(<argument><expr><name>pmentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>mapping_file</name><operator>.</operator><name>size</name></name> <operator>+=</operator> sizeof <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff_maps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>me_head</name></expr>;</return>

<label><name>error</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff_maps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff_smaps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clean_maps</name> <argument_list>(<argument><expr><name>me_head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>auxv_buff_t</name> <modifier>*</modifier></type><name>linux_get_auxv</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>auxv_buff_t</name> <modifier>*</modifier></type><name>auxv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>auxv_entries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/auxv"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>auxv_entries</name> <operator>=</operator> <name>size</name> <operator>/</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_auxv_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>auxv_entries</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>auxv</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>auxv_buff_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>auxv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>auxv</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>auxv</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <call><name>r_mem_dup</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>auxv</name><operator>-&gt;</operator><name>data</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>auxv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>auxv</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>elf_hdr_t</name> <modifier>*</modifier></type><name>build_elf_hdr</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>n_segments</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pad_byte</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ph_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ph_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_hdr_t</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>elf_hdr_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>h</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ph_offset</name> <operator>=</operator> <name>ELF_HDR_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name>ph_size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_phdr_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_MAG0</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG0</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_MAG1</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG1</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_MAG2</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG2</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_MAG3</name></expr>]</index></name> <operator>=</operator> <name>ELFMAG3</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>=</operator> <name>ELFCLASS64</name></expr>;</expr_stmt> 

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__arm__</name></expr></cpp:elif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_CLASS</name></expr>]</index></name> <operator>=</operator> <name>ELFCLASS32</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_DATA</name></expr>]</index></name> <operator>=</operator> <name>ELFDATA2LSB</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_VERSION</name></expr>]</index></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_OSABI</name></expr>]</index></name> <operator>=</operator> <name>ELFOSABI_NONE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>EI_ABIVERSION</name></expr>]</index></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>pad_byte</name> <operator>=</operator> <name>EI_PAD</name></expr>;</init> <condition><expr><name>pad_byte</name> <operator>&lt;</operator> <name>EI_NIDENT</name></expr>;</condition> <incr><expr><name>pad_byte</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ident</name><index>[<expr><name>pad_byte</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_type</name></name> <operator>=</operator> <name>ET_CORE</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name></expr></cpp:if>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_X86_64</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__i386__</name></expr></cpp:elif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_386</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name></expr></cpp:elif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_ARM</name></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm64__</name></expr></cpp:elif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_machine</name></name> <operator>=</operator> <name>EM_AARCH64</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_version</name></name> <operator>=</operator> <name>EV_CURRENT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_entry</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_ehsize</name></name> <operator>=</operator> <name>ELF_HDR_SIZE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_phoff</name></name> <operator>=</operator> <name>ph_offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_phentsize</name></name> <operator>=</operator> <name>ph_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_phnum</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>n_segments</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <name>PN_XNUM</name></expr> ?</condition><then> <expr><name>PN_XNUM</name></expr> </then><else>: <expr><name>n_segments</name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_flags</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_shoff</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_shentsize</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_shnum</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>h</name><operator>-&gt;</operator><name>e_shstrndx</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<return>return <expr><name>h</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_info_mappings</name><parameter_list>(<parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>me_head</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>maps_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_entries</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n_entries</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>me_head</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>perms</name></name> <operator>&amp;</operator> <name>R_PERM_R</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>perms</name></name> <operator>&amp;</operator> <name>R_PERM_W</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <name><name>p</name><operator>-&gt;</operator><name>dumpeable</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>maps_size</name> <operator>+=</operator> <name><name>p</name><operator>-&gt;</operator><name>end_addr</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_entries</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>n_entries</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf_header</name><parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>elf_hdr_t</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>hdr</name></expr></argument>, <argument><expr><name><name>hdr</name><operator>-&gt;</operator><name>e_ehsize</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>get_ntfile_data</name><parameter_list>(<parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maps_data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>n_pag</name></decl>, <decl><type ref="prev"/><name>n_segments</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><name><name>mapping_file</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator><name>size</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n_segments</name> <operator>=</operator> <name><name>mapping_file</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_pag</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>=</operator> <name>maps_data</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_data</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>maps_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_segments</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n_segments</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>maps_data</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>n_segments</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_pag</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>n_pag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>n_segments</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>n_pag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>file_backed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_a_kernel_mapping</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>end_addr</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>+=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>file_backed</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>is_a_kernel_mapping</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>pp</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <operator>(</operator><name>pp</name> <operator>-</operator> <name>maps_data</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pp</name> <operator>+=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>maps_data</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf_pheaders</name><parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>maps</name></decl></parameter>, <parameter><decl><type><name>elf_offset_t</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>note_section_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>me_p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_offset_t</name></type> <name>offset_to_next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_phdr_t</name></type> <name>phdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>=</operator> <name>PT_NOTE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_flags</name></name> <operator>=</operator> <name>PF_R</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>=</operator> <operator>*</operator><name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_vaddr</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_paddr</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_filesz</name></name> <operator>=</operator> <name>note_section_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_memsz</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_align</name></name> <operator>=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>phdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_phdr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset_to_next</name> <operator>=</operator> <operator>*</operator><name>offset</name> <operator>+</operator> <name>note_section_size</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>me_p</name> <operator>=</operator> <name>maps</name></expr>;</init> <condition><expr><name>me_p</name></expr>;</condition> <incr><expr><name>me_p</name> <operator>=</operator> <name><name>me_p</name><operator>-&gt;</operator><name>n</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><operator>(</operator><name><name>me_p</name><operator>-&gt;</operator><name>perms</name></name> <operator>&amp;</operator> <name>R_PERM_R</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name><name>me_p</name><operator>-&gt;</operator><name>perms</name></name> <operator>&amp;</operator> <name>R_PERM_W</name><operator>)</operator><operator>)</operator> <operator>||</operator> <operator>!</operator><name><name>me_p</name><operator>-&gt;</operator><name>dumpeable</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_type</name></name> <operator>=</operator> <name>PT_LOAD</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_flags</name></name> <operator>=</operator> <name><name>me_p</name><operator>-&gt;</operator><name>perms</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_vaddr</name></name> <operator>=</operator> <name><name>me_p</name><operator>-&gt;</operator><name>start_addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_paddr</name></name> <operator>=</operator> <literal type="number">0x0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_memsz</name></name> <operator>=</operator> <name><name>me_p</name><operator>-&gt;</operator><name>end_addr</name></name> <operator>-</operator> <name><name>me_p</name><operator>-&gt;</operator><name>start_addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_filesz</name></name> <operator>=</operator> <ternary><condition><expr><name><name>me_p</name><operator>-&gt;</operator><name>dumpeable</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>phdr</name><operator>.</operator><name>p_memsz</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_offset</name></name> <operator>=</operator> <name>offset_to_next</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>phdr</name><operator>.</operator><name>p_align</name></name> <operator>=</operator> <literal type="number">0x1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>offset_to_next</name> <operator>+=</operator> <ternary><condition><expr><name><name>phdr</name><operator>.</operator><name>p_filesz</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>phdr</name><operator>.</operator><name>p_filesz</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>phdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_phdr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>phdr</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_phdr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name>offset_to_next</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf_note</name><parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>note_data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>note_section_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>note_data</name></expr></argument>, <argument><expr><name>note_section_size</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf_map_content</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>head</name></decl></parameter>, <parameter><decl><type><name>pid_t</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>linux_map_entry_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>map_content</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"dump_elf_map_content starting\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>n</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>dumpeable</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>end_addr</name></name> <operator>-</operator> <name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>map_content</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map_content</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>read_at</name></name> <argument_list>(<argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>iob</name><operator>.</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>, <argument><expr><name>map_content</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Problems reading %"</literal><name>PFMTSZd</name><literal type="string">" bytes at %"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator><name><name>p</name><operator>-&gt;</operator><name>start_addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><name>map_content</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"r_buf_append_bytes - failed\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map_content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"dump_elf_map_content - done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>proc_per_process_t</name> <modifier>*</modifier></type><name>get_proc_process_content</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>proc_per_process_t</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>temp_p_uid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp_p_gid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_uid</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p_gid</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut16</name></type> <name>filter_flags</name></decl>, <decl><type ref="prev"/><name>default_filter_flags</name> <init>= <expr><literal type="number">0x33</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buff</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/stat"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>proc_per_process_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>no_str</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name> <name>unsigned</name> <name>int</name></type> <name>no_lui</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>long</name> <name>int</name></type> <name>no_li</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>no_num</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%d %s %c %d %d %d %d %d %u %lu %lu %lu %lu"</literal>

<literal type="string">"%lu %lu %ld %ld %ld %ld %ld"</literal></expr></argument>,

<argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>no_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>s_name</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>ppid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>pgrp</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>sid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>flag</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_lui</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_li</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>no_li</name></expr></argument>,

<argument><expr><operator>&amp;</operator><name>no_li</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>nice</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>p</name><operator>-&gt;</operator><name>num_threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>p</name><operator>-&gt;</operator><name>num_threads</name></name> <operator>||</operator> <name><name>p</name><operator>-&gt;</operator><name>num_threads</name></name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: number of threads is &lt; 1\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/status"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>temp_p_uid</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"Uid:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>temp_p_gid</name> <operator>=</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"Gid:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>temp_p_uid</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_uid</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name>p_uid</name> <operator>=</operator> <name>temp_p_uid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_uid</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name><name>p_uid</name><index>[<expr><name>temp_p_uid</name> <operator>-</operator> <name>p_uid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>p_uid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>uid</name></name> <operator>=</operator> <ternary><condition><expr><name>p_uid</name></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>p_uid</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>temp_p_gid</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><operator>!</operator><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_gid</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name>p_gid</name> <operator>=</operator> <name>temp_p_gid</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><call><name>isdigit</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>*</operator><name>temp_p_gid</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

</block_content>}</block></while>

<expr_stmt><expr><name><name>p_gid</name><index>[<expr><name>temp_p_gid</name> <operator>-</operator> <name>p_gid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>p_gid</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>gid</name></name> <operator>=</operator> <ternary><condition><expr><name>p_gid</name></expr>?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>p_gid</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"/proc/%d/coredump_filter"</literal></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>buff</name> <operator>=</operator> <call><name>r_file_slurp</name> <argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>buff</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><literal type="string">"%hx"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>filter_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coredump_filter</name></name> <operator>=</operator> <name>filter_flags</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>coredump_filter</name></name> <operator>=</operator> <name>default_filter_flags</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>may_clean_all</name><parameter_list>(<parameter><decl><type><name>elf_proc_note_t</name> <modifier>*</modifier></type><name>elf_proc_note</name></decl></parameter>, <parameter><decl><type><name>proc_content_t</name> <modifier>*</modifier></type><name>proc_data</name></decl></parameter>, <parameter><decl><type><name>elf_hdr_t</name> <modifier>*</modifier></type><name>elf_hdr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>prpsinfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>auxv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>clean_maps</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_proc_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_thread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>proc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>elf_shdr_t</name> <modifier>*</modifier></type><name>get_extra_sectionhdr</name><parameter_list>(<parameter><decl><type><name>elf_hdr_t</name> <modifier>*</modifier></type><name>elf_hdr</name></decl></parameter>, <parameter><decl><type><name>st64</name></type> <name>offset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_segments</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>elf_shdr_t</name> <modifier>*</modifier></type><name>shdr</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>elf_shdr_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>shdr</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shoff</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shentsize</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_shdr_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shnum</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shstrndx</name></name> <operator>=</operator> <name>SHN_UNDEF</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_type</name></name> <operator>=</operator> <name>SHT_NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_size</name></name> <operator>=</operator> <name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shnum</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_link</name></name> <operator>=</operator> <name><name>elf_hdr</name><operator>-&gt;</operator><name>e_shstrndx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>shdr</name><operator>-&gt;</operator><name>sh_info</name></name> <operator>=</operator> <name>n_segments</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<return>return <expr><name>shdr</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>dump_elf_sheader_pxnum</name><parameter_list>(<parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>elf_shdr_t</name> <modifier>*</modifier></type><name>shdr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_buf_append_bytes</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator><name>shdr</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>shdr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>elf_fpxregset_t</name> <modifier>*</modifier></type><name>linux_get_fpx_regset</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETREGSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name>transfer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_fpxregset_t</name> <modifier>*</modifier></type><name>fpxregset</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>elf_fpxregset_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fpxregset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>transfer</name><operator>.</operator><name>iov_base</name></name> <operator>=</operator> <name>fpxregset</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>transfer</name><operator>.</operator><name>iov_len</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_fpxregset_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETREGSET</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>NT_PRXFPREG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>transfer</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"linux_get_fpx_regset"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>fpxregset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>fpxregset</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>NULL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<function><type><name>void</name> <modifier>*</modifier></type><name>linux_get_xsave_data</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETREGSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name>transfer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>xsave_data</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xsave_data</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>transfer</name><operator>.</operator><name>iov_base</name></name> <operator>=</operator> <name>xsave_data</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>transfer</name><operator>.</operator><name>iov_len</name></name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETREGSET</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>NT_X86_XSTATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>transfer</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"linux_get_xsave_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>xsave_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>xsave_data</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>NULL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<function><type><name>void</name> <modifier>*</modifier></type><name>linux_get_arm_vfp_data</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETVFPREGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vfp_data</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>ARM_VFPREGS_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vfp_data</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETVFPREGS</name></expr></argument>, <argument><expr><name>tid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vfp_data</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"linux_get_arm_vfp_data"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>vfp_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>vfp_data</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><name>NULL</name></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>void</name></type> <name>write_note_hdr</name> <parameter_list>(<parameter><decl><type><name>note_type_t</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier><modifier>*</modifier></type><name>note_data</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>elf_nhdr_t</name></type> <name>nhdr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>size_t</name></type> <name>size_note_hdr</name> <init>= <expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_nhdr_t</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>note_type</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>NT_PRPSINFO_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_PRPSINFO</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NT_AUXV_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_AUXV</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NT_FILE_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_FILE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NT_PRSTATUS_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_PRSTATUS</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>NT_FPREGSET_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_FPREGSET</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<case>case <expr><name>NT_PRXFPREG_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_PRXFPREG</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><name>NT_SIGINFO_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_SIGINFO</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<case>case <expr><name>NT_X86_XSTATE_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_X86_XSTATE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:elif>

<case>case <expr><name>NT_ARM_VFP_T</name></expr>:</case>

<expr_stmt><expr><name>note_type</name> <operator>=</operator> <name>NT_ARM_VFP</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_descsz</name></name> <operator>=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>;</expr_stmt>

<break>break;</break>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<default>default:</default>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><operator>*</operator><name>note_data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size_note_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_type</name></name> <operator>=</operator> <name>note_type</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>note_type</name> <operator>==</operator> <name>NT_X86_XSTATE</name> <operator>||</operator> <name>note_type</name> <operator>==</operator> <name>NT_ARM_VFP</name> <operator>||</operator> <name>note_type</name> <operator>==</operator> <name>NT_PRXFPREG</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_namesz</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><literal type="string">"LINUX"</literal></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>nhdr</name><operator>.</operator><name>n_namesz</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><literal type="string">"CORE"</literal></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><operator>*</operator><name>note_data</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name>nhdr</name></expr></argument>, <argument><expr><name>size_note_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>note_data</name> <operator>+=</operator> <name>size_note_hdr</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier></type><name>get_unique_thread_id</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_threads</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugPid</name> <modifier>*</modifier></type><name>th</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>thread_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>h</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name><name>dbg</name><operator>-&gt;</operator><name>h</name><operator>-&gt;</operator><name>threads</name></name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>thread_id</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>n_threads</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>thread_id</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return> 

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>it</argument>, <argument>th</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr> ;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name><name>thread_id</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>th</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>th</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_ATTACH</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"Could not attach to thread"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>thread_id</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>detach_threads</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>thread_id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_threads</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_threads</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_DETACH</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"PTRACE_DETACH"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut8</name> <modifier>*</modifier></type><name>build_note_section</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>elf_proc_note_t</name> <modifier>*</modifier></type><name>elf_proc_note</name></decl></parameter>, <parameter><decl><type><name>proc_content_t</name> <modifier>*</modifier></type><name>proc_data</name></decl></parameter>, <parameter><decl><type><name>size_t</name> <modifier>*</modifier></type><name>section_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>note_data</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pnote_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>maps_data</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n_notes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>thread_id</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>note_type_t</name></type> <name>type</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<decl_stmt><decl><type><name>bool</name></type> <name>fpx_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<decl_stmt><decl><type><name>bool</name></type> <name>xsave_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:elif>

<decl_stmt><decl><type><name>bool</name></type> <name>vfp_flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>maps_data</name> <operator>=</operator> <call><name>get_ntfile_data</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maps_data</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>thread_id</name> <operator>=</operator> <call><name>get_unique_thread_id</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>n_threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>thread_id</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maps_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRPSINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_AUXV_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FILE_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>elf_proc_note</name><operator>-&gt;</operator><name>n_threads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRSTATUS_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_SIGINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FPREGSET_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRXFPREG_T</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fpx_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_X86_XSTATE_T</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>xsave_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_ARM_VFP_T</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>vfp_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>n_notes</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></for>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><name>n_notes</name> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_nhdr_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>section_size</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>note_data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maps_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>pnote_data</name> <operator>=</operator> <name>note_data</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRPSINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>prpsinfo</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<block>{<block_content>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name></name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>thread_elf_note_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>elf_proc_note</name><operator>-&gt;</operator><name>n_threads</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>siginfo</name></name> <operator>=</operator> <call><name>linux_get_siginfo</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>siginfo</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>prstatus</name></name> <operator>=</operator> <call><name>linux_get_prstatus</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>,

<argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>proc_data</name></expr></argument>,

<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>siginfo</name><operator>-&gt;</operator><name>si_signo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>prstatus</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name> <operator>=</operator> <call><name>linux_get_fp_regset</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>fpx_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fpx_regset</name></name> <operator>=</operator> <call><name>linux_get_fpx_regset</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fpx_regset</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>xsave_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>xsave_data</name></name> <operator>=</operator> <call><name>linux_get_xsave_data</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,

<argument><expr><name><name>note_info</name><index>[<expr><name>NT_X86_XSTATE_T</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>xsave_data</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:elif>

<if_stmt><if>if <condition>(<expr><name>vfp_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>arm_vfp_data</name></name> <operator>=</operator> <call><name>linux_get_arm_vfp_data</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>thread_id</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>arm_vfp_data</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>fail</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRSTATUS_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>prstatus</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FPREGSET_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>fpx_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRXFPREG_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fpx_regset</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fpx_regset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_SIGINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>vfp_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_ARM_VFP_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>arm_vfp_data</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>arm_vfp_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>xsave_flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_X86_XSTATE_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>xsave_data</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>xsave_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>siginfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>prstatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_AUXV_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>auxv</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FILE_T</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>write_note_hdr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>, <argument><expr><name>maps_data</name></expr></argument>, <argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>+=</operator> <name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>detach_threads</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>thread_id</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>n_threads</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maps_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>pnote_data</name></expr>;</return>

<label><name>fail</name>:</label>

<if_stmt><if>if <condition>(<expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>siginfo</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>prstatus</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fp_regset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>fpx_regset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64__</name></expr></cpp:if>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>xsave_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:elif>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>thread_note</name><operator>-&gt;</operator><name>arm_vfp_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pnote_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>maps_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name> <operator>||</operator> <name>__x86_64</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_xsave_size</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETREGSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name><name>struct</name> <name>iovec</name></name></type> <name>local</name></decl>;</decl_stmt>

<expr_stmt><expr><name>unsigned</name> <name>long</name> <name><name>xstate_hdr</name><index>[<expr><name>XSTATE_HDR_SIZE</name><operator>/</operator></expr></index></name>sizeof<operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator>]</expr>;</expr_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>xcr0</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>local</name><operator>.</operator><name>iov_base</name></name> <operator>=</operator> <name>xstate_hdr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>local</name><operator>.</operator><name>iov_len</name></name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>xstate_hdr</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_debug_ptrace</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>PTRACE_GETREGSET</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>NT_X86_XSTATE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>local</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>perror</name> <argument_list>(<argument><expr><literal type="string">"NT_X86_XSTATE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>xcr0</name> <operator>=</operator> <name><name>xstate_hdr</name><index>[<expr><name>XCR0_OFFSET</name><operator>/</operator></expr></index></name>sizeof <operator>(</operator><name>unsigned</name> <name>long</name><operator>)</operator>]</expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>xcr0</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>XSTATE_SSE_MASK</name></expr>:</case>

<return>return <expr><name>XSTATE_SSE_SIZE</name></expr>;</return>

<case>case <expr><name>XSTATE_AVX_MASK</name></expr>:</case>

<return>return <expr><name>XSTATE_AVX_SIZE</name></expr>;</return>

<case>case <expr><name>XSTATE_MPX_MASK</name></expr>:</case>

<return>return <expr><name>XSTATE_MPX_SIZE</name></expr>;</return>

<case>case <expr><name>XSTATE_AVX512_MASK</name></expr>:</case>

<return>return <expr><name>XSTATE_FULL_SIZE</name></expr>;</return>

<default>default:</default>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></switch>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_i386_fpx_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETREGSET</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><sizeof>sizeof <argument_list>(<argument><expr><name>elf_fpxregset_t</name></expr></argument>)</argument_list></sizeof></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_arm_vfpregs_size</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PTRACE_GETVFPREGS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><name>ARM_VFPREGS_SIZE</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>init_note_info_structure</name><parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>auxv_size</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>note_type_t</name></type> <name>type</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len_name_core</name> <init>= <expr><call><name>round_up</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"CORE"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len_name_linux</name> <init>= <expr><call><name>round_up</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"LINUX"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<empty_stmt>;</empty_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRPSINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>prpsinfo_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>sizeof_round_up</name> <argument_list>(<argument><expr><name>prpsinfo_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_AUXV_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name>auxv_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><name>auxv_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FILE_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <name><name>mapping_file</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><name><name>mapping_file</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRSTATUS_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>prstatus_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>sizeof_round_up</name> <argument_list>(<argument><expr><name>prstatus_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_SIGINFO_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>siginfo_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>sizeof_round_up</name> <argument_list>(<argument><expr><name>siginfo_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_FPREGSET_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>elf_fpregset_t</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>sizeof_round_up</name> <argument_list>(<argument><expr><name>elf_fpregset_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__i386__</name></expr></cpp:if>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_PRXFPREG_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>get_i386_fpx_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>sizeof_round_up</name> <argument_list>(<argument><expr><name>elf_fpxregset_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"CORE"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name><operator>++</operator></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>__x86_64__</name> <operator>||</operator> <name>__i386__</name></expr></cpp:if>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_X86_XSTATE_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>get_xsave_size</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_linux</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"LINUX"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>__arm__</name> <operator>||</operator> <name>__arm64__</name></expr></cpp:elif>

<expr_stmt><expr><name>type</name> <operator>=</operator> <name>NT_ARM_VFP_T</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name> <operator>=</operator> <call><name>get_arm_vfpregs_size</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_roundedup</name> <operator>=</operator> <call><name>round_up</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>size_name</name> <operator>=</operator> <name>len_name_linux</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>, <argument><expr><literal type="string">"LINUX"</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name><name>note_info</name><index>[<expr><name>type</name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<function><type><name>bool</name></type> <name>linux_generate_corefile</name> <parameter_list>(<parameter><decl><type><name>RDebug</name> <modifier>*</modifier></type><name>dbg</name></decl></parameter>, <parameter><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>proc_content_t</name> <modifier>*</modifier></type><name>proc_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_proc_note_t</name> <modifier>*</modifier></type><name>elf_proc_note</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_shdr_t</name> <modifier>*</modifier></type><name>shdr_pxnum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_hdr_t</name> <modifier>*</modifier></type><name>elf_hdr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>note_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>note_section_size</name></decl>, <decl><type ref="prev"/><name>maps_size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_segments</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>hdr_size</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>elf_offset_t</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>elf_proc_note</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>elf_proc_note_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elf_proc_note</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>proc_data</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>proc_content_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_proc_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name></name> <operator>=</operator> <call><name>get_proc_process_content</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>elf_proc_note</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>proc_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>n_threads</name></name> <operator>=</operator> <name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>num_threads</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>prpsinfo</name></name> <operator>=</operator> <call><name>linux_get_prpsinfo</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>prpsinfo</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>auxv</name></name> <operator>=</operator> <call><name>linux_get_auxv</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>auxv</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name> <operator>=</operator> <call><name>linux_get_mapped_files</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>coredump_filter</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>n_segments</name> <operator>=</operator> <call><name>get_info_mappings</name> <argument_list>(<argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>maps_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>init_note_info_structure</name><argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>auxv</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>note_data</name> <operator>=</operator> <call><name>build_note_section</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>elf_proc_note</name></expr></argument>, <argument><expr><name>proc_data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>note_section_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>note_data</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>elf_hdr</name> <operator>=</operator> <call><name>build_elf_hdr</name> <argument_list>(<argument><expr><name>n_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>elf_hdr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hdr_size</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>proc_data</name><operator>-&gt;</operator><name>per_process</name><operator>-&gt;</operator><name>coredump_filter</name></name> <operator>&amp;</operator> <name>MAP_ELF_HDR</name><operator>)</operator></expr> ?</condition><then> <expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_ehsize</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hdr_size</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phnum</name></name> <operator>==</operator> <name>PN_XNUM</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>elf_offset_t</name></type> <name>offset_shdr</name></decl>;</decl_stmt>

<expr_stmt><expr><name>offset_shdr</name> <operator>=</operator> <name>hdr_size</name> <operator>+</operator> <operator>(</operator><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phnum</name></name> <operator>*</operator> <name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phentsize</name></name><operator>)</operator> <operator>+</operator> <name>note_section_size</name> <operator>+</operator> <name>maps_size</name></expr>;</expr_stmt>

<expr_stmt><expr><name>shdr_pxnum</name> <operator>=</operator> <call><name>get_extra_sectionhdr</name> <argument_list>(<argument><expr><name>elf_hdr</name></expr></argument>, <argument><expr><name>offset_shdr</name></expr></argument>, <argument><expr><name>n_segments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dump_elf_header</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>elf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <name>hdr_size</name> <operator>+</operator> <operator>(</operator><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phnum</name></name> <operator>*</operator> <name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phentsize</name></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dump_elf_pheaders</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset</name></expr></argument>, <argument><expr><name>note_section_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dump_elf_note</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>note_data</name></expr></argument>, <argument><expr><name>note_section_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dump_elf_map_content</name> <argument_list>(<argument><expr><name>dbg</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>elf_proc_note</name><operator>-&gt;</operator><name>maps</name></name></expr></argument>, <argument><expr><name><name>dbg</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>elf_hdr</name><operator>-&gt;</operator><name>e_phnum</name></name> <operator>==</operator> <name>PN_XNUM</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>dump_elf_sheader_pxnum</name> <argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>shdr_pxnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>cleanup</name>:</label>

<expr_stmt><expr><call><name>may_clean_all</name> <argument_list>(<argument><expr><name>elf_proc_note</name></expr></argument>, <argument><expr><name>proc_data</name></expr></argument>, <argument><expr><name>elf_hdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>shdr_pxnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>note_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><name>error</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</unit>
