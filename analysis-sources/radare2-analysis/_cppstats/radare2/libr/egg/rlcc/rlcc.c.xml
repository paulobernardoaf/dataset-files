<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\egg\rlcc\rlcc.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mpc.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eprintf</name><parameter_list>(<parameter><type><name>x</name></type></parameter>,<parameter><type><name>y</name><modifier>...</modifier></type></parameter>)</parameter_list></cpp:macro> <cpp:value>fprintf(stderr,x,##y)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>int</name></type> <name>isComment</name><parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"comment|regex"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"linecomment|regex"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>isInlineAssembly</name><parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"asm|regex"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>isStatement</name><parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"stmt|&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>isSigdef</name><parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"sigdef|&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>isProcedure</name><parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><literal type="string">"procedure|&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>processNode</name> <parameter_list>(<parameter><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>isStatement</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>narg</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>args</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>node</name><operator>-&gt;</operator><name>children_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tag</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>contents</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><literal type="string">"char"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"TAG (%s) = (%s)\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>args</name><index>[<expr><name>narg</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; CALL WITH %d ARGS\n"</literal></expr></argument>, <argument><expr><name>narg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isProcedure</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>contents</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"%s:\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>node</name><operator>-&gt;</operator><name>children_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tag</name></expr></argument>, <argument><expr><literal type="string">"body|&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>node</name><operator>-&gt;</operator><name>children_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tag</name></expr></argument>, <argument><expr><literal type="string">"stmt|&gt;"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>processNode</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"UNK %s\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isSigdef</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>children_num</name></name><operator>&gt;</operator><literal type="number">4</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>contents</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>-&gt;</operator><name>contents</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>size</name> <init>= <expr><name><name>node</name><operator>-&gt;</operator><name>children</name><index>[<expr><literal type="number">4</literal></expr>]</index></name><operator>-&gt;</operator><name>contents</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"alias"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">".equ %s,%s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"syscall"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; TODO: register syscall %s number %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"global"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; TODO: global \n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; UNKNOWN EXPRESISON: NAME = '%s' "</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"TYPE = '%s' "</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"SIZE = '%s'\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isComment</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>contents</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>contents</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>s</name><index>[<expr><name>len</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nl</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>nl</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; %s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>nl</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"; %s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>isInlineAssembly</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>contents</name></name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>int</name></type> <name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>argv</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Ident</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"ident"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Number</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Character</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"character"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>String</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Factor</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"factor"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Term</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"term"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Lexp</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"lexp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Stmt</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"stmt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Exp</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"exp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Vartype</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"vartype"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Typeident</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"typeident"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Decls</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"decls"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Args</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Body</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"body"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Comment</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"comment"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Linecomment</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"linecomment"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Asm</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"asm"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Procedure</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"procedure"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>CProcedure</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"cprocedure"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Sigdef</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"sigdef"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Sigbody</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"sigbody"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Includes</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"includes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_parser_t</name><modifier>*</modifier></type> <name>Smallc</name> <init>= <expr><call><name>mpc_new</name><argument_list>(<argument><expr><literal type="string">"smallc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_err_t</name><modifier>*</modifier></type> <name>err</name> <init>= <expr><call><name>mpca_lang</name><argument_list>(<argument><expr><name>MPCA_LANG_DEFAULT</name></expr></argument>,

<argument><expr><literal type="string">" ident : /[a-zA-Z_][a-zA-Z0-9_]*/ ; \n"</literal>

<literal type="string">" number : /[0-9]+/ ; \n"</literal>

<literal type="string">" character : /'.'/ ; \n"</literal>

<literal type="string">" string : /\"(\\\\.|[^\"])*\"/ ; \n"</literal>

<literal type="string">" \n"</literal>

<literal type="string">" factor : '(' &lt;lexp&gt; ')' \n"</literal>

<literal type="string">" | &lt;number&gt; \n"</literal>

<literal type="string">" | &lt;character&gt; \n"</literal>

<literal type="string">" | &lt;string&gt; \n"</literal>

<literal type="string">" | &lt;ident&gt; '(' &lt;lexp&gt;? (',' &lt;lexp&gt;)* ')' \n"</literal>

<literal type="string">" | &lt;ident&gt; ; \n"</literal>

<literal type="string">" \n"</literal>

<literal type="string">" term : &lt;factor&gt; (('*' | '/' | '%') &lt;factor&gt;)* ; \n"</literal>

<literal type="string">" lexp : &lt;term&gt; (('+' | '-') &lt;term&gt;)* ; \n"</literal>

<literal type="string">" \n"</literal>

<literal type="string">" stmt : '{' &lt;stmt&gt;* '}' \n"</literal>

<literal type="string">" | \"while\" '(' &lt;exp&gt; ')' &lt;stmt&gt; \n"</literal>

<literal type="string">" | \"if\" '(' &lt;exp&gt; ')' &lt;stmt&gt; \n"</literal>

<literal type="string">" | &lt;ident&gt; '=' &lt;lexp&gt; ';' \n"</literal>

<literal type="string">" | \"print\" '(' &lt;lexp&gt;? ')' ';' \n"</literal>

<literal type="string">" | \"return\" &lt;lexp&gt;? ';' \n"</literal>

<literal type="string">" | &lt;ident&gt; '(' (&lt;number&gt;|&lt;ident&gt;|&lt;string&gt;)? (',' (&lt;string&gt;|&lt;number&gt;|&lt;ident&gt;))* ')' ';' ; \n"</literal>

<literal type="string">" \n"</literal>

<literal type="string">" exp : &lt;lexp&gt; '&gt;' &lt;lexp&gt; \n"</literal>

<literal type="string">" | &lt;lexp&gt; '&lt;' &lt;lexp&gt; \n"</literal>

<literal type="string">" | &lt;lexp&gt; \"&gt;=\" &lt;lexp&gt; \n"</literal>

<literal type="string">" | &lt;lexp&gt; \"&lt;=\" &lt;lexp&gt; \n"</literal>

<literal type="string">" | &lt;lexp&gt; \"!=\" &lt;lexp&gt; \n"</literal>

<literal type="string">" | &lt;lexp&gt; \"==\" &lt;lexp&gt; ; \n"</literal>

<literal type="string">" \n"</literal>

<literal type="string">" vartype : (\"int\" | \"char\") ; \n"</literal>

<literal type="string">" typeident : &lt;vartype&gt; &lt;ident&gt; ; \n"</literal>

<literal type="string">" decls : (&lt;typeident&gt; ';')* ; \n"</literal>

<literal type="string">" args : &lt;typeident&gt;? (',' &lt;typeident&gt;)* ; \n"</literal>

<literal type="string">" body : '{' &lt;decls&gt; &lt;stmt&gt;* '}' ; \n"</literal>

<literal type="string">" comment : /\\/\\*([^\\*])*\\*\\// ; \n"</literal>

<literal type="string">" linecomment : /\\/\\/([^\\n])*/ ; \n"</literal>

<literal type="string">" asm : /\\:([^\\n])*/ ; \n"</literal>

<literal type="string">" procedure : &lt;ident&gt; '@' \"global\" '(' &lt;number&gt;? ')' &lt;body&gt; ; \n"</literal>

<literal type="string">" cprocedure : &lt;vartype&gt; &lt;ident&gt; '(' &lt;args&gt; ')' &lt;body&gt; ; \n"</literal>

<literal type="string">" sigdef : &lt;ident&gt; '@' &lt;ident&gt; '(' &lt;number&gt; ')' ';' ; \n"</literal>

<literal type="string">" sigbody : '@' &lt;ident&gt; '(' &lt;number&gt; ')' ';' ; \n"</literal>

<literal type="string">" includes : (\"#include\" &lt;string&gt;)* ; \n"</literal>

<literal type="string">" smallc : /^/ (&lt;comment&gt;|&lt;asm&gt;|&lt;linecomment&gt;|&lt;sigdef&gt;|&lt;sigbody&gt;|&lt;procedure&gt;|&lt;cprocedure&gt;)* &lt;includes&gt; &lt;decls&gt; /$/ ; \n"</literal></expr></argument>,

<argument><expr><name>Ident</name></expr></argument>, <argument><expr><name>Number</name></expr></argument>, <argument><expr><name>Character</name></expr></argument>, <argument><expr><name>String</name></expr></argument>, <argument><expr><name>Factor</name></expr></argument>, <argument><expr><name>Term</name></expr></argument>, <argument><expr><name>Lexp</name></expr></argument>, <argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>,

<argument><expr><name>Vartype</name></expr></argument>, <argument><expr><name>Typeident</name></expr></argument>, <argument><expr><name>Decls</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>, <argument><expr><name>Comment</name></expr></argument>, <argument><expr><name>Linecomment</name></expr></argument>, <argument><expr><name>Asm</name></expr></argument>, <argument><expr><name>Procedure</name></expr></argument>, <argument><expr><name>CProcedure</name></expr></argument>,

<argument><expr><name>Sigdef</name></expr></argument>, <argument><expr><name>Sigbody</name></expr></argument>, <argument><expr><name>Includes</name></expr></argument>, <argument><expr><name>Smallc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mpc_err_print</name> <argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpc_err_delete</name> <argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">1</literal></expr></cpp:if>

<if_stmt><if>if <condition>(<expr><name>argc</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>mpc_result_t</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mpc_parse_contents</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Smallc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mpc_ast_print_to</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>output</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><name><name>r</name><operator>.</operator><name>output</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>children_num</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>mpc_ast_t</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>children</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"; TAG = %s (%s)\n"</literal></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>contents</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>processNode</name> <argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<expr_stmt><expr><call><name>mpc_ast_delete</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>mpc_err_print</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpc_err_delete</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>mpc_result_t</name></type> <name>r</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>mpc_parse_pipe</name><argument_list>(<argument><expr><literal type="string">"&lt;stdin&gt;"</literal></expr></argument>, <argument><expr><name>stdin</name></expr></argument>, <argument><expr><name>Smallc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mpc_ast_print</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpc_ast_delete</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>mpc_err_print</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>mpc_err_delete</name><argument_list>(<argument><expr><name><name>r</name><operator>.</operator><name>error</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>mpc_cleanup</name><argument_list>(<argument><expr><literal type="number">17</literal></expr></argument>, <argument><expr><name>Ident</name></expr></argument>, <argument><expr><name>Number</name></expr></argument>, <argument><expr><name>Character</name></expr></argument>, <argument><expr><name>String</name></expr></argument>, <argument><expr><name>Factor</name></expr></argument>, <argument><expr><name>Term</name></expr></argument>, <argument><expr><name>Lexp</name></expr></argument>, <argument><expr><name>Stmt</name></expr></argument>, <argument><expr><name>Exp</name></expr></argument>,

<argument><expr><name>Vartype</name></expr></argument>, <argument><expr><name>Typeident</name></expr></argument>, <argument><expr><name>Decls</name></expr></argument>, <argument><expr><name>Args</name></expr></argument>, <argument><expr><name>Body</name></expr></argument>, <argument><expr><name>Comment</name></expr></argument>, <argument><expr><name>Procedure</name></expr></argument>, <argument><expr><name>CProcedure</name></expr></argument>,

<argument><expr><name>Sigdef</name></expr></argument>, <argument><expr><name>Includes</name></expr></argument>, <argument><expr><name>Smallc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
