<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_zign.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_anal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_sign.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_list.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cons.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_util.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_z</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"z[*j-aof/cs] [args] "</literal></expr>, <expr><literal type="string">"#Manage zignatures"</literal></expr>,

<expr><literal type="string">"z"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures"</literal></expr>,

<expr><literal type="string">"z."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"find matching zignatures in current offset"</literal></expr>,

<expr><literal type="string">"z*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures in radare format"</literal></expr>,

<expr><literal type="string">"zq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures in quiet mode"</literal></expr>,

<expr><literal type="string">"zj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures in json format"</literal></expr>,

<expr><literal type="string">"zk"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures in sdb format"</literal></expr>,

<expr><literal type="string">"z-"</literal></expr>, <expr><literal type="string">"zignature"</literal></expr>, <expr><literal type="string">"delete zignature"</literal></expr>,

<expr><literal type="string">"z-"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"delete all zignatures"</literal></expr>,

<expr><literal type="string">"za"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"add zignature"</literal></expr>,

<expr><literal type="string">"zg"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"generate zignatures (alias for zaF)"</literal></expr>,

<expr><literal type="string">"zo"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manage zignature files"</literal></expr>,

<expr><literal type="string">"zf"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manage FLIRT signatures"</literal></expr>,

<expr><literal type="string">"z/"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"search zignatures"</literal></expr>,

<expr><literal type="string">"zc"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"compare current zignspace zignatures with another one"</literal></expr>,

<expr><literal type="string">"zs"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"manage zignspaces"</literal></expr>,

<expr><literal type="string">"zi"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show zignatures matching information"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_z_slash</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"z/[*] "</literal></expr>, <expr><literal type="string">"#Search signatures (see 'e?search' for options)"</literal></expr>,

<expr><literal type="string">"z/ "</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search zignatures on range and flag matches"</literal></expr>,

<expr><literal type="string">"z/* "</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search zignatures on range and output radare commands"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_za</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"za[fF?] [args] "</literal></expr>, <expr><literal type="string">"#Add zignature"</literal></expr>,

<expr><literal type="string">"za "</literal></expr>, <expr><literal type="string">"zigname type params"</literal></expr>, <expr><literal type="string">"add zignature"</literal></expr>,

<expr><literal type="string">"zaf "</literal></expr>, <expr><literal type="string">"[fcnname] [zigname]"</literal></expr>, <expr><literal type="string">"create zignature for function"</literal></expr>,

<expr><literal type="string">"zaF "</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"generate zignatures for all functions"</literal></expr>,

<expr><literal type="string">"za?? "</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show extended help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_zf</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"zf[dsz] filename "</literal></expr>, <expr><literal type="string">"#Manage FLIRT signatures"</literal></expr>,

<expr><literal type="string">"zfd "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"open FLIRT file and dump"</literal></expr>,

<expr><literal type="string">"zfs "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"open FLIRT file and scan"</literal></expr>,

<expr><literal type="string">"zfs "</literal></expr>, <expr><literal type="string">"/path/**.sig"</literal></expr>, <expr><literal type="string">"recursively search for FLIRT files and scan them (see dir.depth)"</literal></expr>,

<expr><literal type="string">"zfz "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"open FLIRT file and get sig commands (zfz flirt_file &gt; zignatures.sig)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_zo</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"zo[zs] filename "</literal></expr>, <expr><literal type="string">"#Manage zignature files (see dir.zigns)"</literal></expr>,

<expr><literal type="string">"zo "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"load zinatures from sdb file"</literal></expr>,

<expr><literal type="string">"zoz "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"load zinatures from gzipped sdb file"</literal></expr>,

<expr><literal type="string">"zos "</literal></expr>, <expr><literal type="string">"filename"</literal></expr>, <expr><literal type="string">"save zignatures to sdb file (merge if file exists)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_zs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"zs[+-*] [namespace] "</literal></expr>, <expr><literal type="string">"#Manage zignspaces"</literal></expr>,

<expr><literal type="string">"zs"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"display zignspaces"</literal></expr>,

<expr><literal type="string">"zs "</literal></expr>, <expr><literal type="string">"zignspace"</literal></expr>, <expr><literal type="string">"select zignspace"</literal></expr>,

<expr><literal type="string">"zs "</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"select all zignspaces"</literal></expr>,

<expr><literal type="string">"zs-"</literal></expr>, <expr><literal type="string">"zignspace"</literal></expr>, <expr><literal type="string">"delete zignspace"</literal></expr>,

<expr><literal type="string">"zs-"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"delete all zignspaces"</literal></expr>,

<expr><literal type="string">"zs+"</literal></expr>, <expr><literal type="string">"zignspace"</literal></expr>, <expr><literal type="string">"push previous zignspace and set"</literal></expr>,

<expr><literal type="string">"zs-"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"pop to the previous zignspace"</literal></expr>,

<expr><literal type="string">"zsr "</literal></expr>, <expr><literal type="string">"newname"</literal></expr>, <expr><literal type="string">"rename selected zignspace"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_zc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"zc[n!] other_space "</literal></expr>, <expr><literal type="string">"#Compare zignspaces, match &gt;= threshold (e zign.diff.*)"</literal></expr>,

<expr><literal type="string">"zc"</literal></expr>, <expr><literal type="string">" other_space"</literal></expr>, <expr><literal type="string">"compare all current space with other_space"</literal></expr>,

<expr><literal type="string">"zcn"</literal></expr>, <expr><literal type="string">" other_space"</literal></expr>, <expr><literal type="string">"compare current space with zigns with same name on other_space"</literal></expr>,

<expr><literal type="string">"zcn!"</literal></expr>, <expr><literal type="string">" other_space"</literal></expr>, <expr><literal type="string">"same as above but show the ones not matching"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_zign_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>z</name><operator>/</operator></expr></argument>, <argument><expr><name>z_slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>za</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>zo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnHash</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_sign_add_bb_hash</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnBytes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxsz</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.maxsz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fcnlen</name> <init>= <expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>addrbytes</name></name> <operator>*</operator> <name>fcnlen</name></expr></argument>, <argument><expr><name>maxsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>r_sign_add_anal</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot read at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnGraph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RSignGraph</name></type> <name>graph</name> <init>= <expr><block>{

<expr><operator>.</operator><name>cc</name> <operator>=</operator> <call><name>r_anal_function_complexity</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>nbbs</name> <operator>=</operator> <macro><name>r_list_length</name> <argument_list>(<argument>fcn-&gt;bbs</argument>)</argument_list></macro></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>graph</name><operator>.</operator><name>edges</name></name> <operator>=</operator> <call><name>r_anal_function_count_edges</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>graph</name><operator>.</operator><name>ebbs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>graph</name><operator>.</operator><name>bbsum</name></name> <operator>=</operator> <call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_sign_add_graph</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnXRefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>xrefs</name> <init>= <expr><call><name>r_sign_fcn_xrefs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>xrefs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>r_sign_add_xrefs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>xrefs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnRefs</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_sign_fcn_refs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>refs</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_refs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnVars</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>r_sign_fcn_vars</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vars</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_vars</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addFcnTypes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>r_sign_fcn_types</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>types</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_types</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static char *getFcnComments(RCore *core, RAnalFunction *fcn) {

char *r = r_core_cmd_strf (core, "CCf* @ 0x%08"PFMT64x, fcn-&gt;addr);

if (r &amp;&amp; *r) {

return r;

}

return NULL;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>addFcnZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zignspace</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>zigname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RSpace</name> <modifier>*</modifier></type><name>curspace</name> <init>= <expr><call><name>r_spaces_current</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>zign_spaces</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zigname</name> <operator>=</operator> <call><name>r_str_new</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>ptr</name> <operator>-</operator> <name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>zignspace</name> <operator>=</operator> <call><name>r_str_newlen</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_spaces_push</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>zign_spaces</name></name></expr></argument>, <argument><expr><name>zignspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>curspace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>zigname</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s:"</literal></expr></argument>, <argument><expr><name><name>curspace</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>zigname</name> <operator>=</operator> <call><name>r_str_appendf</name> <argument_list>(<argument><expr><name>zigname</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>addFcnGraph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnBytes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnXRefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnRefs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnVars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnTypes</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>addFcnHash</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>zigname</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_add_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_sign_add_addr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>zignspace</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_spaces_pop</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>zign_spaces</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>zignspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>parseGraphMetrics</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>RSignGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>nbbs</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>ebbs</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>bbsum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"cc="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>cc</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"nbbs="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>nbbs</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"edges="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"ebbs="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>ebbs</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"bbsum="</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>bbsum</name></name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addCommentZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comment</name> <init>= <expr><name>args0</name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>r_sign_add_comment</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addNameZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>realname</name> <init>= <expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>r_sign_add_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>realname</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addGraphZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RSignGraph</name></type> <name>graph</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parseGraphMetrics</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>graph</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>r_sign_add_graph</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addHashZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>args0</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>len</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>r_sign_add_hash</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addBytesZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hexbytes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>mask</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>bytes</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>sep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>blen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hexbytes</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>sep</name> <operator>=</operator> <operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>hexbytes</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>blen</name> <operator>=</operator> <name>sep</name> <operator>-</operator> <operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator> <name>hexbytes</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>blen</name> <operator>||</operator> <operator>(</operator><name>blen</name> <operator>&amp;</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <call><name>strlen</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <operator>++</operator><name>sep</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>blen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot parse hexpairs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>blen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>blen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>hexbytes</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>bytes</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>!=</operator> <name>blen</name> <operator>/</operator> <literal type="number">2</literal> <operator>||</operator> <call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>mask</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>size</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot parse hexpairs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>blen</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>hexbytes</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>r_hex_str2binmask</name> <argument_list>(<argument><expr><name>hexbytes</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot parse hexpairs\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_SIGN_BYTES</name></expr>:</case>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>r_sign_add_bytes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>R_SIGN_ANAL</name></expr>:</case>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>r_sign_add_anal</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<label><name>out</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addOffsetZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>offstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>offstr</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>r_num_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>offstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>r_sign_add_addr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addRefsZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_refs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addXRefsZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>, <argument><expr><call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_xrefs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addVarsZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>vars</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>vars</name></expr></argument>, <argument><expr><call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_vars</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addTypesZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: invalid syntax\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>types</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>types</name></expr></argument>, <argument><expr><call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args0</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><call><name>r_sign_add_types</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>types</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>types</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>addZign</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>args0</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_SIGN_BYTES</name></expr>:</case>

<case>case <expr><name>R_SIGN_ANAL</name></expr>:</case>

<return>return <expr><call><name>addBytesZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_GRAPH</name></expr>:</case>

<return>return <expr><call><name>addGraphZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_COMMENT</name></expr>:</case>

<return>return <expr><call><name>addCommentZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_NAME</name></expr>:</case>

<return>return <expr><call><name>addNameZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_OFFSET</name></expr>:</case>

<return>return <expr><call><name>addOffsetZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_REFS</name></expr>:</case>

<return>return <expr><call><name>addRefsZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_XREFS</name></expr>:</case>

<return>return <expr><call><name>addXRefsZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_VARS</name></expr>:</case>

<return>return <expr><call><name>addVarsZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_TYPES</name></expr>:</case>

<return>return <expr><call><name>addTypesZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><name>R_SIGN_BBHASH</name></expr>:</case>

<return>return <expr><call><name>addHashZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: unknown zignature type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdAdd</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zigname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>args0</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>r_str_new</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: za zigname type params\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out_case_manual</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>zigname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>

<expr_stmt><expr><name>args0</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>addZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>args0</name></expr></argument>, <argument><expr><name>n</name> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out_case_manual</name>;</goto>

</block_content>}</block></if></if_stmt>

<label><name>out_case_manual</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcnname</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>zigname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>r_str_new</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>r_str_word_set0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zaf [fcnname] [zigname]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>out_case_fcn</name>;</goto>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><name>zigname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name>fcnname</name> <operator>=</operator> <call><name>r_str_word_get0</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>fcnname</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>==</operator> <name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>fcnname</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>fcnname</name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>addFcnZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>zigname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<label><name>out_case_fcn</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>addFcnZign</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"generated zignatures: %d\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Adding Zignatures (examples and documentation)\n\n"</literal>

<literal type="string">"Zignature types:\n"</literal>

<literal type="string">" a: bytes pattern (anal mask)\n"</literal>

<literal type="string">" b: bytes pattern\n"</literal>

<literal type="string">" c: base64 comment\n"</literal>

<literal type="string">" n: real function name\n"</literal>

<literal type="string">" g: graph metrics\n"</literal>

<literal type="string">" o: original offset\n"</literal>

<literal type="string">" r: references\n"</literal>

<literal type="string">" x: cross references\n"</literal>

<literal type="string">" h: bbhash (hashing of fcn basic blocks)\n"</literal>

<literal type="string">" v: vars (and args)\n"</literal>

<literal type="string">"Bytes patterns:\n"</literal>

<literal type="string">" bytes can contain '..' (dots) to specify a binary mask\n\n"</literal>

<literal type="string">"Graph metrics:\n"</literal>

<literal type="string">" cc: cyclomatic complexity\n"</literal>

<literal type="string">" edges: number of edges\n"</literal>

<literal type="string">" nbbs: number of basic blocks\n"</literal>

<literal type="string">" ebbs: number of end basic blocks\n\n"</literal>

<literal type="string">"Examples:\n"</literal>

<literal type="string">" za foo b 558bec..e8........\n"</literal>

<literal type="string">" za foo a e811223344\n"</literal>

<literal type="string">" za foo g cc=2 nbbs=3 edges=3 ebbs=1\n"</literal>

<literal type="string">" za foo g nbbs=3 edges=3\n"</literal>

<literal type="string">" za foo v b-32 b-48 b-64\n"</literal>

<literal type="string">" za foo o 0x08048123\n"</literal>

<literal type="string">" za foo c this is a comment (base64?)\n"</literal>

<literal type="string">" za foo r sym.imp.strcpy sym.imp.sprintf sym.imp.strlen\n"</literal>

<literal type="string">" za foo h 2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_za</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: za[fF?] [args]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdOpen</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_sign_load</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zo filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_sign_save</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zos filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>r_sign_load_gz</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zoz filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_zo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zo[zs] filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdSpace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSpaces</name> <modifier>*</modifier></type><name>zs</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>zign_spaces</name></name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zs+zignspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_spaces_push</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zsr newname\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_spaces_rename</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\x00'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_spaces_pop</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_spaces_unset</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_spaces_unset</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>spaces_list</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zs zignspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_spaces_set</name> <argument_list>(<argument><expr><name>zs</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_zs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zs[+-*] [namespace]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdFlirt</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zfd filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_sign_flirt_dump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zfs filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dir.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>files</name> <init>= <expr><call><name>r_file_globsearch</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>files</argument>, <argument>iter</argument>, <argument>file</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_flirt_scan</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>files</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_zf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zf[dsz] filename\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>ctxSearchCB</name> <block>{

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>rad</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__fcnstrValidField</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg_number</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_ret</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"ret"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_args</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_arg</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"arg"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_arg_number</name> <init>= <expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>arg_number</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>!</operator><operator>(</operator><name>is_ret</name> <operator>&amp;&amp;</operator> <name>is_args</name> <operator>&amp;&amp;</operator> <name>is_arg</name> <operator>&amp;&amp;</operator> <name>is_arg_number</name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>__types_list_to_fcnstr</name><parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>types</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_kv</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>k</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>field</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>rettype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nargs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>types</argument>, <argument>iter</argument>, <argument>type_kv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>type_kv</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"\0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strtok</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>__fcnstrValidField</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>field</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name> <operator>=</operator> <name>field</name></expr>;</expr_stmt>

<expr_stmt><expr><name>field</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>field</name></expr></argument>, <argument><expr><literal type="string">"ret"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>arg</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rettype</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rettype</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"void"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s %s("</literal></expr></argument>, <argument><expr><name>rettype</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>args</argument>, <argument>iter</argument>, <argument>arg</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>iter</name> <operator>!=</operator> <call><name>r_list_tail</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s, "</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>

?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s);"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_list_get_top</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s);"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>rettype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>addFlag</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RSignItem</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>prefix</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rad</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zign_prefix</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.prefix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>types</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnstr</name> <init>= <expr><call><name>__types_list_to_fcnstr</name> <argument_list>(<argument><expr><name><name>it</name><operator>-&gt;</operator><name>types</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fcnstr_copy</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>fcnstr_copy</name></expr></argument>, <argument><expr><literal type="string">"("</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim_tail</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fcn_name</name> <init>= <expr><call><name>strrchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>fcn_name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>on_fcn_rename</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>on_fcn_rename</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>user</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_str_to_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcnstr_copy</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnstr_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fcnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>r_name_filter2</name> <argument_list>(<argument><expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s.%s_%d"</literal></expr></argument>, <argument><expr><name>zign_prefix</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rad</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f %s %d @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>it</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\"afn %s @ 0x%08"</literal><name>PFMT64x</name><literal type="string">"\"\n"</literal></expr></argument>, <argument><expr><name><name>it</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>searchHitCB</name><parameter_list>(<parameter><decl><type><name>RSignItem</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator>struct <name>ctxSearchCB</name> <operator>*</operator><operator>)</operator> <name>user</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>addFlag</name> <argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fcnMatchCB</name><parameter_list>(<parameter><decl><type><name>RSignItem</name> <modifier>*</modifier></type><name>it</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><operator>(</operator>struct <name>ctxSearchCB</name> <operator>*</operator><operator>)</operator> <name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>sz</name> <init>= <expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>addFlag</name> <argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>core</name></name></expr></argument>, <argument><expr><name>it</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>sz</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>rad</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ctx</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>searchRange</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rad</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minsz</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.minsz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RSignSearch</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><call><name>r_sign_search_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.align"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sign_search_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>minsz</name></expr></argument>, <argument><expr><name>searchHitCB</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>to</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sign_search_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"search: update read error at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sign_search_free</name> <argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>searchRange2</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RSignSearch</name> <modifier>*</modifier></type><name>ss</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rad</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>rlen</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>to</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sign_search_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rlen</name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"search: update read error at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rad</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only_func</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>bytes_search_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"bytes"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>graph_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"graph"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>offset_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"offset"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>refs_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"refs"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>hash_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"bbhash"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>types_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"types"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zign_prefix</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.prefix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mincc</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.mincc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.in"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useBytes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.bytes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useGraph</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.graph"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useOffset</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.offset"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useRefs</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.refs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useHash</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.hash"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useTypes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.types"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxsz</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.maxsz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs+%s\n"</literal></expr></argument>, <argument><expr><name>zign_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>zign_prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot create flagspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useBytes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>only_func</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] searching 0x%08"</literal><name>PFMT64x</name><literal type="string">" - 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>&amp;=</operator> <call><name>searchRange</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_search_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useGraph</name> <operator>||</operator> <name>useOffset</name> <operator>||</operator> <name>useRefs</name> <operator>||</operator> <name>useHash</name> <operator>||</operator> <operator>(</operator><name>useBytes</name> <operator>&amp;&amp;</operator> <name>only_func</name><operator>)</operator> <operator>||</operator> <name>useTypes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] searching function metrics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSignSearch</name> <modifier>*</modifier></type><name>ss</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>useBytes</name> <operator>&amp;&amp;</operator> <name>only_func</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>r_sign_search_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>ss</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.align"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minsz</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.minsz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_sign_search_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>minsz</name></expr></argument>, <argument><expr><name>searchHitCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_search_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useGraph</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_graph</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>mincc</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>graph_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useOffset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_addr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useRefs</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_refs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refs_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useHash</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_hash</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useBytes</name> <operator>&amp;&amp;</operator> <name>only_func</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Matching func %d / %d (hits %d)\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>bytes_search_ctx</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fcnlen</name> <init>= <expr><call><name>r_anal_function_realsize</name> <argument_list>(<argument><expr><name>fcni</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>addrbytes</name></name> <operator>*</operator> <name>fcnlen</name></expr></argument>, <argument><expr><name>maxsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>retval</name> <operator>&amp;=</operator> <call><name>searchRange2</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>rad</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_search_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useTypes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_types</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

TODO: add useXRefs, useName

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sign_search_free</name> <argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs-\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot restore flagspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>hits</name> <operator>=</operator> <name><name>bytes_search_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>graph_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator>

<name><name>offset_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>refs_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>hash_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>types_match_ctx</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hits: %d\n"</literal></expr></argument>, <argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdCompare</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_bytes_thresh</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.diff.bthresh"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>raw_graph_thresh</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.diff.gthresh"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSignOptions</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>r_sign_options_new</name> <argument_list>(<argument><expr><name>raw_bytes_thresh</name></expr></argument>, <argument><expr><name>raw_graph_thresh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zc other_space\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>r_sign_diff</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zcn other_space\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>r_sign_diff_by_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'!'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zcn! other_space\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>r_sign_diff_by_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zcn! other_space\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_zc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: zc[?n!] other_space\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_sign_options_free</name> <argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdCheck</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSignSearch</name> <modifier>*</modifier></type><name>ss</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcni</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>retval</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>rad</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>bytes_search_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"bytes"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>graph_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"graph"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>offset_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"offset"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>refs_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"refs"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>hash_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"bbhash"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>ctxSearchCB</name></name></type> <name>types_match_ctx</name> <init>= <expr><block>{ <expr><name>core</name></expr>, <expr><name>rad</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="string">"types"</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>zign_prefix</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.prefix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minsz</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.minsz"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mincc</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.mincc"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useBytes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.bytes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useGraph</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.graph"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useOffset</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.offset"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useRefs</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.refs"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useHash</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.hash"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>useTypes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"zign.types"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs+%s\n"</literal></expr></argument>, <argument><expr><name>zign_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>zign_prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot create flagspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useBytes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] searching 0x%08"</literal><name>PFMT64x</name><literal type="string">" - 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>at</name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ss</name> <operator>=</operator> <call><name>r_sign_search_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_sign_search_init</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><name>minsz</name></expr></argument>, <argument><expr><name>searchHitCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_search_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sign_search_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>ss</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>at</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"search: update read error at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>retval</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_sign_search_free</name> <argument_list>(<argument><expr><name>ss</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useGraph</name> <operator>||</operator> <name>useOffset</name> <operator>||</operator> <name>useRefs</name> <operator>||</operator> <name>useHash</name> <operator>||</operator> <name>useTypes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[+] searching function metrics\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcni</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fcni</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>useGraph</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_graph</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>mincc</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>graph_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useOffset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_addr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>offset_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useRefs</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_refs</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>refs_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useHash</name></expr>)</condition><block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_hash</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hash_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>useTypes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_sign_match_types</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcni</name></expr></argument>, <argument><expr><name>fcnMatchCB</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types_match_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rad</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs-\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"error: cannot restore flagspace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>hits</name> <operator>=</operator> <name><name>bytes_search_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>graph_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator>

<name><name>offset_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>refs_match_ctx</name><operator>.</operator><name>count</name></name> <operator>+</operator> <name><name>hash_match_ctx</name><operator>.</operator><name>count</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hits: %d\n"</literal></expr></argument>, <argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>retval</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdSearch</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<return>return <expr><call><name>search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<return>return <expr><call><name>search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: z/[f*]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_z_slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"usage: z/[*]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmdInfo</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>data</name> <operator>||</operator> <operator>!</operator><name>input</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>R_FLAGS_FS_SIGNS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>*</operator><name>input</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_zign</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_sign_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>*</operator><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"k anal/zigns/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_sign_delete</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<return>return <expr><call><name>cmdCheck</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<return>return <expr><call><name>cmdOpen</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<return>return <expr><call><name>cmdAdd</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"F"</literal></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<return>return <expr><call><name>cmdAdd</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<return>return <expr><call><name>cmdFlirt</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'/'</literal></expr>:</case> 

<return>return <expr><call><name>cmdSearch</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<return>return <expr><call><name>cmdCompare</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<return>return <expr><call><name>cmdSpace</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<return>return <expr><call><name>cmdInfo</name> <argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</return>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

</unit>
