<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_type.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_anal.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_cons.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_core.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sdb/sdb.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_t</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: t"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"#cparse types commands"</literal></expr>,

<expr><literal type="string">"t"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded types"</literal></expr>,

<expr><literal type="string">"tj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded types as json"</literal></expr>,

<expr><literal type="string">"t"</literal></expr>, <expr><literal type="string">" &lt;type&gt;"</literal></expr>, <expr><literal type="string">"Show type in 'pf' syntax"</literal></expr>,

<expr><literal type="string">"t*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List types info in r2 commands"</literal></expr>,

<expr><literal type="string">"t-"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Delete types by its name"</literal></expr>,

<expr><literal type="string">"t-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Remove all types"</literal></expr>,

<expr><literal type="string">"tail"</literal></expr>, <expr><literal type="string">" [filename]"</literal></expr>, <expr><literal type="string">"Output the last part of files"</literal></expr>,

<expr><literal type="string">"tc"</literal></expr>, <expr><literal type="string">" [type.name]"</literal></expr>, <expr><literal type="string">"List all/given types in C output format"</literal></expr>,

<expr><literal type="string">"te"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"List all loaded enums"</literal></expr>,

<expr><literal type="string">"td"</literal></expr>, <expr><literal type="string">"[?] &lt;string&gt;"</literal></expr>, <expr><literal type="string">"Load types from string"</literal></expr>,

<expr><literal type="string">"tf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded functions signatures"</literal></expr>,

<expr><literal type="string">"tk"</literal></expr>, <expr><literal type="string">" &lt;sdb-query&gt;"</literal></expr>, <expr><literal type="string">"Perform sdb query"</literal></expr>,

<expr><literal type="string">"tl"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Show/Link type to an address"</literal></expr>,

<expr><literal type="string">"tn"</literal></expr>, <expr><literal type="string">"[?] [-][addr]"</literal></expr>, <expr><literal type="string">"manage noreturn function attributes and marks"</literal></expr>,

<expr><literal type="string">"to"</literal></expr>, <expr><literal type="string">" -"</literal></expr>, <expr><literal type="string">"Open cfg.editor to load types"</literal></expr>,

<expr><literal type="string">"to"</literal></expr>, <expr><literal type="string">" &lt;path&gt;"</literal></expr>, <expr><literal type="string">"Load types from C header file"</literal></expr>,

<expr><literal type="string">"toe"</literal></expr>, <expr><literal type="string">" [type.name]"</literal></expr>, <expr><literal type="string">"Open cfg.editor to edit types"</literal></expr>,

<expr><literal type="string">"tos"</literal></expr>, <expr><literal type="string">" &lt;path&gt;"</literal></expr>, <expr><literal type="string">"Load types from parsed Sdb database"</literal></expr>,

<expr><literal type="string">"tp"</literal></expr>, <expr><literal type="string">" &lt;type&gt; [addr|varname]"</literal></expr>, <expr><literal type="string">"cast data at &lt;address&gt; to &lt;type&gt; and print it (XXX: type can contain spaces)"</literal></expr>,

<expr><literal type="string">"tpv"</literal></expr>, <expr><literal type="string">" &lt;type&gt; @ [value]"</literal></expr>, <expr><literal type="string">"Show offset formatted for given type"</literal></expr>,

<expr><literal type="string">"tpx"</literal></expr>, <expr><literal type="string">" &lt;type&gt; &lt;hexpairs&gt;"</literal></expr>, <expr><literal type="string">"Show value for type with specified byte sequence (XXX: type can contain spaces)"</literal></expr>,

<expr><literal type="string">"ts"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Print loaded struct types"</literal></expr>,

<expr><literal type="string">"tu"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"Print loaded union types"</literal></expr>,

<expr><literal type="string">"tx"</literal></expr>, <expr><literal type="string">"[f?]"</literal></expr>, <expr><literal type="string">"Type xrefs"</literal></expr>,

<expr><literal type="string">"tt"</literal></expr>, <expr><literal type="string">"[?]"</literal></expr>, <expr><literal type="string">"List all loaded typedefs"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tcc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tfc"</literal></expr>, <expr><literal type="string">"[-name]"</literal></expr>, <expr><literal type="string">"#type function calling conventions"</literal></expr>,

<expr><literal type="string">"tcc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all calling convcentions"</literal></expr>,

<expr><literal type="string">"tcc"</literal></expr>, <expr><literal type="string">" r0 pascal(r0,r1,r2)"</literal></expr>, <expr><literal type="string">"Show signature for the 'pascal' calling convention"</literal></expr>,

<expr><literal type="string">"tcc"</literal></expr>, <expr><literal type="string">"-pascal"</literal></expr>, <expr><literal type="string">"Remove the pascal cc"</literal></expr>,

<expr><literal type="string">"tcck"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List calling conventions in k=v"</literal></expr>,

<expr><literal type="string">"tccl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List the cc signatures"</literal></expr>,

<expr><literal type="string">"tccj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List them in JSON"</literal></expr>,

<expr><literal type="string">"tcc*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List them as r2 commands"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_t_minus</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: t-"</literal></expr>, <expr><literal type="string">" &lt;type&gt;"</literal></expr>, <expr><literal type="string">"Delete type by its name"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tf</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tf[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"tf"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all function definitions loaded"</literal></expr>,

<expr><literal type="string">"tf"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show function signature"</literal></expr>,

<expr><literal type="string">"tfc"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show function signature in C syntax"</literal></expr>,

<expr><literal type="string">"tfcj"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Same as above but in JSON"</literal></expr>,

<expr><literal type="string">"tfj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all function definitions in JSON"</literal></expr>,

<expr><literal type="string">"tfj"</literal></expr>, <expr><literal type="string">" &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show function signature in JSON"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_to</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: to[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"to"</literal></expr>, <expr><literal type="string">" -"</literal></expr>, <expr><literal type="string">"Open cfg.editor to load types"</literal></expr>,

<expr><literal type="string">"to"</literal></expr>, <expr><literal type="string">" &lt;path&gt;"</literal></expr>, <expr><literal type="string">"Load types from C header file"</literal></expr>,

<expr><literal type="string">"tos"</literal></expr>, <expr><literal type="string">" &lt;path&gt;"</literal></expr>, <expr><literal type="string">"Load types from parsed Sdb database"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tp</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tp[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"tp"</literal></expr>, <expr><literal type="string">" &lt;type&gt; [addr|varname]"</literal></expr>, <expr><literal type="string">"cast data at &lt;address&gt; to &lt;type&gt; and print it (XXX: type can contain spaces)"</literal></expr>,

<expr><literal type="string">"tpv"</literal></expr>, <expr><literal type="string">" &lt;type&gt; @ [value]"</literal></expr>, <expr><literal type="string">"Show offset formatted for given type"</literal></expr>,

<expr><literal type="string">"tpx"</literal></expr>, <expr><literal type="string">" &lt;type&gt; &lt;hexpairs&gt;"</literal></expr>, <expr><literal type="string">"Show value for type with specified byte sequence (XXX: type can contain spaces)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tc[...]"</literal></expr>, <expr><literal type="string">" [cctype]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"tc"</literal></expr>, <expr><literal type="string">" [type.name]"</literal></expr>, <expr><literal type="string">"List all/given loaded types in C output format with newlines"</literal></expr>,

<expr><literal type="string">"tcd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded types in C output format without newlines"</literal></expr>,

<expr><literal type="string">"tcc"</literal></expr>, <expr><literal type="string">"?"</literal></expr>, <expr><literal type="string">"Manage calling conventions types"</literal></expr>,

<expr><literal type="string">"tc?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_td</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"\"td [...]\""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"td"</literal></expr>, <expr><literal type="string">"[string]"</literal></expr>, <expr><literal type="string">"Load types from string"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_te</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: te[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"te"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded enums"</literal></expr>,

<expr><literal type="string">"te"</literal></expr>, <expr><literal type="string">" &lt;enum&gt;"</literal></expr>, <expr><literal type="string">"Print all values of enum for given name"</literal></expr>,

<expr><literal type="string">"tej"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded enums in json"</literal></expr>,

<expr><literal type="string">"tej"</literal></expr>, <expr><literal type="string">" &lt;enum&gt;"</literal></expr>, <expr><literal type="string">"Show enum in json"</literal></expr>,

<expr><literal type="string">"te"</literal></expr>, <expr><literal type="string">" &lt;enum&gt; &lt;value&gt;"</literal></expr>, <expr><literal type="string">"Show name for given enum number"</literal></expr>,

<expr><literal type="string">"teb"</literal></expr>, <expr><literal type="string">" &lt;enum&gt; &lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show matching enum bitfield for given name"</literal></expr>,

<expr><literal type="string">"tec"</literal></expr>, <expr><literal type="string">"&lt;name&gt;"</literal></expr>, <expr><literal type="string">"List all/given loaded enums in C output format with newlines"</literal></expr>,

<expr><literal type="string">"ted"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded enums in C output format without newlines"</literal></expr>,

<expr><literal type="string">"te?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tt</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tt[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"tt"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded typedefs"</literal></expr>,

<expr><literal type="string">"tt"</literal></expr>, <expr><literal type="string">" &lt;typename&gt;"</literal></expr>, <expr><literal type="string">"Show name for given type alias"</literal></expr>,

<expr><literal type="string">"ttj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show typename and type alias in json"</literal></expr>,

<expr><literal type="string">"ttc"</literal></expr>, <expr><literal type="string">"&lt;name&gt;"</literal></expr>, <expr><literal type="string">"Show typename and type alias in C output format"</literal></expr>,

<expr><literal type="string">"tt?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tl</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tl[...]"</literal></expr>, <expr><literal type="string">"[typename] [[=] address]"</literal></expr>, <expr><literal type="string">"#Type link commands"</literal></expr>,

<expr><literal type="string">"tl"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all links."</literal></expr>,

<expr><literal type="string">"tll"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all links in readable format."</literal></expr>,

<expr><literal type="string">"tllj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all links in readable JSON format."</literal></expr>,

<expr><literal type="string">"tl"</literal></expr>, <expr><literal type="string">" [typename]"</literal></expr>, <expr><literal type="string">"link a type to current address."</literal></expr>,

<expr><literal type="string">"tl"</literal></expr>, <expr><literal type="string">" [typename] = [address]"</literal></expr>, <expr><literal type="string">"link type to given address."</literal></expr>,

<expr><literal type="string">"tls"</literal></expr>, <expr><literal type="string">" [address]"</literal></expr>, <expr><literal type="string">"show link at given address."</literal></expr>,

<expr><literal type="string">"tl-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"delete all links."</literal></expr>,

<expr><literal type="string">"tl-"</literal></expr>, <expr><literal type="string">" [address]"</literal></expr>, <expr><literal type="string">"delete link at given address."</literal></expr>,

<expr><literal type="string">"tl*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all links in radare2 command format."</literal></expr>,

<expr><literal type="string">"tlj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list all links in JSON format."</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tn</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"tn [-][0xaddr|symname]"</literal></expr>, <expr><literal type="string">" manage no-return marks"</literal></expr>,

<expr><literal type="string">"tn[a]"</literal></expr>, <expr><literal type="string">" 0x3000"</literal></expr>, <expr><literal type="string">"stop function analysis if call/jmp to this address"</literal></expr>,

<expr><literal type="string">"tn[n]"</literal></expr>, <expr><literal type="string">" sym.imp.exit"</literal></expr>, <expr><literal type="string">"same as above but for flag/fcn names"</literal></expr>,

<expr><literal type="string">"tn-"</literal></expr>, <expr><literal type="string">" 0x3000 sym.imp.exit ..."</literal></expr>, <expr><literal type="string">"remove some no-return references"</literal></expr>,

<expr><literal type="string">"tn-*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"remove all no-return references"</literal></expr>,

<expr><literal type="string">"tn"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list them all"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_ts</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: ts[...]"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"ts"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded structs"</literal></expr>,

<expr><literal type="string">"ts"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf format string for given struct"</literal></expr>,

<expr><literal type="string">"tsj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded structs in json"</literal></expr>,

<expr><literal type="string">"tsj"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf format string for given struct in json"</literal></expr>,

<expr><literal type="string">"ts*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show pf.&lt;name&gt; format string for all loaded structs"</literal></expr>,

<expr><literal type="string">"ts*"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf.&lt;name&gt; format string for given struct"</literal></expr>,

<expr><literal type="string">"tsc"</literal></expr>, <expr><literal type="string">"&lt;name&gt;"</literal></expr>, <expr><literal type="string">"List all/given loaded structs in C output format with newlines"</literal></expr>,

<expr><literal type="string">"tsd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded structs in C output format without newlines"</literal></expr>,

<expr><literal type="string">"tss"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Display size of struct"</literal></expr>,

<expr><literal type="string">"ts?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_tu</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: tu[...]"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">""</literal></expr>,

<expr><literal type="string">"tu"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded unions"</literal></expr>,

<expr><literal type="string">"tu"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf format string for given union"</literal></expr>,

<expr><literal type="string">"tuj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded unions in json"</literal></expr>,

<expr><literal type="string">"tuj"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf format string for given union in json"</literal></expr>,

<expr><literal type="string">"tu*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Show pf.&lt;name&gt; format string for all loaded unions"</literal></expr>,

<expr><literal type="string">"tu*"</literal></expr>, <expr><literal type="string">" [type]"</literal></expr>, <expr><literal type="string">"Show pf.&lt;name&gt; format string for given union"</literal></expr>,

<expr><literal type="string">"tuc"</literal></expr>, <expr><literal type="string">"&lt;name&gt;"</literal></expr>, <expr><literal type="string">"List all/given loaded unions in C output format with newlines"</literal></expr>,

<expr><literal type="string">"tud"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List all loaded unions in C output format without newlines"</literal></expr>,

<expr><literal type="string">"tu?"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show this help"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_type_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>t</name><operator>-</operator></expr></argument>, <argument><expr><name>t_minus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>show_help</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__core_cmd_tcc</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tcc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_anal_cc_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcl"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>cc</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccexpr</name> <init>= <expr><call><name>r_anal_cc_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcl"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>cc</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccexpr</name> <init>= <expr><call><name>r_anal_cc_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccs</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcl"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>cc</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ccexpr</name> <init>= <expr><call><name>r_anal_cc_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"tfc %s\n"</literal></expr></argument>, <argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ccs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afck"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_cc_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>r_anal_cc_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showFormat</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>isenum</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isenum</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>isenum</name></expr></argument>, <argument><expr><literal type="string">"enum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"IS ENUM\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"pf.%s %s\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"pf %s\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find '%s' type\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_tail</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>_input</name></decl></parameter>)</parameter_list> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>input</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>_input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lines</name> <init>= <expr><literal type="number">5</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>count</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>count</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>lines</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tail [file] #to list last n lines in file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_fs_check</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"md %s"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_syscmd_tail</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>lines</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_type_noreturn</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tn-`tn`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_str_split_list</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>k</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_noreturn_drop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>n</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_noreturn_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_noreturn_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_noreturn_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_noreturn_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_noreturn_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_anal_noreturn_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>TDB_</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

<function><type><specifier>static</specifier> <name>int</name></type> <name>stdifstruct</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>TDB_</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"struct"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"typedef"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typedef_key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"typedef.%s"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB_</name></expr></argument>, <argument><expr><name>typedef_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>&amp;&amp;</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"struct "</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_struct_union_list_json</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name></decl></parameter>, <parameter><decl><type><name>SdbForeachCallback</name></type> <name>filter</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list_filter</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>k</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>k</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizecmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s.!size"</literal></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sizecmd</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>size_s</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sizecmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>size_s</name></expr> ?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>size_s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sizecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>size_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_struct_union_in_c_format</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name></decl></parameter>, <parameter><decl><type><name>SdbForeachCallback</name></type> <name>filter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>multiline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list_filter</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s {%s"</literal></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><literal type="string">"\n"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>var</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>var2</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>var2</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>sdb_array_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>var2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>val</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>multiline</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"\t%s"</literal></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name> <operator>&amp;&amp;</operator> <name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>strstr</name> <argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="string">" *"</literal></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="string">""</literal></expr></then><else>: <expr><literal type="string">" "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s %s;"</literal></expr></argument>, <argument><expr><name>space</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>multiline</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>var2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"};"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>space</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_enum_in_c_format</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>multiline</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>separator</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"enum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s {%s"</literal></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><literal type="string">"\n"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_type_get_enum</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTypeEnum</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<expr_stmt><expr><name>separator</name> <operator>=</operator> <ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><literal type="string">"\t"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>member</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s = %d"</literal></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>separator</name> <operator>=</operator> <ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><literal type="string">",\n\t"</literal></expr></then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><ternary><condition><expr><name>multiline</name></expr>?</condition><then> <expr><literal type="string">"\n};"</literal></expr></then><else>: <expr><literal type="string">"};"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>printkey_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>printFunctionTypeC</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>args</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.ret"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="string">"void"</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>||</operator> <operator>!</operator><name>name</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s ("</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>args</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.arg.%d"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>name</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>i</name><operator>==</operator><literal type="number">0</literal></expr>?</condition><then> <expr><literal type="string">""</literal></expr></then><else>: <expr><literal type="string">", "</literal></expr></else></ternary></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">");\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>printFunctionType</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>args</name> <init>= <expr><call><name>sdb_num_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.args"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret_type</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.ret"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ret"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>ret_type</name></expr>?</condition><then> <expr><name>ret_type</name></expr></then><else>: <expr><literal type="string">"void"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"args"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>args</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"func.%s.arg.%d"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>name</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="string">"(null)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>printfunc_json_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>printFunctionType</name> <argument_list>(<argument><expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>user</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>stdiffunc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>stdifunion</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"union"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"union"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>sdbdeletelink</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"link."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_type_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>stdiflink</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>k</name></expr></argument>, <argument><expr><literal type="string">"link."</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_link_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%s = %s\n"</literal></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_link_json_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"0x%s\":\"%s\"}"</literal></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_link_r_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"tl %s = 0x%s\n"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_link_readable_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't fint type %s"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"(%s)\n"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pf %s @ 0x%s\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_link_readable_json_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't fint type %s"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"%s\":"</literal></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pfj %s @ 0x%s\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"link."</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>stdiftype</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"type"</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_typelist_r_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"tk %s=%s\n"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>print_typelist_json_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>p</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>sdb</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sizecmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"type.%s.size"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>size_s</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>sizecmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>formatcmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"type.%s"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>format_s</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>sdb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>formatcmd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>format_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"type"</literal></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>size_s</name></expr> ?</condition><then> <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>size_s</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"format"</literal></expr></argument>, <argument><expr><name>format_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>size_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>format_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sizecmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>formatcmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_keys</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>SdbForeachCallback</name></type> <name>filter</name></decl></parameter>, <parameter><decl><type><name>SdbForeachCallback</name></type> <name>printfn_cb</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>json</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list_filter</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>filter</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>comma</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>k</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>k</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>comma</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>comma</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>printfn_cb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>json</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>typesList</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>print_typelist_r_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiftype</name></expr></argument>, <argument><expr><name>print_typelist_json_cb</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiftype</name></expr></argument>, <argument><expr><name>printkey_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_offset_hint</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>laddr</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offimm</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_type_get_struct_memb</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>offimm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmt</name> <init>= <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><name>offimm</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>res</name><operator>)</operator></expr>?</condition><then> <expr><name>res</name></expr></then><else>: <expr><name>type</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>offimm</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"link.%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>laddr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&amp;&amp;</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_hint_set_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>cmt</name> <operator>&amp;&amp;</operator> <call><name>r_anal_op_ismemref</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_meta_set_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_VARTYPE</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>cmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_get_stacksz</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>stack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxstack</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name> <modifier>*</modifier></type><name>op</name> <init>= <expr><call><name>r_core_anal_op</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>op</name> <operator>||</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>minopcode</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>op</name><operator>-&gt;</operator><name>stackop</name></name> <operator>==</operator> <name>R_ANAL_STACK_INC</name><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">8096</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stack</name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>stackptr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>&gt;</operator> <name>maxstack</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>maxstack</name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>op</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_free</name> <argument_list>(<argument><expr><name>op</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<return>return <expr><name>maxstack</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_retval</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnal</name> <modifier>*</modifier></type><name>anal</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hint</name> <operator>||</operator> <operator>!</operator><name>fcn</name> <operator>||</operator> <operator>!</operator><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hint</name><operator>-&gt;</operator><name>ret</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cc</name> <init>= <expr><call><name>r_anal_cc_func</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>regname</name> <init>= <expr><call><name>r_anal_cc_ret</name> <argument_list>(<argument><expr><name>anal</name></expr></argument>, <argument><expr><name>cc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>regname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>regname</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg</name></expr></argument>, <argument><expr><name><name>hint</name><operator>-&gt;</operator><name>ret</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_core_link_stroff</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ioCache</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.cache"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>stack_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>resolved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varpfx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dbg_follow</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc_name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp_name</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SP</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>bsize</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>maxinstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MAX_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_reg_arena_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_debug_reg_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>R_REG_TYPE_ALL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>spval</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>spval</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp_name</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curpc</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksz</name> <init>= <expr><call><name>r_core_get_stacksz</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>curpc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>stacksz</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_zero</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>sp</name></expr></argument>, <argument><expr><name>spval</name> <operator>+</operator> <name>stacksz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>stack_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.cache"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>oldoff</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><name>bb_cmpaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>it</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&lt;</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>bsize</name> <operator>-</operator> <name>maxinstrsz</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsize</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>minopcode</name></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>minopcode</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>ret</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>ireg</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>ireg</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>aop</name><operator>.</operator><name>scale</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>src_imm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>dst_imm</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>src_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>dst_addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>src</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>reg</name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>src_addr</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>src_imm</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>src</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>delta</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>dst</name></name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name></name> <operator>&amp;&amp;</operator> <name><name>aop</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dst_addr</name> <operator>=</operator> <call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>aop</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>reg</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>index</name></expr>;</expr_stmt>

<expr_stmt><expr><name>dst_imm</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>dst</name><operator>-&gt;</operator><name>delta</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RAnalVar</name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>var</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>false</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slink</name> <init>= <expr><call><name>r_type_link_at</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>src_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>vlink</name> <init>= <expr><call><name>r_type_link_at</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>src_addr</name> <operator>+</operator> <name>src_imm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dlink</name> <init>= <expr><call><name>r_type_link_at</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>dst_addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vlink</name> <operator>&amp;&amp;</operator> <name>var</name> <operator>&amp;&amp;</operator> <name><name>var</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <literal type="char">'r'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_type_kind</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>vlink</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>R_TYPE_UNION</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>varpfx</name> <operator>=</operator> <literal type="string">"union"</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>varpfx</name> <operator>=</operator> <literal type="string">"struct"</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument> , <argument><expr><name>vlink</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>resolved</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resolved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_retype</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>,

<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name>varpfx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>isarg</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_var_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>R_ANAL_VAR_SCOPE_LOCAL</name></expr></argument>,

<argument><expr><name><name>var</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>vlink</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>slink</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_offset_hint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>slink</name></expr></argument>, <argument><expr><name>src_addr</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>ret</name></expr></argument>, <argument><expr><name>src_imm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>dlink</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_offset_hint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>dlink</name></expr></argument>, <argument><expr><name>dst_addr</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>ret</name></expr></argument>, <argument><expr><name>dst_imm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_op_nonlinear</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>esil</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>set_retval</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>vlink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>slink</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wc-*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"io.cache"</literal></expr></argument>, <argument><expr><name>ioCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dbg.follow"</literal></expr></argument>, <argument><expr><name>dbg_follow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>stack_set</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeim-"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_reg_arena_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_type</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<expr_stmt><expr><name>TDB_</name> <operator>=</operator> <name>TDB</name></expr>;</expr_stmt> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_type_noreturn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case> <block>{<block_content> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tu</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list_filter</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifunion</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>print_struct_union_list_json</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifunion</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_struct_union_in_c_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifunion</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_struct_union_in_c_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifunion</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdifunion</name></expr></argument>, <argument><expr><name>printkey_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case> 

<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>

?</condition><then> <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"*"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>__core_cmd_tcc</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>type</name></expr> ?</condition><then> <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"struct"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tsc %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"union"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tuc %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"enum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tec %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"typedef"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ttc %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="string">"func"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tfc %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ts*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tfc;tuc;tsc;ttc;tec"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"tud;tsd;ttc;ted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> <block>{<block_content> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list_filter</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifstruct</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>it</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><operator>(</operator><call><name>r_type_get_bitsize</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">8</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_ts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdifstruct</name></expr></argument>, <argument><expr><name>printkey_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_struct_union_in_c_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifstruct</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_struct_union_in_c_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifstruct</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>print_struct_union_list_json</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>stdifstruct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>TDB</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>sdb_types</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><ternary><condition><expr><name>temp</name></expr> ?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>temp</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>member_name</name> <init>= <expr><ternary><condition><expr><name>name</name></expr> ?</condition><then> <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>member_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>member_name</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>r_type_kind</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>R_TYPE_ENUM</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s is not an enum\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_te</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"enum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_type_get_enum</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTypeEnum</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>member</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTypeEnum</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>member_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_type_enum_member</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>member_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_type_get_enum</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>member</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_type_enum_member</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>member_name</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<expr_stmt><expr><call><name>print_enum_in_c_format</name><argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_enum_in_c_format</name><argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>member_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_type_enum_member</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>member_name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_type_get_enum</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTypeEnum</name> <modifier>*</modifier></type><name>member</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>member</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s = %s\n"</literal></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>member</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"enum"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>member_name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid enum member\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>showFormat</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>typesList</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"dir.types"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>homefile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>filename</name> <operator>==</operator> <literal type="char">'~'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>filename</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>filename</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>homefile</name> <operator>=</operator> <call><name>r_str_home</name> <argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>homefile</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"-"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"*.h"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_save_parsed_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error_msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_file</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_save_parsed_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error_msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>homefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbpath</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_file_exists</name> <argument_list>(<argument><expr><name>dbpath</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_tmp</name> <init>= <expr><call><name>sdb_new</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>dbpath</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_merge</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>db_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_close</name> <argument_list>(<argument><expr><name>db_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>db_tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument> , <argument><expr><literal type="string">"tc %s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_core_editor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"*.h"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_parse_c_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_save_parsed_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error_msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Sandbox: system call disabled\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Note: The td command should be put between double quotes\n"</literal>

<literal type="string">"Example: \"td struct foo {int bar;int cow;};\""</literal>

<literal type="string">"\nt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s;"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tmp</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>error_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name> <init>= <expr><call><name>r_parse_c_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>error_msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_save_parsed_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>error_msg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fprintf</name> <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>error_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid use of td. See td? for help\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>type2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>r_anal_types_from_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniq</argument> , <argument>iter</argument> , <argument>type</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>uniq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"cannot find function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>r_anal_types_from_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>uniq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniq</argument> , <argument>iter2</argument>, <argument>type</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>iter2</name><operator>-&gt;</operator><name>n</name></name></expr> ?</condition><then> <expr><literal type="string">","</literal></expr></then><else>:<expr><literal type="string">"\n"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>r_anal_types_from_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>uniq</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniq</argument> , <argument>iter2</argument>, <argument>type</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>myType</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_replace_ch</name> <argument_list>(<argument><expr><name>myType</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><literal type="char">'_'</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s\n"</literal></expr></argument>, <argument><expr><name>myType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><name>myType</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>myType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniqList</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>r_anal_types_from_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniq</argument> , <argument>iter2</argument>, <argument>type</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name>uniqList</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name>uniqList</name></expr></argument>, <argument><expr><call><name>strdup</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>uniqList</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator><name>strcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniqList</argument>, <argument>iter</argument>, <argument>type</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>uniqList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;anal-&gt;fcns</argument>, <argument>iter</argument>, <argument>fcn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>uniq</name> <init>= <expr><call><name>r_anal_types_from_fcn</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>uniq</argument> , <argument>iter2</argument>, <argument>type2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>type2</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tx[flg] [...]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" txf | tx. list all types used in this function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" txl list all types used by any function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" txg render the type xrefs graph\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" tx int32_t list functions names using this type\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" tx list functions and the types they use\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cmd_tail</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tail [number] [file]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block> <break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[WARNING] \"ta\" is deprecated. Use \"aht\" instead.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"tl: Address is unvalid\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_type_set_link</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>fcns</name> <init>= <expr><call><name>r_anal_get_functions_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Multiple functions found in here.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_link_stroff</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any function here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>fcns</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"unknown type %s\n"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"link.%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>link</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>link</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>print_link_readable_cb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>link</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>sdbdeletelink</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_type_unlink</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiflink</name></expr></argument>, <argument><expr><name>print_link_r_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiflink</name></expr></argument>, <argument><expr><name>print_link_readable_json_cb</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiflink</name></expr></argument>, <argument><expr><name>print_link_readable_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiflink</name></expr></argument>, <argument><expr><name>print_link_json_cb</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiflink</name></expr></argument>, <argument><expr><name>print_link_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'v'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_name</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type_name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fmt</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>val</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pf %s @v:0x%08"</literal> <name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tpv [type] @ [value]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>||</operator> <operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type_begin</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type_begin</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>type_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type_end</name> <init>= <expr><call><name>r_str_rchr</name> <argument_list>(<argument><expr><name>type_begin</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type_len</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type_end</name><operator>)</operator></expr>

?</condition><then> <expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>type_end</name> <operator>-</operator> <name>type_begin</name><operator>)</operator></expr>

</then><else>: <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>type_begin</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>type_begin</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>type</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>type_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>type_begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>type_end</name><operator>)</operator></expr> ?</condition><then> <expr><name>type_end</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>r_type_format</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fmt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find '%s' type\n"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <name>arg</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pf %s @x:%s"</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name>arg</name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>original_addr</name> <init>= <expr><name>addr</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name> <operator>&amp;&amp;</operator> <name>arg</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_anal_var_addr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pf %s @ 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>original_addr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pf %s @ 0x%08"</literal> <name>PFMT64x</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>original_addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tp?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: tp?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_t_minus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_parse_c_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><call><name>IS_WHITESPACE</name> <argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><name>name</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_remove_parsed_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid use of t- . See t-? for help.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiffunc</name></expr></argument>, <argument><expr><name>printkey_cb</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printFunctionTypeC</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>printFunctionType</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>print_keys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>stdiffunc</name></expr></argument>, <argument><expr><name>printfunc_json_cb</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_querys</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"~~func.%s"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"typedef"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"typedef.%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>l</argument>, <argument>iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"typedef"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>name</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>arg</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>arg</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"typedef.%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s %s;\n"</literal></expr></argument>, <argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ls_free</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_tt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>istypedef</name></decl>;</decl_stmt>

<expr_stmt><expr><name>istypedef</name> <operator>=</operator> <call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>istypedef</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>istypedef</name></expr></argument>, <argument><expr><literal type="string">"typedef"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"typedef.%s"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name>TDB</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"This is not an typedef\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>show_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

</unit>
