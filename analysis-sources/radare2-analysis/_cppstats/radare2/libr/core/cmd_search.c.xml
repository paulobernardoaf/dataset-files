<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_search.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sdb/ht_uu.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_hash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_io.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_list.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_types_base.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmd_search_rop.c"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>cmd_search</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_EMULATION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_m</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"/m"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search for known magic patterns"</literal></expr>,

<expr><literal type="string">"/m"</literal></expr>, <expr><literal type="string">" [file]"</literal></expr>, <expr><literal type="string">"same as above but using the given magic file"</literal></expr>,

<expr><literal type="string">"/me"</literal></expr>, <expr><literal type="string">" "</literal></expr>, <expr><literal type="string">"like ?e similar to IRC's /me"</literal></expr>,

<expr><literal type="string">"/mm"</literal></expr>, <expr><literal type="string">" "</literal></expr>, <expr><literal type="string">"search for known filesystems and mount them automatically"</literal></expr>,

<expr><literal type="string">"/mb"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search recognized RBin headers"</literal></expr>,

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"/[!bf] [arg]"</literal></expr>, <expr><literal type="string">"Search stuff (see 'e??search' for options)\n"</literal>

<literal type="string">"|Use io.va for searching in non virtual addressing spaces"</literal></expr>,

<expr><literal type="string">"/"</literal></expr>, <expr><literal type="string">" foo\\x00"</literal></expr>, <expr><literal type="string">"search for string 'foo\\0'"</literal></expr>,

<expr><literal type="string">"/j"</literal></expr>, <expr><literal type="string">" foo\\x00"</literal></expr>, <expr><literal type="string">"search for string 'foo\\0' (json output)"</literal></expr>,

<expr><literal type="string">"/!"</literal></expr>, <expr><literal type="string">" ff"</literal></expr>, <expr><literal type="string">"search for first occurrence not matching, command modifier"</literal></expr>,

<expr><literal type="string">"/!x"</literal></expr>, <expr><literal type="string">" 00"</literal></expr>, <expr><literal type="string">"inverse hexa search (find first byte != 0x00)"</literal></expr>,

<expr><literal type="string">"/+"</literal></expr>, <expr><literal type="string">" /bin/sh"</literal></expr>, <expr><literal type="string">"construct the string with chunks"</literal></expr>,

<expr><literal type="string">"//"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"repeat last search"</literal></expr>,

<expr><literal type="string">"/a"</literal></expr>, <expr><literal type="string">"[?][1aoditfmsltf] jmp eax"</literal></expr>, <expr><literal type="string">"assemble opcode and search its bytes"</literal></expr>,

<expr><literal type="string">"/b"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search backwards, command modifier, followed by other command"</literal></expr>,

<expr><literal type="string">"/c"</literal></expr>, <expr><literal type="string">"[ar]"</literal></expr>, <expr><literal type="string">"search for crypto materials"</literal></expr>,

<expr><literal type="string">"/d"</literal></expr>, <expr><literal type="string">" 101112"</literal></expr>, <expr><literal type="string">"search for a deltified sequence of bytes"</literal></expr>,

<expr><literal type="string">"/e"</literal></expr>, <expr><literal type="string">" /E.F/i"</literal></expr>, <expr><literal type="string">"match regular expression"</literal></expr>,

<expr><literal type="string">"/E"</literal></expr>, <expr><literal type="string">" esil-expr"</literal></expr>, <expr><literal type="string">"offset matching given esil expressions %%= here"</literal></expr>,

<expr><literal type="string">"/f"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search forwards, (command modifier)"</literal></expr>,

<expr><literal type="string">"/F"</literal></expr>, <expr><literal type="string">" file [off] [sz]"</literal></expr>, <expr><literal type="string">"search contents of file with offset and size"</literal></expr>,

<expr><literal type="string">"/g"</literal></expr>, <expr><literal type="string">"[g] [from]"</literal></expr>, <expr><literal type="string">"find all graph paths A to B (/gg follow jumps, see search.count and anal.depth)"</literal></expr>,

<expr><literal type="string">"/h"</literal></expr>, <expr><literal type="string">"[t] [hash] [len]"</literal></expr>, <expr><literal type="string">"find block matching this hash. See ph"</literal></expr>,

<expr><literal type="string">"/i"</literal></expr>, <expr><literal type="string">" foo"</literal></expr>, <expr><literal type="string">"search for string 'foo' ignoring case"</literal></expr>,

<expr><literal type="string">"/m"</literal></expr>, <expr><literal type="string">"[?][ebm] magicfile"</literal></expr>, <expr><literal type="string">"search for magic, filesystems or binary headers"</literal></expr>,

<expr><literal type="string">"/o"</literal></expr>, <expr><literal type="string">" [n]"</literal></expr>, <expr><literal type="string">"show offset of n instructions backward"</literal></expr>,

<expr><literal type="string">"/O"</literal></expr>, <expr><literal type="string">" [n]"</literal></expr>, <expr><literal type="string">"same as /o, but with a different fallback if anal cannot be used"</literal></expr>,

<expr><literal type="string">"/p"</literal></expr>, <expr><literal type="string">" patternsize"</literal></expr>, <expr><literal type="string">"search for pattern of given size"</literal></expr>,

<expr><literal type="string">"/P"</literal></expr>, <expr><literal type="string">" patternsize"</literal></expr>, <expr><literal type="string">"search similar blocks"</literal></expr>,

<expr><literal type="string">"/s"</literal></expr>, <expr><literal type="string">"[*] [threshold]"</literal></expr>, <expr><literal type="string">"find sections by grouping blocks with similar entropy"</literal></expr>,

<expr><literal type="string">"/r[erwx]"</literal></expr>, <expr><literal type="string">"[?] sym.printf"</literal></expr>, <expr><literal type="string">"analyze opcode reference an offset (/re for esil)"</literal></expr>,

<expr><literal type="string">"/R"</literal></expr>, <expr><literal type="string">" [grepopcode]"</literal></expr>, <expr><literal type="string">"search for matching ROP gadgets, semicolon-separated"</literal></expr>,

<expr><literal type="string">"/v"</literal></expr>, <expr><literal type="string">"[1248] value"</literal></expr>, <expr><literal type="string">"look for an `cfg.bigendian` 32bit value"</literal></expr>,

<expr><literal type="string">"/V"</literal></expr>, <expr><literal type="string">"[1248] min max"</literal></expr>, <expr><literal type="string">"look for an `cfg.bigendian` 32bit value in range"</literal></expr>,

<expr><literal type="string">"/w"</literal></expr>, <expr><literal type="string">" foo"</literal></expr>, <expr><literal type="string">"search for wide string 'f\\0o\\0o\\0'"</literal></expr>,

<expr><literal type="string">"/wi"</literal></expr>, <expr><literal type="string">" foo"</literal></expr>, <expr><literal type="string">"search for wide string ignoring case 'f\\0o\\0o\\0'"</literal></expr>,

<expr><literal type="string">"/x"</literal></expr>, <expr><literal type="string">" ff..33"</literal></expr>, <expr><literal type="string">"search for hex string ignoring some nibbles"</literal></expr>,

<expr><literal type="string">"/x"</literal></expr>, <expr><literal type="string">" ff0033"</literal></expr>, <expr><literal type="string">"search for hex string"</literal></expr>,

<expr><literal type="string">"/x"</literal></expr>, <expr><literal type="string">" ff43:ffd0"</literal></expr>, <expr><literal type="string">"search for hexpair with mask"</literal></expr>,

<expr><literal type="string">"/z"</literal></expr>, <expr><literal type="string">" min max"</literal></expr>, <expr><literal type="string">"search for strings of given size"</literal></expr>,

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

"\nConfiguration:", "", " (type `e??search.` for a complete list)",

"e", " cmd.hit = x", "command to execute on every search hit",

"e", " search.in = ?", "specify where to search stuff (depends on .from/.to)",

"e", " search.align = 4", "only catch aligned search hits",

"e", " search.from = 0", "start address",

"e", " search.to = 0", "end address",

"e", " search.flags = true", "if enabled store flags on keyword hits",

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_a</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"/a[1adefilmost][?ljq] [instr | op.type | op.family]"</literal></expr>, <expr><literal type="string">"Search for assembly"</literal></expr>,

<expr><literal type="string">"/a"</literal></expr>, <expr><literal type="string">" push rbp"</literal></expr>, <expr><literal type="string">"assemble given instruction and search the bytes"</literal></expr>,

<expr><literal type="string">"/a1"</literal></expr>, <expr><literal type="string">" [number]"</literal></expr>, <expr><literal type="string">"find valid assembly generated by changing only the nth byte"</literal></expr>,

<expr><literal type="string">"/aa"</literal></expr>, <expr><literal type="string">" mov eax"</literal></expr>, <expr><literal type="string">"linearly find aproximated assembly (case insensitive strstr)"</literal></expr>,

<expr><literal type="string">"/ac"</literal></expr>, <expr><literal type="string">" mov eax"</literal></expr>, <expr><literal type="string">"same as /aa, but case-sensitive"</literal></expr>,

<expr><literal type="string">"/ad"</literal></expr>, <expr><literal type="string">"[/*j] push;mov"</literal></expr>, <expr><literal type="string">"match ins1 followed by ins2 in linear disasm"</literal></expr>,

<expr><literal type="string">"/ad/"</literal></expr>, <expr><literal type="string">" ins1;ins2"</literal></expr>, <expr><literal type="string">"search for regex instruction 'ins1' followed by regex 'ins2'"</literal></expr>,

<expr><literal type="string">"/ad/a"</literal></expr>, <expr><literal type="string">" instr"</literal></expr>, <expr><literal type="string">"search for every byte instruction that matches regexp 'instr'"</literal></expr>,

<expr><literal type="string">"/ae"</literal></expr>, <expr><literal type="string">" esil"</literal></expr>, <expr><literal type="string">"search for esil expressions matching substring"</literal></expr>,

<expr><literal type="string">"/af"</literal></expr>, <expr><literal type="string">"[l] family"</literal></expr>, <expr><literal type="string">"Search for instruction of specific family (afl=list"</literal></expr>,

<expr><literal type="string">"/ai"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for infinite loop instructions (jmp $$)"</literal></expr>,

<expr><literal type="string">"/aI"</literal></expr>, <expr><literal type="string">"[j] 0x300 [0x500]"</literal></expr>, <expr><literal type="string">"find all the instructions using that immediate (in range)"</literal></expr>,

<expr><literal type="string">"/al"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Same as aoml, list all opcodes"</literal></expr>,

<expr><literal type="string">"/am"</literal></expr>, <expr><literal type="string">" opcode"</literal></expr>, <expr><literal type="string">"Search for specific instructions of specific mnemonic"</literal></expr>,

<expr><literal type="string">"/ao"</literal></expr>, <expr><literal type="string">" instr"</literal></expr>, <expr><literal type="string">"search for instruction 'instr' (in all offsets)"</literal></expr>,

<expr><literal type="string">"/as"</literal></expr>, <expr><literal type="string">"[l] ([type])"</literal></expr>, <expr><literal type="string">"Search for syscalls (See /at swi and /af priv)"</literal></expr>,

<expr><literal type="string">"/at"</literal></expr>, <expr><literal type="string">"[l] ([type])"</literal></expr>, <expr><literal type="string">"Search for instructions of given type"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_c</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: /c"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for crypto materials"</literal></expr>,

<expr><literal type="string">"/ca"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for AES keys expanded in memory"</literal></expr>,

<expr><literal type="string">"/cc"</literal></expr>, <expr><literal type="string">"[algo] [digest]"</literal></expr>, <expr><literal type="string">"Find collisions (bruteforce block length values until given checksum is found)"</literal></expr>,

<expr><literal type="string">"/cd"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for ASN1/DER certificates"</literal></expr>,

<expr><literal type="string">"/cr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for ASN1/DER private keys (RSA and ECC)"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_r</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"/r[acerwx] [address]"</literal></expr>, <expr><literal type="string">" search references to this specific address"</literal></expr>,

<expr><literal type="string">"/r"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"search references to this specific address"</literal></expr>,

<expr><literal type="string">"/ra"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search all references"</literal></expr>,

<expr><literal type="string">"/rc"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"search for call references"</literal></expr>,

<expr><literal type="string">"/re"</literal></expr>, <expr><literal type="string">" [addr]"</literal></expr>, <expr><literal type="string">"search references using esil"</literal></expr>,

<expr><literal type="string">"/rr"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Find read references"</literal></expr>,

<expr><literal type="string">"/rw"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Find write references"</literal></expr>,

<expr><literal type="string">"/rx"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Find exec references"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_R</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: /R"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Search for ROP gadgets"</literal></expr>,

<expr><literal type="string">"/R"</literal></expr>, <expr><literal type="string">" [filter-by-string]"</literal></expr>, <expr><literal type="string">"Show gadgets"</literal></expr>,

<expr><literal type="string">"/R/"</literal></expr>, <expr><literal type="string">" [filter-by-regexp]"</literal></expr>, <expr><literal type="string">"Show gadgets [regular expression]"</literal></expr>,

<expr><literal type="string">"/R/j"</literal></expr>, <expr><literal type="string">" [filter-by-regexp]"</literal></expr>, <expr><literal type="string">"JSON output [regular expression]"</literal></expr>,

<expr><literal type="string">"/R/q"</literal></expr>, <expr><literal type="string">" [filter-by-regexp]"</literal></expr>, <expr><literal type="string">"Show gadgets in a quiet manner [regular expression]"</literal></expr>,

<expr><literal type="string">"/Rj"</literal></expr>, <expr><literal type="string">" [filter-by-string]"</literal></expr>, <expr><literal type="string">"JSON output"</literal></expr>,

<expr><literal type="string">"/Rk"</literal></expr>, <expr><literal type="string">" [select-by-class]"</literal></expr>, <expr><literal type="string">"Query stored ROP gadgets"</literal></expr>,

<expr><literal type="string">"/Rq"</literal></expr>, <expr><literal type="string">" [filter-by-string]"</literal></expr>, <expr><literal type="string">"Show gadgets in a quiet manner"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_Rk</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: /Rk"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"Query stored ROP gadgets"</literal></expr>,

<expr><literal type="string">"/Rk"</literal></expr>, <expr><literal type="string">" [nop|mov|const|arithm|arithm_ct]"</literal></expr>, <expr><literal type="string">"Show gadgets"</literal></expr>,

<expr><literal type="string">"/Rkj"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"JSON output"</literal></expr>,

<expr><literal type="string">"/Rkq"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"List Gadgets offsets"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_slash_x</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage:"</literal></expr>, <expr><literal type="string">"/x [hexpairs]:[binmask]"</literal></expr>, <expr><literal type="string">"Search in memory"</literal></expr>,

<expr><literal type="string">"/x "</literal></expr>, <expr><literal type="string">"9090cd80"</literal></expr>, <expr><literal type="string">"search for those bytes"</literal></expr>,

<expr><literal type="string">"/x "</literal></expr>, <expr><literal type="string">"9090cd80:ffff7ff0"</literal></expr>, <expr><literal type="string">"search with binary mask"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>preludecnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>searchflags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>searchshow</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>searchprefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<struct>struct <name>search_parameters</name> <block>{

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>boundaries</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd_hit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>outmode</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>inverse</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>crypto_search</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>aes_search</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>privkey_search</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>endlist_pair</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>instr_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delay_size</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_search_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator></expr></argument>, <argument><expr><name>slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>a</name></expr></argument>, <argument><expr><name>slash_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>c</name></expr></argument>, <argument><expr><name>slash_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>r</name></expr></argument>, <argument><expr><name>slash_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>R</name></expr></argument>, <argument><expr><name>slash_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>Rk</name></expr></argument>, <argument><expr><name>slash_Rk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR_SPECIAL</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>/</operator><name>x</name></expr></argument>, <argument><expr><name>slash_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>search_hash</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashstr</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>minlen</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>maxlen</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>minlen</name> <operator>||</operator> <name>minlen</name> <operator>==</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>minlen</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>maxlen</name> <operator>||</operator> <name>maxlen</name> <operator>==</operator> <name>UT32_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>maxlen</name> <operator>=</operator> <name>minlen</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <name>minlen</name></expr>;</init> <condition><expr><name>j</name> <operator>&lt;=</operator> <name>maxlen</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>len</name> <init>= <expr><name>j</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Searching %s for %d byte length.\n"</literal></expr></argument>, <argument><expr><name>hashname</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>bufsz</name></decl>;</decl_stmt>

<expr_stmt><expr><name>bufsz</name> <operator>=</operator> <name>to</name> <operator>-</operator> <name>from</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Hash length is bigger than range 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %"</literal><name>PFMT64d</name> <literal type="string">" bytes\n"</literal></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>hell</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Search in range 0x%08"</literal><name>PFMT64x</name> <literal type="string">" and 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>blocks</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>to</name> <operator>-</operator> <name>from</name> <operator>-</operator> <name>len</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Carving %d blocks...\n"</literal></expr></argument>, <argument><expr><name>blocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>(</operator><name>from</name> <operator>+</operator> <name>i</name> <operator>+</operator> <name>len</name><operator>)</operator> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>r_hash_to_string</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>hashname</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>i</name> <operator>%</operator> <literal type="number">5</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%d\r"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Hash fail\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>hashstr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Found at 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f hash.%s.%s = 0x%"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>hashname</name></expr></argument>, <argument><expr><name>hashstr</name></expr></argument>, <argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No hashes found\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

<label><name>hell</name>:</label>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_search_bin</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>itv</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>r_buf_new_with_io</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>iob</name></name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>from</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RBuffer</name> <modifier>*</modifier></type><name>ref</name> <init>= <expr><call><name>r_buf_new_slice</name> <argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinPlugin</name> <modifier>*</modifier></type><name>plug</name> <init>= <expr><call><name>r_bin_get_binplugin_by_buffer</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>plug</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>plug</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>plug</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinOptions</name></type> <name>opt</name> <init>= <expr><block>{

<expr><operator>.</operator><name>pluginname</name> <operator>=</operator> <name><name>plug</name><operator>-&gt;</operator><name>name</name></name></expr>,

<expr><operator>.</operator><name>baseaddr</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>loadaddr</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>sz</name> <operator>=</operator> <literal type="number">4096</literal></expr>,

<expr><operator>.</operator><name>xtr_idx</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>rawstr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>rawstr</name></name></expr>,

<expr><operator>.</operator><name>fd</name> <operator>=</operator> <name>fd</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_bin_open_io</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name><name>plug</name><operator>-&gt;</operator><name>size</name></name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"size %d\n"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name>ref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>from</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_buf_free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>__prelude_cb_hit</name><parameter_list>(<parameter><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_anal_fcn</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_REF_TYPE_NULL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>preludecnt</name><operator>++</operator></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_search_prelude</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>blen</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>mask</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mlen</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"aap: Invalid search range 0x%08"</literal><name>PFMT64x</name> <literal type="string">" - 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><call><name>r_search_keyword_new</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>mlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_callback</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>__prelude_cb_hit</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>preludecnt</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_search_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"search: update read error at 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_search_kw_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>preludecnt</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>count_functions</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_search_preludes</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>log</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prelude</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.prelude"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>where</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.in"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>R_PERM_X</name></expr></argument>, <argument><expr><name>where</name></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fc0</name> <init>= <expr><call><name>count_functions</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\r[&gt;] Scanning %s 0x%"</literal><name>PFMT64x</name> <literal type="string">" - 0x%"</literal><name>PFMT64x</name> <literal type="string">" "</literal></expr></argument>,

<argument><expr><call><name>r_str_rwx_i</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>p</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_X</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"skip\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>p</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>prelude</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>prelude</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>prelude</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kwlen</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>prelude</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_search_prelude</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><name>kwlen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>preds</name> <init>= <expr><call><name>r_anal_preludes</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>preds</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>preds</argument>, <argument>iter</argument>, <argument>kw</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_search_prelude</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>,

<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>bin_keyword</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name></expr></argument>,

<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>bin_binmask</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>binmask_length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ap: Unsupported asm.arch and asm.bits\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>int</name></type> <name>fc1</name> <init>= <expr><call><name>count_functions</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>log</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Analyzed %d functions based on preludes\n"</literal></expr></argument>, <argument><expr><name>fc1</name> <operator>-</operator> <name>fc0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No executable section found, cannot analyze anything. Use 'S' to change or define permissions of sections\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>getstring</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>r</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>l</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>r</name> <operator>=</operator> <name>res</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>l</name></expr>;</condition> <incr><expr><name>b</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>IS_PRINTABLE</name> <argument_list>(<argument><expr><operator>*</operator><name>b</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>r</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>b</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><operator>*</operator><name>r</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>_cb_hit</name><parameter_list>(<parameter><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>param</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>base_addr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>use_color</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>R_PRINT_FLAGS_COLOR</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>keyword_len</name> <init>= <expr><ternary><condition><expr><name>kw</name></expr> ?</condition><then> <expr><name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name> <operator>+</operator> <operator>(</operator><name><name>search</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_SEARCH_DELTAKEY</name><operator>)</operator></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>searchshow</name> <operator>&amp;&amp;</operator> <name>kw</name> <operator>&amp;&amp;</operator> <name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>extra</name></decl>, <decl><type ref="prev"/><name>mallocsize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>extra</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name><operator>)</operator></expr>?</condition><then> <expr><literal type="number">3</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><literal type="string">"hexpair"</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>escaped</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>kw</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_SEARCH_KEYWORD_TYPE_STRING</name></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ctx</name> <init>= <expr><literal type="number">16</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prectx</name> <init>= <expr><ternary><condition><expr><name>addr</name> <operator>&gt;</operator> <literal type="number">16</literal></expr> ?</condition><then> <expr><name>ctx</name></expr> </then><else>: <expr><name>addr</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pre</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pos</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wrd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name> <init>= <expr><name>keyword_len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">32</literal> <operator>+</operator> <name>ctx</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"string"</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>-</operator> <name>prectx</name></expr></argument>, <argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <operator>(</operator><name>ctx</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pre</name> <operator>=</operator> <call><name>getstring</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prectx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wrd</name> <operator>=</operator> <call><name>r_str_utf16_encode</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>prectx</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>getstring</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>prectx</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pos</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pre_esc</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pos_esc</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%s%s"</literal></expr></argument>, <argument><expr><name>pre_esc</name></expr></argument>, <argument><expr><name>wrd</name></expr></argument>, <argument><expr><name>pos_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>escaped</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pre_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pos_esc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>use_color</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">".%s"</literal><name>Color_YELLOW</name> <literal type="string">"%s"</literal><name>Color_RESET</name> <literal type="string">"%s."</literal></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>wrd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"\"%s%s%s\""</literal></expr></argument>, <argument><expr><name>pre</name></expr></argument>, <argument><expr><name>wrd</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pre</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>wrd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>keyword_len</name></expr>;</expr_stmt> 

<expr_stmt><expr><name>mallocsize</name> <operator>=</operator> <operator>(</operator><name>len</name> <operator>*</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>extra</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">0xffff</literal><operator>)</operator></expr>?</condition><then> <expr><name>NULL</name></expr></then><else>: <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>mallocsize</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>bytes</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">40</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">40</literal></expr></then><else>: <expr><name>len</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bytes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>sprintf</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>bytes</name> <operator>!=</operator> <name>len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="string">"..."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d\n"</literal></expr></argument>, <argument><expr><name>mallocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <name>str</name></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>nhits</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><ternary><condition><expr><name>escaped</name></expr> ?</condition><then> <expr><name>s</name></expr> </then><else>: <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"offset\":%"</literal><name>PFMT64d</name> <literal type="string">",\"type\":\"%s\",\"data\":\"%s\"}"</literal></expr></argument>,

<argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>escaped</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>es</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" %s%d_%d %s\n"</literal></expr></argument>,

<argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>kwidx</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>kw</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>nhits</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"offset\": %"</literal><name>PFMT64d</name> <literal type="string">",\"len\":%d}"</literal></expr></argument>,

<argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>kwidx</name></name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>searchflags</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%d_%d\n"</literal></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>kwidx</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f %s%d_%d %d 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>,

<argument><expr><name><name>kw</name><operator>-&gt;</operator><name>kwidx</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>count</name></name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>, <argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>searchflags</name> <operator>&amp;&amp;</operator> <name>kw</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s%d_%d"</literal></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>kwidx</name></name></expr></argument>, <argument><expr><name><name>kw</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>here</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>base_addr</name> <operator>+</operator> <name>addr</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>print_search_progress</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>++</operator><name>c</name> <operator>%</operator> <literal type="number">64</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>columns</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\r[ ] 0x%08"</literal><name>PFMT64x</name> <literal type="string">" hits = %d \r%s"</literal></expr></argument>,

<argument><expr><name>at</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"[ #]"</literal></expr></then><else>: <expr><literal type="string">"[#]"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\r[ ] 0x%08"</literal><name>PFMT64x</name> <literal type="string">" &lt; 0x%08"</literal><name>PFMT64x</name> <literal type="string">" hits = %d \r%s"</literal></expr></argument>,

<argument><expr><name>at</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name>c</name> <operator>%</operator> <literal type="number">2</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"[ #]"</literal></expr></then><else>: <expr><literal type="string">"[#]"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_bound</name><parameter_list>(<parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>RIO</name> <modifier>*</modifier></type><name>io</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>search_itv</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perms</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RIOMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>map</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>io</name> <operator>&amp;&amp;</operator> <name><name>io</name><operator>-&gt;</operator><name>desc</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>fd</name></name> <operator>=</operator> <call><name>r_io_fd_get_current</name> <argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>=</operator> <name>perms</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><block>{<expr><name>from</name></expr>, <expr><name>size</name></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Warning: Invalid range. Use different search.in=? or anal.in=dbg.maps.x\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>search_itv</name><operator>.</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>search_itv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name> <operator>=</operator> <name>itv</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name> <operator>=</operator> <call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>map</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>maskMatches</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>perm</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mask</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>only</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>mask</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>only</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator><name>perm</name> <operator>&amp;</operator> <literal type="number">7</literal><operator>)</operator> <operator>!=</operator> <name>mask</name><operator>)</operator></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name>perm</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <name>mask</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RList</name> <modifier>*</modifier></type><name>r_core_get_boundaries_prot</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>perm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>bound_in</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>bound_from</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>bound_to</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>bound_in</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>bound_in</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"in"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>bound_from</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>bound_from</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"from"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>bound_to</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>bound_to</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><literal type="string">"to"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>search_from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>bound_from</name></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><type ref="prev"/><name>search_to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>bound_to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RInterval</name></type> <name>search_itv</name> <init>= <expr><block>{<expr><name>search_from</name></expr>, <expr><name>search_to</name> <operator>-</operator> <name>search_from</name></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>bound_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>perm</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>perm</name> <operator>=</operator> <name>R_PERM_RWX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>r_io_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"file"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><call><name>r_io_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"block"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"io.map"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></argument>, <argument><expr><name><name>m</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"io.maps"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>begin</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_SKYLINE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_SKYLINE</name></expr></cpp:if>

<decl_stmt><decl><type><specifier>const</specifier> <name>RPVector</name> <modifier>*</modifier></type><name>skyline</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>map_skyline</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>r_pvector_len</name> <argument_list>(<argument><expr><name>skyline</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RIOMapSkyline</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><call><name>r_pvector_at</name> <argument_list>(<argument><expr><name>skyline</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_itv_begin</name> <argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>part</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rwx</name> <init>= <expr><ternary><condition><expr><name>m</name></expr>?</condition><then> <expr><name><name>m</name><operator>-&gt;</operator><name>perm</name></name></expr></then><else>: <expr><name><name>part</name><operator>-&gt;</operator><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_itv_begin</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rwx</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></init></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><name>begin</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>from</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>,

<argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><name>rwx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for> <if_stmt><if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"io.maps."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"io.maps."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>mode</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>mode</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_itv_begin</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rwx</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rwx</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <name>mask</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><call><name>r_itv_size</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rwx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"io.sky."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"io.sky."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>mode</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>mode</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>only</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">".only"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RPVector</name> <modifier>*</modifier></type><name>skyline</name> <init>= <expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>map_skyline</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>begin</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>end</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <call><name>r_pvector_len</name> <argument_list>(<argument><expr><name>skyline</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RIOMapSkyline</name> <modifier>*</modifier></type><name>part</name> <init>= <expr><call><name>r_pvector_at</name> <argument_list>(<argument><expr><name>skyline</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>part</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><name><name>part</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>part</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>perm</name> <init>= <expr><name><name>part</name><operator>-&gt;</operator><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>maskMatches</name> <argument_list>(<argument><expr><name>perm</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>only</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>begin</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>==</operator> <name>from</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>end</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"bin.segments"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"bin.segments."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>mode</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>mode</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>only</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">".only"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>maskMatches</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>only</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"code"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>maskMatches</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>core-&gt;io-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_itv_begin</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><call><name>r_itv_size</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rwx</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rwx</name> <operator>&amp;</operator> <name>mask</name><operator>)</operator> <operator>!=</operator> <name>mask</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>rwx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name><operator>-</operator><name>from</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"bin.sections"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"bin.sections."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>mode</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator></expr>?</condition><then> <expr><call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>mode</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>only</name> <init>= <expr><operator>(</operator><name>bool</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">".only"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>maskMatches</name> <argument_list>(<argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>only</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"bin.segment"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"bin.section"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinObject</name> <modifier>*</modifier></type><name>obj</name> <init>= <expr><call><name>r_bin_cur_object</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>bin</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>obj</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RBinSection</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>obj-&gt;sections</argument>, <argument>iter</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>is_segment</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vaddr</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>paddr</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>size</name> <init>= <expr><ternary><condition><expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>?</condition><then> <expr><name><name>s</name><operator>-&gt;</operator><name>vsize</name></name></expr></then><else>: <expr><name><name>s</name><operator>-&gt;</operator><name>size</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>R_BETWEEN</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>addr</name> <operator>+</operator> <name>size</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"anal.fcn"</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"anal.bb"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,

<argument><expr><name>R_ANAL_FCN_TYPE_FCN</name> <operator>|</operator> <name>R_ANAL_FCN_TYPE_SYM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>size</name> <init>= <expr><call><name>r_anal_function_size_from_entry</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"anal.bb"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>f-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>at</name> <operator>&gt;=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>at</name> <operator>&lt;</operator> <operator>(</operator><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>+</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING: search.in = ( anal.bb | anal.fcn )"</literal>\

<literal type="string">"requires to seek into a valid function\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>mask</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>add</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>heap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>stack</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>all</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.map"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>perm</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>perm</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>perm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>nmap</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RIOMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>nmap</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>to</name> <operator>-</operator> <name>from</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>perm</name></name> <operator>=</operator> <name>perm</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>only</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.program"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>first</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <name>R_PERM_X</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.maps"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>all</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.maps."</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>r_str_rwx</name> <argument_list>(<argument><expr><name>mode</name> <operator>+</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>only</name> <operator>=</operator> <operator>(</operator><name>bool</name><operator>)</operator><operator>(</operator><name>size_t</name><operator>)</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">".only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.heap"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>heap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="string">"dbg.stack"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>stack</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;dbg-&gt;maps</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>all</name> <operator>&amp;&amp;</operator> <call><name>maskMatches</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>only</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>add</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>stack</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"stack"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>add</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>heap</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>R_PERM_W</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"heap"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>add</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mask</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>map</name><operator>-&gt;</operator><name>perm</name></name> <operator>&amp;</operator> <name>mask</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>add</name> <operator>||</operator> <name>all</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>nmap</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RIOMap</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>nmap</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>addr_end</name></name> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name>to</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>nmap</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>perm</name></name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>perm</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>nmap</name><operator>-&gt;</operator><name>delta</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>nmap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>first</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>tmpseek</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>bound_from</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>from</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><name>bound_to</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>file</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_io_fd_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>file</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>append_bound</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name> <operator>-</operator> <name>from</name></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_end_gadget</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAnalOp</name> <modifier>*</modifier></type><name>aop</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>crop</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>family</name></name> <operator>==</operator> <name>R_ANAL_OP_FAMILY_PAC</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_TRAP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RET</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_ICALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_IRCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_RJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_IJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_IRJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_JMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CALL</name></expr>:</case>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>crop</name></expr>)</condition> <block>{<block_content> 

<switch>switch <condition>(<expr><name><name>aop</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_ANAL_OP_TYPE_CJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UCJMP</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_UCCALL</name></expr>:</case>

<case>case <expr><name>R_ANAL_OP_TYPE_CRET</name></expr>:</case> 

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>insert_into</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>ht</name> <init>= <expr><operator>(</operator><name>HtUU</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ht_uu_insert</name> <argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>construct_rop_gadget</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>buflen</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>grep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regex</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>rx_list</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>endlist_pair</name></name> <modifier>*</modifier></type><name>end_gadget</name></decl></parameter>, <parameter><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>badstart</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>endaddr</name> <init>= <expr><name><name>end_gadget</name><operator>-&gt;</operator><name>instr_offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>branch_delay</name> <init>= <expr><name><name>end_gadget</name><operator>-&gt;</operator><name>delay_size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>grep_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCoreAsmHit</name> <modifier>*</modifier></type><name>hit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hitlist</name> <init>= <expr><call><name>r_core_asm_hit_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name>nb_instr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>max_instr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.len"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>grep_find</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>search_hit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUUOptions</name></type> <name>opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>localbadstart</name> <init>= <expr><call><name>ht_uu_new_opt</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>grep</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>grep</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>end</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>start</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>grep_str</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>grep_str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>regex</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>rx_list</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>rx_list</name></expr></argument>, <argument><expr><name>count</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>ht_uu_find</name> <argument_list>(<argument><expr><name>badstart</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>nb_instr</name> <operator>&lt;</operator> <name>max_instr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>ht_uu_insert</name> <argument_list>(<argument><expr><name>localbadstart</name></expr></argument>, <argument><expr><name>idx</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>buflen</name> <operator>-</operator> <name>idx</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nb_instr</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>is_end_gadget</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_NOP</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>opsz</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opst</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>mnemonic</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>opst</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_LOG_WARN</name> <argument_list>(<argument><expr><literal type="string">"Anal plugin %s did not return disassembly\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>idx</name></expr></argument>, <argument><expr><name>buflen</name> <operator>-</operator> <name>idx</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>opst</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_str_ncasecmp</name> <argument_list>(<argument><expr><name>opst</name></expr></argument>, <argument><expr><literal type="string">"invalid"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">"invalid"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator>

<operator>!</operator><call><name>r_str_ncasecmp</name> <argument_list>(<argument><expr><name>opst</name></expr></argument>, <argument><expr><literal type="string">".byte"</literal></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><literal type="string">".byte"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hit</name> <operator>=</operator> <call><name>r_core_asm_hit_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>opsz</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>, <argument><expr><name>hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>idx</name> <operator>+=</operator> <name>opsz</name></expr>;</expr_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>opsz</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>rx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>grep_find</name> <operator>=</operator> <operator>!</operator><call><name>r_regex_match</name> <argument_list>(<argument><expr><name>rx</name></expr></argument>, <argument><expr><literal type="string">"e"</literal></expr></argument>, <argument><expr><name>opst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>search_hit</name> <operator>=</operator> <operator>(</operator><name>end</name> <operator>&amp;&amp;</operator> <name>grep</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>grep_find</name> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>search_hit</name> <operator>=</operator> <operator>(</operator><name>end</name> <operator>&amp;&amp;</operator> <name>grep</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>opst</name></expr></argument>, <argument><expr><name>grep_str</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>search_hit</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>end</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">';'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>start</name> <operator>=</operator> <name>end</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name>end</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><literal type="char">';'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <ternary><condition><expr><name>end</name></expr>?</condition><then> <expr><name>end</name></expr></then><else>: <expr><name>start</name> <operator>+</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>start</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>grep_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>grep_str</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>grep_str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strncpy</name> <argument_list>(<argument><expr><name>grep_str</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>regex</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>rx_list</name></expr></argument>, <argument><expr><name>count</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>endaddr</name> <operator>&lt;=</operator> <operator>(</operator><name>idx</name> <operator>-</operator> <name>opsz</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>valid</name> <operator>=</operator> <operator>(</operator><name>endaddr</name> <operator>==</operator> <name>idx</name> <operator>-</operator> <name>opsz</name><operator>)</operator></expr>;</expr_stmt>

<goto>goto <name>ret</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>opst</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>aop</name><operator>.</operator><name>mnemonic</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nb_instr</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<label><name>ret</name>:</label>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>mnemonic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>grep_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>regex</name> <operator>&amp;&amp;</operator> <name>rx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_uu_free</name> <argument_list>(<argument><expr><name>localbadstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>valid</name> <operator>||</operator> <operator>(</operator><name>grep</name> <operator>&amp;&amp;</operator> <name>end</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_uu_free</name> <argument_list>(<argument><expr><name>localbadstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>ht_uu_foreach</name> <argument_list>(<argument><expr><name>localbadstart</name></expr></argument>, <argument><expr><name>insert_into</name></expr></argument>, <argument><expr><name>badstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>ht_uu_free</name> <argument_list>(<argument><expr><name>localbadstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>branch_delay</name> <operator>&amp;&amp;</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <operator>(</operator><literal type="number">1</literal> <operator>+</operator> <name>branch_delay</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>hitlist</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_rop</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>hitlist</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>json_first</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>otype</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCoreAsmHit</name> <modifier>*</modifier></type><name>hit</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>ropList</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_asm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>analop</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>colorize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>rop_comments</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.comments"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>esil</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.esil"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>rop_db</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.db"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rop_db</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"rop"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ropList</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Could not create SDB 'rop' namespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>json_first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>json_first</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"opcodes\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hitlist</argument>, <argument>iter</argument>, <argument>hit</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>analop</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opstr_n</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>analop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ropList</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>opstr_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"offset\":%"</literal><name>PFMT64d</name> <literal type="string">",\"size\":%d,"</literal>

<literal type="string">"\"opcode\":\"%s\",\"type\":\"%s\"}%s"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>analop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><ternary><condition><expr><name><name>iter</name><operator>-&gt;</operator><name>n</name></name></expr>?</condition><then> <expr><literal type="string">","</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>db</name> <operator>&amp;&amp;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RCoreAsmHit</name> <operator>*</operator><operator>)</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rop_classify</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"],\"retaddr\":%"</literal><name>PFMT64d</name> <literal type="string">",\"size\":%d}"</literal></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>hit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"],\"retaddr\":%"</literal><name>PFMT64d</name> <literal type="string">",\"size\":%d}"</literal></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">":"</literal></expr></argument>,

<argument><expr><operator>(</operator><operator>(</operator><name>RCoreAsmHit</name> <operator>*</operator><operator>)</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hitlist</argument>, <argument>iter</argument>, <argument>hit</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>opstr</name> <init>= <expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>analop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>analop</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ropList</name></expr></argument>, <argument><expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>esil</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>colorize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>buf_asm</name> <operator>=</operator> <call><name>r_print_colorize_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s%s;"</literal></expr></argument>, <argument><expr><name>buf_asm</name></expr></argument>, <argument><expr><name>Color_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf_asm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s;"</literal></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>db</name> <operator>&amp;&amp;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RCoreAsmHit</name> <operator>*</operator><operator>)</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rop_classify</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hitlist</argument>, <argument>iter</argument>, <argument>hit</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comment</name> <init>= <expr><ternary><condition><expr><name>rop_comments</name></expr>?</condition><then> <expr><call><name>r_meta_get_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>,

<argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid hit length here\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>size</name> <operator>+=</operator> <name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>analop</name><operator>.</operator><name>type</name></name> <operator>!=</operator> <name>R_ANAL_OP_TYPE_RET</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opstr_n</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %s"</literal></expr></argument>, <argument><expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>analop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>ropList</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>opstr_n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>asm_op_hex</name> <init>= <expr><call><name>r_asm_op_get_hex</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>colorize</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_asm</name> <init>= <expr><call><name>r_print_colorize_opcode</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>num</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>otype</name> <operator>=</operator> <call><name>r_print_color_op_type</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name><name>analop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>comment</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name> <literal type="string">" %18s%s %s%s ; %s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>asm_op_hex</name></expr></argument>, <argument><expr><name>otype</name></expr></argument>, <argument><expr><name>buf_asm</name></expr></argument>, <argument><expr><name>Color_RESET</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name> <literal type="string">" %18s%s %s%s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>asm_op_hex</name></expr></argument>, <argument><expr><name>otype</name></expr></argument>, <argument><expr><name>buf_asm</name></expr></argument>, <argument><expr><name>Color_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf_asm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>comment</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name> <literal type="string">" %18s %s ; %s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>asm_op_hex</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" 0x%08"</literal><name>PFMT64x</name> <literal type="string">" %18s %s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>asm_op_hex</name></expr></argument>, <argument><expr><call><name>r_asm_op_get_asm</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>asm_op_hex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>db</name> <operator>&amp;&amp;</operator> <name>hit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>addr</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RCoreAsmHit</name> <operator>*</operator><operator>)</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator><operator>-&gt;</operator><name>addr</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>rop_classify</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>ropList</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>ropList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>r_core_search_rop</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>search_itv</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opt</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>grep</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>regexp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>crop</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.conditional"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>subchain</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.subchains"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut8</name></type> <name>max_instr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.len"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arch</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.arch"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_count</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.maxhits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>increment</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>end_list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>rx_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>align</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itermap</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tok</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>gregexp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>grep_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>json_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>rx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>gadgetSdb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"rop.sdb"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>gadgetSdb</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"gadget_sdb"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gadgetSdb</name> <operator>=</operator> <call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"gadget_sdb"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_count</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_count</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_instr</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"ROP length (rop.len) must be greater than 1.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_instr</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"For rop.len = 1, use /c to search for single "</literal>

<literal type="string">"instructions. See /c? for help.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arch</name></expr></argument>, <argument><expr><literal type="string">"mips"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>increment</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arch</name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>increment</name> <operator>=</operator> <ternary><condition><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bits"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">16</literal></expr>?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>arch</name></expr></argument>, <argument><expr><literal type="string">"avr"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>increment</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>grep_arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>grep</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>grep_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>grep_arg</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>*</operator><name>grep</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>++</operator><name>grep</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>grep_arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>grep_arg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>grep_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>grep_arg</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>grep_arg</name></expr></argument>, <argument><expr><literal type="string">",,"</literal></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>grep</name> <operator>=</operator> <name>grep_arg</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>grep</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content> 

<for>for <control>(<init><expr><operator>++</operator><name>grep</name></expr>;</init> <condition><expr><operator>*</operator><name>grep</name> <operator>==</operator> <literal type="char">' '</literal></expr>;</condition> <incr><expr><name>grep</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<empty_stmt>;</empty_stmt>

</block_content>}</block></for>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>grep</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>grep</name> <operator>&amp;&amp;</operator> <name>regexp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rx_list</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rx_list</name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>gregexp</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>grep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>gregexp</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><name>tok</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rx</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>rx_list</name></expr></argument>, <argument><expr><name>rx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">";"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>itermap</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>HtUUOptions</name></type> <name>opt</name> <init>= <expr><block>{ <expr><literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>HtUU</name> <modifier>*</modifier></type><name>badstart</name> <init>= <expr><call><name>ht_uu_new_opt</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>opt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>to</name> <operator>-</operator> <name>from</name></expr>;</expr_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>bad</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>+</operator> <literal type="number">32</literal> <operator>&lt;</operator> <name>delta</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>increment</name></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>end_gadget</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end_gadget</name></expr></argument>, <argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>,

<argument><expr><name>delta</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>end_gadget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_end_gadget</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>end_gadget</name></expr></argument>, <argument><expr><name>crop</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (search-&gt;maxhits &amp;&amp; r_list_length (end_list) &gt;= search-&gt;maxhits) {

r_anal_op_fini (&amp;end_gadget);

break;

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name><name>struct</name> <name>endlist_pair</name></name> <modifier>*</modifier></type><name>epair</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>endlist_pair</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>epair</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>end_gadget</name><operator>.</operator><name>delay</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>epair</name><operator>-&gt;</operator><name>instr_offset</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <name>increment</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>epair</name><operator>-&gt;</operator><name>delay_size</name></name> <operator>=</operator> <name><name>end_gadget</name><operator>.</operator><name>delay</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>epair</name><operator>-&gt;</operator><name>instr_offset</name></name> <operator>=</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>epair</name><operator>-&gt;</operator><name>delay_size</name></name> <operator>=</operator> <name><name>end_gadget</name><operator>.</operator><name>delay</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>intptr_t</name><operator>)</operator> <name>epair</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>end_gadget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_list_reverse</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>prev</name></decl>, <decl><type ref="prev"/><name>next</name></decl>, <decl><type ref="prev"/><name>ropdepth</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>max_inst_size_x86</name> <init>= <expr><literal type="number">15</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ropdepth</name> <operator>=</operator> <ternary><condition><expr><name>increment</name> <operator>==</operator> <literal type="number">1</literal></expr>?</condition><then>

<expr><name>max_instr</name> <operator>*</operator> <name>max_inst_size_x86</name></expr> </then><else>:

<expr><name>max_instr</name> <operator>*</operator> <name>increment</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>endlist_pair</name></name> <modifier>*</modifier></type><name>end_gadget</name> <init>= <expr><operator>(</operator>struct <name>endlist_pair</name> <operator>*</operator><operator>)</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>end_gadget</name><operator>-&gt;</operator><name>instr_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>next</name> <operator>-</operator> <name>ropdepth</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>delta</name> <operator>-</operator> <name>max_inst_size_x86</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>max_count</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>increment</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>increment</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>prev</name> <operator>-</operator> <name>max_inst_size_x86</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>prev</name> <operator>-</operator> <name>max_inst_size_x86</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>prev</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>next</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>end_gadget</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name>end_gadget</name> <operator>=</operator> <operator>(</operator>struct <name>endlist_pair</name> <operator>*</operator><operator>)</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <name><name>end_gadget</name><operator>-&gt;</operator><name>instr_offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>next</name> <operator>-</operator> <name>ropdepth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>end</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>,

<argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><operator>(</operator><name>delta</name> <operator>-</operator> <name>i</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">4096</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">2048</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>delta</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hitlist</name> <init>= <expr><call><name>construct_rop_gadget</name> <argument_list>(<argument><expr><name>core</name></expr></argument>,

<argument><expr><name>from</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>grep</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>,

<argument><expr><name>rx_list</name></expr></argument>, <argument><expr><name>end_gadget</name></expr></argument>, <argument><expr><name>badstart</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hitlist</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><operator>(</operator><name>from</name> <operator>+</operator> <name>i</name><operator>)</operator> <operator>%</operator> <name>align</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>gadgetSdb</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCoreAsmHit</name> <modifier>*</modifier></type><name>hit</name> <init>= <expr><operator>(</operator><name>RCoreAsmHit</name> <operator>*</operator><operator>)</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>headAddr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>headAddr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>bad</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hitlist</argument>, <argument>iter</argument>, <argument>hit</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64x</name><literal type="string">"(%"</literal><name>PFMT32d</name><literal type="string">")"</literal></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>addr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>headAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>bad</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_concat</name> <argument_list>(<argument><expr><name>gadgetSdb</name></expr></argument>, <argument><expr><name>headAddr</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>headAddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <literal type="char">'j'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>mode</name> <operator>==</operator> <literal type="char">'q'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <name>subchain</name></expr>)</condition> <block>{<block_content>

<do>do <block>{<block_content>

<expr_stmt><expr><call><name>print_rop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hitlist</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>json_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hitlist</name><operator>-&gt;</operator><name>head</name></name> <operator>=</operator> <name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>n</name></name></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name><name>hitlist</name><operator>-&gt;</operator><name>head</name><operator>-&gt;</operator><name>n</name></name></expr>)</condition>;</do>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>print_rop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hitlist</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>json_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_count</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>max_count</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>increment</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>bad</name>:</label>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>rx_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>end_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>grep_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>gregexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>result</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>esil_addrinfo</name><parameter_list>(<parameter><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>user</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>src</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>src</name> <operator>&amp;&amp;</operator> <call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>num</name> <operator>=</operator> <call><name>r_core_anal_address</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_pushnum</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_esil_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>hit_combo_limit</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.esilcombo"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>cfgDebug</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name></type> <name>kw</name> <init>= <expr><name>R_EMPTY</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'E'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /E [esil-expr]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aei"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot initialize the ESIL vm\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stacksize"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nonull</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.nonull"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit_happens</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hit_combo</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>nres</name></decl>, <decl><type ref="prev"/><name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>cb</name><operator>.</operator><name>user</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><literal type="string">"AddrInfo"</literal></expr></argument>, <argument><expr><name>esil_addrinfo</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>R_ANAL_ESIL_OP_TYPE_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_setup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>nonull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name><operator>-&gt;</operator><name>verbose</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>addr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>addr</name> <operator>%</operator> <name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

r_anal_esil_set_op (core-&gt;anal-&gt;esil, "AddressInfo", esil_search_address_info);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Breaked at 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_anal_esil_parse</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse esil (%s)\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hit_happens</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_anal_esil_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_esil_get_parm</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nres</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cfgDebug</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"RES 0x%08"</literal><name>PFMT64x</name><literal type="string">" %"</literal><name>PFMT64d</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>nres</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nres</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>_cb_hit</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>kw</name></expr></argument>, <argument><expr><name>param</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>kw</name><operator>.</operator><name>type</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>kw</name><operator>.</operator><name>kwidx</name></name> <operator>=</operator> <name><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw</name><operator>.</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hits: %d\r"</literal></expr></argument>, <argument><expr><name><name>kw</name><operator>.</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>kw</name><operator>.</operator><name>keyword_length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>hit_happens</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot parse esil (%s)\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_anal_esil_stack_free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit_happens</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>hit_combo</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hit_combo</name> <operator>&gt;</operator> <name>hit_combo_limit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Hit search.esilcombo reached (%d). Stopping search. Use f-\n"</literal></expr></argument>, <argument><expr><name>hit_combo_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>hit_combo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.kwidx"</literal></expr></argument>, <argument><expr><name><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXINSTR</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUMARRAY</name><parameter_list>(<parameter><type><name>arr</name></type></parameter>, <parameter><type><name>size</name></type></parameter>, <parameter><type><name>res</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do (res) += (arr)[--(size)]; while ((size))</cpp:value></cpp:define>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EMULATION</name></expr></cpp:if>

<function><type><specifier>static</specifier> <name>int</name></type> <name>emulateSyscallPrelude</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>at</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>curpc</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>inslen</name></decl>, <decl><type ref="prev"/><name>bsize</name> <init>= <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>arr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>reg_a0</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>arr</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d byte(s)\n"</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>curpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>curpc</name> <operator>&lt;</operator> <name>at</name></expr>;</condition> <incr><expr><name>curpc</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>bsize</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>curpc</name></expr></argument>, <argument><expr><name>arr</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>inslen</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>curpc</name></expr></argument>, <argument><expr><name>arr</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsize</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>inslen</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>incr</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>-</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>inslen</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>incr</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>incr</name> <operator>=</operator> <name>minopcode</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>incr</name></expr>;</expr_stmt>

<expr_stmt><expr><name>curpc</name> <operator>+=</operator> <name>incr</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_op_nonlinear</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>curpc</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_esil_step</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sysno</name> <init>= <expr><call><name>r_debug_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_reg_set_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>reg_a0</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<return>return <expr><name>sysno</name></expr>;</return>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_syscall_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EMULATION</name></expr></cpp:if>

<decl_stmt><decl><type><name>ut64</name></type> <name>curpc</name></decl>;</decl_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>curpos</name></decl>, <decl><type ref="prev"/><name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>bsize</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">64</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kwidx</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name><modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mininstrsz</name> <init>= <expr><call><name>r_anal_archinfo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_ANAL_ARCHINFO_MIN_OP_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>minopcode</name> <init>= <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>mininstrsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalEsil</name> <modifier>*</modifier></type><name>esil</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>align</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>stacksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.stack.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>iotrap</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.iotrap"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>addrsize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"esil.addr.size"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>esil</name> <operator>=</operator> <call><name>r_anal_esil_new</name> <argument_list>(<argument><expr><name>stacksize</name></expr></argument>, <argument><expr><name>iotrap</name></expr></argument>, <argument><expr><name>addrsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>previnstr</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>MAXINSTR</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>previnstr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d byte(s)\n"</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>previnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>oldoff</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>syscallNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a0</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_SN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s,="</literal></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>esp32</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>bits</name></name> <operator>==</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>reg</name> <init>= <expr><call><name>r_reg_64_to_32</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>a0</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>reg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>esp32</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s,="</literal></expr></argument>, <argument><expr><name>reg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&gt;=</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: from must be lower than to\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: Invalid destination boundary\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <operator>(</operator><name>bsize</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>at</name> <operator>%</operator> <name>align</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><name>bsize</name> <operator>-</operator> <name>i</name></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_ESIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curpos</name> <operator>=</operator> <name>idx</name><operator>++</operator> <operator>%</operator> <operator>(</operator><name>MAXINSTR</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>previnstr</name><index>[<expr><name>curpos</name></expr>]</index></name> <operator>=</operator> <name>ret</name></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_MOV</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>es</name> <init>= <expr><call><name>R_STRBUF_SAFEGET</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>aop</name><operator>.</operator><name>esil</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>syscallNumber</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>esp32</name> <operator>&amp;&amp;</operator> <call><name>strstr</name> <argument_list>(<argument><expr><name>es</name></expr></argument>, <argument><expr><name>esp32</name></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>aop</name><operator>.</operator><name>val</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>syscallNumber</name> <operator>=</operator> <name><name>aop</name><operator>.</operator><name>val</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>aop</name><operator>.</operator><name>type</name></name> <operator>==</operator> <name>R_ANAL_OP_TYPE_SWI</name><operator>)</operator> <operator>&amp;&amp;</operator> <name>ret</name></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>scVector</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>scNumber</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>USE_EMULATION</name></expr></cpp:if>

<decl_stmt><decl><type><name>int</name></type> <name>nbytes</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nb_opcodes</name> <init>= <expr><name>MAXINSTR</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>SUMARRAY</name> <argument_list>(<argument><expr><name>previnstr</name></expr></argument>, <argument><expr><name>nb_opcodes</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>curpc</name> <operator>=</operator> <name>at</name> <operator>-</operator> <operator>(</operator><name>nbytes</name> <operator>-</operator> <name><name>previnstr</name><index>[<expr><name>curpos</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>scNumber</name> <operator>=</operator> <call><name>emulateSyscallPrelude</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>curpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

<expr_stmt><expr><name>scNumber</name> <operator>=</operator> <name>syscallNumber</name></expr>;</expr_stmt>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><name>scVector</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>aop</name><operator>.</operator><name>val</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>aop</name><operator>.</operator><name>val</name></name></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt> 

<decl_stmt><decl><type><name>RSyscallItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_syscall_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>syscall</name></name></expr></argument>, <argument><expr><name>scNumber</name></expr></argument>, <argument><expr><name>scVector</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memset</name> <argument_list>(<argument><expr><name>previnstr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>MAXINSTR</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof <argument_list>(<argument><expr><operator>*</operator><name>previnstr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<if_stmt><if>if <condition>(<expr><name>searchflags</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>flag</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%d_%d.%s"</literal></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name>kwidx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><ternary><condition><expr><name>item</name></expr>?</condition><then> <expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">"syscall"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>here</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>search</name><operator>-&gt;</operator><name>maxhits</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;=</operator> <name><name>search</name><operator>-&gt;</operator><name>maxhits</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>syscallNumber</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>-</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inc</name> <operator>=</operator> <name>minopcode</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block>

<label><name>beach</name>:</label>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>oldoff</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_esil_free</name> <argument_list>(<argument><expr><name>esil</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esp32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>esp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>previnstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_ref_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>,<parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">512</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>comment</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_anal_xrefs_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>list</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_set_pc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></call></expr></argument>,

<argument><expr><name>str</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>comment</name> <operator>=</operator> <call><name>r_meta_get_string</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>R_META_TYPE_COMMENT</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf_fcn</name> <init>= <expr><ternary><condition><expr><name>comment</name></expr>

?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s; %s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"(nofunc)"</literal></expr></else></ternary></expr></argument>, <argument><expr><call><name>strtok</name> <argument_list>(<argument><expr><name>comment</name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>fcn</name></expr> ?</condition><then> <expr><name><name>fcn</name><operator>-&gt;</operator><name>name</name></name></expr> </then><else>: <expr><literal type="string">"(nofunc)"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&lt;=</operator> <name><name>ref</name><operator>-&gt;</operator><name>addr</name></name> <operator>&amp;&amp;</operator> <name>to</name> <operator>&gt;=</operator> <name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s 0x%"</literal> <name>PFMT64x</name> <literal type="string">" [%s] %s\n"</literal></expr></argument>,

<argument><expr><name>buf_fcn</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_anal_xrefs_type_tostring</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>here</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf_fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>do_anal_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>aop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>type</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kwidx</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ret</name></decl>, <decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>firstItem</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">64</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><ternary><condition><expr><name>type</name> <operator>==</operator> <literal type="char">'f'</literal></expr>

?</condition><then> <expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>str</name> <operator>||</operator> <operator>!</operator><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"undefined"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"asl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aoml"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"wat\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>*</operator><name>input</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></switch>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Shouldn't reach\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

case 's': 

do_syscall_search (core, &amp;param);

dosearch = false;

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RIOMap</name><modifier>*</modifier></type> <name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>at</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>=</operator> <name>from</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>bufop</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>bufop</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufop</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aop</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>bufop</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bufop</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_BASIC</name> <operator>|</operator> <name>R_ANAL_OP_MASK_DISASM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fam</name> <init>= <expr><name><name>aop</name><operator>.</operator><name>mnemonic</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fam</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>*</operator><name>input</name> <operator>||</operator> <call><name>r_str_startswith</name> <argument_list>(<argument><expr><name>fam</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fam</name> <init>= <expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>family</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fam</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><operator>*</operator><name>input</name> <operator>||</operator> <operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>fam</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>type</name> <init>= <expr><call><name>r_anal_optype_to_string</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>type</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>isCandidate</name> <init>= <expr><operator>!</operator><operator>*</operator><name>input</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"cswi"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isCandidate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>isCandidate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>isCandidate</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"swi"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <operator>!</operator><name><name>aop</name><operator>.</operator><name>cond</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>match</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>opstr</name> <init>= <expr><call><name>r_core_op_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s{\"addr\":%"</literal><name>PFMT64d</name> <literal type="string">",\"size\":%d,\"opstr\":\"%s\"}"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name>firstItem</name></expr>?</condition><then> <expr><literal type="string">""</literal></expr></then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr></argument>,

<argument><expr><name>at</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <literal type="char">'f'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fam</name> <init>= <expr><call><name>r_anal_op_family_to_string</name> <argument_list>(<argument><expr><name><name>aop</name><operator>.</operator><name>family</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" %d %s %s\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>fam</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" %d %s\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>opstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <name>searchflags</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>flag</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>flag</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>flag</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s%d_%d"</literal></expr></argument>,

<argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name>kwidx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flag</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>here</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>param</name><operator>-&gt;</operator><name>cmd_hit</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>search</name><operator>-&gt;</operator><name>maxhits</name></name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;=</operator> <name><name>search</name><operator>-&gt;</operator><name>maxhits</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>firstItem</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inc</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>-</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>inc</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name>inc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block>

<label><name>done</name>:</label>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_section_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>double</name></type> <name>threshold</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>r2mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>r2mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="string">"%lf"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>threshold</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>threshold</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>threshold</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>buf_size</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>oe</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>begin</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>, <decl><type ref="prev"/><name>end</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>lastBlock</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from</name></expr>;</init> <condition><expr><name>at</name> <operator>&lt;</operator> <name>to</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <name>buf_size</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>begin</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>at</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>e</name> <init>= <expr><call><name>r_hash_entropy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type> <name>diff</name> <init>= <expr><name>oe</name> <operator>-</operator> <name>e</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>diff</name> <operator>=</operator> <call><name>R_ABS</name> <argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>end</name> <operator>=</operator> <name>at</name> <operator>+</operator> <name>buf_size</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <name>threshold</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r2mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f entropy_section_%d 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" - 0x%08"</literal><name>PFMT64x</name><literal type="string">" ~ %lf\n"</literal></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>lastBlock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>lastBlock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>oe</name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name>begin</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>begin</name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>lastBlock</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r2mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f entropy_section_%d 0x%08"</literal><name>PFMT64x</name><literal type="string">" 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>end</name> <operator>-</operator> <name>begin</name></expr></argument>, <argument><expr><name>begin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" - 0x%08"</literal><name>PFMT64x</name><literal type="string">" ~ %lf .. last\n"</literal></expr></argument>, <argument><expr><name>begin</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_asm_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>search_itv</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCoreAsmHit</name> <modifier>*</modifier></type><name>hit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>itermap</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxhits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>filter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>kwidx</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hits</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>regexp</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>bool</name></type> <name>everyByte</name> <init>= <expr><name>regexp</name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end_cmd</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><operator>(</operator><ternary><condition><expr><name>end_cmd</name></expr> ?</condition><then> <expr><operator>*</operator><operator>(</operator><name>end_cmd</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr> </then><else>: <expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_RADARE</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>everyByte</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>maxhits</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.maxhits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>filter</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.filter"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>everyByte</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>itermap</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>maxhits</name> <operator>&amp;&amp;</operator> <name>count</name> <operator>&gt;=</operator> <name>maxhits</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>hits</name> <operator>=</operator> <call><name>r_core_asm_strsearch</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>end_cmd</name></expr></argument>,

<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>maxhits</name></expr></argument>, <argument><expr><name>regexp</name></expr></argument>, <argument><expr><name>everyByte</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hits</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdhit</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>hits</argument>, <argument>iter</argument>, <argument>hit</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>cmdhit</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmdhit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"%s @ 0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>cmdhit</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><name>R_MODE_JSON</name></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(

<argument><expr><literal type="string">"{\"offset\":%"</literal><name>PFMT64d</name> <literal type="string">",\"len\":%d,\"code\":\"%s\"}"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>R_MODE_RADARE</name></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f %s%d_%i = 0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name>kwidx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name>filter</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>tmp</name><index>[<expr><literal type="number">128</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalHint</name> <modifier>*</modifier></type><name>hint</name> <init>= <expr><call><name>r_anal_hint_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_parse_filter</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>parser</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>code</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></sizeof></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>big_endian</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_hint_free</name> <argument_list>(<argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" #%i: %s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" #%i: %s\n"</literal></expr></argument>,

<argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>code</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>searchflags</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flagname</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%s%d_%d"</literal></expr></argument>, <argument><expr><name>searchprefix</name></expr></argument>, <argument><expr><name>kwidx</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>flagname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagname</name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>do_string_search</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RInterval</name></type> <name>search_itv</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>searchflags</name> <operator>&amp;&amp;</operator> <name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"fs hits\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>inverse</name></name> <operator>=</operator> <name><name>param</name><operator>-&gt;</operator><name>inverse</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>inverse</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>maxhits</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>n_kws</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>param</name><operator>-&gt;</operator><name>crypto_search</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_set_callback</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>_cb_hit</name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>buf</name> <operator>=</operator> <call><name>malloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_string_prepare_backward</name> <argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>saved_nhits</name> <init>= <expr><name><name>search</name><operator>-&gt;</operator><name>nhits</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>kws</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>lenstr</name> <init>= <expr><ternary><condition><expr><name>kw</name></expr>?</condition><then> <expr><name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bytestr</name> <init>= <expr><ternary><condition><expr><name>lenstr</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>?</condition><then> <expr><literal type="string">"bytes"</literal></expr></then><else>: <expr><literal type="string">"byte"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Searching %d %s in [0x%"</literal><name>PFMT64x</name> <literal type="string">"-0x%"</literal><name>PFMT64x</name> <literal type="string">"]\n"</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name>kw</name></expr>?</condition><then> <expr><name><name>kw</name><operator>-&gt;</operator><name>keyword_length</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>, <argument><expr><name>bytestr</name></expr></argument>, <argument><expr><name><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_sandbox_enable</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>itv</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Sandbox restricts search range\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name><modifier>*</modifier></type> <name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name><modifier>*</modifier></type> <name>kw</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>core-&gt;search-&gt;kws</argument>, <argument>it</argument>, <argument>kw</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>kw</name><operator>-&gt;</operator><name>last</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>from</name> <init>= <expr><name><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>, <decl><type ref="prev"/><name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><type ref="prev"/><name>from1</name> <init>= <expr><ternary><condition><expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr> ?</condition><then> <expr><name>to</name></expr> </then><else>: <expr><name>from</name></expr></else></ternary></expr></init></decl>,

<decl><type ref="prev"/><name>to1</name> <init>= <expr><ternary><condition><expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr> ?</condition><then> <expr><name>from</name></expr> </then><else>: <expr><name>to</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>len</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name>from1</name></expr>;</init> <condition><expr><name>at</name> <operator>!=</operator> <name>to1</name></expr>;</condition> <incr><expr><name>at</name> <operator>=</operator> <ternary><condition><expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr> ?</condition><then> <expr><name>at</name> <operator>-</operator> <name>len</name></expr> </then><else>: <expr><name>at</name> <operator>+</operator> <name>len</name></expr></else></ternary></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>print_search_progress</name> <argument_list>(<argument><expr><name>at</name></expr></argument>, <argument><expr><name>to1</name></expr></argument>, <argument><expr><name><name>search</name><operator>-&gt;</operator><name>nhits</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>to</name> <operator>-</operator> <name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>crypto_search</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>aes_search</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>r_search_aes_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>privkey_search</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>t</name> <operator>=</operator> <call><name>r_search_privkey_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name> <operator>||</operator> <name>t</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_search_update</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>maxhits</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>nhits</name></name> <operator>&gt;=</operator> <name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>maxhits</name></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>done</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>print_search_progress</name> <argument_list>(<argument><expr><name>at</name></expr></argument>, <argument><expr><name>to1</name></expr></argument>, <argument><expr><name><name>search</name><operator>-&gt;</operator><name>nhits</name></name></expr></argument>, <argument><expr><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>search</name><operator>-&gt;</operator><name>nhits</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hits: %"</literal> <name>PFMT64d</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>search</name><operator>-&gt;</operator><name>nhits</name></name> <operator>-</operator> <name>saved_nhits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<label><name>done</name>:</label>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No keywords defined\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rop_kuery</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db_rop</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"rop"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>json_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>sdb_iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>sdb_list</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbNs</name> <modifier>*</modifier></type><name>ns</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>db_rop</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: could not find SDB 'rop' namespace\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<macro><name>ls_foreach</name> <argument_list>(<argument>db_rop-&gt;ns</argument>, <argument>it</argument>, <argument>ns</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>sdb_list</name> <operator>=</operator> <call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>sdb_list</argument>, <argument>sdb_iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s "</literal></expr></argument>, <argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"{\"gadgets\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>db_rop-&gt;ns</argument>, <argument>it</argument>, <argument>ns</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>sdb_list</name> <operator>=</operator> <call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name><name>ns</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>sdb_list</argument>, <argument>sdb_iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dup</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>flag</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>size</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>, <argument><expr><literal type="string">" "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>tok</name> <init>= <expr><call><name>strtok</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tok</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">"NOP"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>json_first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>json_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"address\":%s, \"size\":%s, \"type\":\"%s\", \"effect\":\"%s\"}"</literal></expr></argument>,

<argument><expr><call><name>sdbkv_key</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name><name>ns</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]}\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"nop"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/nop/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"mov"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/mov/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"const"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/const/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"arithm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/arithm/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"arithm_ct"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/arithm_ct/*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid ROP class\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>sdb_querys</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="string">"rop/***"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>out</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>memcmpdiff</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>diff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="number">0x00</literal></expr>)</condition> <block>{<block_content>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>a</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name><name>b</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>diff</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>diff</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>search_similar_pattern_in</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>block</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>addr</name> <operator>&lt;</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>diff</name> <init>= <expr><call><name>memcmpdiff</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>equal</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name> <operator>-</operator> <name>diff</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>equal</name> <operator>&gt;=</operator> <name>count</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>pc</name> <init>= <expr><operator>(</operator><name>equal</name> <operator>*</operator> <literal type="number">100</literal><operator>)</operator> <operator>/</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">" %4d/%d %3d%% "</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>equal</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>ptr</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{

<expr><operator>(</operator><name>ut8</name><operator>)</operator><operator>(</operator><name>pc</name> <operator>*</operator> <literal type="number">2.5</literal><operator>)</operator></expr>, <expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_print_fill</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>UT64_MAX</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>search_similar_pattern</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param-&gt;boundaries</argument>, <argument>iter</argument>, <argument>p</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>search_similar_pattern_in</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isArm</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAsm</name> <modifier>*</modifier></type><name>as</name> <init>= <expr><ternary><condition><expr><name>core</name></expr> ?</condition><then> <expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>as</name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>cur</name></name> <operator>&amp;&amp;</operator> <name><name>as</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_str_startswith</name> <argument_list>(<argument><expr><name><name>as</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>arch</name></name></expr></argument>, <argument><expr><literal type="string">"arm"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>as</name><operator>-&gt;</operator><name>cur</name><operator>-&gt;</operator><name>bits</name></name> <operator>&lt;</operator> <literal type="number">64</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>void</name></type> <name>_CbInRangeSearchV</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vsize</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>search_parameters</name></name> <modifier>*</modifier></type><name>param</name> <init>= <expr><name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isarm</name> <init>= <expr><call><name>isArm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.prefix"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isarm</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>to</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>to</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>-&gt;</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name> <literal type="string">": 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"{\"offset\":%"</literal><name>PFMT64d</name> <literal type="string">",\"value\":%"</literal><name>PFMT64d</name> <literal type="string">"}"</literal></expr></argument>,

<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"f %s.value.0x%08"</literal><name>PFMT64x</name><literal type="string">" %d = 0x%08"</literal><name>PFMT64x</name><literal type="string">" \n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"f %s.offset.0x%08"</literal><name>PFMT64x</name><literal type="string">" %d = 0x%08"</literal><name>PFMT64x</name> <literal type="string">" \n"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdHit</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmdHit</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmdHit</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmdHit</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut8</name> <modifier>*</modifier></type><name>v_writebuf</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>nums</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>ch</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bsize</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>n64</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>n32</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut16</name></type> <name>n16</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name>n8</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate %d byte(s)\n"</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<switch>switch <condition>(<expr><name>ch</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<expr_stmt><expr><name>n8</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_pop_head</name> <argument_list>(<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_write_le8</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut8</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<expr_stmt><expr><name>n16</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_pop_head</name> <argument_list>(<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_write_le16</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut16</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<expr_stmt><expr><name>n32</name> <operator>=</operator> <operator>(</operator><name>ut32</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_pop_head</name> <argument_list>(<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_write_le32</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n32</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<expr_stmt><expr><name>n64</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><call><name>r_list_pop_head</name> <argument_list>(<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_write_le64</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>n64</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;</operator> <name>ptr</name> <operator>+</operator> <name>bsize</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>buf</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incPrintBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>IS_PRINTABLE</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incLowerBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>islower</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incUpperBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isupper</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incAlphaBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>incDigitBuffer</name><parameter_list>(<parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>bufsz</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&amp;&amp;</operator> <call><name>isdigit</name> <argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block></while>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>search_collisions</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hashName</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ut8</name> <modifier>*</modifier></type><name>hashValue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hashLength</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut8</name></type> <name>R_ALIGNED</name><argument_list>(<argument><expr><literal type="number">8</literal></expr></argument>)</argument_list> <name><name>cmphash</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>algoType</name> <init>= <expr><name>R_HASH_CRC32</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bufsz</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>block</name></name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>hashLength</name> <operator>&gt;</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>cmphash</name></expr></argument>)</argument_list></sizeof></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Hashlength mismatch %d %d\n"</literal></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><sizeof>sizeof <argument_list>(<argument><expr><name>cmphash</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>cmphash</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>hashBits</name> <init>= <expr><call><name>r_hash_name_to_bits</name> <argument_list>(<argument><expr><name>hashName</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hashSize</name> <init>= <expr><call><name>r_hash_size</name> <argument_list>(<argument><expr><name>hashBits</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hashLength</name> <operator>!=</operator> <name>hashSize</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid hash size %d vs %d\n"</literal></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>, <argument><expr><name>hashSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RHash</name> <modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>r_hash_new</name> <argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>algoType</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ctx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>prev</name> <init>= <expr><call><name>r_sys_now</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>inc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>amount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>now</name> <init>= <expr><call><name>r_sys_now</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&lt;</operator> <operator>(</operator><name>prev</name> <operator>+</operator> <literal type="number">1000000</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>amount</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>mount</name> <operator>+=</operator> <name>amount</name></expr>;</expr_stmt>

<expr_stmt><expr><name>mount</name> <operator>/=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>amount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<expr_stmt><expr><call><name>incPrintBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<expr_stmt><expr><call><name>incLowerBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'A'</literal></expr>:</case> 

<expr_stmt><expr><call><name>incUpperBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<expr_stmt><expr><call><name>incAlphaBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<expr_stmt><expr><call><name>incDigitBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default> 

<expr_stmt><expr><call><name>incBuffer</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal> <name>PFMT64x</name> <literal type="string">" input:"</literal></expr></argument>, <argument><expr><name>inc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>bufsz</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" \"%s\""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_hash_do_begin</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hashBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_hash_calculate</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hashBits</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_hash_do_end</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>hashBits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" digest:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hashLength</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"%02x"</literal></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>digest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" (%d h/s) \r"</literal></expr></argument>, <argument><expr><name>mount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>memcmp</name> <argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>digest</name></name></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\nCOLLISION FOUND!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_hexdump</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bufsz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>inc</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_hash_free</name> <argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__core_cmd_search_asm_infinite</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>search_in</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.in"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>boundaries</name> <init>= <expr><call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>search_in</name></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalOp</name></type> <name>analop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>map_begin</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>map_size</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>map_end</name> <init>= <expr><name>map_begin</name> <operator>+</operator> <name>map_size</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><name>map_end</name> <operator>-</operator> <name>map_begin</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name>map_begin</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>map_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>at</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</init> <condition><expr><name>at</name> <operator>+</operator> <literal type="number">24</literal><operator>&lt;</operator> <name>map_end</name></expr>;</condition> <incr><expr><name>at</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_op</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>, <argument><expr><name>at</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <operator>(</operator><name>at</name> <operator>-</operator> <name>map_begin</name><operator>)</operator></expr></argument>, <argument><expr><literal type="number">24</literal></expr></argument>, <argument><expr><name>R_ANAL_OP_MASK_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name> <operator>==</operator> <name><name>analop</name><operator>.</operator><name>jump</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>at</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>at</name> <operator>+=</operator> <name><name>analop</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_anal_op_fini</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>analop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__core_cmd_search_asm_byteswap</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAsmOp</name></type> <name>asmop</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name></type> <name><name>buf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_io_read_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>nth</name> <operator>&gt;=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0xff</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><name>nth</name></expr>]</index></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_asm_disassemble</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>assembler</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>asmop</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>asmstr</name> <init>= <expr><call><name>r_strbuf_get</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>asmop</name><operator>.</operator><name>buf_asm</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>asmstr</name></expr></argument>, <argument><expr><literal type="string">"invalid"</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strstr</name> <argument_list>(<argument><expr><name>asmstr</name></expr></argument>, <argument><expr><literal type="string">"unaligned"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%02x %s\n"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>asmstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_search</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>dosearch</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator> <name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>search_parameters</name></name></type> <name>param</name> <init>= <expr><block>{

<expr><operator>.</operator><name>core</name> <operator>=</operator> <name>core</name></expr>,

<expr><operator>.</operator><name>cmd_hit</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.hit"</literal></expr></argument>)</argument_list></call></expr>,

<expr><operator>.</operator><name>outmode</name> <operator>=</operator> <literal type="number">0</literal></expr>,

<expr><operator>.</operator><name>inverse</name> <operator>=</operator> <name>false</name></expr>,

<expr><operator>.</operator><name>crypto_search</name> <operator>=</operator> <name>false</name></expr>,

<expr><operator>.</operator><name>aes_search</name> <operator>=</operator> <name>false</name></expr>,

<expr><operator>.</operator><name>privkey_search</name> <operator>=</operator> <name>false</name></expr>,

}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>param</name><operator>.</operator><name>cmd_hit</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>cmd_hit</name></name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RSearch</name> <modifier>*</modifier></type><name>search</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ignorecase</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>param_offset</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>core</name> <operator>||</operator> <operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't search if we don't have an open file.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>in_search</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Can't search from within a search.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>lastsearch</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>lastsearch</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"No previous search done\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>lastsearch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>lastsearch</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>in_search</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>ut64</name></type> <name>search_from</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.from"</literal></expr></argument>)</argument_list></call></expr></init></decl>,

<decl><type ref="prev"/><name>search_to</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.to"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>search_from</name> <operator>&gt;</operator> <name>search_to</name> <operator>&amp;&amp;</operator> <name>search_to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"search.from &gt; search.to is not supported\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RInterval</name></type> <name>search_itv</name> <init>= <expr><block>{<expr><name>search_from</name></expr>, <expr><name>search_to</name> <operator>-</operator> <name>search_from</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>empty_search_itv</name> <init>= <expr><name>search_from</name> <operator>==</operator> <name>search_to</name> <operator>&amp;&amp;</operator> <name>search_from</name> <operator>!=</operator> <name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>search_from</name> <operator>==</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name>search_to</name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>search_itv</name><operator>.</operator><name>addr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>search_itv</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>c</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>searchshow</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.show"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.in"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>boundaries</name></name> <operator>=</operator> <call><name>r_core_get_boundaries_prot</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>mode</name></name></expr></argument>, <argument><expr><literal type="string">"search"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.align"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>searchflags</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.flags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>maxhits</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.maxhits"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>searchprefix</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.prefix"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>overlap</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.overlap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>va</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <macro><name>r_io_size</name> <argument_list>(<argument>core-&gt;io</argument>)</argument_list></macro>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>empty_search_itv</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>search_itv</name> <operator>=</operator> <call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>empty_search_itv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"WARNING from == to?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

<expr_stmt><expr><name>param_offset</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>reread</name>:</label>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'!'</literal></expr>:</case>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>inverse</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>reread</name>;</goto>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><operator>++</operator><name>input</name><operator>)</operator> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /b&lt;command&gt; [value] backward search, see '/?'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>search</name><operator>-&gt;</operator><name>bckwrds</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>search_itv</name> <operator>=</operator> <call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<goto>goto <name>reread</name>;</goto>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>R_ABS</name><argument_list>(<argument><expr><operator>(</operator><name>st64</name><operator>)</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>st64</name><operator>)</operator><name>n</name><operator>)</operator> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_core_prevop_addr</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name>UT64_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_asm_bwdis_len</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[%"</literal><name>PFMT64u</name> <literal type="string">"]"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'O'</literal></expr>:</case> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr> ?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_core_prevop_addr_force</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[%"</literal><name>PFMT64u</name> <literal type="string">"]"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name> <literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'R'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_R</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_search_rop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'k'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_Rk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>rop_kuery</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>gadgetSdb</name> <init>= <expr><call><name>sdb_ns</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>sdb</name></name></expr></argument>, <argument><expr><literal type="string">"gadget_sdb"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gadgetSdb</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_search_rop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>SdbKv</name> <modifier>*</modifier></type><name>kv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbListIter</name> <modifier>*</modifier></type><name>sdb_iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>SdbList</name> <modifier>*</modifier></type><name>sdb_list</name> <init>= <expr><call><name>sdb_foreach_list</name> <argument_list>(<argument><expr><name>gadgetSdb</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>ls_foreach</name> <argument_list>(<argument>sdb_list</argument>, <argument>sdb_iter</argument>, <argument>kv</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>hitlist</name> <init>= <expr><call><name>r_core_asm_hit_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hitlist</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>sdbkv_value</name> <argument_list>(<argument><expr><name>kv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>opsz</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>json_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mode</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>input</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>RCoreAsmHit</name> <modifier>*</modifier></type><name>hit</name> <init>= <expr><call><name>r_core_asm_hit_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hit</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sscanf</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%"</literal><name>PFMT64x</name><literal type="string">"(%"</literal><name>PFMT32d</name><literal type="string">")"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>addr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hit</name><operator>-&gt;</operator><name>addr</name></name> <operator>=</operator> <name>addr</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>hit</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>opsz</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>, <argument><expr><name>hit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><operator>*</operator><operator>(</operator><name>s</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>;</do>

<expr_stmt><expr><call><name>print_rop</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hitlist</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>json_first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>hitlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<goto>goto <name>beach</name>;</goto>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>n</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>==</operator><literal type="char">' '</literal><operator>)</operator><operator>)</operator></expr>

?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>UT64_MAX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find null references.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /re $$ - to find references to current address\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>refptr</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %"</literal><name>PFMT64d</name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>trg</name> <init>= <expr><ternary><condition><expr><name>refptr</name></expr>?</condition><then> <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" %"</literal><name>PFMT64d</name></expr></argument>, <argument><expr><name>refptr</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_anal_esil</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>trg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>curseek</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="char">'r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><literal type="char">'w'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name> <init>= <expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>to</name> <init>= <expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_ref_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_ref_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'d'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'e'</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'c'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'c'</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'o'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'o'</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'a'</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>do_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'1'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>__core_cmd_search_asm_byteswap</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'I'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>__core_cmd_search_asm_infinite</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>kwd</name> <init>= <expr><call><name>r_core_asm_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kwd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>,

<argument><expr><call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><name>kwd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kwd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"asl"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><call><name>do_syscall_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <call><name>do_anal_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> <block>{<block_content> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>crypto_search</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>space</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><ternary><condition><expr><name>space</name></expr>?</condition><then> <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>space</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /cc[aAdlpb] [hashname] [hexpairhashvalue]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /cca - lowercase alphabet chars only\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /ccA - uppercase alphabet chars only\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /ccl - letters (lower + upper alphabet chars)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /ccd - digits (only numbers)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /ccp - printable (alpha + digit)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" /ccb - binary (any number is valid)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>mode</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>sp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sp</name><operator>++</operator></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>hashName</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>hashValue</name> <init>= <expr><operator>(</operator><name>ut8</name><operator>*</operator><operator>)</operator><call><name>strdup</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hashValue</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_str_startswith</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>hashValue</name></expr></argument>, <argument><expr><literal type="string">"0x"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hashLength</name> <init>= <expr><literal type="number">4</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>n</name> <init>= <expr><operator>(</operator><name>ut32</name><operator>)</operator><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>)</operator><name>hashValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>memcpy</name> <argument_list>(<argument><expr><name>hashValue</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>n</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>search_collisions</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hashName</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>hashLength</name> <init>= <expr><call><name>r_hex_str2bin</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>hashLength</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>search_collisions</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>hashName</name></expr></argument>, <argument><expr><name>hashValue</name></expr></argument>, <argument><expr><name>hashLength</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid expected hash hexpairs.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>hashValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot allocate memory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /cc [hashname] [hexpairhashvalue]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /CC to search ascii collisions\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>crypto_search</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_hex</name> <argument_list>(<argument><expr><literal type="string">"308200003082"</literal></expr></argument>, <argument><expr><literal type="string">"ffff0000ffff"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"bad pointer\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><literal type="string">"00"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name>search</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>aes_search</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'r'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><literal type="string">"00"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name>search</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>privkey_search</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default> <block>{<block_content>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>crypto_search</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></switch>

</block_content>}</block> <break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'b'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>bool</name></type> <name>bin_verbose</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.verbose"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.verbose"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>cmd_search_bin</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"bin.verbose"</literal></expr></argument>, <argument><expr><name>bin_verbose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'m'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>search_itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>align</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>search</name><operator>-&gt;</operator><name>align</name></name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>addr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>align</name> <operator>&amp;&amp;</operator> <operator>(</operator><literal type="number">0</literal> <operator>!=</operator> <operator>(</operator><name>addr</name> <operator>%</operator> <name>align</name><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <operator>(</operator><name>addr</name> <operator>%</operator> <name>align</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>mp</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"/mnt%d"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"[*] Trying to mount at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\r["</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_fs_mount</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name> <operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Mounted %s at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>mp</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>mp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'e'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"* r2 thinks%s\n"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><ternary><condition><expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>?</condition><then> <expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>search_itv</name><operator>.</operator><name>addr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_magic_reset</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxHits</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.maxhits"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- %llx %llx\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>addr</name> <operator>=</operator> <name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</init> <condition><expr><name>addr</name> <operator>&lt;</operator> <call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>addr</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_core_magic_at</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">99</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>maxHits</name> <operator>&amp;&amp;</operator> <name>hits</name> <operator>&gt;=</operator> <name>maxHits</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>addr</name> <operator>+=</operator> <name>ret</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /m [file]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>ps</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ps</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"-- %llx %llx\n"</literal></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_pattern_size</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>ps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_pattern</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr></argument>, <argument><expr><call><name>r_itv_end</name> <argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid pattern size (must be &gt; 0)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'P'</literal></expr>:</case> 

<expr_stmt><expr><call><name>search_similar_pattern</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'V'</literal></expr>:</case> 

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

<expr_stmt><expr><name>param_offset</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_RADARE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>, <decl><type ref="prev"/><name>vsize</name> <init>= <expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>num_str</name> <init>= <expr><name>input</name> <operator>+</operator> <name>param_offset</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vsize</name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name>num_str</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>num_str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>w</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>w</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>vmin</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>num_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>vmax</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>vsize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>map</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>param.boundaries</argument>, <argument>iter</argument>, <argument>map</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>err</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>hits</name> <init>= <expr><call><name>r_core_search_value_in_range</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>itv</name></name></expr></argument>,

<argument><expr><name>vmin</name></expr></argument>, <argument><expr><name>vmax</name></expr></argument>, <argument><expr><name>vsize</name></expr></argument>,

<argument><expr><name>_CbInRangeSearchV</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>!=</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"hits: %d\n"</literal></expr></argument>, <argument><expr><name>hits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>err</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /V[1|2|4|8] [minval] [maxval]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_print</name> <argument_list>(<argument><expr><literal type="string">"Usage: /v[1|2|4|8] [value]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

<expr_stmt><expr><name>param_offset</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>v_str</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>nums</name> <init>= <expr><call><name>r_num_str_split_list</name> <argument_list>(<argument><expr><name>v_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>nums</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>v_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'8'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut64</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_buf</name> <operator>=</operator> <call><name>v_writebuf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="char">'8'</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /v8 value\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut8</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_buf</name> <operator>=</operator> <call><name>v_writebuf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="char">'1'</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /v1 value\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut16</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_buf</name> <operator>=</operator> <call><name>v_writebuf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="char">'2'</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /v2 value\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<default>default:</default> 

<case>case <expr><literal type="char">'4'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bsize</name> <operator>=</operator> <sizeof>sizeof <argument_list>(<argument><expr><name>ut32</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v_buf</name> <operator>=</operator> <call><name>v_writebuf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>nums</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="char">'4'</literal></expr></argument>, <argument><expr><name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /v4 value\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<if_stmt><if>if <condition>(<expr><name>v_buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>,

<argument><expr><call><name>r_search_keyword_new</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator> <name>v_buf</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>v_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr> )</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'i'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ignorecase</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_RADARE</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>shift</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name>ignorecase</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shift</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>strstart</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<expr_stmt><expr><name>strstart</name> <operator>=</operator> <name>shift</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>strstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>inp</name> <operator>=</operator> <call><name>calloc</name> <argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>p2</name> <operator>=</operator> <name>input</name> <operator>+</operator> <name>strstart</name></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <name>inp</name></expr>;</init> <condition><expr><operator>*</operator><name>p2</name></expr>;</condition> <incr><expr><name>p</name> <operator>+=</operator> <literal type="number">2</literal></expr><operator>,</operator> <expr><name>p2</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>ignorecase</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>tolower</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name><operator>)</operator> <operator>*</operator><name>p2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <operator>*</operator><name>p2</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>p</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>skw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>skw</name> <operator>=</operator> <call><name>r_search_keyword_new</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator> <name>inp</name></expr></argument>, <argument><expr><name>len</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>skw</name><operator>-&gt;</operator><name>icase</name></name> <operator>=</operator> <name>ignorecase</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>skw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid keyword\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing ' ' after /i\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ignorecase</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>=</operator> <name>R_MODE_JSON</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<case>case <expr><literal type="char">' '</literal></expr>:</case> 

<expr_stmt><expr><name>inp</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>ignorecase</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_str_unescape</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

if (!json) {

eprintf ("Searching %d byte(s) from 0x%08"PFMT64x " to 0x%08"PFMT64x ": ",

len, search_itv.addr, r_itv_end (search_itv));

for (i = 0; i &lt; len; i++) {

eprintf ("%02x ", (ut8) inp[i]);

}

eprintf ("\n");

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>skw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>skw</name> <operator>=</operator> <call><name>r_search_keyword_new</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>ut8</name> <operator>*</operator><operator>)</operator> <name>inp</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>skw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>skw</name><operator>-&gt;</operator><name>icase</name></name> <operator>=</operator> <name>ignorecase</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>skw</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_SEARCH_KEYWORD_TYPE_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>skw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid keyword\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /e /foo/i or /e/foo/i\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_regexp</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>kw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid regexp specified\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_REGEXP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing regex\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'E'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_debug_map_sync</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>do_esil_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_DELTAKEY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>,

<argument><expr><call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing delta\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /h md5 [hash] [datalen]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>min</name> <init>= <expr><name>UT32_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>max</name> <init>= <expr><name>UT32_MAX</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pmax</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>pmin</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>pmin</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pmin</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>pmax</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>pmin</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pmax</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>pmax</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>pmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>pmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>search_hash</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing hash. See ph?\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RInterval</name></type> <name>itv</name> <init>= <expr><block>{<expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>, <expr><operator>-</operator><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_itv_overlap</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>search_itv</name> <operator>=</operator> <call><name>r_itv_intersect</name> <argument_list>(<argument><expr><name>search_itv</name></expr></argument>, <argument><expr><name>itv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /g[g] [fromaddr] @ [toaddr]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"(find all graph paths A to B (/gg follow jumps, see search.count and anal.depth)"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name>UT64_MAX</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_function_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>depth</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"anal.depth"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_anal_paths</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><name>param_offset</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n_args</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>args</name> <init>= <expr><call><name>r_str_argv</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>

<expr_stmt><expr><name>buf</name> <operator>=</operator> <operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator><call><name>r_file_slurp</name> <argument_list>(<argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot open '%s'\n"</literal></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>offset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"size &lt;= offset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_args</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name><name>args</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>size</name> <operator>-</operator> <name>offset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"len too large\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>size</name> <operator>-</operator> <name>offset</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>kw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"no keyword\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_str_argv_free</name> <argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /F[j] [file]([offset] ([sz]))\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <name>param_offset</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_KEYWORD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_hex</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>kw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"no keyword\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<expr_stmt><expr><call><name>do_section_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>malloc</name> <argument_list>(<argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ochunksize</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>chunksize</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.chunk"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>chunksize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>assembler</name><operator>-&gt;</operator><name>bits</name></name> <operator>/</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_str_unescape</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ochunksize</name> <operator>=</operator> <name>chunksize</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Using chunksize: %d\n"</literal></expr></argument>, <argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>in_search</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>chunksize</name></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>chunksize</name> <operator>=</operator> <name>ochunksize</name></expr>;</expr_stmt>

<label><name>again</name>:</label>

<expr_stmt><expr><call><name>r_hex_bin2str</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name> <operator>*</operator><operator>)</operator> <name>str</name> <operator>+</operator> <name>i</name></expr></argument>, <argument><expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>chunksize</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"/x %s\n"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"/x %s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>chunksize</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>chunksize</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Oops\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>beach</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Repeat with chunk size %d\n"</literal></expr></argument>, <argument><expr><name>chunksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<goto>goto <name>again</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /+ [string]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /z min max\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: /z min max\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_search_set_string_limits</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Error: min must be lower than max\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_search_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><name>R_SEARCH_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_set_distance</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>search</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator>

<call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.distance"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<block>{<block_content>

<decl_stmt><decl><type><name>RSearchKeyword</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><call><name>r_search_keyword_new_hexmask</name> <argument_list>(<argument><expr><literal type="string">"00"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>kw</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>R_SEARCH_KEYWORD_TYPE_STRING</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_add</name> <argument_list>(<argument><expr><name>search</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_search_begin</name> <argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dosearch</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_slash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"See /? for help.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"search.kwidx"</literal></expr></argument>, <argument><expr><name><name>search</name><operator>-&gt;</operator><name>n_kws</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dosearch</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>do_string_search</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>search_itv</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>beach</name>:</label>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <name><name>search</name><operator>-&gt;</operator><name>nhits</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>in_search</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>param</name><operator>.</operator><name>outmode</name></name> <operator>==</operator> <name>R_MODE_JSON</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>param</name><operator>.</operator><name>boundaries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_search_kw_reset</name> <argument_list>(<argument><expr><name>search</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function></block_content></block></function>

</unit>
