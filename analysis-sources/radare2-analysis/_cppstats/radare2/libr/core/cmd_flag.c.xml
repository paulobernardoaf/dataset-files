<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\cmd_flag.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_cons.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"r_core.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_f</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: f"</literal></expr>,<expr><literal type="string">"[?] [flagname]"</literal></expr>, <expr><literal type="string">" #Manage offset-name flags"</literal></expr>,

<expr><literal type="string">"f"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags (will only list flags from selected flagspaces)"</literal></expr>,

<expr><literal type="string">"f?"</literal></expr>,<expr><literal type="string">"flagname"</literal></expr>,<expr><literal type="string">"check if flag exists or not, See ?? and ?!"</literal></expr>,

<expr><literal type="string">"f."</literal></expr>,<expr><literal type="string">" [*[*]]"</literal></expr>,<expr><literal type="string">"list local per-function flags (*) as r2 commands"</literal></expr>,

<expr><literal type="string">"f."</literal></expr>,<expr><literal type="string">"blah=$$+12"</literal></expr>,<expr><literal type="string">"set local function label named 'blah'"</literal></expr>,

<expr><literal type="string">"f."</literal></expr>,<expr><literal type="string">" fname"</literal></expr>,<expr><literal type="string">"list all local labels for the given function"</literal></expr>,

<expr><literal type="string">"f,"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"table output for flags"</literal></expr>,

<expr><literal type="string">"f*"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags in r commands"</literal></expr>,

<expr><literal type="string">"f"</literal></expr>,<expr><literal type="string">" name 12 @ 33"</literal></expr>,<expr><literal type="string">"set flag 'name' with length 12 at offset 33"</literal></expr>,

<expr><literal type="string">"f"</literal></expr>,<expr><literal type="string">" name = 33"</literal></expr>,<expr><literal type="string">"alias for 'f name @ 33' or 'f name 1 33'"</literal></expr>,

<expr><literal type="string">"f"</literal></expr>,<expr><literal type="string">" name 12 33 [cmt]"</literal></expr>,<expr><literal type="string">"same as above + optional comment"</literal></expr>,

<expr><literal type="string">"f-"</literal></expr>,<expr><literal type="string">".blah@fcn.foo"</literal></expr>,<expr><literal type="string">"delete local label from function at current seek (also f.-)"</literal></expr>,

<expr><literal type="string">"f--"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"delete all flags and flagspaces (deinit)"</literal></expr>,

<expr><literal type="string">"f+"</literal></expr>,<expr><literal type="string">"name 12 @ 33"</literal></expr>,<expr><literal type="string">"like above but creates new one if doesnt exist"</literal></expr>,

<expr><literal type="string">"f-"</literal></expr>,<expr><literal type="string">"name"</literal></expr>,<expr><literal type="string">"remove flag 'name'"</literal></expr>,

<expr><literal type="string">"f-"</literal></expr>,<expr><literal type="string">"@addr"</literal></expr>,<expr><literal type="string">"remove flag at address expression"</literal></expr>,

<expr><literal type="string">"f="</literal></expr>,<expr><literal type="string">" [glob]"</literal></expr>,<expr><literal type="string">"list range bars graphics with flag offsets and sizes"</literal></expr>,

<expr><literal type="string">"fa"</literal></expr>,<expr><literal type="string">" [name] [alias]"</literal></expr>,<expr><literal type="string">"alias a flag to evaluate an expression"</literal></expr>,

<expr><literal type="string">"fb"</literal></expr>,<expr><literal type="string">" [addr]"</literal></expr>,<expr><literal type="string">"set base address for new flags"</literal></expr>,

<expr><literal type="string">"fb"</literal></expr>,<expr><literal type="string">" [addr] [flag*]"</literal></expr>,<expr><literal type="string">"move flags matching 'flag' to relative addr"</literal></expr>,

<expr><literal type="string">"fc"</literal></expr>,<expr><literal type="string">"[?][name] [color]"</literal></expr>,<expr><literal type="string">"set color for given flag"</literal></expr>,

<expr><literal type="string">"fC"</literal></expr>,<expr><literal type="string">" [name] [cmt]"</literal></expr>,<expr><literal type="string">"set comment for given flag"</literal></expr>,

<expr><literal type="string">"fd"</literal></expr>,<expr><literal type="string">"[?] addr"</literal></expr>,<expr><literal type="string">"return flag+delta"</literal></expr>,

<expr><literal type="string">"fe-"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"resets the enumerator counter"</literal></expr>,

<expr><literal type="string">"fe"</literal></expr>,<expr><literal type="string">" [name]"</literal></expr>,<expr><literal type="string">"create flag name.#num#enumerated flag. See fe?"</literal></expr>,

<expr><literal type="string">"ff"</literal></expr>,<expr><literal type="string">" ([glob])"</literal></expr>,<expr><literal type="string">"distance in bytes to reach the next flag (see sn/sp)"</literal></expr>,

<expr><literal type="string">"fi"</literal></expr>,<expr><literal type="string">" [size] | [from] [to]"</literal></expr>,<expr><literal type="string">"show flags in current block or range"</literal></expr>,

<expr><literal type="string">"fg"</literal></expr>,<expr><literal type="string">"[*] ([prefix])"</literal></expr>,<expr><literal type="string">"construct a graph with the flag names"</literal></expr>,

<expr><literal type="string">"fj"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags in JSON format"</literal></expr>,

<expr><literal type="string">"fl"</literal></expr>,<expr><literal type="string">" (@[flag]) [size]"</literal></expr>,<expr><literal type="string">"show or set flag length (size)"</literal></expr>,

<expr><literal type="string">"fla"</literal></expr>,<expr><literal type="string">" [glob]"</literal></expr>,<expr><literal type="string">"automatically compute the size of all flags matching glob"</literal></expr>,

<expr><literal type="string">"fm"</literal></expr>,<expr><literal type="string">" addr"</literal></expr>,<expr><literal type="string">"move flag at current offset to new address"</literal></expr>,

<expr><literal type="string">"fn"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags displaying the real name (demangled)"</literal></expr>,

<expr><literal type="string">"fnj"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags displaying the real name (demangled) in JSON format"</literal></expr>,

<expr><literal type="string">"fN"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"show real name of flag at current address"</literal></expr>,

<expr><literal type="string">"fN"</literal></expr>,<expr><literal type="string">" [[name]] [realname]"</literal></expr>,<expr><literal type="string">"set flag real name (if no flag name current seek one is used)"</literal></expr>,

<expr><literal type="string">"fo"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"show fortunes"</literal></expr>,

<expr><literal type="string">"fO"</literal></expr>, <expr><literal type="string">" [glob]"</literal></expr>, <expr><literal type="string">"flag as ordinals (sym.* func.* method.*)"</literal></expr>,

<expr><literal type="string">"fr"</literal></expr>,<expr><literal type="string">" [[old]] [new]"</literal></expr>,<expr><literal type="string">"rename flag (if no new flag current seek one is used)"</literal></expr>,

<expr><literal type="string">"fR"</literal></expr>,<expr><literal type="string">"[?] [f] [t] [m]"</literal></expr>,<expr><literal type="string">"relocate all flags matching f&amp;~m 'f'rom, 't'o, 'm'ask"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"[?]+-*"</literal></expr>,<expr><literal type="string">"manage flagspaces"</literal></expr>,

<expr><literal type="string">"ft"</literal></expr>,<expr><literal type="string">"[?]*"</literal></expr>,<expr><literal type="string">"flag tags, useful to find all flags matching some words"</literal></expr>,

<expr><literal type="string">"fV"</literal></expr>,<expr><literal type="string">"[*-] [nkey] [offset]"</literal></expr>,<expr><literal type="string">"dump/restore visual marks (mK/'K)"</literal></expr>,

<expr><literal type="string">"fx"</literal></expr>,<expr><literal type="string">"[d]"</literal></expr>,<expr><literal type="string">"show hexdump (or disasm) of flag:flagsize"</literal></expr>,

<expr><literal type="string">"fq"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"list flags in quiet mode"</literal></expr>,

<expr><literal type="string">"fz"</literal></expr>,<expr><literal type="string">"[?][name]"</literal></expr>,<expr><literal type="string">"add named flag zone -name to delete. see fz?[name]"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_fc</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: fc"</literal></expr>, <expr><literal type="string">"&lt;flagname&gt; [color]"</literal></expr>, <expr><literal type="string">" #List colors with 'ecs'"</literal></expr>,

<expr><literal type="string">"fc"</literal></expr>, <expr><literal type="string">" flagname"</literal></expr>, <expr><literal type="string">"Get current color for given flagname"</literal></expr>,

<expr><literal type="string">"fc"</literal></expr>, <expr><literal type="string">" flagname color"</literal></expr>, <expr><literal type="string">"Set color to a flag"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_fd</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: fd[d]"</literal></expr>, <expr><literal type="string">" [offset|flag|expression]"</literal></expr>, <expr><literal type="string">" #Describe flags"</literal></expr>,

<expr><literal type="string">"fd"</literal></expr>, <expr><literal type="string">" $$"</literal></expr> , <expr><literal type="string">"#describe flag + delta for given offset"</literal></expr>,

<expr><literal type="string">"fd."</literal></expr>, <expr><literal type="string">" $$"</literal></expr>, <expr><literal type="string">"#check flags in current address (no delta)"</literal></expr>,

<expr><literal type="string">"fdd"</literal></expr>, <expr><literal type="string">" $$"</literal></expr>, <expr><literal type="string">"#describe flag without space restrictions"</literal></expr>,

<expr><literal type="string">"fdw"</literal></expr>, <expr><literal type="string">" [string]"</literal></expr>, <expr><literal type="string">"#filter closest flag by string for current offset"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_fs</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: fs"</literal></expr>,<expr><literal type="string">"[*] [+-][flagspace|addr]"</literal></expr>, <expr><literal type="string">" #Manage flagspaces"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces"</literal></expr>,

<expr><literal type="string">"fs*"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces as r2 commands"</literal></expr>,

<expr><literal type="string">"fsj"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces in JSON"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">" *"</literal></expr>,<expr><literal type="string">"select all flagspaces"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">" flagspace"</literal></expr>,<expr><literal type="string">"select flagspace or create if it doesn't exist"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"-flagspace"</literal></expr>,<expr><literal type="string">"remove flagspace"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"-*"</literal></expr>,<expr><literal type="string">"remove all flagspaces"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"+foo"</literal></expr>,<expr><literal type="string">"push previous flagspace and set"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"-"</literal></expr>,<expr><literal type="string">"pop to the previous flagspace"</literal></expr>,

<expr><literal type="string">"fs"</literal></expr>,<expr><literal type="string">"-."</literal></expr>,<expr><literal type="string">"remove the current flagspace"</literal></expr>,

<expr><literal type="string">"fsq"</literal></expr>,<expr><literal type="string">""</literal></expr>, <expr><literal type="string">"list flagspaces in quiet mode"</literal></expr>,

<expr><literal type="string">"fsm"</literal></expr>,<expr><literal type="string">" [addr]"</literal></expr>,<expr><literal type="string">"move flags at given address to the current flagspace"</literal></expr>,

<expr><literal type="string">"fss"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces stack"</literal></expr>,

<expr><literal type="string">"fss*"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces stack in r2 commands"</literal></expr>,

<expr><literal type="string">"fssj"</literal></expr>,<expr><literal type="string">""</literal></expr>,<expr><literal type="string">"display flagspaces stack in JSON"</literal></expr>,

<expr><literal type="string">"fsr"</literal></expr>,<expr><literal type="string">" newname"</literal></expr>,<expr><literal type="string">"rename selected flagspace"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>help_msg_fz</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"Usage: f"</literal></expr>, <expr><literal type="string">"[?|-name| name] [@addr]"</literal></expr>, <expr><literal type="string">" #Manage flagzones"</literal></expr>,

<expr><literal type="string">" fz"</literal></expr>, <expr><literal type="string">" math"</literal></expr>, <expr><literal type="string">"add new flagzone named 'math'"</literal></expr>,

<expr><literal type="string">" fz-"</literal></expr>, <expr><literal type="string">"math"</literal></expr>, <expr><literal type="string">"remove the math flagzone"</literal></expr>,

<expr><literal type="string">" fz-"</literal></expr>, <expr><literal type="string">"*"</literal></expr>, <expr><literal type="string">"remove all flagzones"</literal></expr>,

<expr><literal type="string">" fz."</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show around flagzone context"</literal></expr>,

<expr><literal type="string">" fz:"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"show what's in scr.flagzone for visual"</literal></expr>,

<expr><literal type="string">" fz*"</literal></expr>, <expr><literal type="string">""</literal></expr>, <expr><literal type="string">"dump into r2 commands, for projects"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_flag_init</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>DEFINE_CMD_DESCRIPTOR</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>fz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>listFlag</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type> <name>countMatching</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>matches</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>a</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>b</name></expr>;</condition> <incr><expr><name>a</name><operator>++</operator></expr><operator>,</operator> <expr><name>b</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>a</name> <operator>!=</operator> <operator>*</operator><name>b</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>matches</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></for>

<return>return <expr><name>matches</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>__isOnlySon</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><call><name>strlen</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<return>return <expr><name>fname</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier></type><name>__childrenFlagsOf</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>free</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>f2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>prefix_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter</argument>, <argument>f</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>&gt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>name_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter2</argument>, <argument>f2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>&gt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>prefix_len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>matching</name> <init>= <expr><call><name>countMatching</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>matching</name> <operator>&lt;</operator> <name>prefix_len</name> <operator>||</operator> <name>matching</name> <operator>==</operator> <name>name_len</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>matching</name> <operator>&gt;</operator> <name>name_len</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>matching</name> <operator>&lt;</operator> <name>name_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>name_len</name> <operator>=</operator> <name>matching</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>kw</name> <init>= <expr><call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>kw_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>only</name> <init>= <expr><call><name>__isOnlySon</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>only</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>only</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>fname_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter2</argument>, <argument>f2</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strncmp</name> <argument_list>(<argument><expr><name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><name>kw_len</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fname</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>matching</name> <init>= <expr><call><name>countMatching</name> <argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fname_len</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>matching</name> <operator>&lt;</operator> <name>fname_len</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fname_len</name> <operator>=</operator> <name>matching</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fname_len</name> <operator>=</operator> <name>matching</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>fname</name> <operator>=</operator> <name><name>f2</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>fname_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>kw</name> <operator>=</operator> <call><name>r_str_ndup</name> <argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><name>fname_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter2</argument>, <argument>fn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strcmp</name> <argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<return>return <expr><name>list</name></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>__printRecursive</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__printRecursive</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>depth</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>fn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>prefix_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><operator>*</operator><name>prefix</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn root\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>children</name> <init>= <expr><call><name>__childrenFlagsOf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>children</argument>, <argument>iter</argument>, <argument>fn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name>fn</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"agn %s %s\n"</literal></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>fn</name> <operator>+</operator> <name>prefix_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"age %s %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>prefix</name></expr>?</condition><then> <expr><name>prefix</name></expr></then><else>: <expr><literal type="string">"root"</literal></expr></else></ternary></expr></argument>, <argument><expr><name>fn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>prefix_len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fn</name> <operator>+</operator> <name>prefix_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>__printRecursive</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>fn</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>depth</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>__flag_graph</name> <parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_space</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>listFlag</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>__printRecursive</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>spaces_list</name><parameter_list>(<parameter><decl><type><name>RSpaces</name> <modifier>*</modifier></type><name>sp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RSpaceIter</name></type> <name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RSpace</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RSpace</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><call><name>r_spaces_current</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_spaces_foreach</name> <argument_list>(<argument>sp</argument>, <argument>it</argument>, <argument>s</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>r_spaces_count</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"count"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"selected"</literal></expr></argument>, <argument><expr><name>cur</name> <operator>==</operator> <name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'q'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%5d %c %s\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><operator>!</operator><name>cur</name> <operator>||</operator> <name>cur</name> <operator>==</operator> <name>s</name><operator>)</operator></expr>?</condition><then> <expr><literal type="char">'*'</literal></expr></then><else>: <expr><literal type="char">'.'</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>&amp;&amp;</operator> <call><name>r_spaces_current</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s #current\n"</literal></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>r_spaces_current_name</name> <argument_list>(<argument><expr><name>sp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_fz</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_fz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_zone_around</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s %s\n"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name>a</name></expr>?</condition><then><expr><name>a</name></expr></then><else>:<expr><literal type="string">"~"</literal></expr></else></ternary></expr></argument>, <argument><expr><ternary><condition><expr><name>b</name></expr>?</condition><then><expr><name>b</name></expr></then><else>:<expr><literal type="string">"~"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">':'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>a_len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>w</name> <init>= <expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_zone_around</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>a</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>a</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"[&lt;&lt; %s]"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a_len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>padsize</name> <init>= <expr><operator>(</operator><name>w</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <name>a_len</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>title_size</name> <init>= <expr><literal type="number">12</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>||</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"[ 0x%08"</literal><name>PFMT64x</name><literal type="string">" ]"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>title_size</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>padsize</name> <operator>-=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>halfpad</name> <init>= <expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>padsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s%s"</literal></expr></argument>, <argument><expr><name>halfpad</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>padsize</name> <operator>=</operator> <operator>(</operator><name>w</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>-</operator> <name>title_size</name> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">4</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>halfpad</name> <init>= <expr><ternary><condition><expr><name>padsize</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>?</condition><then> <expr><call><name>r_str_pad</name> <argument_list>(<argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>padsize</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s[%s &gt;&gt;]"</literal></expr></argument>, <argument><expr><name>halfpad</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>a</name> <operator>||</operator> <name>b</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_zone_add</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_zone_reset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_zone_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_zone_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_zone_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<struct>struct <name>flagbar_t</name> <block>{

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cols</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>flagbar_foreach</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>flagbar_t</name></name> <modifier>*</modifier></type><name>u</name> <init>= <expr><operator>(</operator>struct <name>flagbar_t</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>min</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>max</name> <init>= <expr><call><name>r_io_size</name> <argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RIOMap</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>r_io_map_get</name> <argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>m</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>addr</name></name> <operator>+</operator> <name><name>m</name><operator>-&gt;</operator><name>itv</name><operator>.</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" "</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_print_rangebar</name> <argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>print</name></name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>fi</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><name><name>u</name><operator>-&gt;</operator><name>cols</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>fi</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flagbars</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>cols</name> <init>= <expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cols</name> <operator>-=</operator> <literal type="number">80</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cols</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cols</name> <operator>+=</operator> <literal type="number">80</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>flagbar_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>core</name> <operator>=</operator> <name>core</name></expr>, <expr><operator>.</operator><name>cols</name> <operator>=</operator> <name>cols</name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_space_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>flagbar_foreach</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>flag_to_flag_t</name> <block>{

<decl_stmt><decl><type><name>ut64</name></type> <name>next</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>offset</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>flag_to_flag_foreach</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>flag_to_flag_t</name></name> <modifier>*</modifier></type><name>u</name> <init>= <expr><operator>(</operator>struct <name>flag_to_flag_t</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>u</name><operator>-&gt;</operator><name>next</name></name> <operator>&amp;&amp;</operator> <name><name>fi</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name><name>u</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>fi</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>flag_to_flag</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_val_if_fail</name> <argument_list>(<argument><expr><name>glob</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>glob</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>flag_to_flag_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>next</name> <operator>=</operator> <name>UT64_MAX</name></expr>, <expr><operator>.</operator><name>offset</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>flag_to_flag_foreach</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>UT64_MAX</name> <operator>&amp;&amp;</operator> <name><name>u</name><operator>.</operator><name>next</name></name> <operator>&gt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>u</name><operator>.</operator><name>next</name></name> <operator>-</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<typedef>typedef <type><struct>struct <block>{

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name></decl>;</decl_stmt>

}</block></struct></type> <name>FlagTableData</name>;</typedef>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>__tableItemCallback</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>FlagTableData</name> <modifier>*</modifier></type><name>ftd</name> <init>= <expr><name>user</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>R_STR_ISEMPTY</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><name><name>ftd</name><operator>-&gt;</operator><name>t</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>spaceName</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name><name>flag</name><operator>-&gt;</operator><name>space</name></name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name><operator>)</operator></expr>?</condition><then> <expr><name><name>flag</name><operator>-&gt;</operator><name>space</name><operator>-&gt;</operator><name>name</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addr</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_row</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>spaceName</name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_flag_table</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name></type> <name>fmt</name> <init>= <expr><operator>*</operator><name>input</name><operator>++</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><name>input</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>FlagTableData</name></type> <name>ftd</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTable</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>r_core_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>ftd</name><operator>.</operator><name>t</name></name> <operator>=</operator> <name>t</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeString</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"string"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RTableColumnType</name> <modifier>*</modifier></type><name>typeNumber</name> <init>= <expr><call><name>r_table_type</name> <argument_list>(<argument><expr><literal type="string">"number"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"addr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeNumber</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"space"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_table_add_column</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>typeString</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RSpace</name> <modifier>*</modifier></type><name>curSpace</name> <init>= <expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_space</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>curSpace</name></expr></argument>, <argument><expr><name>__tableItemCallback</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ftd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_table_query</name> <argument_list>(<argument><expr><name>t</name></expr></argument>, <argument><expr><name>q</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>fmt</name> <operator>==</operator> <literal type="char">'j'</literal><operator>)</operator></expr>

?</condition><then> <expr><call><name>r_table_tojson</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_table_tofancystring</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_table_free</name> <argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>cmd_flag_tags</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>mode</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>input</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_WHITESPACE</name> <argument_list>(<argument><expr><operator>*</operator><name>input</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>input</name><operator>++</operator></expr></incr>)</control> <block>{<block_content/>}</block></for>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>inp</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>inp</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>arg</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>mode</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_flag_tags_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>tag</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: ft[?ln] [k] [v ...]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ft tag strcpy strlen ... #set words for the 'string' tag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ft tag #get offsets of all matching flags\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ft #list all tags\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ftn tag #get matching flagnames fot given tag\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ftw #flag tags within this file\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ftj #list all flagtags in JSON format\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">" ft* #list all flagtags in r2 commands\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'w'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_flag_tags_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>tag</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s:\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ftn %s"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_flag_tags_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>tag</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>tags</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"tag.%s"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"ft %s %s\n"</literal></expr></argument>, <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tag</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>flg</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_flag_tags_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>tag</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>r_flag_tags_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter2</argument>, <argument>flg</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_s</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name>flg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg1</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>arg1</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>arg1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>a1</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>arg1</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_tags_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>flags</name> <init>= <expr><call><name>r_flag_tags_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">" %s\n"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flags</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>inp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<struct>struct <name>rename_flag_t</name> <block>{

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pfx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>rename_flag_ordinal</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>rename_flag_t</name></name> <modifier>*</modifier></type><name>u</name> <init>= <expr><operator>(</operator>struct <name>rename_flag_t</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newName</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name><name>u</name><operator>-&gt;</operator><name>pfx</name></name></expr></argument>, <argument><expr><name><name>u</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>newName</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name><name>u</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>fi</name></expr></argument>, <argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>newName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>flag_ordinals</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>pfx</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>glob</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>pfx</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>rename_flag_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>core</name> <operator>=</operator> <name>core</name></expr>, <expr><operator>.</operator><name>pfx</name> <operator>=</operator> <name>pfx</name></expr>, <expr><operator>.</operator><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>rename_flag_ordinal</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmpflag</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RFlagItem</name> <modifier>*</modifier></type><name>flag1</name> <init>= <expr><name>_a</name></expr></init></decl> , <decl><type ref="prev"><modifier>*</modifier></type><name>flag2</name> <init>= <expr><name>_b</name></expr></init></decl>;</decl_stmt>

<return>return <expr><operator>(</operator><name><name>flag1</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>flag2</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<struct>struct <name>find_flag_t</name> <block>{

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>win</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>at</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>find_flag_after</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>find_flag_t</name></name> <modifier>*</modifier></type><name>u</name> <init>= <expr><operator>(</operator>struct <name>find_flag_t</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name> <operator>&gt;</operator> <name><name>u</name><operator>-&gt;</operator><name>at</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name><name>u</name><operator>-&gt;</operator><name>win</name></name> <operator>||</operator> <name><name>flag</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>u</name><operator>-&gt;</operator><name>win</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>u</name><operator>-&gt;</operator><name>win</name></name> <operator>=</operator> <name>flag</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>find_flag_after_foreach</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>flag</name><operator>-&gt;</operator><name>size</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>flags</name> <init>= <expr><operator>(</operator><name>RFlag</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>find_flag_t</name></name></type> <name>u</name> <init>= <expr><block>{ <expr><operator>.</operator><name>win</name> <operator>=</operator> <name>NULL</name></expr>, <expr><operator>.</operator><name>at</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr> }</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_foreach</name> <argument_list>(<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>find_flag_after</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>u</name><operator>.</operator><name>win</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>flag</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name><name>u</name><operator>.</operator><name>win</name><operator>-&gt;</operator><name>offset</name></name> <operator>-</operator> <name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>adjust_offset</name><parameter_list>(<parameter><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>st64</name></type> <name>base</name> <init>= <expr><operator>*</operator><operator>(</operator><name>st64</name> <operator>*</operator><operator>)</operator><name>user</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name> <operator>+=</operator> <name>base</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>print_space_stack</name><parameter_list>(<parameter><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ordinal</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>selected</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>first</name> <init>= <expr><name>ordinal</name> <operator>==</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ename</name> <init>= <expr><call><name>r_str_escape</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ename</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"ordinal"</literal></expr></argument>, <argument><expr><name>ordinal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name>ename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kb</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"selected"</literal></expr></argument>, <argument><expr><name>selected</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'*'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name> <init>= <expr><ternary><condition><expr><name>first</name></expr>?</condition><then> <expr><literal type="string">"fs %s\n"</literal></expr></then><else>: <expr><literal type="string">"fs+%s\n"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%-2d %s%s\n"</literal></expr></argument>, <argument><expr><name>ordinal</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><ternary><condition><expr><name>selected</name></expr>?</condition><then> <expr><literal type="string">" (selected)"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>flag_space_stack_list</name><parameter_list>(<parameter><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>f</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>space</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>f-&gt;spaces.spacestack</argument>, <argument>iter</argument>, <argument>space</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>print_space_stack</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>space</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cur_name</name> <init>= <expr><call><name>r_flag_space_cur_name</name> <argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>print_space_stack</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>, <argument><expr><name>cur_name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>pj</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>i</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmd_flag</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>input</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>flagenum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><operator>(</operator><name>RCore</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>st64</name></type> <name>base</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>rep</name>:</label>

<switch>switch <condition>(<expr><operator>*</operator><name>input</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'f'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'s'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><call><name>flag_to_flag</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d\n"</literal></expr></argument>, <argument><expr><call><name>flag_to_flag</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%s.%d"</literal></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>flagenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>flagenum</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><name>flagenum</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"|Usage: fe[-| name] @@= 1 2 3 4\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>flagbars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>flagbars</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: f= [glob] to grep for matching flag names\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'a'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ptr</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition><block type="pseudo"><block_content> <expr_stmt><expr><operator>*</operator><name>ptr</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

<expr_stmt><expr><name>name</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>fi</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fi</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name>fi</name> <operator>=</operator> <call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_item_set_alias</name> <argument_list>(<argument><expr><name>fi</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find flag '%s'\n"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fa flagname flagalias\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'V'</literal></expr>:</case> 

<switch>switch<condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_mark_reset</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>ASCII_MAX</name> <init>= <expr><literal type="number">127</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>ASCII_MAX</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>UT8_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><ternary><condition><expr><name>arg</name></expr>?</condition><then> <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_visual_mark_set</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>atoi</name> <argument_list>(<argument><expr><name>input</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <name>ASCII_MAX</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fV[*-] [nkey] [offset]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Dump/Restore visual marks (mK/'K)\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_core_visual_mark_dump</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_flag_move</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case> 

<switch>switch<condition>(<expr><operator>*</operator><name>str</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fR [from] [to] ([mask])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Example to relocate PIE flags on debugger:\n"</literal>

<literal type="string">" &gt; fR entry0 `dm~:1[1]`\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Usage: fR [from] [to] ([mask])"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><literal type="string">"Example to relocate PIE flags on debugger:\n"</literal>

<literal type="string">" &gt; fR entry0 `dm~:1[1]`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>, <decl><type ref="prev"/><name>mask</name> <init>= <expr><literal type="number">0xffff</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>mask</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>q</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>from</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>to</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_flag_relocate</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Relocated %d flags\n"</literal></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fR [from] [to] ([mask])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Example to relocate PIE flags on debugger:\n"</literal>

<literal type="string">" &gt; fR entry0 `dm~:1[1]`\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ptr</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>ptr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>adjust_offset</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>base</name></name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%"</literal><name>PFMT64d</name><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>base</name></name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fb [addr] [[flags*]]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cstr</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>eq</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>b64</name> <init>= <expr><call><name>strstr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>cstr</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>s2</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>s3</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>comment</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>comment_needs_free</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>bsze</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt> 

<decl_stmt><decl><type><name>int</name></type> <name>eqdir</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name> <operator>&amp;&amp;</operator> <name>eq</name> <operator>&gt;</operator> <name>cstr</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>prech</name> <init>= <expr><name>eq</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>prech</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eqdir</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>prech</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>*</operator><name>prech</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>eqdir</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><operator>*</operator><name>prech</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cstr</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<goto>goto <name>rep</name>;</goto>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name> <operator>&amp;&amp;</operator> <operator>!</operator><operator>(</operator><name>b64</name> <operator>&amp;&amp;</operator> <name>eq</name> <operator>&gt;</operator> <name>b64</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>eq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>||</operator> <operator>(</operator><name><name>eq</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal> <operator>&amp;&amp;</operator> <name><name>eq</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>eq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>arg</name> <init>= <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>eq</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eqdir</name> <operator>&amp;&amp;</operator> <name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <operator>(</operator><name>arg</name> <operator>*</operator> <name>eqdir</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <name>arg</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s2</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s2</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>s2</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>s2</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>s2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>s3</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>s2</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>s3</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>s3</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>s3</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>comment</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>r_base64_decode_dyn</name> <argument_list>(<argument><expr><name>s3</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>comment_needs_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>s3</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>comment</name> <operator>=</operator> <name>s3</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bsze</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>s</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>addFlag</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>item</name> <operator>=</operator> <call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addFlag</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>addFlag</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>cstr</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><name>bsze</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator> <name>comment</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_item_set_comment</name> <argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>comment_needs_free</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>comment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_unset_all</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>flagname</name> <init>= <expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><operator>*</operator><name>flagname</name><operator>==</operator><literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>flagname</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>flagname</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_label_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>flagname</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>flagname</name></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_unset_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_unset_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>flagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_unset_off</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<expr_stmt><expr><name>input</name> <operator>=</operator> <call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_labels</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_labels</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">2</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>name</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>eq</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>eq</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>eq</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>eq</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name><operator>==</operator><literal type="char">'-'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_label_del</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_label_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find function at 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_anal_fcn_labels</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Local flags require a function to work."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fl[a] [flagname][flagsize]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'a'</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>glob</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>glob</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>glob</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_flag_foreach_glob</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>glob</name></expr></argument>, <argument><expr><name>find_flag_after_foreach</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content> 

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content> 

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

case 'd':

if (input[1] == ' ') {

char cmd[128];

RFlagItem *item = r_flag_get_i (core-&gt;flags,

r_num_math (core-&gt;num, input+2));

if (item) {

r_cons_printf ("0x%08"PFMT64x"\n", item-&gt;offset);

snprintf (cmd, sizeof (cmd), "pD@%"PFMT64d":%"PFMT64d,

item-&gt;offset, item-&gt;size);

r_core_cmd0 (core, cmd);

}

} else eprintf ("Missing arguments\n");

break;

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<case>case <expr><literal type="char">'z'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_fz</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>,

<argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"px@%"</literal><name>PFMT64d</name><literal type="string">":%"</literal><name>PFMT64d</name></expr></argument>,

<argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Missing arguments\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">','</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_flag_table</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case> 

<expr_stmt><expr><call><name>cmd_flag_tags</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_space_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator><literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newname</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>newname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fsr [newname]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<expr_stmt><expr><call><name>flag_space_stack_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_space_unset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RSpace</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>sp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_space_unset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>sp</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_flag_space_pop</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_flag_space_unset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_flag_space_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'m'</literal></expr>:</case>

<block>{<block_content> <decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>off</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>input</name><operator>+</operator><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>f</name><operator>-&gt;</operator><name>space</name></name> <operator>=</operator> <call><name>r_flag_space_cur</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find any flag at 0x%"</literal><name>PFMT64x</name><literal type="string">".\n"</literal></expr></argument>, <argument><expr><name>off</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<expr_stmt><expr><call><name>spaces_list</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>spaces</name></name></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>spaces_list</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>spaces</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case> 

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>__flag_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">'*'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<expr_stmt><expr><call><name>__flag_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>__flag_graph</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fg[*] ([prefix])\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>==</operator><literal type="char">'?'</literal> <operator>||</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_fc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>fi</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ret</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_trim_dup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>color</name> <operator>&amp;&amp;</operator> <name><name>color</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>color</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>fi</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>fi</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>r_flag_item_set_color</name> <argument_list>(<argument><expr><name>fi</name></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>color</name> <operator>&amp;&amp;</operator> <name>ret</name></expr>)</condition><block type="pseudo"><block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Unknown flag '%s'\n"</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>dec</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>q</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>q</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>q</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"base64:"</literal></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dec</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>r_base64_decode_dyn</name> <argument_list>(<argument><expr><name>q</name> <operator>+</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>dec</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_item_set_comment</name> <argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>dec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>dec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Failed to decode base64-encoded string\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_item_set_comment</name> <argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>q</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find flag with name '%s'\n"</literal></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name> <operator>&amp;&amp;</operator> <name><name>item</name><operator>-&gt;</operator><name>comment</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot find item\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else<block type="pseudo"><block_content> <expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fC [name] [comment]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case> 

<expr_stmt><expr><call><name>r_core_fortune_print_random</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'O'</literal></expr>:</case> 

<expr_stmt><expr><call><name>flag_ordinals</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>new</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>new</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>new</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>old</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><literal type="string">"fcn."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>old</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>new</name> <operator>=</operator> <name>old</name></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_flag_rename</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>new</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Invalid name\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fr [[old]] [new]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'N'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name>str</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>realname</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>realname</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>realname</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>realname</name><operator>++</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>strncmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"fcn."</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>name</name><operator>+</operator><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>realname</name> <operator>=</operator> <name>name</name></expr>;</expr_stmt>

<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>r_flag_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>item</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_item_set_realname</name> <argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>realname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Usage: fN [[name]] [[realname]]\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<case>case <expr><literal type="char">'n'</literal></expr>:</case> 

<case>case <expr><literal type="char">'*'</literal></expr>:</case> 

<case>case <expr><literal type="char">'j'</literal></expr>:</case> 

<case>case <expr><literal type="char">'q'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><name>input</name><operator>++</operator></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>mode</name> <init>= <expr><name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><call><name>r_flag_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pj</name> <operator>=</operator> <call><name>pj_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>list</argument>, <argument>iter</argument>, <argument>item</argument>)</argument_list></macro> <block>{<block_content>

<switch>switch <condition>(<expr><name>mode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'*'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"f %s = 0x%08"</literal><name>PFMT64x</name><literal type="string">"\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>==</operator> <literal type="char">'j'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name> <init>= <expr><call><name>pj_drain</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_flag_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>*</operator><name>input</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>input</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>?</condition><then> <expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>(</operator><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>input</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal><operator>)</operator></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><call><name>r_str_trim_head_ro</name> <argument_list>(<argument><expr><name>input</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sp</name> <init>= <expr><call><name>strchr</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newarg</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%c0x%"</literal><name>PFMT64x</name><literal type="string">" %s+0x%"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>newarg</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>newarg</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"%c%s"</literal></expr></argument>, <argument><expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <name>newarg</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_flag_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">" 0x%"</literal><name>PFMT64x</name><literal type="string">" 0x%"</literal><name>PFMT64x</name></expr></argument>,

<argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_flag_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>, <argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>strict_offset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

<case>case <expr><literal type="char">'\0'</literal></expr>:</case>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case> 

<block>{<block_content>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>isJson</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>flaglist</name></decl>;</decl_stmt>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>flaglist</name> <operator>=</operator> <call><name>r_flag_get_list</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>isJson</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>isJson</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>flaglist</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>flag</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>isJson</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>realnames</name></name> <operator>&amp;&amp;</operator> <name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt> 

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>isJson</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block>

<case>case <expr><literal type="char">'w'</literal></expr>:</case> <block>{<block_content>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>arg</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>arg</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RFlag</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>temp</name> <init>= <expr><call><name>r_flag_all_list</name> <argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>loff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>uoff</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>curseek</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lmatch</name> <init>= <expr><name>NULL</name></expr></init></decl> , <decl><type ref="prev"><modifier>*</modifier></type><name>umatch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RFlagItem</name> <modifier>*</modifier></type><name>flag</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cmpflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>temp</argument>, <argument>iter</argument>, <argument>flag</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strstr</name> <argument_list>(<argument><expr><name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr></argument> , <argument><expr><name>arg</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>flag</name><operator>-&gt;</operator><name>offset</name></name> <operator>&lt;</operator> <name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>loff</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>lmatch</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>uoff</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>offset</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>umatch</name> <operator>=</operator> <name><name>flag</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>match</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>curseek</name> <operator>-</operator> <name>loff</name><operator>)</operator> <operator>&lt;</operator> <operator>(</operator><name>uoff</name> <operator>-</operator> <name>curseek</name><operator>)</operator></expr> ?</condition><then> <expr><name>lmatch</name></expr> </then><else>: <expr><name>umatch</name></expr></else></ternary></expr></init></decl> ;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>match</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block>

<default>default:</default>

<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>arg</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_num_math</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>num</name></name></expr></argument>, <argument><expr><name>arg</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_flag_get_at</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><operator>!</operator><name>strict_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name> <operator>!=</operator> <name>addr</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt> 

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_kn</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"offset"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>pj</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>realnames</name></name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s + %d\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%s + %d\n"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,

<argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><name>addr</name> <operator>-</operator> <name><name>f</name><operator>-&gt;</operator><name>offset</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>strchr</name> <argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name> <init>= <expr><call><name>pj_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"realname"</literal></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><call><name>pj_string</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_free</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>flags</name><operator>-&gt;</operator><name>realnames</name></name> <operator>&amp;&amp;</operator> <name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>realname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_println</name> <argument_list>(<argument><expr><name><name>f</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<default>default:</default>

<if_stmt><if>if <condition>(<expr><name><name>input</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>num</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <ternary><condition><expr><call><name>r_flag_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd_help</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>help_msg_f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></else></if_stmt>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

</unit>
