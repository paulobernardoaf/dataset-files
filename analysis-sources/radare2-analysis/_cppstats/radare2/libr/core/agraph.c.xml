<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="D:\Pesquisa\Projects\radare2-analysis\_cppstats\radare2\libr\core\agraph.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_core.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;r_cons.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>mousemode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>disMode</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>discroll</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>graphCursor</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>mousemodes</name><index>[]</index></name> <init>= <expr><block>{

<expr><literal type="string">"canvas-y"</literal></expr>,

<expr><literal type="string">"canvas-x"</literal></expr>,

<expr><literal type="string">"node-y"</literal></expr>,

<expr><literal type="string">"node-x"</literal></expr>,

<expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GRAPH_MERGE_FEATURE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BORDER</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BORDER_WIDTH</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BORDER_HEIGHT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARGIN_TEXT_X</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MARGIN_TEXT_Y</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HORIZONTAL_NODE_SPACING</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERTICAL_NODE_SPACING</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_NODE_WIDTH</name></cpp:macro> <cpp:value>22</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_NODE_HEIGHT</name></cpp:macro> <cpp:value>BORDER_HEIGHT</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TITLE_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SPEED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PAGEKEY_SPEED</name></cpp:macro> <cpp:value>(h / 2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIGRAPH_NODE_TEXT_CUR</name></cpp:macro> <cpp:value>"&lt;@@@@@@&gt;"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIGRAPH_NODE_MIN_WIDTH</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIGRAPH_NODE_TITLE_LEN</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MINIGRAPH_NODE_CENTER_X</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MININODE_MIN_WIDTH</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZOOM_STEP</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZOOM_DEFAULT</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BODY_OFFSETS</name></cpp:macro> <cpp:value>0x1</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BODY_SUMMARY</name></cpp:macro> <cpp:value>0x2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BODY_COMMENTS</name></cpp:macro> <cpp:value>0x4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMALIZE_MOV</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; 0 ? -1 : ((x) &gt; 0 ? 1 : 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_set</name><parameter_list>(<parameter><type><name>sdb</name></type></parameter>, <parameter><type><name>k</name></type></parameter>, <parameter><type><name>v</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sdb_num_set (sdb, sdb_fmt ("%"PFMT64u, (ut64) (size_t) (k)), (ut64) (size_t) (v), 0))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_get</name><parameter_list>(<parameter><type><name>sdb</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sdb_num_get (sdb, sdb_fmt ("%"PFMT64u, (ut64) (size_t) (k)), NULL))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_get_rnode</name><parameter_list>(<parameter><type><name>sdb</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RGraphNode *) (size_t) hash_get (sdb, k))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_get_rlist</name><parameter_list>(<parameter><type><name>sdb</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((RList *) (size_t) hash_get (sdb, k))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>hash_get_int</name><parameter_list>(<parameter><type><name>sdb</name></type></parameter>, <parameter><type><name>k</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((int) hash_get (sdb, k))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_anode</name><parameter_list>(<parameter><type><name>gn</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((gn)? (RANode *) (gn)-&gt;data: NULL)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>graph_foreach_anode</name><parameter_list>(<parameter><type><name>list</name></type></parameter>, <parameter><type><name>it</name></type></parameter>, <parameter><type><name>pos</name></type></parameter>, <parameter><type><name>anode</name></type></parameter>)</parameter_list></cpp:macro><cpp:value>if (list) for ((it) = (list)-&gt;head; (it) &amp;&amp; ((pos) = (it)-&gt;data) &amp;&amp; (pos) &amp;&amp; ((anode) = (RANode *) (pos)-&gt;data); (it) = (it)-&gt;n)</cpp:value></cpp:define>

<struct>struct <name>len_pos_t</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>dist_t</name> <block>{

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>g_cb</name> <block>{

<decl_stmt><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>graph</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANodeCallback</name></type> <name>node_cb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAEdgeCallback</name></type> <name>edge_cb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

}</block>;</struct>

<typedef>typedef <type><struct>struct <name>ascii_edge_t</name> <block>{

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>x</name></decl>, <modifier>*</modifier><name>y</name>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>is_reversed</name></decl>;</decl_stmt>

}</block></struct></type> <name>AEdge</name>;</typedef>

<struct>struct <name>layer_t</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>n_nodes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier><modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>position</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>height</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>width</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>gap</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>agraph_refresh_data</name> <block>{

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier><modifier>*</modifier></type><name>fcn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>follow_offset</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fs</name></decl>;</decl_stmt>

}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>G</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_cons_canvas_gotoxy (g-&gt;can, x, y)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>W</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_cons_canvas_write (g-&gt;can, x)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F</name><parameter_list>(<parameter><type><name>x</name></type></parameter>, <parameter><type><name>y</name></type></parameter>, <parameter><type><name>x2</name></type></parameter>, <parameter><type><name>y2</name></type></parameter>, <parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>r_cons_canvas_fill (g-&gt;can, x, y, x2, y2, c)</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_offset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_OFFSET</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_mini</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_MINI</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_tiny</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_TINY</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_summary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_SUMMARY</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_comments</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_COMMENTS</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>next_mode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name>mode</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>R_AGRAPH_MODE_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>prev_mode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name>mode</name> <operator>+</operator> <name>R_AGRAPH_MODE_MAX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>R_AGRAPH_MODE_MAX</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>agraph_get_title</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>outnodes</name> <init>= <expr><ternary><condition><expr><name>in</name></expr>?</condition><then> <expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>in_nodes</name></name></expr> </then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>outnodes</argument>, <argument>iter</argument>, <argument>gn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><name><name>gn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>agraph_get_title</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>an</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>mode2opts</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>opts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_offset</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>opts</name> <operator>|=</operator> <name>BODY_OFFSETS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_comments</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>opts</name> <operator>|=</operator> <name>BODY_COMMENTS</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_summary</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>opts</name> <operator>|=</operator> <name>BODY_SUMMARY</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>opts</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rotateAsmemu</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isEmuStr</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"emu.str"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isEmu</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.emu"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isEmu</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>isEmuStr</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"emu.str"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.emu"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"emu.str"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>showcursor</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>x</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>wheel</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.wheel"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>wheel</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_enable_mouse</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_enable_mouse</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_cons_show_cursor</name> <argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_title</name><parameter_list>(<parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"0x%"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>agraph_refresh</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>agraph_refresh_data</name></name> <modifier>*</modifier></type><name>grd</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_node_dimension</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_mini</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>zoom</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>edgemode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>callgraph</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>layout</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_mini</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>MINIGRAPH_NODE_MIN_WIDTH</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>MININODE_MIN_WIDTH</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>r_str_bounds</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <name>MARGIN_TEXT_X</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>+=</operator> <name>BORDER_WIDTH</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>+=</operator> <name>BORDER_HEIGHT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name>MIN_NODE_WIDTH</name></expr></argument>, <argument><expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>*</operator> <name>zoom</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name>MIN_NODE_HEIGHT</name></expr></argument>, <argument><expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>*</operator> <name>zoom</name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>edgemode</name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>callgraph</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>layout</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>R_EDGES_X_INC</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>R_EDGES_X_INC</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>R_EDGES_X_INC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>(</operator><call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>R_EDGES_X_INC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>append_shortcut</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nodetitle</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>left</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>shortcut</name> <init>= <expr><call><name>sdb_const_get</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.shortcut"</literal></expr></argument>, <argument><expr><name>nodetitle</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shortcut</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>color</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><name>Color_YELLOW</name><literal type="string">"[o%s]"</literal><name>Color_RESET</name></expr></argument>, <argument><expr><name>shortcut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>strncat</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"[o%s]"</literal></expr></argument>, <argument><expr><name>shortcut</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>mini_RANode_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>details</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>title</name><index>[<expr><name>TITLE_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>delta_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MINIGRAPH_NODE_CENTER_X</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>

<operator>!</operator><call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MINIGRAPH_NODE_CENTER_X</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MINIGRAPH_NODE_CENTER_X</name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta_x</name> <operator>=</operator> <operator>-</operator><name>x</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MINIGRAPH_NODE_CENTER_X</name> <operator>+</operator> <name>delta_x</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>details</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>MINIGRAPH_NODE_TEXT_CUR</name><index>[<expr><name>delta_x</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>G</name> <argument_list>(<argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><literal type="string">"[ %s ]"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>discroll</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>r_str_ansi_crop</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>discroll</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>G</name> <argument_list>(<argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>G</name> <argument_list>(<argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><literal type="string">"____"</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>str</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>l</name> <operator>&gt;</operator> <name>MINIGRAPH_NODE_TITLE_LEN</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>str</name> <operator>+=</operator> <name>l</name> <operator>-</operator> <name>MINIGRAPH_NODE_TITLE_LEN</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>color</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%s__%s__"</literal></expr></argument>, <argument><expr><name>Color_RESET</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"__%s__"</literal></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>append_shortcut</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><call><name>r_str_ansi_crop</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><name>delta_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name>cur</name></expr>?</condition><then> <expr><literal type="string">"[ %s ]"</literal></expr></then><else>: <expr><literal type="string">" %s "</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>tiny_RANode_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RCons</name> <modifier>*</modifier></type><name>cons</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>circle</name> <init>= <expr><ternary><condition><expr><name><name>cons</name><operator>-&gt;</operator><name>use_utf8</name></name></expr> ?</condition><then> <expr><name>UTF_CIRCLE</name></expr> </then><else>:<expr><literal type="string">"()"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><literal type="string">"##"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>circle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_node_color</name> <parameter_list>(<parameter><decl><type><name>int</name></type> <name>color</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCons</name> <modifier>*</modifier></type><name>cons</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>color</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name>cur</name></expr> ?</condition><then> <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_box2</name></name></expr> </then><else>: <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_box</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><ternary><condition><expr><name>color</name></expr> ?</condition><then> <expr><operator>(</operator>\

<ternary><condition><expr><name>color</name><operator>==</operator><name>R_ANAL_DIFF_TYPE_MATCH</name></expr> ?</condition><then> <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_diff_match</name></name></expr></then><else>:

<expr><ternary><condition><expr><name>color</name><operator>==</operator><name>R_ANAL_DIFF_TYPE_UNMATCH</name></expr>?</condition><then> <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_diff_unmatch</name></name></expr> </then><else>: <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_diff_new</name></name></expr></else></ternary></expr></else></ternary><operator>)</operator></expr></then><else>: <expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_diff_unknown</name></name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>normal_RANode_print</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>center_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>center_y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>delta_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>delta_txt_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>delta_y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>delta_txt_y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>title</name><index>[<expr><name>TITLE_LEN</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>color</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>difftype</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>showTitle</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>show_node_titles</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>showBody</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>show_node_body</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>+</operator> <name>MARGIN_TEXT_X</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta_x</name> <operator>=</operator> <operator>-</operator><operator>(</operator><name>x</name> <operator>+</operator> <name>MARGIN_TEXT_X</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>x</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>&lt;</operator> <operator>-</operator><name>MARGIN_TEXT_X</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>y</name> <operator>&lt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>delta_y</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>-</operator> <name>BORDER_HEIGHT</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><name>y</name> <operator>-</operator> <name>MARGIN_TEXT_Y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>showTitle</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"[%s]"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>color</name> <init>= <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>color</name></name></expr> ?</condition><then> <expr><name>Color_RESET</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>snprintf</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">" %s%s "</literal></expr></argument>, <argument><expr><name>color</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>append_shortcut</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>delta_x</name> <operator>&lt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MARGIN_TEXT_X</name> <operator>+</operator> <name>delta_x</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_str_ansi_crop</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><name>delta_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>-</operator> <name>BORDER_WIDTH</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&gt;</operator> <name>ZOOM_DEFAULT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>center_x</name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>-</operator> <name>ZOOM_DEFAULT</name><operator>)</operator> <operator>/</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>center_y</name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>-</operator> <name>ZOOM_DEFAULT</name><operator>)</operator> <operator>/</operator> <literal type="number">30</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>delta_txt_x</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>delta_x</name></expr></argument>, <argument><expr><name>center_x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta_txt_y</name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name>delta_y</name></expr></argument>, <argument><expr><name>center_y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>showBody</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>G</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>MARGIN_TEXT_X</name> <operator>+</operator> <name>delta_x</name> <operator>+</operator> <name>center_x</name> <operator>-</operator> <name>delta_txt_x</name></expr></argument>,

<argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name>MARGIN_TEXT_Y</name> <operator>+</operator> <name>delta_y</name> <operator>+</operator> <name>center_y</name> <operator>-</operator> <name>delta_txt_y</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut32</name></type> <name>body_x</name> <init>= <expr><ternary><condition><expr><name>center_x</name> <operator>&gt;=</operator> <name>delta_x</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name>delta_x</name> <operator>-</operator> <name>center_x</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>body_y</name> <init>= <expr><ternary><condition><expr><name>center_y</name> <operator>&gt;=</operator> <name>delta_y</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name>delta_y</name> <operator>-</operator> <name>center_y</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut32</name></type> <name>body_h</name> <init>= <expr><ternary><condition><expr><name>BORDER_HEIGHT</name> <operator>&gt;=</operator> <name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>-</operator> <name>BORDER_HEIGHT</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&lt;</operator> <name>ZOOM_DEFAULT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>body_h</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>body_y</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;=</operator> <name>body_h</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>r_str_ansi_crop</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>,

<argument><expr><name>body_x</name></expr></argument>, <argument><expr><name>body_y</name></expr></argument>,

<argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>-</operator> <name>BORDER_WIDTH</name></expr></argument>,

<argument><expr><name>body_h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>body</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&lt;</operator> <name>ZOOM_DEFAULT</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>body_y</name> <operator>&lt;=</operator> <name>body_h</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&lt;</operator> <name>ZOOM_DEFAULT</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dots</name> <init>= <expr><literal type="string">"..."</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>delta_x</name> <operator>&lt;</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>dots</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dots</name> <operator>+=</operator> <name>delta_x</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>dots</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>show_node_bubble</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_circle</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>get_node_color</name> <argument_list>(<argument><expr><name>color</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_box</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><call><name>get_node_color</name> <argument_list>(<argument><expr><name>color</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>get_crossing_matrix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>,

<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>layer_t</name></name></type> <name><name>layers</name><index>[]</index></name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>maxlayer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>,

<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>n_rows</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>len</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>m</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>m</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>err_row</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>from_up</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>err_row</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>layers</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gj</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itk</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>neigh</argument>, <argument>itk</argument>, <argument>gk</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>gj</name> <operator>==</operator> <name>gk</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name>j</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh_s</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itt</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>neigh_s</argument>, <argument>itt</argument>, <argument>gt</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>at</name></decl>;</decl_stmt> 

<if_stmt><if>if <condition>(<expr><name>gt</name> <operator>==</operator> <name>gk</name> <operator>||</operator> <name>gt</name> <operator>==</operator> <name>gs</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ak</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>gk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>gt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>layer</name></name> <operator>!=</operator> <name>i</name> <operator>||</operator> <name><name>at</name><operator>-&gt;</operator><name>layer</name></name> <operator>!=</operator> <name>i</name></expr>)</condition> <block>{<block_content>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

eprintf ("(WARNING) \"%s\" (%d) or \"%s\" (%d) are not on the right layer (%d)\n",

ak-&gt;title, ak-&gt;layer,

at-&gt;title, at-&gt;layer,

i);

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>m</name><index>[<expr><name><name>ak</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>]</index><index>[<expr><name><name>at</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>maxlayer</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>from_up</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>err_row</name>;</goto>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gj</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>aj</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itk</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<goto>goto <name>err_row</name>;</goto>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh</argument>, <argument>itk</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>s</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>s</name> <operator>&lt;</operator> <name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gs</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh_s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>at</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>as</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>gs</name> <operator>==</operator> <name>gj</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>neigh_s</name> <operator>=</operator> <call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh_s</argument>, <argument>itt</argument>, <argument>gt</argument>, <argument>at</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>at</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>&lt;</operator> <name><name>ak</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>m</name><index>[<expr><name><name>aj</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>]</index><index>[<expr><name><name>as</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n_rows</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>n_rows</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>m</name></expr>;</return>

<label><name>err_row</name>:</label>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>len</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>m</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>layer_sweep</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>layer_t</name></name></type> <name><name>layers</name><index>[]</index></name></decl></parameter>,

<parameter><decl><type><name>int</name></type> <name>maxlayer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>u</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>au</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>n_rows</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>changed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>cross_matrix</name> <init>= <expr><call><name>get_crossing_matrix</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>layers</name></expr></argument>, <argument><expr><name>maxlayer</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_rows</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cross_matrix</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return> 

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>auidx</name></decl>, <decl><type ref="prev"/><name>avidx</name></decl>;</decl_stmt>

<expr_stmt><expr><name>u</name> <operator>=</operator> <name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>au</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>av</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>auidx</name> <operator>=</operator> <name><name>au</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>avidx</name> <operator>=</operator> <name><name>av</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>cross_matrix</name><index>[<expr><name>auidx</name></expr>]</index><index>[<expr><name>avidx</name></expr>]</index></name> <operator>&gt;</operator> <name><name>cross_matrix</name><index>[<expr><name>avidx</name></expr>]</index><index>[<expr><name>auidx</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>u</name></expr>;</expr_stmt>

<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>n_rows</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>cross_matrix</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cross_matrix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>changed</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>view_cyclic_edge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><operator>(</operator><name>RAGraph</name> <operator>*</operator><operator>)</operator> <name><name>vis</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphEdge</name> <modifier>*</modifier></type><name>new_e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RGraphEdge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_e</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>nth</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>nth</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>back_edges</name></name></expr></argument>, <argument><expr><name>new_e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>view_dummy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>long_edges</name> <init>= <expr><operator>(</operator><name>RList</name> <operator>*</operator><operator>)</operator> <name><name>vis</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <operator>!</operator><name>b</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>a</name><operator>-&gt;</operator><name>layer</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphEdge</name> <modifier>*</modifier></type><name>new_e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RGraphEdge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_e</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>new_e</name><operator>-&gt;</operator><name>nth</name></name> <operator>=</operator> <name><name>e</name><operator>-&gt;</operator><name>nth</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>long_edges</name></expr></argument>, <argument><expr><name>new_e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>remove_cycles</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphVisitor</name></type> <name>cyclic_vis</name> <init>= <expr><block>{

<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>back_edges</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cyclic_vis</name><operator>.</operator><name>back_edge</name></name> <operator>=</operator> <operator>(</operator><name>RGraphEdgeCallback</name><operator>)</operator> <name>view_cyclic_edge</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cyclic_vis</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_dfs</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cyclic_vis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>g-&gt;back_edges</argument>, <argument>it</argument>, <argument>e</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr>?</condition><then> <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr>?</condition><then> <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>from</name> <operator>&amp;&amp;</operator> <name>to</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_del_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge_at</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>nth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>add_sorted</name><parameter_list>(<parameter><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>RGraphVisitor</name> <modifier>*</modifier></type><name>vis</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><operator>(</operator><name>RList</name> <operator>*</operator><operator>)</operator> <name><name>vis</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_prepend</name> <argument_list>(<argument><expr><name>l</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>assign_layers</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphVisitor</name></type> <name>layer_vis</name> <init>= <expr><block>{

<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>topological_sort</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>layer_vis</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name>topological_sort</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>layer_vis</name><operator>.</operator><name>finish_node</name></name> <operator>=</operator> <operator>(</operator><name>RGraphNodeCallback</name><operator>)</operator> <name>add_sorted</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_dfs</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>layer_vis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>topological_sort</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>innodes</name> <init>= <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>preva</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>innodes</argument>, <argument>it</argument>, <argument>prev</argument>, <argument>preva</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>preva</name><operator>-&gt;</operator><name>layer</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name> <operator>=</operator> <name><name>preva</name><operator>-&gt;</operator><name>layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>topological_sort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_edge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>to</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>from</name></name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>is_reversed</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name>bool</name><operator>)</operator><call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>back_edges</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>find_edge</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_dummy_nodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>dummy</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RGraphVisitor</name></type> <name>dummy_vis</name> <init>= <expr><block>{

<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>long_edges</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator><name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy_vis</name><operator>.</operator><name>data</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>long_edges</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy_vis</name><operator>.</operator><name>tree_edge</name></name> <operator>=</operator> <operator>(</operator><name>RGraphEdgeCallback</name><operator>)</operator> <name>view_dummy</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy_vis</name><operator>.</operator><name>fcross_edge</name></name> <operator>=</operator> <operator>(</operator><name>RGraphEdgeCallback</name><operator>)</operator> <name>view_dummy</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_dfs</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dummy_vis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>g-&gt;long_edges</argument>, <argument>it</argument>, <argument>e</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>diff_layer</name> <init>= <expr><call><name>R_ABS</name> <argument_list>(<argument><expr><name><name>from</name><operator>-&gt;</operator><name>layer</name></name> <operator>-</operator> <name><name>to</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>nth</name> <init>= <expr><name><name>e</name><operator>-&gt;</operator><name>nth</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_agraph_del_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>diff_layer</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>dummy</name> <init>= <expr><call><name>r_agraph_add_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dummy</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>dummy</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy</name><operator>-&gt;</operator><name>layer</name></name> <operator>=</operator> <name><name>from</name><operator>-&gt;</operator><name>layer</name></name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>=</operator> <call><name>is_reversed</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>dummy</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge_at</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>dummy</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>dummy</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>r_graph_add_edge</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>prev</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>create_layers</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name> <operator>&gt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>layer_t</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name></name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr>struct <name>layer_t</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>n_nodes</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><sizeof>sizeof <argument_list>(<argument><expr><name>RGraphNode</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodes</name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>RGraphNode</name> <operator>*</operator></expr></argument>,

<argument><expr><literal type="number">1</literal> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>position</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>position</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>position</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>minimize_crossings</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>cross_changed</name></decl>, <decl><type ref="prev"/><name>max_changes</name> <init>= <expr><literal type="number">4096</literal></expr></init></decl>;</decl_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>cross_changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_changes</name><operator>--</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>layer_sweep</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cross_changed</name> <operator>|=</operator> <operator>!</operator><operator>!</operator><name>rc</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block> while <condition>(<expr><name>cross_changed</name> <operator>&amp;&amp;</operator> <name>max_changes</name></expr>)</condition>;</do>

<expr_stmt><expr><name>max_changes</name> <operator>=</operator> <literal type="number">4096</literal></expr>;</expr_stmt>

<do>do <block>{<block_content>

<expr_stmt><expr><name>cross_changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_changes</name><operator>--</operator></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><call><name>layer_sweep</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>cross_changed</name> <operator>|=</operator> <operator>!</operator><operator>!</operator><name>rc</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block> while <condition>(<expr><name>cross_changed</name> <operator>&amp;&amp;</operator> <name>max_changes</name></expr>)</condition>;</do>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>find_dist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dist_t</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>dist_t</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>from</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>from</name></name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>to</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>to</name></name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>dist_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dist_t</name></name></type> <name>d</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>aa</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ab</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>find_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>it</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dist_t</name></name> <modifier>*</modifier></type><name>old</name> <init>= <expr><operator>(</operator>struct <name>dist_t</name> <operator>*</operator><operator>)</operator> <call><name>r_list_iter_get_data</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><name><name>old</name><operator>-&gt;</operator><name>dist</name></name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>aa</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ab</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>aa</name> <operator>&amp;&amp;</operator> <name>ab</name> <operator>&amp;&amp;</operator> <name><name>aa</name><operator>-&gt;</operator><name>layer</name></name> <operator>==</operator> <name><name>ab</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <ternary><condition><expr><name>aa</name> <operator>==</operator> <name>ab</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>aa</name><operator>-&gt;</operator><name>is_reversed</name></name></expr>?</condition><then> <expr><name>HORIZONTAL_NODE_SPACING</name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>aa</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>ab</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>aa</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>anext</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>acur</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>find_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>it</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dist_t</name></name> <modifier>*</modifier></type><name>old</name> <init>= <expr><operator>(</operator>struct <name>dist_t</name> <operator>*</operator><operator>)</operator> <call><name>r_list_iter_get_data</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>old</name><operator>-&gt;</operator><name>dist</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>acur</name> <operator>&amp;&amp;</operator> <name>anext</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>space</name> <init>= <expr><name>HORIZONTAL_NODE_SPACING</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>acur</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>&amp;&amp;</operator> <name><name>anext</name><operator>-&gt;</operator><name>is_reversed</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>acur</name><operator>-&gt;</operator><name>is_reversed</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>acur</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>anext</name><operator>-&gt;</operator><name>is_reversed</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>anext</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>+=</operator> <name><name>acur</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>anext</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name>space</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_dist_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>next</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>dist_t</name></name> <modifier>*</modifier></type><name>d</name></decl>, <decl><type ref="prev"/><name>find_el</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>vi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vip</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>avi</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>avip</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vi</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vip</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>next</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>avi</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>avip</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>vip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>find_el</name><operator>.</operator><name>from</name></name> <operator>=</operator> <name>vi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>find_el</name><operator>.</operator><name>to</name></name> <operator>=</operator> <name>vip</name></expr>;</expr_stmt>

<expr_stmt><expr><name>it</name> <operator>=</operator> <call><name>r_list_find</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>find_el</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>find_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>d</name> <operator>=</operator> <ternary><condition><expr><name>it</name></expr>?</condition><then> <expr><operator>(</operator>struct <name>dist_t</name> <operator>*</operator><operator>)</operator> <call><name>r_list_iter_get_data</name> <argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>dist_t</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>vi</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>vip</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>d</name><operator>-&gt;</operator><name>dist</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avip</name> <operator>&amp;&amp;</operator> <name>avi</name><operator>)</operator></expr>?</condition><then> <expr><name><name>avip</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>avi</name><operator>-&gt;</operator><name>x</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>it</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_push</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_valid_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pos</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name>pos</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>pos</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>compute_vertical_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>Ln</name> <init>= <expr><call><name>hash_get_rlist</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Ln</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>vert</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>an</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>next</name> <init>= <expr><name>gn</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>anext</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name><name>anext</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>vert</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>r_graph_nth_neighbour</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>next</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>anext</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>vert</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>compute_classes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>v_nodes</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>n_classes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>RList</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>r_graph_get_nodes (g-&gt;graph)</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>klass</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</init>

<condition><expr><operator>(</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition>

<incr><expr><name>j</name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>j</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gj</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>aj</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>aj</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>laj</name> <init>= <expr><call><name>hash_get_rlist</name> <argument_list>(<argument><expr><name>v_nodes</name></expr></argument>, <argument><expr><name>gj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>res</name><index>[<expr><name>c</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>res</name><index>[<expr><name>c</name></expr>]</index></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>laj</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>res</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>klass</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>c</name> <operator>=</operator> <name><name>aj</name><operator>-&gt;</operator><name>klass</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>n_classes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>n_classes</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>cmp_dist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>a</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>b</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>get_sibling</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_adjust_class</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>pos</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name>is_adjust_class</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_left</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_adjust_class</name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>pos</name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_valid_pos</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>res</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>n</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>adjust_class_val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>sibl</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_class</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>classes</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>an</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dist</name></decl>, <decl><type ref="prev"/><name>v</name></decl>, <decl><type ref="prev"/><name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>classes[c]</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>sibling</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>sibl_anode</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sibling</name> <operator>=</operator> <call><name>get_sibling</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>an</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sibling</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sibl_anode</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>sibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>sibl_anode</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name>c</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>adjust_class_val</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>sibling</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dist</name> <operator>=</operator> <ternary><condition><expr><name>is_first</name></expr>?</condition><then> <expr><name>v</name></expr></then><else>: <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>dist</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>heap</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>classes[c]</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_all_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>itk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh</argument>, <argument>itk</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>klass</name></name> <operator>&lt;</operator> <name>c</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>d</name> <init>= <expr><operator>(</operator><name><name>ak</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>an</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>d</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>dist</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>cmp_dist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>dist</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>len</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>heap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>classes[c]</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>old_val</name> <init>= <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>new_val</name> <init>= <expr><ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><name>old_val</name> <operator>+</operator> <name>dist</name></expr></then><else>: <expr><name>old_val</name> <operator>-</operator> <name>dist</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>place_nodes_val</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>sibl</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>sibl</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>place_nodes_sel_p</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>oldval</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_first</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>newval</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>R_MAX</name> <argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><call><name>R_MIN</name> <argument_list>(<argument><expr><name>oldval</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>place_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>v_nodes</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>classes</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>placed</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>lv</name> <init>= <expr><call><name>hash_get_rlist</name> <argument_list>(<argument><expr><name>v_nodes</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>v</name></decl>, <decl><type ref="prev"/><name>is_first</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>itk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>lv</argument>, <argument>itk</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>sibling</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>sibl_anode</name></decl>;</decl_stmt>

<expr_stmt><expr><name>sibling</name> <operator>=</operator> <call><name>get_sibling</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>ak</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>sibling</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sibl_anode</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>sibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>klass</name></name> <operator>==</operator> <name><name>sibl_anode</name><operator>-&gt;</operator><name>klass</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_get</name> <argument_list>(<argument><expr><name>placed</name></expr></argument>, <argument><expr><name>sibling</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>place_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>sibling</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><name>v_nodes</name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>placed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>place_nodes_val</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gk</name></expr></argument>, <argument><expr><name>sibling</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>place_nodes_sel_p</name> <argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>is_first</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>is_first</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>is_first</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><literal type="number">50</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>lv</argument>, <argument>itk</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>gk</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>placed</name></expr></argument>, <argument><expr><name>gk</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Sdb</name> <modifier>*</modifier></type><name>compute_pos</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>v_nodes</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>n_classes</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier><modifier>*</modifier></type><name>classes</name> <init>= <expr><call><name>compute_classes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v_nodes</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>n_classes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>classes</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>placed</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_classes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>classes[i]</argument>, <argument>it</argument>, <argument>gn</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_get_rnode</name> <argument_list>(<argument><expr><name>placed</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>place_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><name>v_nodes</name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>placed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>adjust_class</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>is_left</name></expr></argument>, <argument><expr><name>classes</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>placed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_classes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>classes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>classes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>free_vertical_nodes_cb</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><name>user</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>k</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><operator>(</operator><name>RList</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>sdb_atoi</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>place_dummies</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>vertical_nodes</name> <init>= <expr><call><name>compute_vertical_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vertical_nodes</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>xminus</name> <init>= <expr><call><name>compute_pos</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>vertical_nodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xminus</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>xminus_err</name>;</goto>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>xplus</name> <init>= <expr><call><name>compute_pos</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>vertical_nodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>xplus</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>xplus_err</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nodes</name> <operator>=</operator> <call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>xminus</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>hash_get_int</name> <argument_list>(<argument><expr><name>xplus</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>xplus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>xplus_err</name>:</label>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>xminus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>xminus_err</name>:</label>

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name>vertical_nodes</name></expr></argument>, <argument><expr><operator>(</operator><name>SdbForeachCallback</name><operator>)</operator><name>free_vertical_nodes_cb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>vertical_nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>get_right_dummy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>an</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>, <decl><type ref="prev"/><name>layer</name> <init>= <expr><name><name>an</name><operator>-&gt;</operator><name>layer</name></name></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>an</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>layer</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>layer</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gk</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ak</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>gk</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>adjust_directions</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>P</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>vm</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>vma</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>wma</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>d</name> <init>= <expr><ternary><condition><expr><name>from_up</name></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <name>d</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>i</name> <operator>+</operator> <name>d</name> <operator>&gt;=</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name> <operator>+</operator> <name>d</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>wp</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vp</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name> <operator>+</operator> <name>d</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>wpa</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vpa</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vpa</name> <operator>||</operator> <operator>!</operator><name><name>vpa</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>from_up</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>vp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>wp</name> <operator>=</operator> <call><name>r_graph_nth_neighbour</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>vp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>wpa</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>wp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>wpa</name> <operator>||</operator> <operator>!</operator><name><name>wpa</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>vm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>p</name> <init>= <expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>wm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>wma</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>wpa</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>w</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>wma</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>aw</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>aw</name> <operator>&amp;&amp;</operator> <name><name>aw</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>p</name> <operator>&amp;=</operator> <call><name>hash_get_int</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>vm</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>vma</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name><name>vpa</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>vma</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>k</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>av</name> <operator>&amp;&amp;</operator> <name><name>av</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>vm</name> <operator>=</operator> <name>vp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>wm</name> <operator>=</operator> <name>wp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>vma</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>vm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>wma</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>wm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>place_single</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>va</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>v</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>va</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>av</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>itk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><ternary><condition><expr><name>from_up</name></expr>

?</condition><then> <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>neigh</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sum_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh</argument>, <argument>itk</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>is_reversed</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>sum_x</name> <operator>+=</operator> <name><name>ak</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>av</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>sum_x</name> <operator>/</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>bma</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>bm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>bma</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bp</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>bpa</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>bpa</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>RM_listcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>pos</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>pos</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>RP_listcmp</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>b</name><operator>-&gt;</operator><name>pos</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>collect_changes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>s</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>e</name></decl></parameter>, <parameter><decl><type><name>RList</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_left</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>vt</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>e</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>vtp</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>s</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>cx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListComparator</name></type> <name>lcmp</name> <init>= <expr><ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>RM_listcmp</name></expr></then><else>: <expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>RP_listcmp</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><name>s</name></expr></then><else>: <expr><name>e</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</init> <condition><expr><operator>(</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name>e</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <name>s</name><operator>)</operator></expr>;</condition> <incr><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>v</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vi</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>av</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>avi</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>avi</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>neigh</name> <operator>=</operator> <ternary><condition><expr><name>from_up</name></expr>

?</condition><then> <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh</argument>, <argument>it</argument>, <argument>v</argument>, <argument>av</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;=</operator> <name><name>avi</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_left</name> <operator>&amp;&amp;</operator> <name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;=</operator> <name><name>avi</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>c</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>cx</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr>struct <name>len_pos_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>c</name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>av</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vtp</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_add_sorted</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

<expr_stmt><expr><name>cx</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>len_pos_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <name>c</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>avi</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vtp</name></expr></argument>, <argument><expr><name>vi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_add_sorted</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>b</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>ab</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cx</name> <operator>=</operator> <call><name>R_NEW</name> <argument_list>(<argument><expr>struct <name>len_pos_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>len</name></name> <operator>=</operator> <ternary><condition><expr><name>is_left</name></expr>?</condition><then> <expr><name>INT_MAX</name></expr></then><else>: <expr><name>INT_MIN</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name><name>ab</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_left</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vtp</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_add_sorted</name> <argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>cx</name></expr></argument>, <argument><expr><name>lcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>combine_sequences</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>r</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>Rm</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>Rp</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>vt</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>vtp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>at</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>atp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rm</name></decl>, <decl><type ref="prev"/><name>rp</name></decl>, <decl><type ref="prev"/><name>t</name></decl>, <decl><type ref="prev"/><name>m</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>Rm</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>Rp</name><operator>-&gt;</operator><name>free</name></name> <operator>=</operator> <operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr>;</expr_stmt>

<expr_stmt><expr><name>t</name> <operator>=</operator> <operator>(</operator><name>a</name> <operator>+</operator> <name>r</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>vt</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>t</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>vtp</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>t</name></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>at</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>atp</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>vtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>collect_changes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>Rm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>collect_changes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>t</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name>Rp</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <name>rp</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>m</name> <operator>=</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>, <argument><expr><name>vtp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>at</name> <operator>&amp;&amp;</operator> <name>atp</name></expr>)</condition> <block>{<block_content>

<while>while <condition>(<expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name>m</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name><name>at</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>step</name> <init>= <expr><name>m</name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>-=</operator> <name>step</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>+=</operator> <name>m</name> <operator>-</operator> <name>step</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>rm</name> <operator>&lt;</operator> <name>rp</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>Rm</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name>m</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>cx</name> <init>= <expr><operator>(</operator>struct <name>len_pos_t</name> <operator>*</operator><operator>)</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name>Rm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rm</name> <operator>=</operator> <name>rm</name> <operator>+</operator> <name><name>cx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_list_empty</name> <argument_list>(<argument><expr><name>Rp</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>m</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>len_pos_t</name></name> <modifier>*</modifier></type><name>cx</name> <init>= <expr><operator>(</operator>struct <name>len_pos_t</name> <operator>*</operator><operator>)</operator> <call><name>r_list_pop</name> <argument_list>(<argument><expr><name>Rp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>rp</name> <operator>=</operator> <name>rp</name> <operator>+</operator> <name><name>cx</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>cx</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>Rm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>Rp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>t</name> <operator>-</operator> <literal type="number">2</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <name>a</name></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gv</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>av</name> <operator>&amp;&amp;</operator> <name>at</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MIN</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>at</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gv</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>t</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>r</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gv</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>l</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>av</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>av</name> <operator>&amp;&amp;</operator> <name>atp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>R_MAX</name> <argument_list>(<argument><expr><name><name>av</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><name><name>atp</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>vtp</name></expr></argument>, <argument><expr><name>gv</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>place_sequence</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>l</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bm</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bp</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>va</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>vr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>vr</name> <operator>==</operator> <name>va</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>place_single</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>vr</name> <operator>&gt;</operator> <name>va</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>vt</name> <init>= <expr><operator>(</operator><name>vr</name> <operator>+</operator> <name>va</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>place_sequence</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>place_sequence</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>vt</name></expr></argument>, <argument><expr><name>vr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>combine_sequences</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>l</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>vr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>original_traverse_l</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>D</name></decl></parameter>, <parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>P</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>from_up</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>va</name></decl>, <decl><type ref="prev"/><name>vr</name></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>from_up</name></expr>?</condition><then> <expr><literal type="number">0</literal></expr></then><else>: <expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</init>

<condition><expr><operator>(</operator><name>from_up</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>from_up</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</condition>

<incr><expr><name>i</name> <operator>=</operator> <ternary><condition><expr><name>from_up</name></expr>?</condition><then> <expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bm</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>bma</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>bm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>an</name> <operator>&amp;&amp;</operator> <name><name>an</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>va</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>vr</name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bm</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>

<expr_stmt><expr><name>bma</name> <operator>=</operator> <name>an</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>va</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>vr</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>place_sequence</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>vr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>va</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>set_dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>is_valid_pos</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>vr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>bm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>vr</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name><name>bma</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<while>while <condition>(<expr><name>bm</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>bp</name> <init>= <expr><call><name>get_right_dummy</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>bpa</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>bma</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>bm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>bp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>va</name> <operator>=</operator> <name><name>bma</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>vr</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>bma</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>place_sequence</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>vr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name>va</name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>vr</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>set_dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>k</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><call><name>is_valid_pos</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>set_dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>bma</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr></argument>, <argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>hash_get_int</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>from_up</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>bpa</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>va</name> <operator>=</operator> <name><name>bma</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>vr</name> <operator>=</operator> <name><name>bpa</name><operator>-&gt;</operator><name>pos_in_layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>place_sequence</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>va</name></expr></argument>, <argument><expr><name>vr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>bm</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bm</name> <operator>=</operator> <name>bp</name></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>adjust_directions</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>from_up</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>place_original</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>itn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>an</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>D</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>D</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>P</name> <init>= <expr><call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>P</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name> <operator>=</operator> <call><name>r_list_newf</name> <argument_list>(<argument><expr><operator>(</operator><name>RListFree</name><operator>)</operator> <name>free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>itn</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>an</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>right_v</name> <init>= <expr><call><name>get_right_dummy</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>right</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>right_v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>right_v</name> <operator>&amp;&amp;</operator> <name>right</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>D</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>dt_eq</name> <init>= <expr><name><name>right</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>an</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <call><name>dist_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>right_v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>hash_set</name> <argument_list>(<argument><expr><name>P</name></expr></argument>, <argument><expr><name>gn</name></expr></argument>, <argument><expr><name>dt_eq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>original_traverse_l</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>original_traverse_l</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>D</name></expr></argument>, <argument><expr><name>P</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>dists</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>P</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name>D</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>

static void free_anode(RANode *n);

static void remove_dummy_nodes(const RAGraph *g) {

const RList *nodes = r_graph_get_nodes (g-&gt;graph);

RGraphNode *gn;

RListIter *it;

RANode *n;

graph_foreach_anode (nodes, it, gn, n) {

if (n-&gt;is_dummy) {

r_graph_del_node (g-&gt;graph, gn);

n-&gt;gnode = NULL;

free_anode (n);

}

}

}

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_layer_gap</name> <parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>gap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>ga</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>gb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>outnodes</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>gap</name> <operator>=</operator> <name>gap</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>ga</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ga</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <name><name>ga</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>outnodes</name> <operator>=</operator> <name><name>ga</name><operator>-&gt;</operator><name>out_nodes</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outnodes</name> <operator>||</operator> <operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>outnodes</argument>, <argument>itn</argument>, <argument>gb</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>x</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>gap</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+=</operator> <name>gap</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fix_back_edge_dummy_nodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>v</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gv</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>g</name> <operator>&amp;&amp;</operator> <name>from</name> <operator>&amp;&amp;</operator> <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neighbours</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>to</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neighbours</argument>, <argument>it</argument>, <argument>gv</argument>, <argument>v</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <name><name>from</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>tmp</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name> <operator>!=</operator> <name><name>from</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt>

<expr_stmt><expr><name>tmp</name> <operator>=</operator> <operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>v</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<while>while <condition>(<expr><name><name>v</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name> <operator>!=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>idx</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></while>

<while>while <condition>(<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>i</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>n_nodes</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>v</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index></name><operator>.</operator><name>n_nodes</name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_del_node</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>v</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_edge_number</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>outgoing</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>cur_nth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>outgoing</name> <operator>&amp;&amp;</operator> <name><name>src</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><call><name>r_list_first</name> <argument_list>(<argument><expr><operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>gnode</name></name><operator>)</operator><operator>-&gt;</operator><name>in_nodes</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>data</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>cur_nth</name> <operator>=</operator> <call><name>get_edge_number</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>in</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>outgoing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neighbours</name> <init>= <expr><ternary><condition><expr><name>outgoing</name></expr>

?</condition><then> <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>dst</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>exit_edges</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>neighbours</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neighbours</argument>, <argument>itn</argument>, <argument>gv</argument>, <argument>v</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>cur_nth</name> <operator>=</operator> <name>nth</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur_nth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>exit_edges</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cur_nth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>outgoing</name> <operator>&amp;&amp;</operator> <name><name>gv</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <operator>(</operator><name><name>dst</name><operator>-&gt;</operator><name>gnode</name></name><operator>)</operator><operator>-&gt;</operator><name>idx</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>outgoing</name> <operator>&amp;&amp;</operator> <name><name>gv</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>gnode</name></name><operator>)</operator><operator>-&gt;</operator><name>idx</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nth</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>cur_nth</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>count_edges</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>dst</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>get_edge_number</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>backedge_info</name> <parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>min</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>inedge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>outedge</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier><modifier>*</modifier></type><name>arr</name> <init>= <expr><call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>int</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>arr</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>R_NEWS0</name> <argument_list>(<argument><expr><name>int</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<goto>goto <name>err</name>;</goto>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gt</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gt</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>t</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <name><name>gt</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>t</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tc</name> <init>= <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>t</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><name><name>t</name><operator>-&gt;</operator><name>y</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tl</name> <init>= <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>t</name><operator>-&gt;</operator><name>w</name></name></expr> </then><else>: <expr><name><name>t</name><operator>-&gt;</operator><name>h</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>j</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tc</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tc</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&gt;</operator> <name>tc</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tc</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;</operator> <name>tc</name> <operator>+</operator> <name>tl</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>tc</name> <operator>+</operator> <name>tl</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neighbours</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itm</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>inedge</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>outedge</name> <operator>+=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name>neighbours</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neighbours</argument>, <argument>itm</argument>, <argument>gb</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><call><name>count_edges</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>xinc</name> <init>= <expr><name>R_EDGES_X_INC</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>nth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ax</name> <init>= <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>xinc</name></expr> </then><else>: <expr><name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>h</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>nth</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bx</name> <init>= <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>b</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>xinc</name></expr> </then><else>: <expr><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>h</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>+</operator> <name>nth</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>nth</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bx</name> <operator>&gt;</operator> <name>ax</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>+=</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>min</name> <operator>&gt;</operator> <name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>min</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&lt;</operator> <name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max</name> <operator>=</operator> <name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>int</name></type> <name>l</name> <init>= <expr><operator>(</operator><name>ax</name> <operator>-</operator> <name>min</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bx</name> <operator>-</operator> <name>min</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>r</name> <init>= <expr><operator>(</operator><name>max</name> <operator>-</operator> <name>ax</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>max</name> <operator>-</operator> <name>bx</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>max</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>arr</name><index>[<expr><name>k</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>min</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></for>

<decl_stmt><decl><type><name>AEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>AEdge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>b</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>r</name> <operator>&lt;</operator> <name>l</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>max</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name></expr></else></ternary><operator>)</operator></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name>min</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name><argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></for>

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name>inedge</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>AEdge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>inedge</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>-</operator> <name>inedge</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>outedge</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AEdge</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>AEdge</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>e</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>height</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>outedge</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>x</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>width</name> <operator>+</operator> <literal type="number">2</literal> <operator>+</operator> <name>outedge</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<label><name>err</name>:</label>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>arr</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>arr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>set_layout</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name> <operator>=</operator> <call><name>r_list_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>remove_cycles</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>assign_layers</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_dummy_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>create_layers</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>minimize_crossings</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_break_end</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>rh</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rw</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>&gt;</operator> <name>rh</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rh</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>&gt;</operator> <name>rw</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>rw</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>height</name> <operator>=</operator> <name>rh</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>width</name> <operator>=</operator> <name>rw</name></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name><operator>-&gt;</operator><name>data</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>height</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>width</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>layer_height</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>height</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>a</name><operator>-&gt;</operator><name>layer_width</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>width</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>place_dummies</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>place_original</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphEdge</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>g-&gt;back_edges</argument>, <argument>it</argument>, <argument>e</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>from</name> <init>= <expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr>?</condition><then> <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>from</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>to</name> <init>= <expr><ternary><condition><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr>?</condition><then> <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>e</name><operator>-&gt;</operator><name>to</name></name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>fix_back_edge_dummy_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_del_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge_at</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name><name>e</name><operator>-&gt;</operator><name>nth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<switch>switch <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name></expr>)</condition> <block>{<block_content>

<default>default:</default>

<case>case <expr><literal type="number">0</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>-=</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>/=</operator> <literal type="number">8</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>set_layer_gap</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>tmp_y</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tmp_y</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gap</name></expr>;</expr_stmt> 

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>tmp_y</name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>height</name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt> 

</block_content>}</block></for>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tmp_y</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>tmp_y</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> 

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;</operator> <name>j</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>m</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>k</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>-=</operator> <operator>(</operator><name><name>m</name><operator>-&gt;</operator><name>h</name></name> <operator>+</operator> <name>VERTICAL_NODE_SPACING</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

</block_content>}</block></for>

<expr_stmt><expr><call><name>set_layer_gap</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>xval</name> <init>= <expr><literal type="number">1</literal> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<for>for <control>(<init><expr><name>k</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>k</name> <operator>&lt;=</operator> <name>i</name></expr>;</condition> <incr><expr><name>k</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><name>xval</name> <operator>+=</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>k</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>width</name> <operator>+</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>k</name></expr>]</index></name><operator>.</operator><name>gap</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></for>

<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>n_nodes</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>nodes</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>xval</name></expr>;</expr_stmt>

</block_content>}</block></for>

</block_content>}</block></for>

<break>break;</break>

</block_content>}</block></switch>

<expr_stmt><expr><call><name>backedge_info</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>n_layers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>nodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></for>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>layers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>long_edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>back_edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_body</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hc</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>,

<argument><expr><literal type="string">"asm.cmt.col"</literal></expr></argument>, <argument><expr><literal type="string">"asm.marks"</literal></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>,

<argument><expr><literal type="string">"asm.comments"</literal></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="string">"asm.bb.line"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_comments</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.comments"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_cmtright</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.cmtright"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_bytes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.bytes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_flags_in_bytes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.flags.inbytes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>o_graph_offset</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.offset"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>o_cursor</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>BODY_COMMENTS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_visual_toggle_decompiler_disasm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>res</name> <init>= <expr><call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pD %d @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_replace</name> <argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><literal type="string">"; "</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_str_trim</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>r_str_trim_lines</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_visual_toggle_decompiler_disasm</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>BODY_SUMMARY</name><operator>)</operator></expr>?</condition><then> <expr><literal type="string">"pds"</literal></expr></then><else>: <expr><literal type="string">"pD"</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bb.line"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.lines"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.col"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.marks"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>BODY_SUMMARY</name><operator>)</operator> <operator>||</operator> <name>o_cmtright</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.comments"</literal></expr></argument>, <argument><expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <name>BODY_SUMMARY</name><operator>)</operator> <operator>||</operator> <name>o_comments</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>,

<argument><expr><operator>(</operator><name>opts</name> <operator>&amp;</operator> <operator>(</operator><name>BODY_SUMMARY</name> <operator>|</operator> <name>BODY_OFFSETS</name><operator>)</operator><operator>)</operator> <operator>||</operator> <name>o_bytes</name> <operator>||</operator> <name>o_flags_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bb.middle"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>opts</name> <operator>&amp;</operator> <name>BODY_OFFSETS</name> <operator>||</operator> <name>opts</name> <operator>&amp;</operator> <name>BODY_SUMMARY</name> <operator>||</operator> <name>o_graph_offset</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.offset"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>html</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.aeab"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"%s 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><literal type="string">"aeab"</literal></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>body</name> <operator>=</operator> <call><name>r_core_cmd_strf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"%s %d @ 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.html"</literal></expr></argument>, <argument><expr><name>html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <name>o_cursor</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>body</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_bb_body</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opts</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>emu</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>saved_gp</name></decl></parameter>, <parameter><decl><type><name>ut8</name> <modifier>*</modifier></type><name>saved_arena</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>emu</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name> <operator>=</operator> <name>saved_gp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>parent_reg_arena</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_poke</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>parent_reg_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>parent_reg_arena</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>gp</name> <init>= <expr><call><name>r_reg_getv</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><literal type="string">"gp"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>gp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name> <operator>=</operator> <name>gp</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_poke</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>!=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>parent_stackptr</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>get_body</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>size</name></name></expr></argument>, <argument><expr><name>opts</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>jumpbb</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>jumpbb</name> <operator>&amp;&amp;</operator> <call><name>r_list_contains</name> <argument_list>(<argument><expr><name><name>jumpbb</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>emu</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>last_disasm_reg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>jumpbb</name><operator>-&gt;</operator><name>parent_reg_arena</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>jumpbb</name><operator>-&gt;</operator><name>parent_reg_arena</name></name> <operator>=</operator> <call><name>r_reg_arena_dup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>last_disasm_reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>jumpbb</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>jumpbb</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>stackptr</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>failbb</name> <init>= <expr><call><name>r_anal_get_block_at</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>failbb</name> <operator>&amp;&amp;</operator> <call><name>r_list_contains</name> <argument_list>(<argument><expr><name><name>failbb</name><operator>-&gt;</operator><name>fcns</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>emu</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>last_disasm_reg</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>failbb</name><operator>-&gt;</operator><name>parent_reg_arena</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>failbb</name><operator>-&gt;</operator><name>parent_reg_arena</name></name> <operator>=</operator> <call><name>r_reg_arena_dup</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>last_disasm_reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>failbb</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>failbb</name><operator>-&gt;</operator><name>parent_stackptr</name></name> <operator>=</operator> <name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>stackptr</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>body</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bbcmp</name><parameter_list>(<parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><name><name>a</name><operator>-&gt;</operator><name>addr</name></name> <operator>-</operator> <name><name>b</name><operator>-&gt;</operator><name>addr</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>get_bbupdate</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>emu</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.emu"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>saved_gp</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>saved_arena</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>saved_stackptr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shortcut</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>shortcuts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>emu</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>saved_arena</name> <operator>=</operator> <call><name>r_reg_arena_peek</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>bbcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>shortcuts</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.nodejmps"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>get_bb_body</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>mode2opts</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>emu</name></expr></argument>, <argument><expr><name>saved_gp</name></expr></argument>, <argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>shortcuts</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shortcut</name> <operator>=</operator> <call><name>r_core_add_asmqjmp</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shortcut</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.shortcut"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shortcut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>shortcut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <name>body</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>emu</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name> <operator>=</operator> <name>saved_gp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>saved_arena</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_poke</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <name>saved_stackptr</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>fold_asm_trace</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>curnode</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>curnode</name> <operator>==</operator> <name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RDebugTracepoint</name> <modifier>*</modifier></type><name>tp</name> <init>= <expr><call><name>r_debug_trace_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name> <operator>=</operator> <operator>(</operator><name>tp</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>delete_dup_edges</name> <parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in_it</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in_it2</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>in_it2_tmp</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>a</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>g-&gt;graph-&gt;nodes</argument>, <argument>it</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>n-&gt;out_nodes</argument>, <argument>in_it</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<for>for <control>(<init><expr><name>in_it2</name> <operator>=</operator> <name><name>in_it</name><operator>-&gt;</operator><name>n</name></name></expr>;</init> <condition><expr><name>in_it2</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>b</name> <operator>=</operator> <name><name>in_it2</name><operator>-&gt;</operator><name>data</name></name><operator>,</operator> <name>in_it2_tmp</name> <operator>=</operator> <name><name>in_it2</name><operator>-&gt;</operator><name>n</name></name><operator>,</operator> <literal type="number">1</literal><operator>)</operator></expr>;</condition> <incr><expr><name>in_it2</name> <operator>=</operator> <name>in_it2_tmp</name></expr></incr>)</control> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <name><name>b</name><operator>-&gt;</operator><name>idx</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_delete</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>, <argument><expr><name>in_it2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_delete_data</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>all_neighbours</name></name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_delete_data</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_delete_data</name> <argument_list>(<argument><expr><name><name>b</name><operator>-&gt;</operator><name>all_neighbours</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>n_edges</name></name><operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></for>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>isbbfew</name><parameter_list>(<parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>curbb</name></decl></parameter>, <parameter><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>curbb</name><operator>-&gt;</operator><name>addr</name></name> <operator>||</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>curbb</name><operator>-&gt;</operator><name>jump</name></name> <operator>||</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>curbb</name><operator>-&gt;</operator><name>fail</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>curbb</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>curbb-&gt;switch_op-&gt;cases</argument>, <argument>it</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_bbnodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>shortcut</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>shortcuts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>emu</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.emu"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>few</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>saved_gp</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut8</name> <modifier>*</modifier></type><name>saved_arena</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>saved_stackptr</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>emu</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>saved_arena</name> <operator>=</operator> <call><name>r_reg_arena_peek</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>bbs</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RListComparator</name><operator>)</operator> <name>bbcmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>curbb</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>few</name></expr>)</condition> <block>{<block_content>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>curbb</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>curbb</name> <operator>=</operator> <name>bb</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_anal_block_contains</name> <argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>curbb</name> <operator>=</operator> <name>bb</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>few</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isbbfew</name> <argument_list>(<argument><expr><name>curbb</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>get_bb_body</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><call><name>mode2opts</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>emu</name></expr></argument>, <argument><expr><name>saved_gp</name></expr></argument>, <argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>r_agraph_add_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>shortcuts</name> <operator>=</operator> <ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>is_interactive</name></name></expr> ?</condition><then> <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.nodejmps"</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shortcuts</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>shortcut</name> <operator>=</operator> <call><name>r_core_add_asmqjmp</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>shortcut</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.shortcut"</literal></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>shortcut</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>shortcut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>

<goto>goto <name>cleanup</name>;</goto>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>fcn-&gt;bbs</argument>, <argument>iter</argument>, <argument>bb</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name> <operator>==</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>few</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isbbfew</name> <argument_list>(<argument><expr><name>curbb</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>u</name> <init>= <expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>title</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>jump</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>title</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>bb</name><operator>-&gt;</operator><name>fail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>bb</name><operator>-&gt;</operator><name>switch_op</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalCaseOp</name> <modifier>*</modifier></type><name>cop</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>bb-&gt;switch_op-&gt;cases</argument>, <argument>it</argument>, <argument>cop</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>title</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>cop</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>delete_dup_edges</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<label><name>cleanup</name>:</label>

<if_stmt><if>if <condition>(<expr><name>emu</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>gp</name></name> <operator>=</operator> <name>saved_gp</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>saved_arena</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_reg_arena_poke</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>R_FREE</name> <argument_list>(<argument><expr><name>saved_arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name><operator>-&gt;</operator><name>stackptr</name></name> <operator>=</operator> <name>saved_stackptr</name></expr>;</expr_stmt>

<return>return <expr><name>ret</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>get_cgnodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>node</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>fcn_anode</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalRef</name> <modifier>*</modifier></type><name>ref</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>refs</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>f</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>fcn_anode</name> <operator>=</operator> <call><name>r_agraph_add_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn_anode</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>fcn_anode</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>fcn_anode</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>refs</name> <operator>=</operator> <call><name>r_anal_function_get_refs</name> <argument_list>(<argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>refs</argument>, <argument>iter</argument>, <argument>ref</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>title</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_bb_from_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>size</name> <operator>=</operator> <name><name>bb</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>body</name> <init>= <expr><call><name>get_body</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mode2opts</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>title</name> <operator>=</operator> <call><name>get_title</name> <argument_list>(<argument><expr><name><name>ref</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>r_agraph_add_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>node</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_add_edge</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>fcn_anode</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>refs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>reload_nodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>is_c</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr></init></decl>;</decl_stmt>

<return>return <expr><ternary><condition><expr><name>is_c</name></expr>?</condition><then> <expr><call><name>get_cgnodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>get_bbnodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_seek</name><parameter_list>(<parameter><decl><type><name>RConsCanvas</name> <modifier>*</modifier></type><name>can</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>w</name></decl>, <decl><type ref="prev"/><name>h</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>doscroll</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>x</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>can</name><operator>-&gt;</operator><name>sy</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <name><name>can</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <name><name>can</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>doscroll</name> <operator>=</operator> <name>force</name> <operator>||</operator> <name><name>y</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>y</name> <operator>+</operator> <literal type="number">5</literal></expr></argument> &gt;</argument_list></name> <name>h</name> <operator>||</operator> <name>x</name> <operator>+</operator> <literal type="number">5</literal> <operator>&gt;</operator> <name>w</name> <operator>||</operator> <name>x</name> <operator>+</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>+</operator> <literal type="number">5</literal> <operator>&lt;</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>doscroll</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>&gt;</operator> <name>w</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>=</operator> <operator>-</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>=</operator> <operator>-</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal> <operator>+</operator> <name>w</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>&gt;</operator> <name>h</name></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <operator>-</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <operator>-</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name><name>n</name><operator>-&gt;</operator><name>h</name></name> <operator>/</operator> <literal type="number">8</literal> <operator>+</operator> <name>h</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_near</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_next</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_next</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name>y</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name>x</name><operator>)</operator> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name>y</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name>y</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name>x</name><operator>)</operator> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name>y</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>is_near_h</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>y</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_next</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>is_next</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>x</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name>y</name><operator>)</operator> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name>x</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>==</operator> <name>x</name> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name>y</name><operator>)</operator> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name>x</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>find_near_of</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>cur</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_next</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>resgn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>acur</name> <init>= <expr><ternary><condition><expr><name>cur</name></expr>?</condition><then> <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>default_v</name> <init>= <expr><ternary><condition><expr><name>is_next</name></expr>?</condition><then> <expr><name>INT_MIN</name></expr></then><else>: <expr><name>INT_MAX</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>start_y</name> <init>= <expr><ternary><condition><expr><name>acur</name></expr>?</condition><then> <expr><name><name>acur</name><operator>-&gt;</operator><name>y</name></name></expr></then><else>: <expr><name>default_v</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>start_x</name> <init>= <expr><ternary><condition><expr><name>acur</name></expr>?</condition><then> <expr><name><name>acur</name><operator>-&gt;</operator><name>x</name></name></expr></then><else>: <expr><name>default_v</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>bool</name></type> <name>isNear</name> <init>= <expr><ternary><condition><expr><name>true</name></expr>

?</condition><then> <expr><call><name>is_near</name> <argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>start_x</name></expr></argument>, <argument><expr><name>start_y</name></expr></argument>, <argument><expr><name>is_next</name></expr></argument>)</argument_list></call></expr>

</then><else>: <expr><call><name>is_near_h</name> <argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>start_x</name></expr></argument>, <argument><expr><name>start_y</name></expr></argument>, <argument><expr><name>is_next</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>isNear</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RANode</name> <modifier>*</modifier></type><name>resn</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resgn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resgn</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>resn</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>resgn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>is_next</name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>is_next</name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resgn</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><operator>(</operator><name>is_next</name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator> <operator>||</operator>

<operator>(</operator><operator>!</operator><name>is_next</name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>resn</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name><name>n</name><operator>-&gt;</operator><name>x</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resgn</name> <operator>=</operator> <name>gn</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resgn</name> <operator>&amp;&amp;</operator> <name>cur</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>resgn</name> <operator>=</operator> <call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>is_next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>resgn</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>update_graph_sizes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gk</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>ak</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>min_gn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>max_gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>max_x</name></decl>, <decl><type ref="prev"/><name>max_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>delta_x</name></decl>, <decl><type ref="prev"/><name>delta_y</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>AEdge</name> <modifier>*</modifier></type><name>e</name></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_x</name> <operator>=</operator> <name>max_y</name> <operator>=</operator> <name>INT_MIN</name></expr>;</expr_stmt>

<expr_stmt><expr><name>min_gn</name> <operator>=</operator> <name>max_gn</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>r_graph_get_nodes (g-&gt;graph)</argument>, <argument>it</argument>, <argument>gk</argument>, <argument>ak</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>ak</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nd</name> <operator>=</operator> <call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>gk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>nd</name></expr> ?</condition><then> <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name>len</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>ak</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>min_gn</name> <operator>=</operator> <name>ak</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>ak</name><operator>-&gt;</operator><name>w</name></name> <operator>&gt;</operator> <name>max_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_x</name> <operator>=</operator> <name><name>ak</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>ak</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>nd</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name>nd</name> <operator>=</operator> <call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>gk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <ternary><condition><expr><name>nd</name></expr> ?</condition><then> <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>nd</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>ak</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>ak</name><operator>-&gt;</operator><name>h</name></name> <operator>+</operator> <name>len</name> <operator>&gt;</operator> <name>max_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_y</name> <operator>=</operator> <name><name>ak</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>ak</name><operator>-&gt;</operator><name>h</name></name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

<expr_stmt><expr><name>max_gn</name> <operator>=</operator> <name>ak</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>g-&gt;edges</argument>, <argument>it</argument>, <argument>e</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>kt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>vv</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>v</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>e-&gt;x</argument>, <argument>kt</argument>, <argument>vv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>vv</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>max_x</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_x</name> <operator>=</operator> <name>v</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>e-&gt;y</argument>, <argument>kt</argument>, <argument>vv</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>v</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>vv</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&lt;</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <name>max_y</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_y</name> <operator>=</operator> <name>v</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>min_gn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>min_gn</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>neigh</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>y</name></name><operator>--</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>max_y</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>max_gn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>min_gn</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>neigh</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>max_y</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>!=</operator> <name>INT_MAX</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>!=</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>max_x</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>INT_MAX</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <name>len</name> <operator>&gt;</operator> <name><name>g</name><operator>-&gt;</operator><name>w</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <name>max_y</name> <operator>-</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.w"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.h"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>delta_x</name> <operator>=</operator> <ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>x</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>delta_y</name> <operator>=</operator> <ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>y</name></name></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.delta_x"</literal></expr></argument>, <argument><expr><name>delta_x</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.delta_y"</literal></expr></argument>, <argument><expr><name>delta_y</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_set_curnode</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.curnode"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>on_curnode_change</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name><name>g</name><operator>-&gt;</operator><name>on_curnode_change</name></name> <argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>on_curnode_change_data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ut64</name></type> <name>rebase</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>?</condition><then> <expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>v</name></expr></then><else>: <expr><name>v</name></expr></else></ternary></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_set_layout</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>set_layout</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>update_graph_sizes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>r_graph_get_nodes (g-&gt;graph)</argument>, <argument>it</argument>, <argument>n</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name></decl>;</decl_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.x"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>rebase</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.y"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><call><name>rebase</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.w"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>k</name> <operator>=</operator> <call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.h"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_update_seek</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>force</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>force</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>cur</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name> <operator>&amp;&amp;</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>n</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>bool</name></type> <name>isMini</name> <init>= <expr><call><name>is_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>tiny_RANode_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>isMini</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>mini_RANode_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>isMini</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>normal_RANode_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>gn</name> <operator>!=</operator> <name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_print_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_print_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<struct>struct <name>tmplayer</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>layer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>edgectr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>revedgectr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>maxx</name></decl>;</decl_stmt>

}</block>;</struct>

<struct>struct <name>tmpbackedgeinfo</name> <block>{

<decl_stmt><decl><type><name>int</name></type> <name>ax</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ay</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>bx</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>by</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>edgectr</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>fromlayer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>tolayer</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCanvasLineStyle</name></type> <name>style</name></decl>;</decl_stmt>

}</block>;</struct>

<function><type><name>int</name></type> <name>tmplayercmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><operator>(</operator><operator>(</operator>struct <name>tmplayer</name> <operator>*</operator><operator>)</operator><name>a</name><operator>)</operator><operator>-&gt;</operator><name>layer</name> <operator>&gt;</operator> <operator>(</operator><operator>(</operator>struct <name>tmplayer</name> <operator>*</operator><operator>)</operator><name>b</name><operator>)</operator><operator>-&gt;</operator><name>layer</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_edges_simple</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RCanvasLineStyle</name></type> <name>style</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>gn2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>iter</argument>, <argument>gn</argument>, <argument>n</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>outnodes</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>outnodes</argument>, <argument>iter2</argument>, <argument>gn2</argument>, <argument>n2</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>sx</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sy</name> <init>= <expr><name><name>n</name><operator>-&gt;</operator><name>h</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>sx2</name> <init>= <expr><name><name>n2</name><operator>-&gt;</operator><name>w</name></name> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>sx</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>sx2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_line</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>,

<argument><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>sx</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name>sy</name></expr></argument>,

<argument><expr><name><name>n2</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>sx2</name></expr></argument>, <argument><expr><name><name>n2</name><operator>-&gt;</operator><name>y</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>n2</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_line</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>,

<argument><expr><name><name>n2</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>sx2</name></expr></argument>, <argument><expr><name><name>n2</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>,

<argument><expr><name><name>n2</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>sx2</name></expr></argument>, <argument><expr><name><name>n2</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>n2</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>first_x_cmp</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>_b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>ga</name> <init>= <expr><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><name>_a</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gb</name> <init>= <expr><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><name>_b</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><operator>(</operator><name>RANode</name><operator>*</operator><operator>)</operator> <name><name>ga</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name> <init>= <expr><operator>(</operator><name>RANode</name><operator>*</operator><operator>)</operator> <name><name>gb</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>&lt;</operator> <name><name>b</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_print_edges</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_print_edges_simple</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>out_nth</name></decl>, <decl><type ref="prev"/><name>in_nth</name></decl>, <decl><type ref="prev"/><name>bendpoint</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>itn</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>itm</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>ito</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RCanvasLineStyle</name></type> <name>style</name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>ga</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>lyr</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>bckedges</name> <init>= <expr><call><name>r_list_new</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tmplayer</name></name> <modifier>*</modifier></type><name>tl</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>nodes</argument>, <argument>itm</argument>, <argument>ga</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gb</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>neighbours</name> <init>= <expr><operator>(</operator><name>RList</name> <operator>*</operator><operator>)</operator><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>ga</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ax</name></decl>, <decl><type ref="prev"/><name>ay</name></decl>, <decl><type ref="prev"/><name>bx</name></decl>, <decl><type ref="prev"/><name>by</name></decl>, <decl><type ref="prev"/><name>a_x_inc</name></decl>, <decl><type ref="prev"/><name>b_x_inc</name></decl>;</decl_stmt>

<expr_stmt><expr><name>tl</name> <operator>=</operator> <name>tm</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>lyr</argument>, <argument>ito</argument>, <argument>tl</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tl</name><operator>-&gt;</operator><name>layer</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tm</name> <operator>=</operator> <name>tl</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>&gt;</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>tmplayer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>tm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>layer</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>revedgectr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>minx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>maxx</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_list_add_sorted</name> <argument_list>(<argument><expr><name>lyr</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>tmplayercmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>many</name> <init>= <expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>neighbours</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>many</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>ga</name><operator>-&gt;</operator><name>out_nodes</name><operator>-&gt;</operator><name>sorted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_sort</name> <argument_list>(<argument><expr><name>neighbours</name></expr></argument>, <argument><expr><name>first_x_cmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neighbours</argument>, <argument>itn</argument>, <argument>gb</argument>, <argument>b</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><name>out_nth</name> <operator>=</operator> <call><name>get_edge_number</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>in_nth</name> <operator>=</operator> <call><name>get_edge_number</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>parent_many</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>in</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><call><name>r_list_first</name> <argument_list>(<argument><expr><name><name>ga</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>data</name><operator>)</operator></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>in</name> <operator>&amp;&amp;</operator> <name><name>in</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>in</name> <operator>=</operator> <operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>RGraphNode</name> <operator>*</operator><operator>)</operator><call><name>r_list_first</name> <argument_list>(<argument><expr><operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>gnode</name></name><operator>)</operator><operator>-&gt;</operator><name>in_nodes</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>in</name> <operator>&amp;&amp;</operator> <name><name>in</name><operator>-&gt;</operator><name>gnode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>parent_many</name> <operator>=</operator> <call><name>r_list_length</name> <argument_list>(<argument><expr><name><name>in</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>parent_many</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>dot_style</name></name> <operator>=</operator> <name>DOT_STYLE_NORMAL</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>many</name> <operator>||</operator> <name>parent_many</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>LINE_UNCJMP</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<switch>switch <condition>(<expr><name>out_nth</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>LINE_TRUE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>dot_style</name></name> <operator>=</operator> <name>DOT_STYLE_CONDITIONAL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>LINE_FALSE</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>dot_style</name></name> <operator>=</operator> <name>DOT_STYLE_CONDITIONAL</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>LINE_UNCJMP</name></expr>;</expr_stmt>

<break>break;</break>

<default>default:</default>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>color</name></name> <operator>=</operator> <name>LINE_NONE</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></else></if_stmt>

<switch>switch <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<default>default:</default>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>hints</name></name> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LINE_NOSYM_VERT</name></expr> </then><else>: <expr><name><name>style</name><operator>.</operator><name>color</name></name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>y</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>dot_style</name></name> <operator>=</operator> <name>DOT_STYLE_BACKEDGE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>a_x_inc</name> <operator>=</operator> <name>R_EDGES_X_INC</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>out_nth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>b_x_inc</name> <operator>=</operator> <name>R_EDGES_X_INC</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name>in_nth</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>bx</name> <operator>=</operator> <ternary><condition><expr><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name></expr> ?</condition><then> <expr><name><name>b</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>b_x_inc</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ay</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>by</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>many</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>t</name> <init>= <expr><name>R_EDGES_X_INC</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> <operator>(</operator><name><name>neighbours</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>ax</name> <operator>=</operator> <ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name><operator>/</operator><literal type="number">2</literal> <operator>+</operator> <operator>(</operator><name>t</name><operator>/</operator><literal type="number">2</literal> <operator>-</operator> <name>a_x_inc</name><operator>)</operator><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>bendpoint</name> <operator>=</operator> <ternary><condition><expr><name>bx</name> <operator>&lt;</operator> <name>ax</name></expr> ?</condition><then> <expr><name><name>neighbours</name><operator>-&gt;</operator><name>length</name></name> <operator>-</operator> <name>out_nth</name></expr> </then><else>: <expr><name>out_nth</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>=</operator> <ternary><condition><expr><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr> ?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr> </then><else>: <expr><operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name>a_x_inc</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>bendpoint</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name>itn</name> <operator>==</operator> <name><name>neighbours</name><operator>-&gt;</operator><name>head</name></name> <operator>&amp;&amp;</operator> <name>out_nth</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>bx</name> <operator>&gt;</operator> <name>ax</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>+=</operator> <ternary><condition><expr><operator>(</operator><name>many</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>h</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_height</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_line</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_height</name></name> <operator>-</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ay</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_height</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <name>LINE_NOSYM_VERT</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>by</name> <operator>&gt;=</operator> <name>ay</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_line_square_defined</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>by</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>, <argument><expr><name>bendpoint</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>tmpbackedgeinfo</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>tmpbackedgeinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>ax</name></name> <operator>=</operator> <name>ax</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>bx</name></name> <operator>=</operator> <name>bx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>ay</name></name> <operator>=</operator> <name>ay</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>by</name></name> <operator>=</operator> <name>by</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>edgectr</name></name> <operator>=</operator> <name>bendpoint</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>fromlayer</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tolayer</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>style</name></name> <operator>=</operator> <name>style</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>bckedges</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <name>LINE_NOSYM_VERT</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_line</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>by</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>h</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>x</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>tm</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>hints</name></name> <operator>||</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr> ?</condition><then> <expr><name>LINE_NOSYM_HORIZ</name></expr> </then><else>: <expr><name><name>style</name><operator>.</operator><name>color</name></name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name> <operator>&gt;</operator> <name><name>b</name><operator>-&gt;</operator><name>x</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>dot_style</name></name> <operator>=</operator> <name>DOT_STYLE_BACKEDGE</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>ax</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>+=</operator> <name><name>a</name><operator>-&gt;</operator><name>w</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>ay</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ay</name> <operator>+=</operator> <name>R_EDGES_X_INC</name> <operator>+</operator> <name>out_nth</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>bx</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>x</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>by</name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>y</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>by</name> <operator>+=</operator> <name>R_EDGES_X_INC</name> <operator>+</operator> <name>out_nth</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>w</name></name> <operator>&lt;</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_width</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_line_square_defined</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>x</name></name> <operator>+</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_width</name></name></expr></argument>, <argument><expr><name>ay</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ax</name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>+=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer_width</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>ax</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <name>LINE_NOSYM_HORIZ</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>bx</name> <operator>&gt;=</operator> <name>ax</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_line_square_defined</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>ax</name></expr></argument>, <argument><expr><name>ay</name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>by</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>tmpbackedgeinfo</name></name> <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>calloc</name> <argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>struct <name>tmpbackedgeinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>tmp</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>ax</name></name> <operator>=</operator> <name>ax</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>bx</name></name> <operator>=</operator> <name>bx</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>ay</name></name> <operator>=</operator> <name>ay</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>by</name></name> <operator>=</operator> <name>by</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>edgectr</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>fromlayer</name></name> <operator>=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>tolayer</name></name> <operator>=</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>style</name></name> <operator>=</operator> <name>style</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>bckedges</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>style</name><operator>.</operator><name>symbol</name></name> <operator>=</operator> <name>LINE_NOSYM_HORIZ</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_line_square_defined</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>bx</name></expr></argument>, <argument><expr><name>by</name></expr></argument>, <argument><expr><name>bx</name> <operator>+</operator> <name><name>b</name><operator>-&gt;</operator><name>layer_width</name></name></expr></argument>, <argument><expr><name>by</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>style</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>==</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>h</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>h</name></name><operator>)</operator> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>y</name></name> <operator>!=</operator> <name><name>a</name><operator>-&gt;</operator><name>y</name></name> <operator>||</operator> <name><name>b</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>a</name><operator>-&gt;</operator><name>layer</name></name> <operator>||</operator> <operator>(</operator><operator>!</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator> <operator>||</operator> <operator>(</operator><name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>b</name><operator>-&gt;</operator><name>is_dummy</name></name><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>edgectr</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block>

</block_content>}</block>

<decl_stmt><decl><type><name><name>struct</name> <name>tmpbackedgeinfo</name></name> <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>bckedges</argument>, <argument>itm</argument>, <argument>temp</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>leftlen</name></decl>, <decl><type ref="prev"/><name>rightlen</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>minx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>maxx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>tmplayer</name></name> <modifier>*</modifier></type><name>tt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>tl</name> <operator>=</operator> <call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>lyr</name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>fromlayer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>lyr</argument>, <argument>ito</argument>, <argument>tl</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tl</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;=</operator> <name><name>temp</name><operator>-&gt;</operator><name>tolayer</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>tt</name> <operator>=</operator> <name>tl</name></expr>;</expr_stmt>

<expr_stmt><expr><name>minx</name> <operator>=</operator> <name><name>tl</name><operator>-&gt;</operator><name>minx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name>maxx</name> <operator>=</operator> <name><name>tl</name><operator>-&gt;</operator><name>maxx</name></name></expr>;</expr_stmt>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>minx</name> <operator>=</operator> <ternary><condition><expr><name>minx</name> <operator>&lt;</operator> <name><name>tl</name><operator>-&gt;</operator><name>minx</name></name></expr> ?</condition><then> <expr><name>minx</name></expr> </then><else>: <expr><name><name>tl</name><operator>-&gt;</operator><name>minx</name></name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>maxx</name> <operator>=</operator> <ternary><condition><expr><name>maxx</name> <operator>&gt;</operator> <name><name>tl</name><operator>-&gt;</operator><name>maxx</name></name></expr> ?</condition><then> <expr><name>maxx</name></expr> </then><else>: <expr><name><name>tl</name><operator>-&gt;</operator><name>maxx</name></name></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tl</name><operator>-&gt;</operator><name>layer</name></name> <operator>&gt;=</operator> <name><name>temp</name><operator>-&gt;</operator><name>fromlayer</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<if_stmt><if>if <condition>(<expr><name>tt</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tt</name><operator>-&gt;</operator><name>revedgectr</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>leftlen</name> <operator>=</operator> <operator>(</operator><name><name>temp</name><operator>-&gt;</operator><name>ax</name></name> <operator>-</operator> <name>minx</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>temp</name><operator>-&gt;</operator><name>bx</name></name> <operator>-</operator> <name>minx</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>rightlen</name> <operator>=</operator> <operator>(</operator><name>maxx</name> <operator>-</operator> <name><name>temp</name><operator>-&gt;</operator><name>ax</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>maxx</name> <operator>-</operator> <name><name>temp</name><operator>-&gt;</operator><name>bx</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>leftlen</name> <operator>=</operator> <operator>(</operator><name><name>temp</name><operator>-&gt;</operator><name>ay</name></name> <operator>-</operator> <name>minx</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>temp</name><operator>-&gt;</operator><name>by</name></name> <operator>-</operator> <name>minx</name><operator>)</operator></expr>;</expr_stmt>

<expr_stmt><expr><name>rightlen</name> <operator>=</operator> <operator>(</operator><name>maxx</name> <operator>-</operator> <name><name>temp</name><operator>-&gt;</operator><name>ay</name></name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>maxx</name> <operator>-</operator> <name><name>temp</name><operator>-&gt;</operator><name>by</name></name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>tt</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>arg</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>rightlen</name> <operator>&lt;</operator> <name>leftlen</name><operator>)</operator></expr>?</condition><then> <expr><name>maxx</name> <operator>+</operator> <literal type="number">1</literal></expr></then><else>: <expr><name>minx</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_line_back_edge</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>ax</name></name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>ay</name></name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>bx</name></name></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>by</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>temp</name><operator>-&gt;</operator><name>style</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>temp</name><operator>-&gt;</operator><name>edgectr</name></name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name><name>tt</name><operator>-&gt;</operator><name>revedgectr</name></name></expr></argument>, <argument><expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>layout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>lyr</argument>, <argument>ito</argument>, <argument>tl</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>tl</name><operator>-&gt;</operator><name>layer</name></name> <operator>&lt;</operator> <name><name>temp</name><operator>-&gt;</operator><name>tolayer</name></name></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>rightlen</name> <operator>&lt;</operator> <name>leftlen</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>tl</name><operator>-&gt;</operator><name>maxx</name></name> <operator>=</operator> <name>maxx</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>tl</name><operator>-&gt;</operator><name>minx</name></name> <operator>=</operator> <name>minx</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>tl</name><operator>-&gt;</operator><name>layer</name></name> <operator>&gt;=</operator> <name><name>temp</name><operator>-&gt;</operator><name>fromlayer</name></name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>lyr</argument>, <argument>ito</argument>, <argument>tl</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<macro><name>r_list_foreach</name> <argument_list>(<argument>bckedges</argument>, <argument>ito</argument>, <argument>tl</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>tl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>lyr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>bckedges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_toggle_callgraph</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_set_zoom</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">10</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>v</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>R_AGRAPH_MODE_MINI</name></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>v</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>R_AGRAPH_MODE_TINY</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>R_AGRAPH_MODE_NORMAL</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>K</name> <init>= <expr><literal type="number">920</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>&lt;</operator> <name>v</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>*</operator> <name>K</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>

</block_content>}</block></if>

<else>else <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <operator>(</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator> <operator>/</operator> <name>K</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>=</operator> <name>v</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>agraph_reload_nodes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_reset</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><call><name>reload_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>follow_nth</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>cn</name> <init>= <expr><call><name>r_graph_nth_neighbour</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>cn</name> <operator>=</operator> <call><name>r_graph_nth_neighbour</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<if_stmt><if>if <condition>(<expr><name>a</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>move_current_node</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>xdiff</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ydiff</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_tiny</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>xdiff</name> <operator>=</operator> <call><name>NORMALIZE_MOV</name> <argument_list>(<argument><expr><name>xdiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ydiff</name> <operator>=</operator> <call><name>NORMALIZE_MOV</name> <argument_list>(<argument><expr><name>ydiff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>x</name></name> <operator>+=</operator> <name>xdiff</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>y</name></name> <operator>+=</operator> <name>ydiff</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>GRAPH_MERGE_FEATURE</name></expr></cpp:if>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>K_NEIGHBOURS</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(sdb_fmt ("agraph.nodes.%s.neighbours", x-&gt;title))</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_merge_child</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>idx</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>nn</name> <init>= <expr><call><name>r_graph_nth_neighbour</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>, <argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>cn</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cn</name> <operator>&amp;&amp;</operator> <name>nn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>ann</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>nn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>acn</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>cn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name><name>ann</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><literal type="string">"\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <call><name>r_str_append</name> <argument_list>(<argument><expr><name><name>acn</name><operator>-&gt;</operator><name>body</name></name></expr></argument>, <argument><expr><name><name>ann</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>acn</name><operator>-&gt;</operator><name>h</name></name> <operator>+=</operator> <name><name>ann</name><operator>-&gt;</operator><name>h</name></name> <operator>-</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>ann</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>neis</name> <init>= <expr><call><name>sdb_get</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>K_NEIGHBOURS</name> <argument_list>(<argument><expr><name>ann</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>neis</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_set_owned</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>K_NEIGHBOURS</name> <argument_list>(<argument><expr><name>ann</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>neis</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_del_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>ann</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_print_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_print_edges</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_toggle_tiny</name> <parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_refresh</name> <argument_list>(<argument><expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>event_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_set_layout</name> <argument_list>(<argument><expr><operator>(</operator><name>RAGraph</name> <operator>*</operator><operator>)</operator> <name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_toggle_mini</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name> <operator>=</operator> <operator>!</operator><name><name>n</name><operator>-&gt;</operator><name>is_mini</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_refresh</name> <argument_list>(<argument><expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>event_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_set_layout</name> <argument_list>(<argument><expr><operator>(</operator><name>RAGraph</name> <operator>*</operator><operator>)</operator> <name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_follow_innodes</name> <parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>in</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>an</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><name><name>an</name><operator>-&gt;</operator><name>gnode</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>list</name> <init>= <expr><ternary><condition><expr><name>in</name></expr>?</condition><then> <expr><name><name>an</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></then><else>: <expr><name><name>an</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>nth</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_gotoxy</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><ternary><condition><expr><name>in</name></expr>?</condition><then> <expr><literal type="string">"Input nodes:\n"</literal></expr></then><else>: <expr><literal type="string">"Output nodes:\n"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>options</name> <init>= <expr><call><name>r_list_newf</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>gnodes</name> <init>= <expr><ternary><condition><expr><name>in</name></expr>?</condition><then> <expr><name><name>an</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>in_nodes</name></name></expr></then><else>: <expr><name><name>an</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>gnodes</argument>, <argument>iter</argument>, <argument>gn</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>an</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gnn</name> <init>= <expr><call><name>agraph_get_title</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>an</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>gnn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>nnn</name> <init>= <expr><name><name>gnn</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>o</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>iter2</name></decl>;</decl_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>options</argument>, <argument>iter2</argument>, <argument>o</argument>)</argument_list></macro> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>strcmp</name> <argument_list>(<argument><expr><name><name>o</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name><name>nnn</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<continue>continue;</continue>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%d %s\n"</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name><name>nnn</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_append</name> <argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>nnn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_list_length</name> <argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">10</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name>r_cons_readchar</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <name>ch</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_show_cursor</name> <argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_enable_mouse</name> <argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>nth_string</name> <init>= <expr><call><name>r_cons_input</name> <argument_list>(<argument><expr><literal type="string">"index&gt; "</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <call><name>atoi</name> <argument_list>(<argument><expr><name>nth_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>nth_string</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>nth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>nth_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><name>nth</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>selected_node</name> <init>= <expr><call><name>r_list_get_n</name> <argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>selected_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name>options</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_follow_true</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>follow_nth</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_follow_false</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>follow_nth</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_next_node</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_prev_node</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<while>while <condition>(<expr><name>a</name> <operator>&amp;&amp;</operator> <name><name>a</name><operator>-&gt;</operator><name>is_dummy</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_update_title</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>sig</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"afcf"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_title</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(

<argument><expr><literal type="string">"%s[0x%08"</literal><name>PFMT64x</name> <literal type="string">"]&gt; %s #%s "</literal></expr></argument>,

<argument><expr><ternary><condition><expr><name>graphCursor</name></expr>?</condition><then> <expr><literal type="string">"(cursor)"</literal></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,

<argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>a</name></expr>?</condition><then> <expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>, <argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_agraph_set_title</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>new_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>new_title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>sig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>check_changes</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_interactive</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name><name>oldpos</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{

<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>

}</block></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>&amp;&amp;</operator> <name>core</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>oldpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>oldpos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>agraph_reload_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_update_title</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>core</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.trace"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>fold_asm_trace</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>||</operator> <operator>!</operator><name>is_interactive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>update_node_dimension</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><call><name>is_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>||</operator> <operator>!</operator><name>is_interactive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_set_layout</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>core</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_anal_get_bbaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>off</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>cur_anode</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>is_interactive</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>cur_anode</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>cur_anode</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>cur_anode</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hints</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.hints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>||</operator> <name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>update_seek</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>oldpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>||</operator> <name><name>oldpos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>=</operator> <name><name>oldpos</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <name><name>oldpos</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>agraph_print</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_interactive</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>w</name> <init>= <expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>ret</name> <init>= <expr><call><name>check_changes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>is_interactive</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_interactive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_clear00</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>update_graph_sizes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <ternary><condition><expr><name>is_interactive</name></expr>?</condition><then> <expr><name>h</name></expr></then><else>: <expr><name><name>g</name><operator>-&gt;</operator><name>h</name></name> <operator>+</operator> <literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>w</name> <operator>=</operator> <ternary><condition><expr><name>is_interactive</name></expr>?</condition><then> <expr><name>w</name></expr></then><else>: <expr><name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>+</operator> <literal type="number">2</literal></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_canvas_resize</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>is_interactive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>=</operator> <operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>x</name></name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>=</operator> <operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>G</name> <argument_list>(<argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>scr_utf8</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asm_bytes</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>asm_cmt_right</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>r_core_cmd_str</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pd $r"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>str</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.utf8"</literal></expr></argument>, <argument><expr><name>scr_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.bytes"</literal></expr></argument>, <argument><expr><name>asm_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><name>asm_cmt_right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>++</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>agraph_print_edges</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_print_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>--</operator></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>G</name> <argument_list>(<argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>W</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>is_interactive</name> <operator>&amp;&amp;</operator> <name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>title_len</name> <init>= <expr><call><name>strlen</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_fill</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>+</operator> <name>title_len</name></expr></argument>, <argument><expr><operator>-</operator><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>sy</name></name></expr></argument>,

<argument><expr><name>w</name> <operator>-</operator> <name>title_len</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_print_region</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>is_interactive</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmdv</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>mustFlush</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_visual_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmdv</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmdv</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_gotoxy</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_strcat</name> <argument_list>(<argument><expr><name>Color_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmdv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>mustFlush</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>core</name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>scr_gadgets</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"pg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>mustFlush</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>agraph_refresh</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>agraph_refresh_data</name></name> <modifier>*</modifier></type><name>grd</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>grd</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call><operator>-&gt;</operator><name>event_data</name> <operator>=</operator> <name>grd</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name><name>grd</name><operator>-&gt;</operator><name>core</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>grd</name><operator>-&gt;</operator><name>g</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier><modifier>*</modifier></type><name>fcn</name> <init>= <expr><name><name>grd</name><operator>-&gt;</operator><name>fcn</name></name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<return>return <expr><call><name>agraph_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>grd</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_instep</name></name> <operator>&amp;&amp;</operator> <name><name>core</name><operator>-&gt;</operator><name>io</name><operator>-&gt;</operator><name>debug</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pc</name> <init>= <expr><call><name>r_reg_get_name</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>R_REG_NAME_PC</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RRegItem</name> <modifier>*</modifier></type><name>r</name> <init>= <expr><call><name>r_reg_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>pc</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_reg_get_value</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>dbg</name><operator>-&gt;</operator><name>reg</name></name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>acur</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>addr</name> <operator>=</operator> <call><name>r_anal_get_bbaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>acur</name> <operator>||</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name><name>acur</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"sr PC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_instep</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name><name>grd</name><operator>-&gt;</operator><name>follow_offset</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_io_is_valid_offset</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>r_cons_yesno</name> <argument_list>(<argument><expr><literal type="char">'y'</literal></expr></argument>, <argument><expr><literal type="string">"\rNo function at 0x%08"</literal><name>PFMT64x</name><literal type="string">". Define it here (Y/n)? "</literal></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"af"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&amp;&amp;</operator> <name>fcn</name> <operator>&amp;&amp;</operator> <name>f</name> <operator>!=</operator> <operator>*</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>*</operator><name>fcn</name> <operator>=</operator> <name>f</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_message</name> <argument_list>(<argument><expr><literal type="string">"This is not a valid offset\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>agraph_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>grd</name><operator>-&gt;</operator><name>fs</name></name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><operator>*</operator><name>fcn</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.scrollbar"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_print_scrollbar</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_refresh_oneshot</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>agraph_refresh_data</name></name> <modifier>*</modifier></type><name>grd</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_task_enqueue_oneshot</name> <argument_list>(<argument><expr><operator>&amp;</operator><name><name>grd</name><operator>-&gt;</operator><name>core</name><operator>-&gt;</operator><name>tasks</name></name></expr></argument>, <argument><expr><operator>(</operator><name>RCoreTaskOneShot</name><operator>)</operator> <name>agraph_refresh</name></expr></argument>, <argument><expr><name>grd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_toggle_speed</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>alt</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.scroll"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>movspeed</name></name> <operator>=</operator> <ternary><condition><expr><name><name>g</name><operator>-&gt;</operator><name>movspeed</name></name> <operator>==</operator> <name>DEFAULT_SPEED</name></expr>?</condition><then> <expr><name>alt</name></expr></then><else>: <expr><name>DEFAULT_SPEED</name></expr></else></ternary></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_init</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_instep</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_titles</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_body</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name> <operator>=</operator> <call><name>r_graph_new</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>=</operator> <name>ZOOM_DEFAULT</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hints</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>movspeed</name></name> <operator>=</operator> <name>DEFAULT_SPEED</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>free_anode</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>graphNodeMove</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dir</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>speed</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dir</name> <operator>==</operator> <literal type="char">'k'</literal><operator>)</operator></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <literal type="char">'H'</literal></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><name>dir</name> <operator>==</operator> <literal type="char">'h'</literal> <operator>||</operator> <name>dir</name> <operator>==</operator> <literal type="char">'l'</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>delta</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>dir</name> <operator>==</operator> <literal type="char">'l'</literal><operator>)</operator></expr>?</condition><then> <expr><literal type="number">1</literal></expr></then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>move_current_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>speed</name> <operator>*</operator> <name>delta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><call><name>is_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>discroll</name> <operator>+=</operator> <operator>(</operator><name>delta</name> <operator>*</operator> <name>speed</name><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>delta</name> <operator>*</operator> <literal type="number">4</literal><operator>)</operator> <operator>*</operator> <name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>move_current_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>delta</name> <operator>*</operator> <name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_free_nodes</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>r_graph_get_nodes (g-&gt;graph)</argument>, <argument>it</argument>, <argument>n</argument>, <argument>a</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>free_anode</name> <argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>sdb_set_enc</name><parameter_list>(<parameter><decl><type><name>Sdb</name> <modifier>*</modifier></type><name>db</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>, <parameter><decl><type><name>ut32</name></type> <name>cas</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>estr</name> <init>= <expr><call><name>sdb_encode</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>v</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>estr</name></expr></argument>, <argument><expr><name>cas</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>agraph_sdb_init</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>sdb_bool_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.is_callgraph"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RCons</name> <modifier>*</modifier></type><name>cons</name> <init>= <expr><call><name>r_cons_singleton</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_set_enc</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.color_box"</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_box</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_enc</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.color_box2"</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_box2</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_enc</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.color_box3"</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_box3</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_enc</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.color_true"</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_true</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_enc</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.color_false"</literal></expr></argument>, <argument><expr><name><name>cons</name><operator>-&gt;</operator><name>context</name><operator>-&gt;</operator><name>pal</name><operator>.</operator><name>graph_false</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>Sdb</name> <modifier>*</modifier></type><name>r_agraph_get_sdb</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>check_changes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_print</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_print</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>n_nodes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_print_json</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>PJ</name> <modifier>*</modifier></type><name>pj</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RList</name> <modifier>*</modifier></type><name>nodes</name> <init>= <expr><name><name>g</name><operator>-&gt;</operator><name>graph</name><operator>-&gt;</operator><name>nodes</name></name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>neighbours</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>itt</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>neighbour</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>pj</name></expr>)</condition> <block>{<block_content>

<return>return;</return>

</block_content>}</block></if></if_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>nodes</argument>, <argument>it</argument>, <argument>node</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>anode</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <name><name>node</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>label</name> <init>= <expr><call><name>strdup</name> <argument_list>(<argument><expr><name><name>anode</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>pj_o</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ki</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"id"</literal></expr></argument>, <argument><expr><name><name>anode</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"title"</literal></expr></argument>, <argument><expr><name><name>anode</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_ks</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"body"</literal></expr></argument>, <argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_k</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><literal type="string">"out_nodes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_a</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>neighbours</name> <operator>=</operator> <name><name>anode</name><operator>-&gt;</operator><name>gnode</name><operator>-&gt;</operator><name>out_nodes</name></name></expr>;</expr_stmt>

<macro><name>r_list_foreach</name> <argument_list>(<argument>neighbours</argument>, <argument>itt</argument>, <argument>neighbour</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>pj_i</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>, <argument><expr><name><name>neighbour</name><operator>-&gt;</operator><name>idx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>pj_end</name> <argument_list>(<argument><expr><name>pj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_set_title</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <ternary><condition><expr><name>title</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.title"</literal></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RANode</name> <modifier>*</modifier></type><name>r_agraph_add_node_with_color</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>body</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>color</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RANode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name> <operator>=</operator> <ternary><condition><expr><name>title</name></expr>?</condition><then> <expr><call><name>r_str_trunc_ellipsis</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>body</name></name> <operator>=</operator> <ternary><condition><expr><name>body</name></expr>?</condition><then> <expr><call><name>strdup</name> <argument_list>(<argument><expr><name>body</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><call><name>strdup</name> <argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>layer</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>pos_in_layer</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>is_dummy</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>is_reversed</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>klass</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>difftype</name></name> <operator>=</operator> <name>color</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>gnode</name></name> <operator>=</operator> <call><name>r_graph_add_node</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_num_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><operator>(</operator><name>ut64</name><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>res</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>estr</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>b</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.nodes"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name><name>res</name><operator>-&gt;</operator><name>body</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>b</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>b</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>estr</name> <operator>=</operator> <call><name>sdb_encode</name> <argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>void</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"base64:%s"</literal></expr></argument>, <argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>estr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set_owned</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.body"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>res</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RANode</name> <modifier>*</modifier></type><name>r_agraph_add_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>body</name></decl></parameter>)</parameter_list> <block>{<block_content>

<return>return <expr><call><name>r_agraph_add_node_with_color</name><argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>body</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>bool</name></type> <name>r_agraph_del_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title_trunc</name> <init>= <expr><call><name>r_str_trunc_ellipsis</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>an</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>res</name> <init>= <expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title_trunc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title_trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>res</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_array_remove</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><literal type="string">"agraph.nodes"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.body"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.x"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.y"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.w"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.h"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_set</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.neighbours"</literal></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>innodes</name> <init>= <expr><call><name>r_graph_innodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>innodes</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.neighbours"</literal></expr></argument>, <argument><expr><name><name>an</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_remove</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>r_graph_del_node</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>res</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>res</name><operator>-&gt;</operator><name>gnode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free_anode</name> <argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>user_node_cb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>g_cb</name></name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>k</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RANodeCallback</name></type> <name>cb</name> <init>= <expr><name><name>user</name><operator>-&gt;</operator><name>node_cb</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name> <init>= <expr><name><name>user</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>sdb_atoi</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>user_edge_cb</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>g_cb</name></name> <modifier>*</modifier></type><name>user</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><name>k</name></type> <name>UNUSED</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>v</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAEdgeCallback</name></type> <name>cb</name> <init>= <expr><name><name>user</name><operator>-&gt;</operator><name>edge_cb</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><name><name>user</name><operator>-&gt;</operator><name>graph</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>user_data</name> <init>= <expr><name><name>user</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>an</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>n</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>sdb_atoi</name> <argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>n</name></expr>)</condition> <block>{<block_content>

<return>return <expr><literal type="number">0</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>neigh</name> <init>= <expr><call><name>r_graph_get_neighbours</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RListIter</name> <modifier>*</modifier></type><name>it</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name></decl>;</decl_stmt>

<macro><name>graph_foreach_anode</name> <argument_list>(<argument>neigh</argument>, <argument>it</argument>, <argument>gn</argument>, <argument>an</argument>)</argument_list></macro> <block>{<block_content>

<expr_stmt><expr><call><name>cb</name> <argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr><name>an</name></expr></argument>, <argument><expr><name>user_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<return>return <expr><literal type="number">1</literal></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_foreach</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANodeCallback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>g_cb</name></name></type> <name>u</name> <init>= <expr><block>{

<expr><operator>.</operator><name>node_cb</name> <operator>=</operator> <name>cb</name></expr>,

<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>user</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SdbForeachCallback</name><operator>)</operator> <name>user_node_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_foreach_edge</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RAEdgeCallback</name></type> <name>cb</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>user</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name><name>struct</name> <name>g_cb</name></name></type> <name>u</name> <init>= <expr><block>{

<expr><operator>.</operator><name>graph</name> <operator>=</operator> <name>g</name></expr>,

<expr><operator>.</operator><name>edge_cb</name> <operator>=</operator> <name>cb</name></expr>,

<expr><operator>.</operator><name>data</name> <operator>=</operator> <name>user</name></expr>

}</block></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_foreach</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><operator>(</operator><name>SdbForeachCallback</name><operator>)</operator> <name>user_edge_cb</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RANode</name> <modifier>*</modifier></type><name>r_agraph_get_first_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RList</name> <modifier>*</modifier></type><name>l</name> <init>= <expr><call><name>r_graph_get_nodes</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RGraphNode</name> <modifier>*</modifier></type><name>rgn</name> <init>= <expr><call><name>r_list_first</name> <argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<return>return <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name>rgn</name></expr></argument>)</argument_list></call></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RANode</name> <modifier>*</modifier></type><name>r_agraph_get_node</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>title</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title_trunc</name> <init>= <expr><ternary><condition><expr><name>title</name></expr> ?</condition><then> <expr><call><name>r_str_trunc_ellipsis</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><literal type="number">255</literal></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><operator>(</operator><name>RANode</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <call><name>sdb_num_get</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name></expr></argument>, <argument><expr><name>title_trunc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title_trunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>node</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_add_edge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>g</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_add_edge</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.neighbours"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_add</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_add_edge_at</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nth</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>g</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.neighbours"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_insert</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>nth</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_graph_add_edge_at</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name>nth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_del_edge</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_return_if_fail</name> <argument_list>(<argument><expr><name>g</name> <operator>&amp;&amp;</operator> <name>a</name> <operator>&amp;&amp;</operator> <name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name> <operator>&amp;&amp;</operator> <name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><call><name>sdb_fmt</name> <argument_list>(<argument><expr><literal type="string">"agraph.nodes.%s.neighbours"</literal></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>sdb_array_remove</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>title</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_graph_del_edge</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>, <argument><expr><name><name>a</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>, <argument><expr><name><name>b</name><operator>-&gt;</operator><name>gnode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_reset</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_free_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_reset</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_set_title</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_reset</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_list_purge</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>nodes</name></name> <operator>=</operator> <call><name>sdb_new0</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>w</name></name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>h</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_sdb_init</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>void</name></type> <name>r_agraph_free</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>g</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_free_nodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_graph_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>graph</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_list_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>edges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_set_title</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>sdb_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>db</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_free</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>RAGraph</name> <modifier>*</modifier></type><name>r_agraph_new</name><parameter_list>(<parameter><decl><type><name>RConsCanvas</name> <modifier>*</modifier></type><name>can</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name> <init>= <expr><call><name>R_NEW0</name> <argument_list>(<argument><expr><name>RAGraph</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>NULL</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name> <operator>=</operator> <name>can</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_init</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_sdb_init</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>g</name></expr>;</return>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>visual_offset</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rows</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_gotoxy</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name><operator>-&gt;</operator><name>prompt_type</name></name> <operator>=</operator> <name>R_LINE_PROMPT_OFFSET</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_line_set_hist_callback</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_offset_up</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_offset_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_line_set_prompt</name> <argument_list>(<argument><expr><literal type="string">"[offset]&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>strcpy</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"s "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_fgets</name> <argument_list>(<argument><expr><name>buf</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>buf</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_line_set_hist_callback</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_cmd_up</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>r_line_hist_cmd_down</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name><operator>-&gt;</operator><name>prompt_type</name></name> <operator>=</operator> <name>R_LINE_PROMPT_DEFAULT</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>goto_asmqjmps</name><parameter_list>(<parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>h</name> <init>= <expr><literal type="string">"[Fast goto call/jmp]&gt; "</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>obuf</name><index>[<expr><name>R_CORE_ASMQJMPS_LEN_LETTERS</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>rows</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>cont</name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_gotoxy</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_clear_line</name> <argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><name>Color_RESET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<do>do <block>{<block_content>

<decl_stmt><decl><type><name>char</name></type> <name>ch</name> <init>= <expr><call><name>r_cons_readchar</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>obuf</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>cont</name> <operator>=</operator> <call><name>isalpha</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>islower</name> <argument_list>(<argument><expr><operator>(</operator><name>ut8</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block> while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>R_CORE_ASMQJMPS_LEN_LETTERS</name> <operator>&amp;&amp;</operator> <name>cont</name></expr>)</condition>;</do>

<expr_stmt><expr><call><name>r_cons_flush</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>obuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_core_get_asmqjmps</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>obuf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr</name> <operator>!=</operator> <name>UT64_MAX</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>addr_node</name> <init>= <expr><call><name>r_agraph_get_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>addr_node</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_set_curnode</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>addr_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>addr_node</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_io_sundo_push</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>seek_to_node</name><parameter_list>(<parameter><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>, <parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_anal_get_bbaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>title</name> <init>= <expr><call><name>get_title</name> <argument_list>(<argument><expr><name>off</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>title</name> <operator>&amp;&amp;</operator> <call><name>strcmp</name> <argument_list>(<argument><expr><name>title</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_str_newf</name> <argument_list>(<argument><expr><literal type="string">"s %s"</literal></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>graph_single_step_in</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dcu 0x%08"</literal><name>PFMT64x</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name> <operator>+</operator> <name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ds"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aes"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_instep</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>graph_single_step_over</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>)</parameter_list> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cfg.debug"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dcr"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>print</name><operator>-&gt;</operator><name>cur_enabled</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dso"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".dr*"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"aeso"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">".ar*"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_instep</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>graph_breakpoint</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dbs $$"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>graph_continue</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dc"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>applyDisMode</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<switch>switch <condition>(<expr><name>disMode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.pseudo"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.esil"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.pseudo"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.esil"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.pseudo"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.esil"</literal></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>rotateColor</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>color</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>color</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>color</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>, <argument><expr><name>color</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>toggle_bb</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>ut64</name></type> <name>addr</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>addr</name></expr></argument>, <argument><expr><name>R_ANAL_FCN_TYPE_NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>RAnalBlock</name> <modifier>*</modifier></type><name>bb</name> <init>= <expr><call><name>r_anal_fcn_bbget_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>bb</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>bb</name><operator>-&gt;</operator><name>folded</name></name> <operator>=</operator> <operator>!</operator><name><name>bb</name><operator>-&gt;</operator><name>folded</name></name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_warn_if_reached</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<return>return <expr><name>true</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></function>

<function><type><name>R_API</name> <name>int</name></type> <name>r_core_visual_graph</name><parameter_list>(<parameter><decl><type><name>RCore</name> <modifier>*</modifier></type><name>core</name></decl></parameter>, <parameter><decl><type><name>RAGraph</name> <modifier>*</modifier></type><name>g</name></decl></parameter>, <parameter><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>_fcn</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>is_interactive</name></decl></parameter>)</parameter_list> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>o_asmqjmps_letter</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>is_asmqjmps_letter</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>o_scrinteractive</name> <init>= <expr><call><name>r_cons_is_interactive</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>o_vmode</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>vmode</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>exit_graph</name> <init>= <expr><name>false</name></expr></init></decl>, <decl><type ref="prev"/><name>is_error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>update_seek</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name><name>struct</name> <name>agraph_refresh_data</name></name> <modifier>*</modifier></type><name>grd</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>okey</name></decl>, <decl><type ref="prev"/><name>key</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>key_s</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RConsCanvas</name> <modifier>*</modifier></type><name>can</name></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>o_can</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>graph_allocated</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>movspeed</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>, <decl><type ref="prev"/><name>invscroll</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>RConfigHold</name> <modifier>*</modifier></type><name>hc</name> <init>= <expr><call><name>r_config_hold_new</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>hc</name></expr>)</condition> <block>{<block_content>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_hold_i</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>, <argument><expr><literal type="string">"asm.pseudo"</literal></expr></argument>, <argument><expr><literal type="string">"asm.esil"</literal></expr></argument>, <argument><expr><literal type="string">"asm.cmt.right"</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>int</name></type> <name>h</name></decl>, <decl><type ref="prev"/><name>w</name> <init>= <expr><call><name>r_cons_get_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>can</name> <operator>=</operator> <call><name>r_cons_canvas_new</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>w</name> <operator>=</operator> <literal type="number">80</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>h</name> <operator>=</operator> <literal type="number">25</literal></expr>;</expr_stmt>

<expr_stmt><expr><name>can</name> <operator>=</operator> <call><name>r_cons_canvas_new</name> <argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot create RCons.canvas context. Invalid screen "</literal>

<literal type="string">"size? See scr.columns + scr.rows\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>linemode</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.linemode"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>color</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.color"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>graph_allocated</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>fcn</name> <operator>=</operator> <ternary><condition><expr><name>_fcn</name></expr>?</condition><then> <expr><name>_fcn</name></expr></then><else>: <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_canvas_free</name> <argument_list>(<argument><expr><name>can</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>g</name> <operator>=</operator> <call><name>r_agraph_new</name> <argument_list>(<argument><expr><name>can</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_free</name> <argument_list>(<argument><expr><name>can</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_tiny</name></name> <operator>=</operator> <name>is_interactive</name> <operator>==</operator> <literal type="number">2</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>dummy</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.dummy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_titles</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.ntitles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>o_can</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>can</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name> <operator>=</operator> <name>can</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>movspeed</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.scroll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_titles</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.ntitles"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_body</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.body"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>show_node_bubble</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.bubble"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>on_curnode_change</name></name> <operator>=</operator> <operator>(</operator><name>RANodeCallback</name><operator>)</operator> <name>seek_to_node</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>on_curnode_change_data</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>hints</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.hints"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_interactive</name></name> <operator>=</operator> <name>is_interactive</name></expr>;</expr_stmt>

<decl_stmt><decl><type><name>bool</name></type> <name>asm_comments</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.comments"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.comments"</literal></expr></argument>,

<argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.comments"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>is_asmqjmps_letter</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>vmode</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>grd</name> <operator>=</operator> <call><name>R_NEW0</name> <argument_list>(<argument><expr>struct <name>agraph_refresh_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>grd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_canvas_free</name> <argument_list>(<argument><expr><name>can</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_agraph_free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<return>return <expr><name>false</name></expr>;</return>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>grd</name><operator>-&gt;</operator><name>g</name></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>grd</name><operator>-&gt;</operator><name>fs</name></name> <operator>=</operator> <name>is_interactive</name> <operator>==</operator> <literal type="number">1</literal></expr>;</expr_stmt>

<expr_stmt><expr><name><name>grd</name><operator>-&gt;</operator><name>core</name></name> <operator>=</operator> <name>core</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>grd</name><operator>-&gt;</operator><name>follow_offset</name></name> <operator>=</operator> <name>_fcn</name> <operator>==</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>grd</name><operator>-&gt;</operator><name>fcn</name></name> <operator>=</operator> <ternary><condition><expr><name>fcn</name> <operator>!=</operator> <name>NULL</name></expr>?</condition><then> <expr><operator>&amp;</operator><name>fcn</name></expr></then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>agraph_refresh</name> <argument_list>(<argument><expr><name>grd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name> <operator>||</operator> <name>is_interactive</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_cons_newline</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_graph</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>is_error</name> <operator>=</operator> <operator>!</operator><name>ret</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>event_resize</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt> 

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>event_data</name></name> <operator>=</operator> <name>grd</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>event_resize</name></name> <operator>=</operator> <operator>(</operator><name>RConsEvent</name><operator>)</operator> <name>agraph_refresh_oneshot</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_break_push</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<while>while <condition>(<expr><operator>!</operator><name>exit_graph</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_error</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_cons_is_breaked</name> <argument_list>()</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>w</name> <operator>=</operator> <call><name>r_cons_get_size</name> <argument_list>(<argument><expr><operator>&amp;</operator><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>invscroll</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.invscroll"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>agraph_refresh</name> <argument_list>(<argument><expr><name>grd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ret</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>is_error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>okey</name> <operator>=</operator> <call><name>r_cons_readchar</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>r_cons_arrow_to_hjkl</name> <argument_list>(<argument><expr><name>okey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>mouse_event</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>movspeed</name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.wheel.speed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<switch>switch <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<switch>switch <condition>(<expr><name>mousemode</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="number">0</literal></expr>:</case> <break>break;</break>

<case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>key</name> <operator>=</operator> <ternary><condition><expr><name>key</name> <operator>==</operator> <literal type="char">'k'</literal></expr>?</condition><then> <expr><literal type="char">'h'</literal></expr></then><else>: <expr><literal type="char">'l'</literal></expr></else></ternary></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>key</name> <operator>=</operator> <ternary><condition><expr><name>key</name> <operator>==</operator> <literal type="char">'k'</literal></expr>?</condition><then> <expr><literal type="char">'J'</literal></expr></then><else>: <expr><literal type="char">'K'</literal></expr></else></ternary></expr>;</expr_stmt> <break>break;</break>

<case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>key</name> <operator>=</operator> <ternary><condition><expr><name>key</name> <operator>==</operator> <literal type="char">'k'</literal></expr>?</condition><then> <expr><literal type="char">'L'</literal></expr></then><else>: <expr><literal type="char">'H'</literal></expr></else></ternary></expr>;</expr_stmt> <break>break;</break>

</block_content>}</block></switch>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>movspeed</name> <operator>=</operator> <name><name>g</name><operator>-&gt;</operator><name>movspeed</name></name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

<switch>switch <condition>(<expr><name>key</name></expr>)</condition> <block>{<block_content>

<case>case <expr><literal type="char">'-'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_set_zoom</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>-</operator> <name>ZOOM_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'+'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_set_zoom</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name><name>g</name><operator>-&gt;</operator><name>zoom</name></name> <operator>+</operator> <name>ZOOM_STEP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>force_update_seek</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'0'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_set_zoom</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>ZOOM_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'1'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so;.aeg*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'2'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so-1;.aeg*"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'='</literal></expr>:</case>

<block>{<block_content> 

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cmd</name> <init>= <expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_line_set_prompt</name> <argument_list>(<argument><expr><literal type="string">"cmd.gprompt&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name><operator>-&gt;</operator><name>contents</name></name> <operator>=</operator> <call><name>strdup</name> <argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name> <init>= <expr><call><name>r_line_readline</name> <argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>line</name><operator>-&gt;</operator><name>contents</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"cmd.gprompt"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'|'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><operator>++</operator><name>e</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_set_layout</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'e'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_update_dim</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'b'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_browse</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'E'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.linemode"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name>e</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>e</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>e</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.linemode"</literal></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name><operator>-&gt;</operator><name>linemode</name></name> <operator>=</operator> <name>e</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="number">13</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>update_seek</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>exit_graph</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'&gt;'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name> <operator>&amp;&amp;</operator> <call><name>r_cons_yesno</name> <argument_list>(<argument><expr><literal type="char">'y'</literal></expr></argument>, <argument><expr><literal type="string">"Compute function callgraph? (Y/n)"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-;.agc* @$FB;.axfg @$FB;aggi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'&lt;'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-;.axtg $FB;aggi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'G'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ag-;.dtg*;aggi"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'V'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_toggle_callgraph</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'Z'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>okey</name> <operator>==</operator> <literal type="number">27</literal></expr>)</condition> <block>{<block_content> 

<expr_stmt><expr><call><name>agraph_prev_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<decl_stmt><decl><type><name>RANode</name> <modifier>*</modifier></type><name>n</name> <init>= <expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>n</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>ut64</name></type> <name>addr</name> <init>= <expr><call><name>r_num_get</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>title</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>toggle_bb</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>addr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'s'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>key_s</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.s"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>key_s</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>key_s</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>key_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>graph_single_step_in</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'S'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>graph_single_step_over</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'x'</literal></expr>:</case>

<case>case <expr><literal type="char">'X'</literal></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>old_off</name> <init>= <expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ut64</name></type> <name>off</name> <init>= <expr><call><name>r_anal_get_bbaddr</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>(</operator><name>key</name> <operator>==</operator> <literal type="char">'x'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_core_visual_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>

<operator>(</operator><name>key</name> <operator>==</operator> <literal type="char">'X'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>r_core_visual_refs</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>old_off</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="number">9</literal></expr>:</case> 

<expr_stmt><expr><call><name>agraph_next_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'?'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_cons_clear00</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_printf</name> <argument_list>(<argument><expr><literal type="string">"Visual Ascii Art graph keybindings:\n"</literal>

<literal type="string">" :e cmd.gprompt = agft - show tinygraph in one side\n"</literal>

<literal type="string">" +/-/0 - zoom in/out/default\n"</literal>

<literal type="string">" ; - add comment in current basic block\n"</literal>

<literal type="string">" . (dot) - center graph to the current node\n"</literal>

<literal type="string">" , (comma) - toggle graph.few\n"</literal>

<literal type="string">" ^ - seek to the first bb of the function\n"</literal>

<literal type="string">" = - toggle graph.layout\n"</literal>

<literal type="string">" :cmd - run radare command\n"</literal>

<literal type="string">" ' - toggle graph.comments\n"</literal>

<literal type="string">" \" - toggle graph.refs\n"</literal>

<literal type="string">" #- toggle graph.hints\n"</literal>

<literal type="string">" / - highlight text\n"</literal>

<literal type="string">" | - set cmd.gprompt\n"</literal>

<literal type="string">" _ - enter hud selector\n"</literal>

<literal type="string">" &gt; - show function callgraph (see graph.refs)\n"</literal>

<literal type="string">" &lt; - show program callgraph (see graph.refs)\n"</literal>

<literal type="string">" ( - reverse conditional branch of last instruction in bb\n"</literal>

<literal type="string">" ) - rotate asm.emu and emu.str\n"</literal>

<literal type="string">" Home/End - go to the top/bottom of the canvas\n"</literal>

<literal type="string">" Page-UP/DOWN - scroll canvas up/down\n"</literal>

<literal type="string">" b - visual browse things\n"</literal>

<literal type="string">" c - toggle graph cursor mode\n"</literal>

<literal type="string">" C - toggle scr.colors\n"</literal>

<literal type="string">" d - rename function\n"</literal>

<literal type="string">" D - toggle the mixed graph+disasm mode\n"</literal>

<literal type="string">" e - rotate graph.edges (show/hide edges)\n"</literal>

<literal type="string">" E - rotate graph.linemode (square/diagonal lines)\n"</literal>

<literal type="string">" F - enter flag selector\n"</literal>

<literal type="string">" g - go/seek to given offset\n"</literal>

<literal type="string">" G - debug trace callgraph (generated with dtc)\n"</literal>

<literal type="string">" hjkl/HJKL - scroll canvas or node depending on graph cursor (uppercase for faster)\n"</literal>

<literal type="string">" i - select input nodes by index\n"</literal>

<literal type="string">" I - select output node by index\n"</literal>

<literal type="string">" m/M - change mouse modes\n"</literal>

<literal type="string">" n/N - next/previous scr.nkey (function/flag..)\n"</literal>

<literal type="string">" o([A-Za-z]*) - follow jmp/call identified by shortcut (like ;[oa])\n"</literal>

<literal type="string">" O - toggle asm.pseudo and asm.esil\n"</literal>

<literal type="string">" p/P - rotate graph modes (normal, display offsets, minigraph, summary)\n"</literal>

<literal type="string">" q - back to Visual mode\n"</literal>

<literal type="string">" r - toggle jmphints/leahints\n"</literal>

<literal type="string">" R - randomize colors\n"</literal>

<literal type="string">" s/S - step / step over\n"</literal>

<literal type="string">" tab - select next node\n"</literal>

<literal type="string">" TAB - select previous node\n"</literal>

<literal type="string">" t/f - follow true/false edges\n"</literal>

<literal type="string">" u/U - undo/redo seek\n"</literal>

<literal type="string">" V - toggle basicblock / call graphs\n"</literal>

<literal type="string">" w - toggle between movements speed 1 and graph.scroll\n"</literal>

<literal type="string">" x/X - jump to xref/ref\n"</literal>

<literal type="string">" Y - toggle tiny graph\n"</literal>

<literal type="string">" z - toggle node folding\n"</literal>

<literal type="string">" Z - toggle basic block folding"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_less</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_cons_any_key</name> <argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'"'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_config_toggle</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.refs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'#'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>R_AGRAPH_MODE_COMMENTS</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>R_AGRAPH_MODE_NORMAL</name></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>R_AGRAPH_MODE_COMMENTS</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'p'</literal></expr>:</case>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <call><name>next_mode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'P'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <call><name>prev_mode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'o'</literal></expr>:</case>

<expr_stmt><expr><call><name>goto_asmqjmps</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'g'</literal></expr>:</case>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>visual_offset</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'O'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name>disMode</name> <operator>=</operator> <operator>(</operator><name>disMode</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">3</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>applyDisMode</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'u'</literal></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RIOUndos</name> <modifier>*</modifier></type><name>undo</name> <init>= <expr><call><name>r_io_sundo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>undo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>undo</name><operator>-&gt;</operator><name>off</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot undo\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'U'</literal></expr>:</case>

<block>{<block_content>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<decl_stmt><decl><type><name>RIOUndos</name> <modifier>*</modifier></type><name>undo</name> <init>= <expr><call><name>r_io_sundo_redo</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>io</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>undo</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>undo</name><operator>-&gt;</operator><name>off</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>eprintf</name> <argument_list>(<argument><expr><literal type="string">"Cannot redo\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

</block_content>}</block>

<case>case <expr><literal type="char">'r'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>layout</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.layout"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.hint.call"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.jmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.hint.jmp"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.jmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.lea"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.hint.lea"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.lea"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"e!asm.hint.call"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'$'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"dr PC=$$"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"sr PC"</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'R'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.randpal"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ecr"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"ecn"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fcn</name></expr>)</condition> <block>{<block_content>

<break>break;</break>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>edgemode</name></name> <operator>=</operator> <call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.edges"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'!'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_panels_root</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>panels_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'\''</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_config_toggle</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.comments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">';'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

<expr_stmt><expr><call><name>r_line_set_prompt</name> <argument_list>(<argument><expr><literal type="string">"[comment]&gt; "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_fgets</name> <argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmdf</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"\"CC %s\""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'C'</literal></expr>:</case>

<expr_stmt><expr><call><name>rotateColor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'m'</literal></expr>:</case>

<expr_stmt><expr><name>mousemode</name><operator>++</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>mousemodes</name><index>[<expr><name>mousemode</name></expr>]</index></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mousemode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'M'</literal></expr>:</case>

<expr_stmt><expr><name>mousemode</name><operator>--</operator></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>mousemode</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>mousemode</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'('</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"wao recj@B:-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">')'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>rotateAsmemu</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'d'</literal></expr>:</case>

<block>{<block_content>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_visual_define</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block>

<break>break;</break>

<case>case <expr><literal type="char">'D'</literal></expr>:</case>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name> <operator>=</operator> <operator>!</operator><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'n'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_seek_next</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.nkey"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'N'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_seek_previous</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.nkey"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'Y'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_toggle_tiny</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'z'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_toggle_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'v'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_anal</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'J'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><name>speed</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>-=</operator> <operator>(</operator><literal type="number">5</literal><operator>*</operator><name>movspeed</name><operator>)</operator> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'K'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>, <argument><expr><name>speed</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+=</operator> <operator>(</operator><literal type="number">5</literal><operator>*</operator><name>movspeed</name><operator>)</operator> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'H'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>, <argument><expr><name>movspeed</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>okey</name> <operator>==</operator> <literal type="number">27</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>+=</operator> <operator>(</operator><literal type="number">5</literal> <operator>*</operator> <name>movspeed</name><operator>)</operator> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'L'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><name>movspeed</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>is_mini</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>-=</operator> <operator>(</operator><literal type="number">5</literal> <operator>*</operator> <name>movspeed</name><operator>)</operator> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'c'</literal></expr>:</case>

<expr_stmt><expr><name>graphCursor</name> <operator>=</operator> <operator>!</operator><name>graphCursor</name></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'j'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so 1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'j'</literal></expr></argument>, <argument><expr><name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>-=</operator> <name>movspeed</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'k'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_dis</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"so -1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'k'</literal></expr></argument>, <argument><expr><name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sy</name></name> <operator>+=</operator> <name>movspeed</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'l'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'l'</literal></expr></argument>, <argument><expr><name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>-=</operator> <name>movspeed</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'h'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>graphCursor</name></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><name>int</name></type> <name>speed</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>okey</name> <operator>==</operator> <literal type="number">27</literal><operator>)</operator></expr>?</condition><then> <expr><name>PAGEKEY_SPEED</name></expr></then><else>: <expr><name>movspeed</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><call><name>graphNodeMove</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><literal type="char">'h'</literal></expr></argument>, <argument><expr><name>speed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>can</name><operator>-&gt;</operator><name>sx</name></name> <operator>+=</operator> <name>movspeed</name> <operator>*</operator> <operator>(</operator><ternary><condition><expr><name>invscroll</name></expr>?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr></then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'^'</literal></expr>:</case>

<block>{<block_content>

<decl_stmt><decl><type><name>RAnalFunction</name> <modifier>*</modifier></type><name>fcn</name> <init>= <expr><call><name>r_anal_get_fcn_in</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>anal</name></name></expr></argument>, <argument><expr><name><name>core</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<if_stmt><if>if <condition>(<expr><name>fcn</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_core_seek</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name><name>fcn</name><operator>-&gt;</operator><name>addr</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">','</literal></expr>:</case>

<expr_stmt><expr><call><name>r_config_toggle</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'.'</literal></expr>:</case>

<expr_stmt><expr><name>discroll</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<expr_stmt><expr><call><name>agraph_update_seek</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><call><name>get_anode</name> <argument_list>(<argument><expr><name><name>g</name><operator>-&gt;</operator><name>curnode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'i'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_follow_innodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'I'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_follow_innodes</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'t'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_follow_true</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'T'</literal></expr>:</case>

<break>break;</break>

<case>case <expr><literal type="char">'f'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_follow_false</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><call><name>r_config_get_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"graph.few"</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'F'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name>okey</name> <operator>==</operator> <literal type="number">27</literal></expr>)</condition> <block>{<block_content>

<decl_stmt><decl><type><specifier>const</specifier> <name>RGraphNode</name> <modifier>*</modifier></type><name>gn</name> <init>= <expr><call><name>find_near_of</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>update_seek_on</name></name> <operator>=</operator> <call><name>get_anode</name> <argument_list>(<argument><expr><name>gn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>r_core_visual_trackflags</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'/'</literal></expr>:</case>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><literal type="string">"?i highlight;e scr.highlight=`yp`"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>showcursor</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">':'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_prompt_input</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><operator>!</operator><name>g</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>need_reload_nodes</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt> 

<expr_stmt><expr><call><name>get_bbupdate</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>, <argument><expr><name>fcn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'w'</literal></expr>:</case>

<expr_stmt><expr><call><name>agraph_toggle_speed</name> <argument_list>(<argument><expr><name>g</name></expr></argument>, <argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><literal type="char">'_'</literal></expr>:</case>

<expr_stmt><expr><call><name>r_core_visual_hudstuff</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F1</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F2</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f2"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>graph_breakpoint</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F3</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f3"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F4</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f4"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F5</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f5"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F6</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f6"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F7</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f7"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>graph_single_step_in</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F8</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f8"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>graph_single_step_over</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F9</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f9"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><call><name>graph_continue</name> <argument_list>(<argument><expr><name>core</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F10</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f10"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F11</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f11"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><name>R_CONS_KEY_F12</name></expr>:</case>

<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>r_config_get</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"key.f12"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>cmd</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cmd</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>r_core_cmd0</name> <argument_list>(<argument><expr><name>core</name></expr></argument>, <argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case> 

<case>case <expr><literal type="char">' '</literal></expr>:</case>

<case>case <expr><literal type="char">'Q'</literal></expr>:</case>

<case>case <expr><literal type="char">'q'</literal></expr>:</case>

<if_stmt><if>if <condition>(<expr><name><name>g</name><operator>-&gt;</operator><name>is_callgraph</name></name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_toggle_callgraph</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name>exit_graph</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<break>break;</break>

<case>case <expr><literal type="number">27</literal></expr>:</case> 

<if_stmt><if>if <condition>(<expr><call><name>r_cons_readchar</name> <argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">91</literal></expr>)</condition> <block>{<block_content>

<if_stmt><if>if <condition>(<expr><call><name>r_cons_readchar</name> <argument_list>()</argument_list></call> <operator>==</operator> <literal type="number">90</literal></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>agraph_prev_node</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if></if_stmt>

</block_content>}</block></if></if_stmt>

<break>break;</break>

<default>default:</default>

<break>break;</break>

</block_content>}</block></switch>

</block_content>}</block></while>

<expr_stmt><expr><call><name>r_cons_break_pop</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"asm.comments"</literal></expr></argument>, <argument><expr><call><name>r_str_bool</name> <argument_list>(<argument><expr><name>asm_comments</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>event_resize</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>cons</name><operator>-&gt;</operator><name>event_data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>vmode</name></name> <operator>=</operator> <name>o_vmode</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>is_asmqjmps_letter</name></name> <operator>=</operator> <name>o_asmqjmps_letter</name></expr>;</expr_stmt>

<expr_stmt><expr><name><name>core</name><operator>-&gt;</operator><name>keep_asmqjmps</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

<expr_stmt><expr><call><name>free</name> <argument_list>(<argument><expr><name>grd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>graph_allocated</name></expr>)</condition> <block>{<block_content>

<expr_stmt><expr><call><name>r_agraph_free</name> <argument_list>(<argument><expr><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_set_i</name> <argument_list>(<argument><expr><name><name>core</name><operator>-&gt;</operator><name>config</name></name></expr></argument>, <argument><expr><literal type="string">"scr.interactive"</literal></expr></argument>, <argument><expr><name>o_scrinteractive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></if> <else>else <block>{<block_content>

<expr_stmt><expr><name><name>g</name><operator>-&gt;</operator><name>can</name></name> <operator>=</operator> <name>o_can</name></expr>;</expr_stmt>

</block_content>}</block></else></if_stmt>

<expr_stmt><expr><call><name>r_config_hold_restore</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>r_config_hold_free</name> <argument_list>(<argument><expr><name>hc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<if_stmt><if>if <condition>(<expr><name>update_seek</name></expr>)</condition> <block>{<block_content>

<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>

</block_content>}</block></if></if_stmt>

<return>return <expr><operator>!</operator><name>is_error</name></expr>;</return>

</block_content>}</block></function>

</unit>
